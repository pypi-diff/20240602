# Comparing `tmp/satnogs_decoders-1.9.0-py3-none-any.whl.zip` & `tmp/satnogs_decoders-1.9.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,69 +1,69 @@
-Zip file size: 152496 bytes, number of entries: 67
--rw-r--r--  2.0 unx      208 b- defN 20-Sep-07 07:00 satnogsdecoders/__init__.py
--rw-r--r--  2.0 unx      497 b- defN 20-Sep-07 07:00 satnogsdecoders/_version.py
--rw-r--r--  2.0 unx     1186 b- defN 20-Sep-07 07:00 satnogsdecoders/decode_frame.py
--rw-r--r--  2.0 unx     5597 b- defN 20-Sep-07 07:00 satnogsdecoders/decode_multiple.py
--rw-r--r--  2.0 unx     2614 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/__init__.py
--rw-r--r--  2.0 unx    11218 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/aausat4.py
--rw-r--r--  2.0 unx     9619 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/acrux1.py
--rw-r--r--  2.0 unx    15739 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/alsat1n.py
--rw-r--r--  2.0 unx    75019 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/amicalsat.py
--rw-r--r--  2.0 unx    12289 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/armadillo.py
--rw-r--r--  2.0 unx     3062 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/ascii85test.py
--rw-r--r--  2.0 unx    25498 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/asuphoenix.py
--rw-r--r--  2.0 unx     4958 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/ax25frames.py
--rw-r--r--  2.0 unx     7047 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/ax25monitor.py
--rw-r--r--  2.0 unx    15040 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/bisonsat.py
--rw-r--r--  2.0 unx    15999 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/bobcat1.py
--rw-r--r--  2.0 unx    14472 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/bugsat1.py
--rw-r--r--  2.0 unx     8580 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/cape1.py
--rw-r--r--  2.0 unx    11706 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/cas4.py
--rw-r--r--  2.0 unx    15040 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/chomptt.py
--rw-r--r--  2.0 unx    29203 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/csim.py
--rw-r--r--  2.0 unx     4656 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/cspheader.py
--rw-r--r--  2.0 unx    45093 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/cubebel1.py
--rw-r--r--  2.0 unx    25125 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/cubesatsim.py
--rw-r--r--  2.0 unx    20534 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/duchifat3.py
--rw-r--r--  2.0 unx    41509 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/elfin.py
--rw-r--r--  2.0 unx    11397 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/entrysat.py
--rw-r--r--  2.0 unx   107182 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/equisat.py
--rw-r--r--  2.0 unx    44733 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/eshail2.py
--rw-r--r--  2.0 unx    21745 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/fox.py
--rw-r--r--  2.0 unx    25164 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/irazu.py
--rw-r--r--  2.0 unx    30588 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/irvine.py
--rw-r--r--  2.0 unx    46869 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/lightsail2.py
--rw-r--r--  2.0 unx    11283 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/minxss.py
--rw-r--r--  2.0 unx    81971 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/mxl.py
--rw-r--r--  2.0 unx    11311 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/mysat.py
--rw-r--r--  2.0 unx    17721 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/opssat1.py
--rw-r--r--  2.0 unx    21035 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/origamisat1.py
--rw-r--r--  2.0 unx    12633 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/painani.py
--rw-r--r--  2.0 unx    19114 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/polyitan1.py
--rw-r--r--  2.0 unx    45175 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/pwsat2.py
--rw-r--r--  2.0 unx    18160 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/qarman.py
--rw-r--r--  2.0 unx     5860 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/qbee.py
--rw-r--r--  2.0 unx    31604 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/quetzal1.py
--rw-r--r--  2.0 unx    17645 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/siriussat.py
--rw-r--r--  2.0 unx    33386 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/skcube.py
--rw-r--r--  2.0 unx    27826 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/strand.py
--rw-r--r--  2.0 unx     8635 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/us6.py
--rw-r--r--  2.0 unx    16047 b- defN 20-Sep-07 06:55 satnogsdecoders/decoder/uwe4.py
--rw-r--r--  2.0 unx      309 b- defN 20-Sep-07 07:00 satnogsdecoders/process/__init__.py
--rw-r--r--  2.0 unx      459 b- defN 20-Sep-07 07:00 satnogsdecoders/process/b85decode.py
--rw-r--r--  2.0 unx      469 b- defN 20-Sep-07 07:00 satnogsdecoders/process/b85encode.py
--rw-r--r--  2.0 unx     1095 b- defN 20-Sep-07 07:00 satnogsdecoders/process/elfin_pp.py
--rw-r--r--  2.0 unx     3307 b- defN 20-Sep-07 07:00 satnogsdecoders/process/scrambler.py
--rw-r--r--  2.0 unx        0 b- defN 20-Sep-07 07:00 tests/__init__.py
--rw-r--r--  2.0 unx      725 b- defN 20-Sep-07 07:00 tests/shared_methods.py
--rw-r--r--  2.0 unx      955 b- defN 20-Sep-07 07:00 tests/test_ascii85process.py
--rw-r--r--  2.0 unx     3245 b- defN 20-Sep-07 07:00 tests/test_cape1.py
--rw-r--r--  2.0 unx      634 b- defN 20-Sep-07 07:00 tests/test_elfin_pp.py
--rw-r--r--  2.0 unx      895 b- defN 20-Sep-07 07:00 tests/test_entrysat.py
--rw-r--r--  2.0 unx    14939 b- defN 20-Sep-07 07:00 tests/test_equisat.py
--rw-rw-rw-  2.0 unx    34523 b- defN 20-Sep-07 07:00 satnogs_decoders-1.9.0.dist-info/LICENSE
--rw-r--r--  2.0 unx      792 b- defN 20-Sep-07 07:00 satnogs_decoders-1.9.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 20-Sep-07 07:00 satnogs_decoders-1.9.0.dist-info/WHEEL
--rw-r--r--  2.0 unx      123 b- defN 20-Sep-07 07:00 satnogs_decoders-1.9.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       22 b- defN 20-Sep-07 07:00 satnogs_decoders-1.9.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     6020 b- defN 20-Sep-07 07:00 satnogs_decoders-1.9.0.dist-info/RECORD
-67 files, 1157196 bytes uncompressed, 142914 bytes compressed:  87.6%
+Zip file size: 153895 bytes, number of entries: 67
+-rw-r--r--  2.0 unx      208 b- defN 20-Sep-13 17:57 satnogsdecoders/__init__.py
+-rw-r--r--  2.0 unx      497 b- defN 20-Sep-13 17:57 satnogsdecoders/_version.py
+-rw-r--r--  2.0 unx     1186 b- defN 20-Sep-13 17:57 satnogsdecoders/decode_frame.py
+-rw-r--r--  2.0 unx     5597 b- defN 20-Sep-13 17:57 satnogsdecoders/decode_multiple.py
+-rw-r--r--  2.0 unx     2614 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/__init__.py
+-rw-r--r--  2.0 unx    11218 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/aausat4.py
+-rw-r--r--  2.0 unx     9619 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/acrux1.py
+-rw-r--r--  2.0 unx    15739 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/alsat1n.py
+-rw-r--r--  2.0 unx   100162 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/amicalsat.py
+-rw-r--r--  2.0 unx    12289 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/armadillo.py
+-rw-r--r--  2.0 unx     3062 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/ascii85test.py
+-rw-r--r--  2.0 unx    25498 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/asuphoenix.py
+-rw-r--r--  2.0 unx     4958 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/ax25frames.py
+-rw-r--r--  2.0 unx     7047 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/ax25monitor.py
+-rw-r--r--  2.0 unx    15040 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/bisonsat.py
+-rw-r--r--  2.0 unx    15999 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/bobcat1.py
+-rw-r--r--  2.0 unx    14472 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/bugsat1.py
+-rw-r--r--  2.0 unx     8580 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/cape1.py
+-rw-r--r--  2.0 unx    11706 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/cas4.py
+-rw-r--r--  2.0 unx    15040 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/chomptt.py
+-rw-r--r--  2.0 unx    29203 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/csim.py
+-rw-r--r--  2.0 unx     4656 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/cspheader.py
+-rw-r--r--  2.0 unx    45093 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/cubebel1.py
+-rw-r--r--  2.0 unx    25125 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/cubesatsim.py
+-rw-r--r--  2.0 unx    20534 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/duchifat3.py
+-rw-r--r--  2.0 unx    41509 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/elfin.py
+-rw-r--r--  2.0 unx    11397 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/entrysat.py
+-rw-r--r--  2.0 unx   107182 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/equisat.py
+-rw-r--r--  2.0 unx    44733 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/eshail2.py
+-rw-r--r--  2.0 unx    21745 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/fox.py
+-rw-r--r--  2.0 unx    25164 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/irazu.py
+-rw-r--r--  2.0 unx    30588 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/irvine.py
+-rw-r--r--  2.0 unx    46869 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/lightsail2.py
+-rw-r--r--  2.0 unx    11283 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/minxss.py
+-rw-r--r--  2.0 unx    81971 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/mxl.py
+-rw-r--r--  2.0 unx    11311 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/mysat.py
+-rw-r--r--  2.0 unx    17721 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/opssat1.py
+-rw-r--r--  2.0 unx    21035 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/origamisat1.py
+-rw-r--r--  2.0 unx    12633 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/painani.py
+-rw-r--r--  2.0 unx    19114 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/polyitan1.py
+-rw-r--r--  2.0 unx    45175 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/pwsat2.py
+-rw-r--r--  2.0 unx    18160 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/qarman.py
+-rw-r--r--  2.0 unx     5860 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/qbee.py
+-rw-r--r--  2.0 unx    31604 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/quetzal1.py
+-rw-r--r--  2.0 unx    17645 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/siriussat.py
+-rw-r--r--  2.0 unx    33386 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/skcube.py
+-rw-r--r--  2.0 unx    27826 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/strand.py
+-rw-r--r--  2.0 unx     8635 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/us6.py
+-rw-r--r--  2.0 unx    16047 b- defN 20-Sep-13 17:52 satnogsdecoders/decoder/uwe4.py
+-rw-r--r--  2.0 unx      309 b- defN 20-Sep-13 17:57 satnogsdecoders/process/__init__.py
+-rw-r--r--  2.0 unx      459 b- defN 20-Sep-13 17:57 satnogsdecoders/process/b85decode.py
+-rw-r--r--  2.0 unx      469 b- defN 20-Sep-13 17:57 satnogsdecoders/process/b85encode.py
+-rw-r--r--  2.0 unx     1095 b- defN 20-Sep-13 17:57 satnogsdecoders/process/elfin_pp.py
+-rw-r--r--  2.0 unx     3307 b- defN 20-Sep-13 17:57 satnogsdecoders/process/scrambler.py
+-rw-r--r--  2.0 unx        0 b- defN 20-Sep-13 17:57 tests/__init__.py
+-rw-r--r--  2.0 unx      725 b- defN 20-Sep-13 17:57 tests/shared_methods.py
+-rw-r--r--  2.0 unx      955 b- defN 20-Sep-13 17:57 tests/test_ascii85process.py
+-rw-r--r--  2.0 unx     3245 b- defN 20-Sep-13 17:57 tests/test_cape1.py
+-rw-r--r--  2.0 unx      634 b- defN 20-Sep-13 17:57 tests/test_elfin_pp.py
+-rw-r--r--  2.0 unx      895 b- defN 20-Sep-13 17:57 tests/test_entrysat.py
+-rw-r--r--  2.0 unx    14939 b- defN 20-Sep-13 17:57 tests/test_equisat.py
+-rw-rw-rw-  2.0 unx    34523 b- defN 20-Sep-13 17:57 satnogs_decoders-1.9.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx      792 b- defN 20-Sep-13 17:57 satnogs_decoders-1.9.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 20-Sep-13 17:57 satnogs_decoders-1.9.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx      123 b- defN 20-Sep-13 17:57 satnogs_decoders-1.9.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       22 b- defN 20-Sep-13 17:57 satnogs_decoders-1.9.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     6021 b- defN 20-Sep-13 17:57 satnogs_decoders-1.9.1.dist-info/RECORD
+67 files, 1182340 bytes uncompressed, 144313 bytes compressed:  87.8%
```

## zipnote {}

```diff
@@ -177,26 +177,26 @@
 
 Filename: tests/test_entrysat.py
 Comment: 
 
 Filename: tests/test_equisat.py
 Comment: 
 
-Filename: satnogs_decoders-1.9.0.dist-info/LICENSE
+Filename: satnogs_decoders-1.9.1.dist-info/LICENSE
 Comment: 
 
-Filename: satnogs_decoders-1.9.0.dist-info/METADATA
+Filename: satnogs_decoders-1.9.1.dist-info/METADATA
 Comment: 
 
-Filename: satnogs_decoders-1.9.0.dist-info/WHEEL
+Filename: satnogs_decoders-1.9.1.dist-info/WHEEL
 Comment: 
 
-Filename: satnogs_decoders-1.9.0.dist-info/entry_points.txt
+Filename: satnogs_decoders-1.9.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: satnogs_decoders-1.9.0.dist-info/top_level.txt
+Filename: satnogs_decoders-1.9.1.dist-info/top_level.txt
 Comment: 
 
-Filename: satnogs_decoders-1.9.0.dist-info/RECORD
+Filename: satnogs_decoders-1.9.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## satnogsdecoders/_version.py

```diff
@@ -4,18 +4,18 @@
 # unpacked source archive. Distribution tarballs contain a pre-generated copy
 # of this file.
 
 import json
 
 version_json = '''
 {
- "date": "2020-09-07T06:43:55+0000",
+ "date": "2020-09-13T19:42:24+0200",
  "dirty": false,
  "error": null,
- "full-revisionid": "299fb081e8c0fb3f5b3a02e67ef836bc845aea33",
- "version": "1.9.0"
+ "full-revisionid": "e58c41de808e1cbbadf2c01e96a930561369695d",
+ "version": "1.9.1"
 }
 '''  # END VERSION_JSON
 
 
 def get_versions():
     return json.loads(version_json)
```

## satnogsdecoders/decoder/amicalsat.py

```diff
@@ -4,243 +4,385 @@
 from kaitaistruct import __version__ as ks_version, KaitaiStruct, KaitaiStream, BytesIO
 
 
 if parse_version(ks_version) < parse_version('0.7'):
     raise Exception("Incompatible Kaitai Struct Python API: 0.7 or later is required, but you have %s" % (ks_version))
 
 class Amicalsat(KaitaiStruct):
-    """Author  : C. Mercier for AMSAT-Francophone
-    Adapted for SatNOGS and modified by deckbsd
-    
-    :field dst_callsign: ax25_frame.ax25_header.dest_callsign_raw.callsign_ror.callsign
+    """:field dest_callsign: ax25_frame.ax25_header.dest_callsign_raw.callsign_ror.callsign
+    :field dest_ssid: ax25_frame.ax25_header.dest_ssid_raw.ssid
     :field src_callsign: ax25_frame.ax25_header.src_callsign_raw.callsign_ror.callsign
+    :field src_ssid: ax25_frame.ax25_header.src_ssid_raw.ssid
     :field ctl: ax25_frame.ax25_header.ctl
     :field pid: ax25_frame.payload.pid
+    :field start: ax25_frame.payload.ax25_info.start
     :field tlm_area: ax25_frame.payload.ax25_info.tlm_area
-    :field tlm_type: ax25_frame.payload.ax25_info.tlm_type
-    :field cpu_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cpu_voltage_volt
-    :field boot_number_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.boot_number_int
-    :field cpu_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cpu_temperature_degree
-    :field up_time_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.up_time_int
-    :field imc_aocs_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.imc_aocs_ok
-    :field imc_cu_l_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.imc_cu_l_ok
-    :field imc_cu_r_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.imc_cu_r_ok
-    :field imc_vhf1_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.imc_vhf1_ok
-    :field imc_uhf2_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.imc_uhf2_ok
-    :field vhf1_downlink: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.vhf1_downlink
-    :field uhf2_downlink: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.uhf2_downlink
-    :field imc_check: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.imc_check
-    :field beacon_mode: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.beacon_mode
-    :field cyclic_reset_on: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cyclic_reset_on
-    :field survival_mode: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.survival_mode
-    :field payload_off: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.payload_off
-    :field cu_auto_off: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cu_auto_off
-    :field tm_log: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.tm_log
-    :field cul_on: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cul_on
-    :field cul_faut: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cul_faut
-    :field cur_on: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cur_on
-    :field cur_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cur_fault
-    :field cu_on: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cu_on
-    :field cul_dead: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cul_dead
-    :field cur_dead: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.cur_dead
-    :field fault_3v_r: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.fault_3v_r
-    :field fault_3v_m: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.fault_3v_m
-    :field charge_r: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.charge_r
-    :field charge_m: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.charge_m
-    :field long_log: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.long_log
-    :field log_to_flash: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.log_to_flash
-    :field plan: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.plan
-    :field stream: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.stream
-    :field vhf1_packet_ready: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.vhf1_packet_ready
-    :field uhf2_packet_ready: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.uhf2_packet_ready
-    :field survival_start: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.survival_start
-    :field survival_end: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.survival_end
-    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.timestamp_int
-    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.timestamp_int
-    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.timestamp_int
-    :field detumbling: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.detumbling
-    :field adcs_on_off: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.adcs_on_off
-    :field detumbling_status: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.detumbling_status
-    :field manual: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.manual
-    :field act_on_off: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.act_on_off
-    :field sun_contr: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.sun_contr
-    :field sens_on_off: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.sens_on_off
-    :field act_man_contr: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.act_man_contr
-    :field act_limited_contr: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.act_limited_contr
-    :field gyro_acc_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.gyro_acc_fault
-    :field mag_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.mag_fault
-    :field sun_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.sun_fault
-    :field l1_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.l1_fault
-    :field l2_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.l2_fault
-    :field l3_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.l3_fault
-    :field mag_x_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.mag_x_int
-    :field mag_y_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.mag_y_int
-    :field mag_z_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.mag_z_int
-    :field gyro_x_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.gyro_x_int
-    :field gyro_y_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.gyro_y_int
-    :field gyro_z_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.gyro_z_int
-    :field latitude_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.latitude_int
-    :field longitude_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_sw.longitude_int
-    :field tlmsw_boot_number_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.boot_number_int
-    :field input_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.input_voltage_volt
-    :field input_current_ma: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.input_current_ma
-    :field input_power_mw: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.input_power_mw
-    :field peak_power_mw: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.peak_power_mw
-    :field solar_panel_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.solar_panel_voltage_volt
-    :field v_in_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.v_in_volt
-    :field v_solar_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.v_solar_volt
-    :field i_in_ma: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.i_in_ma
-    :field p_in_mw: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.p_in_mw
-    :field p_peak_mw: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.p_peak_mw
-    :field t_cpu_degree: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.t_cpu_degree
-    :field v_cpu_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.v_cpu_volt
-    :field battery_voltage: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.battery_voltage
-    :field tlmsw_cpu_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.cpu_voltage_volt
-    :field battery_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.battery_voltage_volt
-    :field tlmsw_cpu_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.cpu_temperature_degree
-    :field amplifier_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.amplifier_temperature_degree
-    :field fec: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.fec
-    :field downlink: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.downlink
-    :field band_lock: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.band_lock
-    :field xor: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.xor
-    :field aes_128: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.aes_128
-    :field amp_ovt: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.amp_ovt
-    :field current_rssi: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.current_rssi
-    :field latch_rssi: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.latch_rssi
-    :field a_f_c_offset: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.a_f_c_offset
-    :field current_rssi_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.current_rssi_int
-    :field latch_rssi_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.latch_rssi_int
-    :field a_f_c_offset_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.a_f_c_offset_int
-    :field return_value_int: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.return_value_int
-    :field onyx_on: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.onyx_on
-    :field llc_onyx_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.llc_onyx_fault
-    :field llc_sram_fault: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.llc_sram_fault
-    :field fault_1v8_r: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.fault_1v8_r
-    :field fault_1v8_m: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.fault_1v8_m
-    :field fault_3v3_12v: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.fault_3v3_12v
-    :field pic_ready_conv: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.pic_ready_conv
-    :field pic_ready_compressed: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.pic_ready_compressed
-    :field pic_ready_compressed_8: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.pic_ready_compressed_8
-    :field sd_pic_write_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.sd_pic_write_ok
-    :field sd_pic_read_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.sd_pic_read_ok
-    :field sd_get_info_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.sd_get_info_ok
-    :field sd_erase_ok: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.sd_erase_ok
-    :field sd_full: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.sd_full
-    :field adc_ready: ax25_frame.payload.ax25_info.tlm_area_switch.tlmsw.adc_ready
+    :field tlm_type: ax25_frame.payload.ax25_info.tlm_area_switch.tlm_type
+    :field m1_cpu_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cpu_voltage_volt
+    :field m1_boot_number_int: ax25_frame.payload.ax25_info.tlm_area_switch.m1.boot_number_int
+    :field m1_cpu_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cpu_temperature_degree
+    :field m1_up_time_int: ax25_frame.payload.ax25_info.tlm_area_switch.m1.up_time_int
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.m1.timestamp_int
+    :field m1_imc_aocs_ok: ax25_frame.payload.ax25_info.tlm_area_switch.m1.imc_aocs_ok
+    :field m1_imc_cu_l_ok: ax25_frame.payload.ax25_info.tlm_area_switch.m1.imc_cu_l_ok
+    :field m1_imc_cu_r_ok: ax25_frame.payload.ax25_info.tlm_area_switch.m1.imc_cu_r_ok
+    :field m1_imc_vhf1_ok: ax25_frame.payload.ax25_info.tlm_area_switch.m1.imc_vhf1_ok
+    :field m1_imc_uhf2_ok: ax25_frame.payload.ax25_info.tlm_area_switch.m1.imc_uhf2_ok
+    :field m1_vhf1_downlink: ax25_frame.payload.ax25_info.tlm_area_switch.m1.vhf1_downlink
+    :field m1_uhf2_downlink: ax25_frame.payload.ax25_info.tlm_area_switch.m1.uhf2_downlink
+    :field m1_imc_check: ax25_frame.payload.ax25_info.tlm_area_switch.m1.imc_check
+    :field m1_beacon_mode: ax25_frame.payload.ax25_info.tlm_area_switch.m1.beacon_mode
+    :field m1_cyclic_reset_on: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cyclic_reset_on
+    :field m1_survival_mode: ax25_frame.payload.ax25_info.tlm_area_switch.m1.survival_mode
+    :field m1_payload_off: ax25_frame.payload.ax25_info.tlm_area_switch.m1.payload_off
+    :field m1_cu_auto_off: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cu_auto_off
+    :field m1_tm_log: ax25_frame.payload.ax25_info.tlm_area_switch.m1.tm_log
+    :field m1_cul_on: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cul_on
+    :field m1_cul_faut: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cul_faut
+    :field m1_cur_on: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cur_on
+    :field m1_cur_fault: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cur_fault
+    :field m1_cu_on: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cu_on
+    :field m1_cul_dead: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cul_dead
+    :field m1_cur_dead: ax25_frame.payload.ax25_info.tlm_area_switch.m1.cur_dead
+    :field m1_fault_3v_r: ax25_frame.payload.ax25_info.tlm_area_switch.m1.fault_3v_r
+    :field m1_fault_3v_m: ax25_frame.payload.ax25_info.tlm_area_switch.m1.fault_3v_m
+    :field m1_charge_r: ax25_frame.payload.ax25_info.tlm_area_switch.m1.charge_r
+    :field m1_charge_m: ax25_frame.payload.ax25_info.tlm_area_switch.m1.charge_m
+    :field m1_long_log: ax25_frame.payload.ax25_info.tlm_area_switch.m1.long_log
+    :field m1_log_to_flash: ax25_frame.payload.ax25_info.tlm_area_switch.m1.log_to_flash
+    :field m1_plan: ax25_frame.payload.ax25_info.tlm_area_switch.m1.plan
+    :field m1_stream: ax25_frame.payload.ax25_info.tlm_area_switch.m1.stream
+    :field m1_vhf1_packet_ready: ax25_frame.payload.ax25_info.tlm_area_switch.m1.vhf1_packet_ready
+    :field m1_uhf2_packet_ready: ax25_frame.payload.ax25_info.tlm_area_switch.m1.uhf2_packet_ready
+    :field m1_survival_start: ax25_frame.payload.ax25_info.tlm_area_switch.m1.survival_start
+    :field m1_survival_end: ax25_frame.payload.ax25_info.tlm_area_switch.m1.survival_end
+    :field a1_adcs_mode: ax25_frame.payload.ax25_info.tlm_area_switch.a1.adcs_mode
+    :field a1_faults: ax25_frame.payload.ax25_info.tlm_area_switch.a1.faults
+    :field a1_detumbling: ax25_frame.payload.ax25_info.tlm_area_switch.a1.detumbling
+    :field a1_adcs_on_off: ax25_frame.payload.ax25_info.tlm_area_switch.a1.adcs_on_off
+    :field a1_detumbling_status: ax25_frame.payload.ax25_info.tlm_area_switch.a1.detumbling_status
+    :field a1_manual: ax25_frame.payload.ax25_info.tlm_area_switch.a1.manual
+    :field a1_act_on_off: ax25_frame.payload.ax25_info.tlm_area_switch.a1.act_on_off
+    :field a1_sun_contr: ax25_frame.payload.ax25_info.tlm_area_switch.a1.sun_contr
+    :field a1_sens_on_off: ax25_frame.payload.ax25_info.tlm_area_switch.a1.sens_on_off
+    :field a1_act_man_contr: ax25_frame.payload.ax25_info.tlm_area_switch.a1.act_man_contr
+    :field a1_act_limited_contr: ax25_frame.payload.ax25_info.tlm_area_switch.a1.act_limited_contr
+    :field a1_gyro_acc_fault: ax25_frame.payload.ax25_info.tlm_area_switch.a1.gyro_acc_fault
+    :field a1_mag_fault: ax25_frame.payload.ax25_info.tlm_area_switch.a1.mag_fault
+    :field a1_sun_fault: ax25_frame.payload.ax25_info.tlm_area_switch.a1.sun_fault
+    :field a1_l1_fault: ax25_frame.payload.ax25_info.tlm_area_switch.a1.l1_fault
+    :field a1_l2_fault: ax25_frame.payload.ax25_info.tlm_area_switch.a1.l2_fault
+    :field a1_l3_fault: ax25_frame.payload.ax25_info.tlm_area_switch.a1.l3_fault
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.timestamp_int
+    :field a1_mag_x: ax25_frame.payload.ax25_info.tlm_area_switch.a1.mag_x
+    :field a1_mag_y: ax25_frame.payload.ax25_info.tlm_area_switch.a1.mag_y
+    :field a1_mag_z: ax25_frame.payload.ax25_info.tlm_area_switch.a1.mag_z
+    :field a1_mag_x_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.mag_x_int
+    :field a1_mag_y_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.mag_y_int
+    :field a1_mag_z_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.mag_z_int
+    :field a1_gyro_x_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.gyro_x_int
+    :field a1_gyro_y_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.gyro_y_int
+    :field a1_gyro_z_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.gyro_z_int
+    :field a1_latitude_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.latitude_int
+    :field a1_longitude_int: ax25_frame.payload.ax25_info.tlm_area_switch.a1.longitude_int
+    :field em_boot_number_int: ax25_frame.payload.ax25_info.tlm_area_switch.em.boot_number_int
+    :field em_input_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.em.input_voltage_volt
+    :field em_input_current_ma: ax25_frame.payload.ax25_info.tlm_area_switch.em.input_current_ma
+    :field em_input_power_mw: ax25_frame.payload.ax25_info.tlm_area_switch.em.input_power_mw
+    :field em_peak_power_mw: ax25_frame.payload.ax25_info.tlm_area_switch.em.peak_power_mw
+    :field em_solar_panel_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.em.solar_panel_voltage_volt
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.em.timestamp_int
+    :field em_v_in_volt: ax25_frame.payload.ax25_info.tlm_area_switch.em.v_in_volt
+    :field em_v_solar_volt: ax25_frame.payload.ax25_info.tlm_area_switch.em.v_solar_volt
+    :field em_i_in_ma: ax25_frame.payload.ax25_info.tlm_area_switch.em.i_in_ma
+    :field em_p_in_mw: ax25_frame.payload.ax25_info.tlm_area_switch.em.p_in_mw
+    :field em_p_peak_mw: ax25_frame.payload.ax25_info.tlm_area_switch.em.p_peak_mw
+    :field em_t_cpu_degree: ax25_frame.payload.ax25_info.tlm_area_switch.em.t_cpu_degree
+    :field em_v_cpu_volt: ax25_frame.payload.ax25_info.tlm_area_switch.em.v_cpu_volt
+    :field timestamp: ax25_frame.payload.ax25_info.tlm_area_switch.er.timestamp
+    :field boot_number: ax25_frame.payload.ax25_info.tlm_area_switch.er.boot_number
+    :field er_input_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.er.input_voltage_volt
+    :field er_input_current_ma: ax25_frame.payload.ax25_info.tlm_area_switch.er.input_current_ma
+    :field er_input_power_mw: ax25_frame.payload.ax25_info.tlm_area_switch.er.input_power_mw
+    :field er_peak_power_mw: ax25_frame.payload.ax25_info.tlm_area_switch.er.peak_power_mw
+    :field er_solar_panel_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.er.solar_panel_voltage_volt
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.er.timestamp_int
+    :field er_v_in_volt: ax25_frame.payload.ax25_info.tlm_area_switch.er.v_in_volt
+    :field er_v_solar_volt: ax25_frame.payload.ax25_info.tlm_area_switch.er.v_solar_volt
+    :field er_i_in_ma: ax25_frame.payload.ax25_info.tlm_area_switch.er.i_in_ma
+    :field er_p_in_mw: ax25_frame.payload.ax25_info.tlm_area_switch.er.p_in_mw
+    :field er_p_peak_mw: ax25_frame.payload.ax25_info.tlm_area_switch.er.p_peak_mw
+    :field er_t_cpu_degree: ax25_frame.payload.ax25_info.tlm_area_switch.er.t_cpu_degree
+    :field er_v_cpu_volt: ax25_frame.payload.ax25_info.tlm_area_switch.er.v_cpu_volt
+    :field timestamp: ax25_frame.payload.ax25_info.tlm_area_switch.v1.timestamp
+    :field v1_cpu_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.v1.cpu_voltage_volt
+    :field v1_battery_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.v1.battery_voltage_volt
+    :field v1_cpu_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.v1.cpu_temperature_degree
+    :field v1_amplifier_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.v1.amplifier_temperature_degree
+    :field v1_fec: ax25_frame.payload.ax25_info.tlm_area_switch.v1.fec
+    :field v1_downlink: ax25_frame.payload.ax25_info.tlm_area_switch.v1.downlink
+    :field v1_band_lock: ax25_frame.payload.ax25_info.tlm_area_switch.v1.band_lock
+    :field v1_xor: ax25_frame.payload.ax25_info.tlm_area_switch.v1.xor
+    :field v1_aes_128: ax25_frame.payload.ax25_info.tlm_area_switch.v1.aes_128
+    :field v1_amp_ovt: ax25_frame.payload.ax25_info.tlm_area_switch.v1.amp_ovt
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.v1.timestamp_int
+    :field v1_current_rssi_int: ax25_frame.payload.ax25_info.tlm_area_switch.v1.current_rssi_int
+    :field v1_latch_rssi_int: ax25_frame.payload.ax25_info.tlm_area_switch.v1.latch_rssi_int
+    :field v1_a_f_c_offset_int: ax25_frame.payload.ax25_info.tlm_area_switch.v1.a_f_c_offset_int
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.u2.timestamp_int
+    :field u2_current_rssi: ax25_frame.payload.ax25_info.tlm_area_switch.u2.current_rssi
+    :field u2_latch_rssi: ax25_frame.payload.ax25_info.tlm_area_switch.u2.latch_rssi
+    :field u2_a_f_c_offset: ax25_frame.payload.ax25_info.tlm_area_switch.u2.a_f_c_offset
+    :field u2_current_rssi_int: ax25_frame.payload.ax25_info.tlm_area_switch.u2.current_rssi_int
+    :field u2_latch_rssi_int: ax25_frame.payload.ax25_info.tlm_area_switch.u2.latch_rssi_int
+    :field u2_a_f_c_offset_int: ax25_frame.payload.ax25_info.tlm_area_switch.u2.a_f_c_offset_int
+    :field cu_r_return_value_int: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.return_value_int
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.timestamp_int
+    :field cu_r_cpu_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.cpu_voltage_volt
+    :field cu_r_cpu_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.cpu_temperature_degree
+    :field cu_r_onyx_on: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.onyx_on
+    :field cu_r_llc_onyx_fault: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.llc_onyx_fault
+    :field cu_r_llc_sram_fault: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.llc_sram_fault
+    :field cu_r_fault_1v8_r: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.fault_1v8_r
+    :field cu_r_fault_1v8_m: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.fault_1v8_m
+    :field cu_r_fault_3v3_12v: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.fault_3v3_12v
+    :field cu_r_pic_ready_raw: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.pic_ready_raw
+    :field cu_r_pic_ready_conv: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.pic_ready_conv
+    :field cu_r_pic_ready_compressed: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.pic_ready_compressed
+    :field cu_r_pic_ready_compressed_8: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.pic_ready_compressed_8
+    :field cu_r_sd_pic_write_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.sd_pic_write_ok
+    :field cu_r_sd_pic_read_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.sd_pic_read_ok
+    :field cu_r_sd_get_info_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.sd_get_info_ok
+    :field cu_r_sd_erase_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.sd_erase_ok
+    :field cu_r_sd_full: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.sd_full
+    :field cu_r_adc_ready: ax25_frame.payload.ax25_info.tlm_area_switch.cu_r.adc_ready
+    :field timestamp_int: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.timestamp_int
+    :field cu_l_cpu_voltage_volt: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.cpu_voltage_volt
+    :field cu_l_cpu_temperature_degree: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.cpu_temperature_degree
+    :field cu_l_onyx_on: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.onyx_on
+    :field cu_l_llc_onyx_fault: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.llc_onyx_fault
+    :field cu_l_llc_sram_fault: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.llc_sram_fault
+    :field cu_l_fault_1v8_r: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.fault_1v8_r
+    :field cu_l_fault_1v8_m: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.fault_1v8_m
+    :field cu_l_fault_3v3_12v: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.fault_3v3_12v
+    :field cu_l_pic_ready_raw: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.pic_ready_raw
+    :field cu_l_pic_ready_conv: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.pic_ready_conv
+    :field cu_l_pic_ready_compressed: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.pic_ready_compressed
+    :field cu_l_pic_ready_compressed_8: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.pic_ready_compressed_8
+    :field cu_l_sd_pic_write_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.sd_pic_write_ok
+    :field cu_l_sd_pic_read_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.sd_pic_read_ok
+    :field cu_l_sd_get_info_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.sd_get_info_ok
+    :field cu_l_sd_erase_ok: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.sd_erase_ok
+    :field cu_l_sd_full: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.sd_full
+    :field cu_l_adc_ready: ax25_frame.payload.ax25_info.tlm_area_switch.cu_l.adc_ready
     :field aprs_message: ax25_frame.payload.ax25_info.aprs_message
     
     .. seealso::
        Source - https://gitlab.com/librespacefoundation/satnogs-ops/uploads/f6fde8b864f8cdf37d65433bd958e138/AmicalSat_downlinks_v0.3.pdf
     """
     def __init__(self, _io, _parent=None, _root=None):
         self._io = _io
         self._parent = _parent
         self._root = _root if _root else self
         self._read()
 
     def _read(self):
         self.ax25_frame = self._root.Ax25Frame(self._io, self, self._root)
 
-    class EmmnType(KaitaiStruct):
-        """[EM/ER];MN;[Timestamp];[V in];[V solar];[I in];[P in];[P peak];[T cpu];[V cpu]
+    class Ax25Frame(KaitaiStruct):
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.ax25_header = self._root.Ax25Header(self._io, self, self._root)
+            _on = (self.ax25_header.ctl & 19)
+            if _on == 0:
+                self.payload = self._root.IFrame(self._io, self, self._root)
+            elif _on == 3:
+                self.payload = self._root.UiFrame(self._io, self, self._root)
+            elif _on == 19:
+                self.payload = self._root.UiFrame(self._io, self, self._root)
+            elif _on == 16:
+                self.payload = self._root.IFrame(self._io, self, self._root)
+            elif _on == 18:
+                self.payload = self._root.IFrame(self._io, self, self._root)
+            elif _on == 2:
+                self.payload = self._root.IFrame(self._io, self, self._root)
+
+
+    class CuRLogType(KaitaiStruct):
+        """CU_R;LOG;[Timestamp];[CPU voltage];[CPU temperature];[flags]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.v_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.v_solar = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.i_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.p_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.p_peak = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.t_cpu = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.v_cpu = (self._io.read_bytes_full()).decode(u"ASCII")
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.cpu_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.cpu_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.flagsmagic = self._io.ensure_fixed_contents(b"\x30\x78")
+            self.cu_flags = (self._io.read_bytes_full()).decode(u"ASCII")
 
         @property
-        def p_peak_mw(self):
-            if hasattr(self, '_m_p_peak_mw'):
-                return self._m_p_peak_mw if hasattr(self, '_m_p_peak_mw') else None
+        def cpu_temperature_degree(self):
+            if hasattr(self, '_m_cpu_temperature_degree'):
+                return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
 
-            self._m_p_peak_mw = int(self.p_peak)
-            return self._m_p_peak_mw if hasattr(self, '_m_p_peak_mw') else None
+            self._m_cpu_temperature_degree = int(self.cpu_temperature)
+            return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
 
         @property
-        def t_cpu_degree(self):
-            if hasattr(self, '_m_t_cpu_degree'):
-                return self._m_t_cpu_degree if hasattr(self, '_m_t_cpu_degree') else None
+        def sd_pic_write_ok(self):
+            if hasattr(self, '_m_sd_pic_write_ok'):
+                return self._m_sd_pic_write_ok if hasattr(self, '_m_sd_pic_write_ok') else None
 
-            self._m_t_cpu_degree = int(self.t_cpu)
-            return self._m_t_cpu_degree if hasattr(self, '_m_t_cpu_degree') else None
+            self._m_sd_pic_write_ok = ((int(self.cu_flags, 16) & 1024) >> 10)
+            return self._m_sd_pic_write_ok if hasattr(self, '_m_sd_pic_write_ok') else None
 
         @property
-        def v_solar_volt(self):
-            if hasattr(self, '_m_v_solar_volt'):
-                return self._m_v_solar_volt if hasattr(self, '_m_v_solar_volt') else None
+        def sd_pic_read_ok(self):
+            if hasattr(self, '_m_sd_pic_read_ok'):
+                return self._m_sd_pic_read_ok if hasattr(self, '_m_sd_pic_read_ok') else None
 
-            self._m_v_solar_volt = (int(self.v_solar) / 1000.0)
-            return self._m_v_solar_volt if hasattr(self, '_m_v_solar_volt') else None
+            self._m_sd_pic_read_ok = ((int(self.cu_flags, 16) & 2048) >> 11)
+            return self._m_sd_pic_read_ok if hasattr(self, '_m_sd_pic_read_ok') else None
 
         @property
-        def v_in_volt(self):
-            if hasattr(self, '_m_v_in_volt'):
-                return self._m_v_in_volt if hasattr(self, '_m_v_in_volt') else None
+        def pic_ready_conv(self):
+            if hasattr(self, '_m_pic_ready_conv'):
+                return self._m_pic_ready_conv if hasattr(self, '_m_pic_ready_conv') else None
 
-            self._m_v_in_volt = (int(self.v_in) / 1000.0)
-            return self._m_v_in_volt if hasattr(self, '_m_v_in_volt') else None
+            self._m_pic_ready_conv = ((int(self.cu_flags, 16) & 128) >> 7)
+            return self._m_pic_ready_conv if hasattr(self, '_m_pic_ready_conv') else None
 
         @property
-        def p_in_mw(self):
-            if hasattr(self, '_m_p_in_mw'):
-                return self._m_p_in_mw if hasattr(self, '_m_p_in_mw') else None
+        def fault_1v8_r(self):
+            if hasattr(self, '_m_fault_1v8_r'):
+                return self._m_fault_1v8_r if hasattr(self, '_m_fault_1v8_r') else None
 
-            self._m_p_in_mw = int(self.p_in)
-            return self._m_p_in_mw if hasattr(self, '_m_p_in_mw') else None
+            self._m_fault_1v8_r = ((int(self.cu_flags, 16) & 8) >> 3)
+            return self._m_fault_1v8_r if hasattr(self, '_m_fault_1v8_r') else None
 
         @property
-        def i_in_ma(self):
-            if hasattr(self, '_m_i_in_ma'):
-                return self._m_i_in_ma if hasattr(self, '_m_i_in_ma') else None
+        def fault_1v8_m(self):
+            if hasattr(self, '_m_fault_1v8_m'):
+                return self._m_fault_1v8_m if hasattr(self, '_m_fault_1v8_m') else None
 
-            self._m_i_in_ma = int(self.i_in)
-            return self._m_i_in_ma if hasattr(self, '_m_i_in_ma') else None
+            self._m_fault_1v8_m = ((int(self.cu_flags, 16) & 16) >> 4)
+            return self._m_fault_1v8_m if hasattr(self, '_m_fault_1v8_m') else None
 
         @property
-        def v_cpu_volt(self):
-            if hasattr(self, '_m_v_cpu_volt'):
-                return self._m_v_cpu_volt if hasattr(self, '_m_v_cpu_volt') else None
+        def llc_sram_fault(self):
+            if hasattr(self, '_m_llc_sram_fault'):
+                return self._m_llc_sram_fault if hasattr(self, '_m_llc_sram_fault') else None
 
-            self._m_v_cpu_volt = (int(self.v_cpu) / 1000.0)
-            return self._m_v_cpu_volt if hasattr(self, '_m_v_cpu_volt') else None
+            self._m_llc_sram_fault = ((int(self.cu_flags, 16) & 4) >> 2)
+            return self._m_llc_sram_fault if hasattr(self, '_m_llc_sram_fault') else None
 
+        @property
+        def fault_3v3_12v(self):
+            if hasattr(self, '_m_fault_3v3_12v'):
+                return self._m_fault_3v3_12v if hasattr(self, '_m_fault_3v3_12v') else None
 
-    class Ax25Frame(KaitaiStruct):
-        def __init__(self, _io, _parent=None, _root=None):
-            self._io = _io
-            self._parent = _parent
-            self._root = _root if _root else self
-            self._read()
+            self._m_fault_3v3_12v = ((int(self.cu_flags, 16) & 32) >> 5)
+            return self._m_fault_3v3_12v if hasattr(self, '_m_fault_3v3_12v') else None
 
-        def _read(self):
-            self.ax25_header = self._root.Ax25Header(self._io, self, self._root)
-            _on = (self.ax25_header.ctl & 19)
-            if _on == 0:
-                self.payload = self._root.IFrame(self._io, self, self._root)
-            elif _on == 3:
-                self.payload = self._root.UiFrame(self._io, self, self._root)
-            elif _on == 19:
-                self.payload = self._root.UiFrame(self._io, self, self._root)
-            elif _on == 16:
-                self.payload = self._root.IFrame(self._io, self, self._root)
-            elif _on == 18:
-                self.payload = self._root.IFrame(self._io, self, self._root)
-            elif _on == 2:
-                self.payload = self._root.IFrame(self._io, self, self._root)
+        @property
+        def llc_onyx_fault(self):
+            if hasattr(self, '_m_llc_onyx_fault'):
+                return self._m_llc_onyx_fault if hasattr(self, '_m_llc_onyx_fault') else None
+
+            self._m_llc_onyx_fault = ((int(self.cu_flags, 16) & 2) >> 1)
+            return self._m_llc_onyx_fault if hasattr(self, '_m_llc_onyx_fault') else None
+
+        @property
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+        @property
+        def sd_erase_ok(self):
+            if hasattr(self, '_m_sd_erase_ok'):
+                return self._m_sd_erase_ok if hasattr(self, '_m_sd_erase_ok') else None
+
+            self._m_sd_erase_ok = ((int(self.cu_flags, 16) & 8192) >> 13)
+            return self._m_sd_erase_ok if hasattr(self, '_m_sd_erase_ok') else None
+
+        @property
+        def sd_get_info_ok(self):
+            if hasattr(self, '_m_sd_get_info_ok'):
+                return self._m_sd_get_info_ok if hasattr(self, '_m_sd_get_info_ok') else None
+
+            self._m_sd_get_info_ok = ((int(self.cu_flags, 16) & 4096) >> 12)
+            return self._m_sd_get_info_ok if hasattr(self, '_m_sd_get_info_ok') else None
+
+        @property
+        def onyx_on(self):
+            if hasattr(self, '_m_onyx_on'):
+                return self._m_onyx_on if hasattr(self, '_m_onyx_on') else None
+
+            self._m_onyx_on = (int(self.cu_flags, 16) & 1)
+            return self._m_onyx_on if hasattr(self, '_m_onyx_on') else None
+
+        @property
+        def pic_ready_raw(self):
+            if hasattr(self, '_m_pic_ready_raw'):
+                return self._m_pic_ready_raw if hasattr(self, '_m_pic_ready_raw') else None
+
+            self._m_pic_ready_raw = ((int(self.cu_flags, 16) & 64) >> 6)
+            return self._m_pic_ready_raw if hasattr(self, '_m_pic_ready_raw') else None
+
+        @property
+        def cpu_voltage_volt(self):
+            if hasattr(self, '_m_cpu_voltage_volt'):
+                return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
+
+            self._m_cpu_voltage_volt = (int(self.cpu_voltage) / 1000.0)
+            return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
+
+        @property
+        def sd_full(self):
+            if hasattr(self, '_m_sd_full'):
+                return self._m_sd_full if hasattr(self, '_m_sd_full') else None
+
+            self._m_sd_full = ((int(self.cu_flags, 16) & 16384) >> 14)
+            return self._m_sd_full if hasattr(self, '_m_sd_full') else None
+
+        @property
+        def pic_ready_compressed_8(self):
+            if hasattr(self, '_m_pic_ready_compressed_8'):
+                return self._m_pic_ready_compressed_8 if hasattr(self, '_m_pic_ready_compressed_8') else None
+
+            self._m_pic_ready_compressed_8 = ((int(self.cu_flags, 16) & 512) >> 9)
+            return self._m_pic_ready_compressed_8 if hasattr(self, '_m_pic_ready_compressed_8') else None
+
+        @property
+        def adc_ready(self):
+            if hasattr(self, '_m_adc_ready'):
+                return self._m_adc_ready if hasattr(self, '_m_adc_ready') else None
+
+            self._m_adc_ready = ((int(self.cu_flags, 16) & 32768) >> 15)
+            return self._m_adc_ready if hasattr(self, '_m_adc_ready') else None
+
+        @property
+        def pic_ready_compressed(self):
+            if hasattr(self, '_m_pic_ready_compressed'):
+                return self._m_pic_ready_compressed if hasattr(self, '_m_pic_ready_compressed') else None
+
+            self._m_pic_ready_compressed = ((int(self.cu_flags, 16) & 256) >> 8)
+            return self._m_pic_ready_compressed if hasattr(self, '_m_pic_ready_compressed') else None
 
 
     class Ax25Header(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
@@ -325,20 +467,106 @@
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            _on = self._parent.tlm_type
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
             if _on == u"LOG":
-                self.tlm_sw = self._root.LogType(self._io, self, self._root)
+                self.m1 = self._root.M1LogType(self._io, self, self._root)
             elif _on == u"FLAGS":
-                self.tlm_sw = self._root.FlagsType(self._io, self, self._root)
+                self.m1 = self._root.M1FlagsType(self._io, self, self._root)
+
+
+    class CuLOnyxType(KaitaiStruct):
+        """CU_L;ONYX SENSOR T;[Timestamp];[Return value]
+        """
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.return_value = (self._io.read_bytes_full()).decode(u"ASCII")
+
+        @property
+        def return_value_int(self):
+            if hasattr(self, '_m_return_value_int'):
+                return self._m_return_value_int if hasattr(self, '_m_return_value_int') else None
+
+            self._m_return_value_int = int(self.return_value)
+            return self._m_return_value_int if hasattr(self, '_m_return_value_int') else None
+
+        @property
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+
+    class CuLType(KaitaiStruct):
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
+            if _on == u"ONYX SENSOR T":
+                self.cu_l = self._root.CuLOnyxType(self._io, self, self._root)
+            elif _on == u"LOG":
+                self.cu_l = self._root.CuLLogType(self._io, self, self._root)
+
+
+    class V1MsType(KaitaiStruct):
+        """V1;MS;[Timestamp];[Current rssi];[Latch rssi];[AFC offset]
+        """
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.current_rssi = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.latch_rssi = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.a_f_c_offset = (self._io.read_bytes_full()).decode(u"ASCII")
+
+        @property
+        def current_rssi_int(self):
+            if hasattr(self, '_m_current_rssi_int'):
+                return self._m_current_rssi_int if hasattr(self, '_m_current_rssi_int') else None
+
+            self._m_current_rssi_int = int(self.current_rssi)
+            return self._m_current_rssi_int if hasattr(self, '_m_current_rssi_int') else None
+
+        @property
+        def latch_rssi_int(self):
+            if hasattr(self, '_m_latch_rssi_int'):
+                return self._m_latch_rssi_int if hasattr(self, '_m_latch_rssi_int') else None
+
+            self._m_latch_rssi_int = int(self.latch_rssi)
+            return self._m_latch_rssi_int if hasattr(self, '_m_latch_rssi_int') else None
+
+        @property
+        def a_f_c_offset_int(self):
+            if hasattr(self, '_m_a_f_c_offset_int'):
+                return self._m_a_f_c_offset_int if hasattr(self, '_m_a_f_c_offset_int') else None
+
+            self._m_a_f_c_offset_int = int(self.a_f_c_offset)
+            return self._m_a_f_c_offset_int if hasattr(self, '_m_a_f_c_offset_int') else None
 
         @property
         def timestamp_int(self):
             if hasattr(self, '_m_timestamp_int'):
                 return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
             self._m_timestamp_int = int(self.timestamp)
@@ -351,14 +579,15 @@
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.boot_number = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.input_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.input_current = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.input_power = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.peak_power = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.solar_panel_voltage = (self._io.read_bytes_full()).decode(u"ASCII")
 
@@ -391,14 +620,22 @@
             if hasattr(self, '_m_boot_number_int'):
                 return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
 
             self._m_boot_number_int = int(self.boot_number)
             return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
 
         @property
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+        @property
         def input_voltage_volt(self):
             if hasattr(self, '_m_input_voltage_volt'):
                 return self._m_input_voltage_volt if hasattr(self, '_m_input_voltage_volt') else None
 
             self._m_input_voltage_volt = (int(self.input_voltage) / 1000.0)
             return self._m_input_voltage_volt if hasattr(self, '_m_input_voltage_volt') else None
 
@@ -407,461 +644,265 @@
             if hasattr(self, '_m_solar_panel_voltage_volt'):
                 return self._m_solar_panel_voltage_volt if hasattr(self, '_m_solar_panel_voltage_volt') else None
 
             self._m_solar_panel_voltage_volt = (int(self.solar_panel_voltage) / 1000.0)
             return self._m_solar_panel_voltage_volt if hasattr(self, '_m_solar_panel_voltage_volt') else None
 
 
-    class A1FlagType(KaitaiStruct):
-        """A1;FLAGS;[mode];[flags];[faults]
+    class ErMnType(KaitaiStruct):
+        """ER;MN;[Timestamp];[V in];[V solar];[I in];[P in];[P peak];[T cpu];[V cpu]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
             self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.adcs_mode = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.a1_flags = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.faults = (self._io.read_bytes_full()).decode(u"ASCII")
-
-        @property
-        def sens_on_off(self):
-            if hasattr(self, '_m_sens_on_off'):
-                return self._m_sens_on_off if hasattr(self, '_m_sens_on_off') else None
-
-            self._m_sens_on_off = ((int(self.a1_flags, 16) & 4) >> 2)
-            return self._m_sens_on_off if hasattr(self, '_m_sens_on_off') else None
-
-        @property
-        def l3_fault(self):
-            if hasattr(self, '_m_l3_fault'):
-                return self._m_l3_fault if hasattr(self, '_m_l3_fault') else None
-
-            self._m_l3_fault = ((int(self.faults, 16) & 32) >> 5)
-            return self._m_l3_fault if hasattr(self, '_m_l3_fault') else None
-
-        @property
-        def manual(self):
-            if hasattr(self, '_m_manual'):
-                return self._m_manual if hasattr(self, '_m_manual') else None
-
-            self._m_manual = ((int(self.adcs_mode, 16) & 240) >> 4)
-            return self._m_manual if hasattr(self, '_m_manual') else None
-
-        @property
-        def sun_contr(self):
-            if hasattr(self, '_m_sun_contr'):
-                return self._m_sun_contr if hasattr(self, '_m_sun_contr') else None
-
-            self._m_sun_contr = ((int(self.a1_flags, 16) & 2) >> 1)
-            return self._m_sun_contr if hasattr(self, '_m_sun_contr') else None
-
-        @property
-        def gyro_acc_fault(self):
-            if hasattr(self, '_m_gyro_acc_fault'):
-                return self._m_gyro_acc_fault if hasattr(self, '_m_gyro_acc_fault') else None
-
-            self._m_gyro_acc_fault = (int(self.faults, 16) & 1)
-            return self._m_gyro_acc_fault if hasattr(self, '_m_gyro_acc_fault') else None
-
-        @property
-        def l1_fault(self):
-            if hasattr(self, '_m_l1_fault'):
-                return self._m_l1_fault if hasattr(self, '_m_l1_fault') else None
-
-            self._m_l1_fault = ((int(self.faults, 16) & 8) >> 3)
-            return self._m_l1_fault if hasattr(self, '_m_l1_fault') else None
+            self.v_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.v_solar = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.i_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.p_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.p_peak = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.t_cpu = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.v_cpu = (self._io.read_bytes_full()).decode(u"ASCII")
 
         @property
-        def act_man_contr(self):
-            if hasattr(self, '_m_act_man_contr'):
-                return self._m_act_man_contr if hasattr(self, '_m_act_man_contr') else None
+        def p_peak_mw(self):
+            if hasattr(self, '_m_p_peak_mw'):
+                return self._m_p_peak_mw if hasattr(self, '_m_p_peak_mw') else None
 
-            self._m_act_man_contr = ((int(self.a1_flags, 16) & 8) >> 3)
-            return self._m_act_man_contr if hasattr(self, '_m_act_man_contr') else None
+            self._m_p_peak_mw = int(self.p_peak)
+            return self._m_p_peak_mw if hasattr(self, '_m_p_peak_mw') else None
 
         @property
         def timestamp_int(self):
             if hasattr(self, '_m_timestamp_int'):
                 return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
             self._m_timestamp_int = int(self.timestamp)
             return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
         @property
-        def adcs_on_off(self):
-            if hasattr(self, '_m_adcs_on_off'):
-                return self._m_adcs_on_off if hasattr(self, '_m_adcs_on_off') else None
-
-            self._m_adcs_on_off = ((int(self.adcs_mode, 16) & 2) >> 1)
-            return self._m_adcs_on_off if hasattr(self, '_m_adcs_on_off') else None
-
-        @property
-        def detumbling_status(self):
-            if hasattr(self, '_m_detumbling_status'):
-                return self._m_detumbling_status if hasattr(self, '_m_detumbling_status') else None
-
-            self._m_detumbling_status = ((int(self.adcs_mode, 16) & 12) >> 2)
-            return self._m_detumbling_status if hasattr(self, '_m_detumbling_status') else None
-
-        @property
-        def act_limited_contr(self):
-            if hasattr(self, '_m_act_limited_contr'):
-                return self._m_act_limited_contr if hasattr(self, '_m_act_limited_contr') else None
+        def t_cpu_degree(self):
+            if hasattr(self, '_m_t_cpu_degree'):
+                return self._m_t_cpu_degree if hasattr(self, '_m_t_cpu_degree') else None
 
-            self._m_act_limited_contr = ((int(self.a1_flags, 16) & 16) >> 4)
-            return self._m_act_limited_contr if hasattr(self, '_m_act_limited_contr') else None
+            self._m_t_cpu_degree = int(self.t_cpu)
+            return self._m_t_cpu_degree if hasattr(self, '_m_t_cpu_degree') else None
 
         @property
-        def act_on_off(self):
-            if hasattr(self, '_m_act_on_off'):
-                return self._m_act_on_off if hasattr(self, '_m_act_on_off') else None
+        def v_solar_volt(self):
+            if hasattr(self, '_m_v_solar_volt'):
+                return self._m_v_solar_volt if hasattr(self, '_m_v_solar_volt') else None
 
-            self._m_act_on_off = (int(self.a1_flags, 16) & 1)
-            return self._m_act_on_off if hasattr(self, '_m_act_on_off') else None
+            self._m_v_solar_volt = (int(self.v_solar) / 1000.0)
+            return self._m_v_solar_volt if hasattr(self, '_m_v_solar_volt') else None
 
         @property
-        def mag_fault(self):
-            if hasattr(self, '_m_mag_fault'):
-                return self._m_mag_fault if hasattr(self, '_m_mag_fault') else None
+        def v_in_volt(self):
+            if hasattr(self, '_m_v_in_volt'):
+                return self._m_v_in_volt if hasattr(self, '_m_v_in_volt') else None
 
-            self._m_mag_fault = ((int(self.faults, 16) & 2) >> 1)
-            return self._m_mag_fault if hasattr(self, '_m_mag_fault') else None
+            self._m_v_in_volt = (int(self.v_in) / 1000.0)
+            return self._m_v_in_volt if hasattr(self, '_m_v_in_volt') else None
 
         @property
-        def sun_fault(self):
-            if hasattr(self, '_m_sun_fault'):
-                return self._m_sun_fault if hasattr(self, '_m_sun_fault') else None
+        def p_in_mw(self):
+            if hasattr(self, '_m_p_in_mw'):
+                return self._m_p_in_mw if hasattr(self, '_m_p_in_mw') else None
 
-            self._m_sun_fault = ((int(self.faults, 16) & 4) >> 2)
-            return self._m_sun_fault if hasattr(self, '_m_sun_fault') else None
+            self._m_p_in_mw = int(self.p_in)
+            return self._m_p_in_mw if hasattr(self, '_m_p_in_mw') else None
 
         @property
-        def l2_fault(self):
-            if hasattr(self, '_m_l2_fault'):
-                return self._m_l2_fault if hasattr(self, '_m_l2_fault') else None
+        def i_in_ma(self):
+            if hasattr(self, '_m_i_in_ma'):
+                return self._m_i_in_ma if hasattr(self, '_m_i_in_ma') else None
 
-            self._m_l2_fault = ((int(self.faults, 16) & 16) >> 4)
-            return self._m_l2_fault if hasattr(self, '_m_l2_fault') else None
+            self._m_i_in_ma = int(self.i_in)
+            return self._m_i_in_ma if hasattr(self, '_m_i_in_ma') else None
 
         @property
-        def detumbling(self):
-            if hasattr(self, '_m_detumbling'):
-                return self._m_detumbling if hasattr(self, '_m_detumbling') else None
+        def v_cpu_volt(self):
+            if hasattr(self, '_m_v_cpu_volt'):
+                return self._m_v_cpu_volt if hasattr(self, '_m_v_cpu_volt') else None
 
-            self._m_detumbling = (int(self.adcs_mode, 16) & 1)
-            return self._m_detumbling if hasattr(self, '_m_detumbling') else None
+            self._m_v_cpu_volt = (int(self.v_cpu) / 1000.0)
+            return self._m_v_cpu_volt if hasattr(self, '_m_v_cpu_volt') else None
 
 
-    class FlagsType(KaitaiStruct):
-        """M1;FLAGS;[Timestamp];[Hex flags];
-        """
+    class CuRType(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.hex_part = (self._io.read_bytes_term(120, False, True, True)).decode(u"ASCII")
-            self.flags = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-
-        @property
-        def beacon_mode(self):
-            if hasattr(self, '_m_beacon_mode'):
-                return self._m_beacon_mode if hasattr(self, '_m_beacon_mode') else None
-
-            self._m_beacon_mode = ((int(self.flags, 16) & 256) >> 8)
-            return self._m_beacon_mode if hasattr(self, '_m_beacon_mode') else None
-
-        @property
-        def cur_dead(self):
-            if hasattr(self, '_m_cur_dead'):
-                return self._m_cur_dead if hasattr(self, '_m_cur_dead') else None
-
-            self._m_cur_dead = ((int(self.flags, 16) & 4026531840) >> 28)
-            return self._m_cur_dead if hasattr(self, '_m_cur_dead') else None
-
-        @property
-        def cur_on(self):
-            if hasattr(self, '_m_cur_on'):
-                return self._m_cur_on if hasattr(self, '_m_cur_on') else None
-
-            self._m_cur_on = ((int(self.flags, 16) & 262144) >> 18)
-            return self._m_cur_on if hasattr(self, '_m_cur_on') else None
-
-        @property
-        def stream(self):
-            if hasattr(self, '_m_stream'):
-                return self._m_stream if hasattr(self, '_m_stream') else None
-
-            self._m_stream = ((int(self.flags, 16) & 281474976710656) >> 48)
-            return self._m_stream if hasattr(self, '_m_stream') else None
-
-        @property
-        def imc_aocs_ok(self):
-            if hasattr(self, '_m_imc_aocs_ok'):
-                return self._m_imc_aocs_ok if hasattr(self, '_m_imc_aocs_ok') else None
-
-            self._m_imc_aocs_ok = (int(self.flags, 16) & 1)
-            return self._m_imc_aocs_ok if hasattr(self, '_m_imc_aocs_ok') else None
-
-        @property
-        def uhf2_downlink(self):
-            if hasattr(self, '_m_uhf2_downlink'):
-                return self._m_uhf2_downlink if hasattr(self, '_m_uhf2_downlink') else None
-
-            self._m_uhf2_downlink = ((int(self.flags, 16) & 64) >> 6)
-            return self._m_uhf2_downlink if hasattr(self, '_m_uhf2_downlink') else None
-
-        @property
-        def cul_on(self):
-            if hasattr(self, '_m_cul_on'):
-                return self._m_cul_on if hasattr(self, '_m_cul_on') else None
-
-            self._m_cul_on = ((int(self.flags, 16) & 65536) >> 16)
-            return self._m_cul_on if hasattr(self, '_m_cul_on') else None
-
-        @property
-        def payload_off(self):
-            if hasattr(self, '_m_payload_off'):
-                return self._m_payload_off if hasattr(self, '_m_payload_off') else None
-
-            self._m_payload_off = ((int(self.flags, 16) & 2048) >> 11)
-            return self._m_payload_off if hasattr(self, '_m_payload_off') else None
-
-        @property
-        def cu_auto_off(self):
-            if hasattr(self, '_m_cu_auto_off'):
-                return self._m_cu_auto_off if hasattr(self, '_m_cu_auto_off') else None
-
-            self._m_cu_auto_off = ((int(self.flags, 16) & 4096) >> 12)
-            return self._m_cu_auto_off if hasattr(self, '_m_cu_auto_off') else None
-
-        @property
-        def survival_start(self):
-            if hasattr(self, '_m_survival_start'):
-                return self._m_survival_start if hasattr(self, '_m_survival_start') else None
-
-            self._m_survival_start = ((int(self.flags, 16) & 2251799813685248) >> 51)
-            return self._m_survival_start if hasattr(self, '_m_survival_start') else None
-
-        @property
-        def fault_3v_m(self):
-            if hasattr(self, '_m_fault_3v_m'):
-                return self._m_fault_3v_m if hasattr(self, '_m_fault_3v_m') else None
-
-            self._m_fault_3v_m = ((int(self.flags, 16) & 2199023255552) >> 41)
-            return self._m_fault_3v_m if hasattr(self, '_m_fault_3v_m') else None
-
-        @property
-        def plan(self):
-            if hasattr(self, '_m_plan'):
-                return self._m_plan if hasattr(self, '_m_plan') else None
-
-            self._m_plan = ((int(self.flags, 16) & 140737488355328) >> 47)
-            return self._m_plan if hasattr(self, '_m_plan') else None
-
-        @property
-        def vhf1_downlink(self):
-            if hasattr(self, '_m_vhf1_downlink'):
-                return self._m_vhf1_downlink if hasattr(self, '_m_vhf1_downlink') else None
-
-            self._m_vhf1_downlink = ((int(self.flags, 16) & 32) >> 5)
-            return self._m_vhf1_downlink if hasattr(self, '_m_vhf1_downlink') else None
-
-        @property
-        def cyclic_reset_on(self):
-            if hasattr(self, '_m_cyclic_reset_on'):
-                return self._m_cyclic_reset_on if hasattr(self, '_m_cyclic_reset_on') else None
-
-            self._m_cyclic_reset_on = ((int(self.flags, 16) & 512) >> 9)
-            return self._m_cyclic_reset_on if hasattr(self, '_m_cyclic_reset_on') else None
-
-        @property
-        def uhf2_packet_ready(self):
-            if hasattr(self, '_m_uhf2_packet_ready'):
-                return self._m_uhf2_packet_ready if hasattr(self, '_m_uhf2_packet_ready') else None
-
-            self._m_uhf2_packet_ready = ((int(self.flags, 16) & 1125899906842624) >> 50)
-            return self._m_uhf2_packet_ready if hasattr(self, '_m_uhf2_packet_ready') else None
-
-        @property
-        def cur_fault(self):
-            if hasattr(self, '_m_cur_fault'):
-                return self._m_cur_fault if hasattr(self, '_m_cur_fault') else None
-
-            self._m_cur_fault = ((int(self.flags, 16) & 524288) >> 19)
-            return self._m_cur_fault if hasattr(self, '_m_cur_fault') else None
-
-        @property
-        def vhf1_packet_ready(self):
-            if hasattr(self, '_m_vhf1_packet_ready'):
-                return self._m_vhf1_packet_ready if hasattr(self, '_m_vhf1_packet_ready') else None
-
-            self._m_vhf1_packet_ready = ((int(self.flags, 16) & 562949953421312) >> 49)
-            return self._m_vhf1_packet_ready if hasattr(self, '_m_vhf1_packet_ready') else None
-
-        @property
-        def cul_faut(self):
-            if hasattr(self, '_m_cul_faut'):
-                return self._m_cul_faut if hasattr(self, '_m_cul_faut') else None
-
-            self._m_cul_faut = ((int(self.flags, 16) & 131072) >> 17)
-            return self._m_cul_faut if hasattr(self, '_m_cul_faut') else None
-
-        @property
-        def tm_log(self):
-            if hasattr(self, '_m_tm_log'):
-                return self._m_tm_log if hasattr(self, '_m_tm_log') else None
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
+            if _on == u"ONYX SENSOR T":
+                self.cu_r = self._root.CuROnyxType(self._io, self, self._root)
+            elif _on == u"LOG":
+                self.cu_r = self._root.CuRLogType(self._io, self, self._root)
 
-            self._m_tm_log = ((int(self.flags, 16) & 8192) >> 13)
-            return self._m_tm_log if hasattr(self, '_m_tm_log') else None
 
-        @property
-        def long_log(self):
-            if hasattr(self, '_m_long_log'):
-                return self._m_long_log if hasattr(self, '_m_long_log') else None
-
-            self._m_long_log = ((int(self.flags, 16) & 35184372088832) >> 45)
-            return self._m_long_log if hasattr(self, '_m_long_log') else None
+    class IFrame(KaitaiStruct):
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
 
-        @property
-        def imc_uhf2_ok(self):
-            if hasattr(self, '_m_imc_uhf2_ok'):
-                return self._m_imc_uhf2_ok if hasattr(self, '_m_imc_uhf2_ok') else None
+        def _read(self):
+            self.pid = self._io.read_u1()
+            self._raw_ax25_info = self._io.read_bytes_full()
+            io = KaitaiStream(BytesIO(self._raw_ax25_info))
+            self.ax25_info = self._root.Ax25InfoData(io, self, self._root)
 
-            self._m_imc_uhf2_ok = ((int(self.flags, 16) & 16) >> 4)
-            return self._m_imc_uhf2_ok if hasattr(self, '_m_imc_uhf2_ok') else None
 
-        @property
-        def imc_check(self):
-            if hasattr(self, '_m_imc_check'):
-                return self._m_imc_check if hasattr(self, '_m_imc_check') else None
+    class U2RlType(KaitaiStruct):
+        """U2;RL;[Timestamp],[CPU voltage];[Battery voltage];[CPU temperature];[Amplifier temperature];[Flags]
+        """
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
 
-            self._m_imc_check = ((int(self.flags, 16) & 128) >> 7)
-            return self._m_imc_check if hasattr(self, '_m_imc_check') else None
+        def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.cpu_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.battery_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.cpu_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.amplifier_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.flagsmagic = self._io.ensure_fixed_contents(b"\x30\x78")
+            self.flags = (self._io.read_bytes(1)).decode(u"ASCII")
 
         @property
-        def charge_m(self):
-            if hasattr(self, '_m_charge_m'):
-                return self._m_charge_m if hasattr(self, '_m_charge_m') else None
+        def cpu_temperature_degree(self):
+            if hasattr(self, '_m_cpu_temperature_degree'):
+                return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
 
-            self._m_charge_m = ((int(self.flags, 16) & 8796093022208) >> 43)
-            return self._m_charge_m if hasattr(self, '_m_charge_m') else None
+            self._m_cpu_temperature_degree = int(self.cpu_temperature)
+            return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
 
         @property
-        def survival_end(self):
-            if hasattr(self, '_m_survival_end'):
-                return self._m_survival_end if hasattr(self, '_m_survival_end') else None
+        def fec(self):
+            if hasattr(self, '_m_fec'):
+                return self._m_fec if hasattr(self, '_m_fec') else None
 
-            self._m_survival_end = ((int(self.flags, 16) & 4503599627370496) >> 52)
-            return self._m_survival_end if hasattr(self, '_m_survival_end') else None
+            self._m_fec = (int(self.flags, 16) & 1)
+            return self._m_fec if hasattr(self, '_m_fec') else None
 
         @property
-        def fault_3v_r(self):
-            if hasattr(self, '_m_fault_3v_r'):
-                return self._m_fault_3v_r if hasattr(self, '_m_fault_3v_r') else None
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
-            self._m_fault_3v_r = ((int(self.flags, 16) & 1099511627776) >> 40)
-            return self._m_fault_3v_r if hasattr(self, '_m_fault_3v_r') else None
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
         @property
-        def survival_mode(self):
-            if hasattr(self, '_m_survival_mode'):
-                return self._m_survival_mode if hasattr(self, '_m_survival_mode') else None
+        def band_lock(self):
+            if hasattr(self, '_m_band_lock'):
+                return self._m_band_lock if hasattr(self, '_m_band_lock') else None
 
-            self._m_survival_mode = ((int(self.flags, 16) & 1024) >> 10)
-            return self._m_survival_mode if hasattr(self, '_m_survival_mode') else None
+            self._m_band_lock = ((int(self.flags, 16) & 4) >> 2)
+            return self._m_band_lock if hasattr(self, '_m_band_lock') else None
 
         @property
-        def imc_cu_r_ok(self):
-            if hasattr(self, '_m_imc_cu_r_ok'):
-                return self._m_imc_cu_r_ok if hasattr(self, '_m_imc_cu_r_ok') else None
+        def cpu_voltage_volt(self):
+            if hasattr(self, '_m_cpu_voltage_volt'):
+                return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
 
-            self._m_imc_cu_r_ok = ((int(self.flags, 16) & 4) >> 2)
-            return self._m_imc_cu_r_ok if hasattr(self, '_m_imc_cu_r_ok') else None
+            self._m_cpu_voltage_volt = (int(self.cpu_voltage) / 1000.0)
+            return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
 
         @property
-        def cul_dead(self):
-            if hasattr(self, '_m_cul_dead'):
-                return self._m_cul_dead if hasattr(self, '_m_cul_dead') else None
+        def aes_128(self):
+            if hasattr(self, '_m_aes_128'):
+                return self._m_aes_128 if hasattr(self, '_m_aes_128') else None
 
-            self._m_cul_dead = ((int(self.flags, 16) & 251658240) >> 24)
-            return self._m_cul_dead if hasattr(self, '_m_cul_dead') else None
+            self._m_aes_128 = ((int(self.flags, 16) & 16) >> 4)
+            return self._m_aes_128 if hasattr(self, '_m_aes_128') else None
 
         @property
-        def charge_r(self):
-            if hasattr(self, '_m_charge_r'):
-                return self._m_charge_r if hasattr(self, '_m_charge_r') else None
+        def amplifier_temperature_degree(self):
+            if hasattr(self, '_m_amplifier_temperature_degree'):
+                return self._m_amplifier_temperature_degree if hasattr(self, '_m_amplifier_temperature_degree') else None
 
-            self._m_charge_r = ((int(self.flags, 16) & 4398046511104) >> 42)
-            return self._m_charge_r if hasattr(self, '_m_charge_r') else None
+            self._m_amplifier_temperature_degree = int(self.amplifier_temperature)
+            return self._m_amplifier_temperature_degree if hasattr(self, '_m_amplifier_temperature_degree') else None
 
         @property
-        def imc_vhf1_ok(self):
-            if hasattr(self, '_m_imc_vhf1_ok'):
-                return self._m_imc_vhf1_ok if hasattr(self, '_m_imc_vhf1_ok') else None
+        def amp_ovt(self):
+            if hasattr(self, '_m_amp_ovt'):
+                return self._m_amp_ovt if hasattr(self, '_m_amp_ovt') else None
 
-            self._m_imc_vhf1_ok = ((int(self.flags, 16) & 8) >> 3)
-            return self._m_imc_vhf1_ok if hasattr(self, '_m_imc_vhf1_ok') else None
+            self._m_amp_ovt = ((int(self.flags, 16) & 32) >> 5)
+            return self._m_amp_ovt if hasattr(self, '_m_amp_ovt') else None
 
         @property
-        def cu_on(self):
-            if hasattr(self, '_m_cu_on'):
-                return self._m_cu_on if hasattr(self, '_m_cu_on') else None
+        def xor(self):
+            if hasattr(self, '_m_xor'):
+                return self._m_xor if hasattr(self, '_m_xor') else None
 
-            self._m_cu_on = ((int(self.flags, 16) & 1048576) >> 20)
-            return self._m_cu_on if hasattr(self, '_m_cu_on') else None
+            self._m_xor = ((int(self.flags, 16) & 8) >> 3)
+            return self._m_xor if hasattr(self, '_m_xor') else None
 
         @property
-        def log_to_flash(self):
-            if hasattr(self, '_m_log_to_flash'):
-                return self._m_log_to_flash if hasattr(self, '_m_log_to_flash') else None
+        def downlink(self):
+            if hasattr(self, '_m_downlink'):
+                return self._m_downlink if hasattr(self, '_m_downlink') else None
 
-            self._m_log_to_flash = ((int(self.flags, 16) & 70368744177664) >> 46)
-            return self._m_log_to_flash if hasattr(self, '_m_log_to_flash') else None
+            self._m_downlink = ((int(self.flags, 16) & 2) >> 1)
+            return self._m_downlink if hasattr(self, '_m_downlink') else None
 
         @property
-        def imc_cu_l_ok(self):
-            if hasattr(self, '_m_imc_cu_l_ok'):
-                return self._m_imc_cu_l_ok if hasattr(self, '_m_imc_cu_l_ok') else None
+        def battery_voltage_volt(self):
+            if hasattr(self, '_m_battery_voltage_volt'):
+                return self._m_battery_voltage_volt if hasattr(self, '_m_battery_voltage_volt') else None
 
-            self._m_imc_cu_l_ok = ((int(self.flags, 16) & 2) >> 1)
-            return self._m_imc_cu_l_ok if hasattr(self, '_m_imc_cu_l_ok') else None
+            self._m_battery_voltage_volt = (int(self.battery_voltage) / 1000.0)
+            return self._m_battery_voltage_volt if hasattr(self, '_m_battery_voltage_volt') else None
 
 
-    class IFrame(KaitaiStruct):
+    class SsidMask(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.pid = self._io.read_u1()
-            self._raw_ax25_info = self._io.read_bytes_full()
-            io = KaitaiStream(BytesIO(self._raw_ax25_info))
-            self.ax25_info = self._root.Ax25InfoData(io, self, self._root)
+            self.ssid_mask = self._io.read_u1()
 
+        @property
+        def ssid(self):
+            if hasattr(self, '_m_ssid'):
+                return self._m_ssid if hasattr(self, '_m_ssid') else None
 
-    class U2RlType(KaitaiStruct):
-        """[U2];RL;[Timestamp],[CPU voltage];[Battery voltage];[CPU temperature];[Amplifier temperature];[Flags]
+            self._m_ssid = ((self.ssid_mask & 15) >> 1)
+            return self._m_ssid if hasattr(self, '_m_ssid') else None
+
+
+    class V1RlType(KaitaiStruct):
+        """V1;RL;[Timestamp],[CPU voltage];[Battery voltage];[CPU temperature];[Amplifier temperature];[Flags]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.timestamp = (self._io.read_bytes_term(44, False, True, True)).decode(u"ASCII")
             self.cpu_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.battery_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.cpu_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.amplifier_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.flagsmagic = self._io.ensure_fixed_contents(b"\x30\x78")
             self.flags = (self._io.read_bytes(1)).decode(u"ASCII")
 
@@ -950,43 +991,187 @@
             if hasattr(self, '_m_battery_voltage_volt'):
                 return self._m_battery_voltage_volt if hasattr(self, '_m_battery_voltage_volt') else None
 
             self._m_battery_voltage_volt = (int(self.battery_voltage) / 1000.0)
             return self._m_battery_voltage_volt if hasattr(self, '_m_battery_voltage_volt') else None
 
 
-    class SsidMask(KaitaiStruct):
+    class EmMnType(KaitaiStruct):
+        """EM;MN;[Timestamp];[V in];[V solar];[I in];[P in];[P peak];[T cpu];[V cpu]
+        """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.ssid_mask = self._io.read_u1()
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.v_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.v_solar = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.i_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.p_in = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.p_peak = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.t_cpu = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.v_cpu = (self._io.read_bytes_full()).decode(u"ASCII")
 
         @property
-        def ssid(self):
-            if hasattr(self, '_m_ssid'):
-                return self._m_ssid if hasattr(self, '_m_ssid') else None
+        def p_peak_mw(self):
+            if hasattr(self, '_m_p_peak_mw'):
+                return self._m_p_peak_mw if hasattr(self, '_m_p_peak_mw') else None
 
-            self._m_ssid = ((self.ssid_mask & 15) >> 1)
-            return self._m_ssid if hasattr(self, '_m_ssid') else None
+            self._m_p_peak_mw = int(self.p_peak)
+            return self._m_p_peak_mw if hasattr(self, '_m_p_peak_mw') else None
+
+        @property
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+        @property
+        def t_cpu_degree(self):
+            if hasattr(self, '_m_t_cpu_degree'):
+                return self._m_t_cpu_degree if hasattr(self, '_m_t_cpu_degree') else None
+
+            self._m_t_cpu_degree = int(self.t_cpu)
+            return self._m_t_cpu_degree if hasattr(self, '_m_t_cpu_degree') else None
+
+        @property
+        def v_solar_volt(self):
+            if hasattr(self, '_m_v_solar_volt'):
+                return self._m_v_solar_volt if hasattr(self, '_m_v_solar_volt') else None
+
+            self._m_v_solar_volt = (int(self.v_solar) / 1000.0)
+            return self._m_v_solar_volt if hasattr(self, '_m_v_solar_volt') else None
+
+        @property
+        def v_in_volt(self):
+            if hasattr(self, '_m_v_in_volt'):
+                return self._m_v_in_volt if hasattr(self, '_m_v_in_volt') else None
+
+            self._m_v_in_volt = (int(self.v_in) / 1000.0)
+            return self._m_v_in_volt if hasattr(self, '_m_v_in_volt') else None
+
+        @property
+        def p_in_mw(self):
+            if hasattr(self, '_m_p_in_mw'):
+                return self._m_p_in_mw if hasattr(self, '_m_p_in_mw') else None
+
+            self._m_p_in_mw = int(self.p_in)
+            return self._m_p_in_mw if hasattr(self, '_m_p_in_mw') else None
+
+        @property
+        def i_in_ma(self):
+            if hasattr(self, '_m_i_in_ma'):
+                return self._m_i_in_ma if hasattr(self, '_m_i_in_ma') else None
+
+            self._m_i_in_ma = int(self.i_in)
+            return self._m_i_in_ma if hasattr(self, '_m_i_in_ma') else None
+
+        @property
+        def v_cpu_volt(self):
+            if hasattr(self, '_m_v_cpu_volt'):
+                return self._m_v_cpu_volt if hasattr(self, '_m_v_cpu_volt') else None
+
+            self._m_v_cpu_volt = (int(self.v_cpu) / 1000.0)
+            return self._m_v_cpu_volt if hasattr(self, '_m_v_cpu_volt') else None
+
+
+    class Repeaters(KaitaiStruct):
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.rpt_callsign_raw = self._root.CallsignRaw(self._io, self, self._root)
+            self.rpt_ssid_raw = self._root.SsidMask(self._io, self, self._root)
+
+
+    class Repeater(KaitaiStruct):
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.rpt_instance = []
+            i = 0
+            while True:
+                _ = self._root.Repeaters(self._io, self, self._root)
+                self.rpt_instance.append(_)
+                if (_.rpt_ssid_raw.ssid_mask & 1) == 1:
+                    break
+                i += 1
 
 
-    class CuLogType(KaitaiStruct):
-        """[CU_R/CU_L];LOG;[Timestamp];[CPU voltage];[CPU temperature];[flags]
+    class U2MsType(KaitaiStruct):
+        """U2;MS;[Timestamp];[Current rssi];[Latch rssi];[AFC offset]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.current_rssi = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.latch_rssi = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.a_f_c_offset = (self._io.read_bytes_full()).decode(u"ASCII")
+
+        @property
+        def current_rssi_int(self):
+            if hasattr(self, '_m_current_rssi_int'):
+                return self._m_current_rssi_int if hasattr(self, '_m_current_rssi_int') else None
+
+            self._m_current_rssi_int = int(self.current_rssi)
+            return self._m_current_rssi_int if hasattr(self, '_m_current_rssi_int') else None
+
+        @property
+        def latch_rssi_int(self):
+            if hasattr(self, '_m_latch_rssi_int'):
+                return self._m_latch_rssi_int if hasattr(self, '_m_latch_rssi_int') else None
+
+            self._m_latch_rssi_int = int(self.latch_rssi)
+            return self._m_latch_rssi_int if hasattr(self, '_m_latch_rssi_int') else None
+
+        @property
+        def a_f_c_offset_int(self):
+            if hasattr(self, '_m_a_f_c_offset_int'):
+                return self._m_a_f_c_offset_int if hasattr(self, '_m_a_f_c_offset_int') else None
+
+            self._m_a_f_c_offset_int = int(self.a_f_c_offset)
+            return self._m_a_f_c_offset_int if hasattr(self, '_m_a_f_c_offset_int') else None
+
+        @property
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+
+    class CuLLogType(KaitaiStruct):
+        """CU_L;LOG;[Timestamp];[CPU voltage];[CPU temperature];[flags]
+        """
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.cpu_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.cpu_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             self.flagsmagic = self._io.ensure_fixed_contents(b"\x30\x78")
             self.cu_flags = (self._io.read_bytes_full()).decode(u"ASCII")
 
         @property
         def cpu_temperature_degree(self):
@@ -1057,14 +1242,22 @@
             if hasattr(self, '_m_llc_onyx_fault'):
                 return self._m_llc_onyx_fault if hasattr(self, '_m_llc_onyx_fault') else None
 
             self._m_llc_onyx_fault = ((int(self.cu_flags, 16) & 2) >> 1)
             return self._m_llc_onyx_fault if hasattr(self, '_m_llc_onyx_fault') else None
 
         @property
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+        @property
         def sd_erase_ok(self):
             if hasattr(self, '_m_sd_erase_ok'):
                 return self._m_sd_erase_ok if hasattr(self, '_m_sd_erase_ok') else None
 
             self._m_sd_erase_ok = ((int(self.cu_flags, 16) & 8192) >> 13)
             return self._m_sd_erase_ok if hasattr(self, '_m_sd_erase_ok') else None
 
@@ -1129,519 +1322,835 @@
             if hasattr(self, '_m_pic_ready_compressed'):
                 return self._m_pic_ready_compressed if hasattr(self, '_m_pic_ready_compressed') else None
 
             self._m_pic_ready_compressed = ((int(self.cu_flags, 16) & 256) >> 8)
             return self._m_pic_ready_compressed if hasattr(self, '_m_pic_ready_compressed') else None
 
 
-    class V1RlType(KaitaiStruct):
-        """[V1];RL;[Timestamp],[CPU voltage];[Battery voltage];[CPU temperature];[Amplifier temperature];[Flags]
+    class A1GyroType(KaitaiStruct):
+        """A1;GYRO;[Current timestamp];[GyroX];[GyroY];[GyroZ]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.timestamp = (self._io.read_bytes_term(44, False, True, True)).decode(u"ASCII")
-            self.cpu_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.battery_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.cpu_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.amplifier_temperature = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.flagsmagic = self._io.ensure_fixed_contents(b"\x30\x78")
-            self.flags = (self._io.read_bytes(1)).decode(u"ASCII")
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.giro_x = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.giro_y = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.giro_z = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
 
         @property
-        def cpu_temperature_degree(self):
-            if hasattr(self, '_m_cpu_temperature_degree'):
-                return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
+        def gyro_x_int(self):
+            if hasattr(self, '_m_gyro_x_int'):
+                return self._m_gyro_x_int if hasattr(self, '_m_gyro_x_int') else None
 
-            self._m_cpu_temperature_degree = int(self.cpu_temperature)
-            return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
+            self._m_gyro_x_int = int(self.giro_x)
+            return self._m_gyro_x_int if hasattr(self, '_m_gyro_x_int') else None
 
         @property
-        def fec(self):
-            if hasattr(self, '_m_fec'):
-                return self._m_fec if hasattr(self, '_m_fec') else None
+        def gyro_y_int(self):
+            if hasattr(self, '_m_gyro_y_int'):
+                return self._m_gyro_y_int if hasattr(self, '_m_gyro_y_int') else None
 
-            self._m_fec = (int(self.flags, 16) & 1)
-            return self._m_fec if hasattr(self, '_m_fec') else None
+            self._m_gyro_y_int = int(self.giro_y)
+            return self._m_gyro_y_int if hasattr(self, '_m_gyro_y_int') else None
+
+        @property
+        def gyro_z_int(self):
+            if hasattr(self, '_m_gyro_z_int'):
+                return self._m_gyro_z_int if hasattr(self, '_m_gyro_z_int') else None
+
+            self._m_gyro_z_int = int(self.giro_z)
+            return self._m_gyro_z_int if hasattr(self, '_m_gyro_z_int') else None
 
         @property
         def timestamp_int(self):
             if hasattr(self, '_m_timestamp_int'):
                 return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
             self._m_timestamp_int = int(self.timestamp)
             return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
-        @property
-        def band_lock(self):
-            if hasattr(self, '_m_band_lock'):
-                return self._m_band_lock if hasattr(self, '_m_band_lock') else None
-
-            self._m_band_lock = ((int(self.flags, 16) & 4) >> 2)
-            return self._m_band_lock if hasattr(self, '_m_band_lock') else None
-
-        @property
-        def cpu_voltage_volt(self):
-            if hasattr(self, '_m_cpu_voltage_volt'):
-                return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
 
-            self._m_cpu_voltage_volt = (int(self.cpu_voltage) / 1000.0)
-            return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
-
-        @property
-        def aes_128(self):
-            if hasattr(self, '_m_aes_128'):
-                return self._m_aes_128 if hasattr(self, '_m_aes_128') else None
-
-            self._m_aes_128 = ((int(self.flags, 16) & 16) >> 4)
-            return self._m_aes_128 if hasattr(self, '_m_aes_128') else None
-
-        @property
-        def amplifier_temperature_degree(self):
-            if hasattr(self, '_m_amplifier_temperature_degree'):
-                return self._m_amplifier_temperature_degree if hasattr(self, '_m_amplifier_temperature_degree') else None
+    class A1MagType(KaitaiStruct):
+        """A1;MAG;[Current timestamp];[MagX];[MagY];[MagZ]
+        """
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
 
-            self._m_amplifier_temperature_degree = int(self.amplifier_temperature)
-            return self._m_amplifier_temperature_degree if hasattr(self, '_m_amplifier_temperature_degree') else None
+        def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.mag_x = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.mag_y = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.mag_z = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
 
         @property
-        def amp_ovt(self):
-            if hasattr(self, '_m_amp_ovt'):
-                return self._m_amp_ovt if hasattr(self, '_m_amp_ovt') else None
+        def mag_x_int(self):
+            if hasattr(self, '_m_mag_x_int'):
+                return self._m_mag_x_int if hasattr(self, '_m_mag_x_int') else None
 
-            self._m_amp_ovt = ((int(self.flags, 16) & 32) >> 5)
-            return self._m_amp_ovt if hasattr(self, '_m_amp_ovt') else None
+            self._m_mag_x_int = int(self.mag_x)
+            return self._m_mag_x_int if hasattr(self, '_m_mag_x_int') else None
 
         @property
-        def xor(self):
-            if hasattr(self, '_m_xor'):
-                return self._m_xor if hasattr(self, '_m_xor') else None
+        def mag_y_int(self):
+            if hasattr(self, '_m_mag_y_int'):
+                return self._m_mag_y_int if hasattr(self, '_m_mag_y_int') else None
 
-            self._m_xor = ((int(self.flags, 16) & 8) >> 3)
-            return self._m_xor if hasattr(self, '_m_xor') else None
+            self._m_mag_y_int = int(self.mag_y)
+            return self._m_mag_y_int if hasattr(self, '_m_mag_y_int') else None
 
         @property
-        def downlink(self):
-            if hasattr(self, '_m_downlink'):
-                return self._m_downlink if hasattr(self, '_m_downlink') else None
+        def mag_z_int(self):
+            if hasattr(self, '_m_mag_z_int'):
+                return self._m_mag_z_int if hasattr(self, '_m_mag_z_int') else None
 
-            self._m_downlink = ((int(self.flags, 16) & 2) >> 1)
-            return self._m_downlink if hasattr(self, '_m_downlink') else None
+            self._m_mag_z_int = int(self.mag_z)
+            return self._m_mag_z_int if hasattr(self, '_m_mag_z_int') else None
 
         @property
-        def battery_voltage_volt(self):
-            if hasattr(self, '_m_battery_voltage_volt'):
-                return self._m_battery_voltage_volt if hasattr(self, '_m_battery_voltage_volt') else None
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
-            self._m_battery_voltage_volt = (int(self.battery_voltage) / 1000.0)
-            return self._m_battery_voltage_volt if hasattr(self, '_m_battery_voltage_volt') else None
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
 
-    class Repeaters(KaitaiStruct):
+    class EmType(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.rpt_callsign_raw = self._root.CallsignRaw(self._io, self, self._root)
-            self.rpt_ssid_raw = self._root.SsidMask(self._io, self, self._root)
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
+            if _on == u"LOG":
+                self.em = self._root.EmLogType(self._io, self, self._root)
+            elif _on == u"MN":
+                self.em = self._root.EmMnType(self._io, self, self._root)
 
 
-    class Repeater(KaitaiStruct):
+    class A1Type(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.rpt_instance = []
-            i = 0
-            while True:
-                _ = self._root.Repeaters(self._io, self, self._root)
-                self.rpt_instance.append(_)
-                if (_.rpt_ssid_raw.ssid_mask & 1) == 1:
-                    break
-                i += 1
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
+            if _on == u"FLAGS":
+                self.a1 = self._root.A1FlagsType(self._io, self, self._root)
+            elif _on == u"MAG":
+                self.a1 = self._root.A1MagType(self._io, self, self._root)
+            elif _on == u"GYRO":
+                self.a1 = self._root.A1GyroType(self._io, self, self._root)
+            elif _on == u"POSITION":
+                self.a1 = self._root.A1PositionType(self._io, self, self._root)
 
 
-    class OnyxType(KaitaiStruct):
-        """[CU_R/CU_L];ONYX SENSOR T;[Timestamp];[Return value]
+    class A1FlagsType(KaitaiStruct):
+        """A1;FLAGS;[timestamp];[mode];[flags];[faults]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
             self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.return_value = (self._io.read_bytes_full()).decode(u"ASCII")
+            self.adcs_mode = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.a1_flags = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.faults = (self._io.read_bytes_full()).decode(u"ASCII")
 
         @property
-        def return_value_int(self):
-            if hasattr(self, '_m_return_value_int'):
-                return self._m_return_value_int if hasattr(self, '_m_return_value_int') else None
+        def sens_on_off(self):
+            if hasattr(self, '_m_sens_on_off'):
+                return self._m_sens_on_off if hasattr(self, '_m_sens_on_off') else None
 
-            self._m_return_value_int = int(self.return_value)
-            return self._m_return_value_int if hasattr(self, '_m_return_value_int') else None
+            self._m_sens_on_off = ((int(self.a1_flags, 16) & 4) >> 2)
+            return self._m_sens_on_off if hasattr(self, '_m_sens_on_off') else None
 
         @property
-        def timestamp_int(self):
-            if hasattr(self, '_m_timestamp_int'):
-                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+        def l3_fault(self):
+            if hasattr(self, '_m_l3_fault'):
+                return self._m_l3_fault if hasattr(self, '_m_l3_fault') else None
 
-            self._m_timestamp_int = int(self.timestamp)
-            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+            self._m_l3_fault = ((int(self.faults, 16) & 32) >> 5)
+            return self._m_l3_fault if hasattr(self, '_m_l3_fault') else None
 
+        @property
+        def manual(self):
+            if hasattr(self, '_m_manual'):
+                return self._m_manual if hasattr(self, '_m_manual') else None
 
-    class EmerType(KaitaiStruct):
-        def __init__(self, _io, _parent=None, _root=None):
-            self._io = _io
-            self._parent = _parent
-            self._root = _root if _root else self
-            self._read()
+            self._m_manual = ((int(self.adcs_mode, 16) & 240) >> 4)
+            return self._m_manual if hasattr(self, '_m_manual') else None
 
-        def _read(self):
-            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            _on = self._parent.tlm_type
-            if _on == u"LOG":
-                self.tlmsw = self._root.EmLogType(self._io, self, self._root)
-            elif _on == u"MN":
-                self.tlmsw = self._root.EmmnType(self._io, self, self._root)
+        @property
+        def sun_contr(self):
+            if hasattr(self, '_m_sun_contr'):
+                return self._m_sun_contr if hasattr(self, '_m_sun_contr') else None
+
+            self._m_sun_contr = ((int(self.a1_flags, 16) & 2) >> 1)
+            return self._m_sun_contr if hasattr(self, '_m_sun_contr') else None
+
+        @property
+        def gyro_acc_fault(self):
+            if hasattr(self, '_m_gyro_acc_fault'):
+                return self._m_gyro_acc_fault if hasattr(self, '_m_gyro_acc_fault') else None
+
+            self._m_gyro_acc_fault = (int(self.faults, 16) & 1)
+            return self._m_gyro_acc_fault if hasattr(self, '_m_gyro_acc_fault') else None
+
+        @property
+        def l1_fault(self):
+            if hasattr(self, '_m_l1_fault'):
+                return self._m_l1_fault if hasattr(self, '_m_l1_fault') else None
+
+            self._m_l1_fault = ((int(self.faults, 16) & 8) >> 3)
+            return self._m_l1_fault if hasattr(self, '_m_l1_fault') else None
+
+        @property
+        def act_man_contr(self):
+            if hasattr(self, '_m_act_man_contr'):
+                return self._m_act_man_contr if hasattr(self, '_m_act_man_contr') else None
+
+            self._m_act_man_contr = ((int(self.a1_flags, 16) & 8) >> 3)
+            return self._m_act_man_contr if hasattr(self, '_m_act_man_contr') else None
 
         @property
         def timestamp_int(self):
             if hasattr(self, '_m_timestamp_int'):
                 return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
             self._m_timestamp_int = int(self.timestamp)
             return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
+        @property
+        def adcs_on_off(self):
+            if hasattr(self, '_m_adcs_on_off'):
+                return self._m_adcs_on_off if hasattr(self, '_m_adcs_on_off') else None
+
+            self._m_adcs_on_off = ((int(self.adcs_mode, 16) & 2) >> 1)
+            return self._m_adcs_on_off if hasattr(self, '_m_adcs_on_off') else None
+
+        @property
+        def detumbling_status(self):
+            if hasattr(self, '_m_detumbling_status'):
+                return self._m_detumbling_status if hasattr(self, '_m_detumbling_status') else None
 
-    class CuType(KaitaiStruct):
+            self._m_detumbling_status = ((int(self.adcs_mode, 16) & 12) >> 2)
+            return self._m_detumbling_status if hasattr(self, '_m_detumbling_status') else None
+
+        @property
+        def act_limited_contr(self):
+            if hasattr(self, '_m_act_limited_contr'):
+                return self._m_act_limited_contr if hasattr(self, '_m_act_limited_contr') else None
+
+            self._m_act_limited_contr = ((int(self.a1_flags, 16) & 16) >> 4)
+            return self._m_act_limited_contr if hasattr(self, '_m_act_limited_contr') else None
+
+        @property
+        def act_on_off(self):
+            if hasattr(self, '_m_act_on_off'):
+                return self._m_act_on_off if hasattr(self, '_m_act_on_off') else None
+
+            self._m_act_on_off = (int(self.a1_flags, 16) & 1)
+            return self._m_act_on_off if hasattr(self, '_m_act_on_off') else None
+
+        @property
+        def mag_fault(self):
+            if hasattr(self, '_m_mag_fault'):
+                return self._m_mag_fault if hasattr(self, '_m_mag_fault') else None
+
+            self._m_mag_fault = ((int(self.faults, 16) & 2) >> 1)
+            return self._m_mag_fault if hasattr(self, '_m_mag_fault') else None
+
+        @property
+        def sun_fault(self):
+            if hasattr(self, '_m_sun_fault'):
+                return self._m_sun_fault if hasattr(self, '_m_sun_fault') else None
+
+            self._m_sun_fault = ((int(self.faults, 16) & 4) >> 2)
+            return self._m_sun_fault if hasattr(self, '_m_sun_fault') else None
+
+        @property
+        def l2_fault(self):
+            if hasattr(self, '_m_l2_fault'):
+                return self._m_l2_fault if hasattr(self, '_m_l2_fault') else None
+
+            self._m_l2_fault = ((int(self.faults, 16) & 16) >> 4)
+            return self._m_l2_fault if hasattr(self, '_m_l2_fault') else None
+
+        @property
+        def detumbling(self):
+            if hasattr(self, '_m_detumbling'):
+                return self._m_detumbling if hasattr(self, '_m_detumbling') else None
+
+            self._m_detumbling = (int(self.adcs_mode, 16) & 1)
+            return self._m_detumbling if hasattr(self, '_m_detumbling') else None
+
+
+    class CallsignRaw(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            _on = self._parent.tlm_type
-            if _on == u"ONYX SENSOR T":
-                self.tlmsw = self._root.OnyxType(self._io, self, self._root)
-            elif _on == u"LOG":
-                self.tlmsw = self._root.CuLogType(self._io, self, self._root)
-
-        @property
-        def timestamp_int(self):
-            if hasattr(self, '_m_timestamp_int'):
-                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
-
-            self._m_timestamp_int = int(self.timestamp)
-            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+            self._raw__raw_callsign_ror = self._io.read_bytes(6)
+            self._raw_callsign_ror = KaitaiStream.process_rotate_left(self._raw__raw_callsign_ror, 8 - (1), 1)
+            io = KaitaiStream(BytesIO(self._raw_callsign_ror))
+            self.callsign_ror = self._root.Callsign(io, self, self._root)
 
 
-    class A1GyroType(KaitaiStruct):
-        """A1;GYRO;[Current timestamp];[GyroX];[GyroY];[GyroZ]
+    class M1LogType(KaitaiStruct):
+        """M1;LOG;[Timestamp];[Boot number];[Up time];[CPU voltage];[CPU temperature]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
             self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.giro_x = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.giro_y = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.giro_z = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.boot_number = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.up_time = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.cpu_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.cpu_temperature = (self._io.read_bytes_full()).decode(u"ASCII")
 
         @property
-        def gyro_x_int(self):
-            if hasattr(self, '_m_gyro_x_int'):
-                return self._m_gyro_x_int if hasattr(self, '_m_gyro_x_int') else None
+        def cpu_temperature_degree(self):
+            if hasattr(self, '_m_cpu_temperature_degree'):
+                return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
 
-            self._m_gyro_x_int = int(self.giro_x)
-            return self._m_gyro_x_int if hasattr(self, '_m_gyro_x_int') else None
+            self._m_cpu_temperature_degree = int(self.cpu_temperature)
+            return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
 
         @property
-        def gyro_y_int(self):
-            if hasattr(self, '_m_gyro_y_int'):
-                return self._m_gyro_y_int if hasattr(self, '_m_gyro_y_int') else None
+        def up_time_int(self):
+            if hasattr(self, '_m_up_time_int'):
+                return self._m_up_time_int if hasattr(self, '_m_up_time_int') else None
 
-            self._m_gyro_y_int = int(self.giro_y)
-            return self._m_gyro_y_int if hasattr(self, '_m_gyro_y_int') else None
+            self._m_up_time_int = int(self.up_time)
+            return self._m_up_time_int if hasattr(self, '_m_up_time_int') else None
 
         @property
-        def gyro_z_int(self):
-            if hasattr(self, '_m_gyro_z_int'):
-                return self._m_gyro_z_int if hasattr(self, '_m_gyro_z_int') else None
+        def boot_number_int(self):
+            if hasattr(self, '_m_boot_number_int'):
+                return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
 
-            self._m_gyro_z_int = int(self.giro_z)
-            return self._m_gyro_z_int if hasattr(self, '_m_gyro_z_int') else None
+            self._m_boot_number_int = int(self.boot_number)
+            return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
 
         @property
         def timestamp_int(self):
             if hasattr(self, '_m_timestamp_int'):
                 return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
             self._m_timestamp_int = int(self.timestamp)
             return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
+        @property
+        def cpu_voltage_volt(self):
+            if hasattr(self, '_m_cpu_voltage_volt'):
+                return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
 
-    class A1MagType(KaitaiStruct):
-        """A1;MAG;[Current timestamp];[MagX];[MagY];[MagZ]
+            self._m_cpu_voltage_volt = (int(self.cpu_voltage) / 1000.0)
+            return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
+
+
+    class ErType(KaitaiStruct):
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
+            if _on == u"LOG":
+                self.er = self._root.ErLogType(self._io, self, self._root)
+            elif _on == u"MN":
+                self.er = self._root.ErMnType(self._io, self, self._root)
+
+
+    class ErLogType(KaitaiStruct):
+        """ER;LOG;[Timestamp];[Boot number];[Input voltage];[Input current];[Input power];[Peak Power];[Solar panel voltage]
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
             self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.mag_x = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.mag_y = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.mag_z = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.boot_number = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.input_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.input_current = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.input_power = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.peak_power = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.solar_panel_voltage = (self._io.read_bytes_full()).decode(u"ASCII")
 
         @property
-        def mag_x_int(self):
-            if hasattr(self, '_m_mag_x_int'):
-                return self._m_mag_x_int if hasattr(self, '_m_mag_x_int') else None
+        def input_current_ma(self):
+            if hasattr(self, '_m_input_current_ma'):
+                return self._m_input_current_ma if hasattr(self, '_m_input_current_ma') else None
 
-            self._m_mag_x_int = int(self.mag_x)
-            return self._m_mag_x_int if hasattr(self, '_m_mag_x_int') else None
+            self._m_input_current_ma = int(self.input_current)
+            return self._m_input_current_ma if hasattr(self, '_m_input_current_ma') else None
 
         @property
-        def mag_y_int(self):
-            if hasattr(self, '_m_mag_y_int'):
-                return self._m_mag_y_int if hasattr(self, '_m_mag_y_int') else None
+        def peak_power_mw(self):
+            if hasattr(self, '_m_peak_power_mw'):
+                return self._m_peak_power_mw if hasattr(self, '_m_peak_power_mw') else None
 
-            self._m_mag_y_int = int(self.mag_y)
-            return self._m_mag_y_int if hasattr(self, '_m_mag_y_int') else None
+            self._m_peak_power_mw = int(self.peak_power)
+            return self._m_peak_power_mw if hasattr(self, '_m_peak_power_mw') else None
 
         @property
-        def mag_z_int(self):
-            if hasattr(self, '_m_mag_z_int'):
-                return self._m_mag_z_int if hasattr(self, '_m_mag_z_int') else None
+        def input_power_mw(self):
+            if hasattr(self, '_m_input_power_mw'):
+                return self._m_input_power_mw if hasattr(self, '_m_input_power_mw') else None
 
-            self._m_mag_z_int = int(self.mag_z)
-            return self._m_mag_z_int if hasattr(self, '_m_mag_z_int') else None
+            self._m_input_power_mw = int(self.input_power)
+            return self._m_input_power_mw if hasattr(self, '_m_input_power_mw') else None
+
+        @property
+        def boot_number_int(self):
+            if hasattr(self, '_m_boot_number_int'):
+                return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
+
+            self._m_boot_number_int = int(self.boot_number)
+            return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
 
         @property
         def timestamp_int(self):
             if hasattr(self, '_m_timestamp_int'):
                 return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
             self._m_timestamp_int = int(self.timestamp)
             return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
+        @property
+        def input_voltage_volt(self):
+            if hasattr(self, '_m_input_voltage_volt'):
+                return self._m_input_voltage_volt if hasattr(self, '_m_input_voltage_volt') else None
 
-    class A1Type(KaitaiStruct):
-        def __init__(self, _io, _parent=None, _root=None):
-            self._io = _io
-            self._parent = _parent
-            self._root = _root if _root else self
-            self._read()
+            self._m_input_voltage_volt = (int(self.input_voltage) / 1000.0)
+            return self._m_input_voltage_volt if hasattr(self, '_m_input_voltage_volt') else None
 
-        def _read(self):
-            _on = self._parent.tlm_type
-            if _on == u"FLAGS":
-                self.tlm_sw = self._root.A1FlagType(self._io, self, self._root)
-            elif _on == u"MAG":
-                self.tlm_sw = self._root.A1MagType(self._io, self, self._root)
-            elif _on == u"GYRO":
-                self.tlm_sw = self._root.A1GyroType(self._io, self, self._root)
-            elif _on == u"POSITION":
-                self.tlm_sw = self._root.A1PositionType(self._io, self, self._root)
+        @property
+        def solar_panel_voltage_volt(self):
+            if hasattr(self, '_m_solar_panel_voltage_volt'):
+                return self._m_solar_panel_voltage_volt if hasattr(self, '_m_solar_panel_voltage_volt') else None
+
+            self._m_solar_panel_voltage_volt = (int(self.solar_panel_voltage) / 1000.0)
+            return self._m_solar_panel_voltage_volt if hasattr(self, '_m_solar_panel_voltage_volt') else None
 
 
-    class MsType(KaitaiStruct):
-        """[V1/U2];MS;[Timestamp];[Current rssi];[Latch rssi];[AFC offset]
+    class M1FlagsType(KaitaiStruct):
+        """M1;FLAGS;[Timestamp];[Hex flags];
         """
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
             self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.current_rssi = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.latch_rssi = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.a_f_c_offset = (self._io.read_bytes_full()).decode(u"ASCII")
+            self.hex_part = (self._io.read_bytes_term(120, False, True, True)).decode(u"ASCII")
+            self.flags = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
 
         @property
-        def current_rssi_int(self):
-            if hasattr(self, '_m_current_rssi_int'):
-                return self._m_current_rssi_int if hasattr(self, '_m_current_rssi_int') else None
+        def beacon_mode(self):
+            if hasattr(self, '_m_beacon_mode'):
+                return self._m_beacon_mode if hasattr(self, '_m_beacon_mode') else None
 
-            self._m_current_rssi_int = int(self.current_rssi)
-            return self._m_current_rssi_int if hasattr(self, '_m_current_rssi_int') else None
+            self._m_beacon_mode = ((int(self.flags, 16) & 256) >> 8)
+            return self._m_beacon_mode if hasattr(self, '_m_beacon_mode') else None
 
         @property
-        def latch_rssi_int(self):
-            if hasattr(self, '_m_latch_rssi_int'):
-                return self._m_latch_rssi_int if hasattr(self, '_m_latch_rssi_int') else None
+        def cur_dead(self):
+            if hasattr(self, '_m_cur_dead'):
+                return self._m_cur_dead if hasattr(self, '_m_cur_dead') else None
 
-            self._m_latch_rssi_int = int(self.latch_rssi)
-            return self._m_latch_rssi_int if hasattr(self, '_m_latch_rssi_int') else None
+            self._m_cur_dead = ((int(self.flags, 16) & 4026531840) >> 28)
+            return self._m_cur_dead if hasattr(self, '_m_cur_dead') else None
 
         @property
-        def a_f_c_offset_int(self):
-            if hasattr(self, '_m_a_f_c_offset_int'):
-                return self._m_a_f_c_offset_int if hasattr(self, '_m_a_f_c_offset_int') else None
+        def cur_on(self):
+            if hasattr(self, '_m_cur_on'):
+                return self._m_cur_on if hasattr(self, '_m_cur_on') else None
 
-            self._m_a_f_c_offset_int = int(self.a_f_c_offset)
-            return self._m_a_f_c_offset_int if hasattr(self, '_m_a_f_c_offset_int') else None
+            self._m_cur_on = ((int(self.flags, 16) & 262144) >> 18)
+            return self._m_cur_on if hasattr(self, '_m_cur_on') else None
+
+        @property
+        def stream(self):
+            if hasattr(self, '_m_stream'):
+                return self._m_stream if hasattr(self, '_m_stream') else None
+
+            self._m_stream = ((int(self.flags, 16) & 281474976710656) >> 48)
+            return self._m_stream if hasattr(self, '_m_stream') else None
+
+        @property
+        def imc_aocs_ok(self):
+            if hasattr(self, '_m_imc_aocs_ok'):
+                return self._m_imc_aocs_ok if hasattr(self, '_m_imc_aocs_ok') else None
+
+            self._m_imc_aocs_ok = (int(self.flags, 16) & 1)
+            return self._m_imc_aocs_ok if hasattr(self, '_m_imc_aocs_ok') else None
+
+        @property
+        def uhf2_downlink(self):
+            if hasattr(self, '_m_uhf2_downlink'):
+                return self._m_uhf2_downlink if hasattr(self, '_m_uhf2_downlink') else None
+
+            self._m_uhf2_downlink = ((int(self.flags, 16) & 64) >> 6)
+            return self._m_uhf2_downlink if hasattr(self, '_m_uhf2_downlink') else None
+
+        @property
+        def cul_on(self):
+            if hasattr(self, '_m_cul_on'):
+                return self._m_cul_on if hasattr(self, '_m_cul_on') else None
+
+            self._m_cul_on = ((int(self.flags, 16) & 65536) >> 16)
+            return self._m_cul_on if hasattr(self, '_m_cul_on') else None
+
+        @property
+        def payload_off(self):
+            if hasattr(self, '_m_payload_off'):
+                return self._m_payload_off if hasattr(self, '_m_payload_off') else None
+
+            self._m_payload_off = ((int(self.flags, 16) & 2048) >> 11)
+            return self._m_payload_off if hasattr(self, '_m_payload_off') else None
+
+        @property
+        def cu_auto_off(self):
+            if hasattr(self, '_m_cu_auto_off'):
+                return self._m_cu_auto_off if hasattr(self, '_m_cu_auto_off') else None
+
+            self._m_cu_auto_off = ((int(self.flags, 16) & 4096) >> 12)
+            return self._m_cu_auto_off if hasattr(self, '_m_cu_auto_off') else None
+
+        @property
+        def survival_start(self):
+            if hasattr(self, '_m_survival_start'):
+                return self._m_survival_start if hasattr(self, '_m_survival_start') else None
+
+            self._m_survival_start = ((int(self.flags, 16) & 2251799813685248) >> 51)
+            return self._m_survival_start if hasattr(self, '_m_survival_start') else None
+
+        @property
+        def fault_3v_m(self):
+            if hasattr(self, '_m_fault_3v_m'):
+                return self._m_fault_3v_m if hasattr(self, '_m_fault_3v_m') else None
+
+            self._m_fault_3v_m = ((int(self.flags, 16) & 2199023255552) >> 41)
+            return self._m_fault_3v_m if hasattr(self, '_m_fault_3v_m') else None
+
+        @property
+        def plan(self):
+            if hasattr(self, '_m_plan'):
+                return self._m_plan if hasattr(self, '_m_plan') else None
+
+            self._m_plan = ((int(self.flags, 16) & 140737488355328) >> 47)
+            return self._m_plan if hasattr(self, '_m_plan') else None
 
         @property
         def timestamp_int(self):
             if hasattr(self, '_m_timestamp_int'):
                 return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
             self._m_timestamp_int = int(self.timestamp)
             return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
 
+        @property
+        def vhf1_downlink(self):
+            if hasattr(self, '_m_vhf1_downlink'):
+                return self._m_vhf1_downlink if hasattr(self, '_m_vhf1_downlink') else None
 
-    class LogType(KaitaiStruct):
-        """M1;LOG;[Timestamp];[Boot number];[Up time];[CPU voltage];[CPU temperature]
-        """
-        def __init__(self, _io, _parent=None, _root=None):
-            self._io = _io
-            self._parent = _parent
-            self._root = _root if _root else self
-            self._read()
+            self._m_vhf1_downlink = ((int(self.flags, 16) & 32) >> 5)
+            return self._m_vhf1_downlink if hasattr(self, '_m_vhf1_downlink') else None
 
-        def _read(self):
-            self.boot_number = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.up_time = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.cpu_voltage = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.cpu_temperature = (self._io.read_bytes_full()).decode(u"ASCII")
+        @property
+        def cyclic_reset_on(self):
+            if hasattr(self, '_m_cyclic_reset_on'):
+                return self._m_cyclic_reset_on if hasattr(self, '_m_cyclic_reset_on') else None
+
+            self._m_cyclic_reset_on = ((int(self.flags, 16) & 512) >> 9)
+            return self._m_cyclic_reset_on if hasattr(self, '_m_cyclic_reset_on') else None
 
         @property
-        def cpu_voltage_volt(self):
-            if hasattr(self, '_m_cpu_voltage_volt'):
-                return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
+        def uhf2_packet_ready(self):
+            if hasattr(self, '_m_uhf2_packet_ready'):
+                return self._m_uhf2_packet_ready if hasattr(self, '_m_uhf2_packet_ready') else None
 
-            self._m_cpu_voltage_volt = (int(self.cpu_voltage) / 1000.0)
-            return self._m_cpu_voltage_volt if hasattr(self, '_m_cpu_voltage_volt') else None
+            self._m_uhf2_packet_ready = ((int(self.flags, 16) & 1125899906842624) >> 50)
+            return self._m_uhf2_packet_ready if hasattr(self, '_m_uhf2_packet_ready') else None
 
         @property
-        def boot_number_int(self):
-            if hasattr(self, '_m_boot_number_int'):
-                return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
+        def cur_fault(self):
+            if hasattr(self, '_m_cur_fault'):
+                return self._m_cur_fault if hasattr(self, '_m_cur_fault') else None
 
-            self._m_boot_number_int = int(self.boot_number)
-            return self._m_boot_number_int if hasattr(self, '_m_boot_number_int') else None
+            self._m_cur_fault = ((int(self.flags, 16) & 524288) >> 19)
+            return self._m_cur_fault if hasattr(self, '_m_cur_fault') else None
 
         @property
-        def cpu_temperature_degree(self):
-            if hasattr(self, '_m_cpu_temperature_degree'):
-                return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
+        def vhf1_packet_ready(self):
+            if hasattr(self, '_m_vhf1_packet_ready'):
+                return self._m_vhf1_packet_ready if hasattr(self, '_m_vhf1_packet_ready') else None
 
-            self._m_cpu_temperature_degree = int(self.cpu_temperature)
-            return self._m_cpu_temperature_degree if hasattr(self, '_m_cpu_temperature_degree') else None
+            self._m_vhf1_packet_ready = ((int(self.flags, 16) & 562949953421312) >> 49)
+            return self._m_vhf1_packet_ready if hasattr(self, '_m_vhf1_packet_ready') else None
 
         @property
-        def up_time_int(self):
-            if hasattr(self, '_m_up_time_int'):
-                return self._m_up_time_int if hasattr(self, '_m_up_time_int') else None
+        def cul_faut(self):
+            if hasattr(self, '_m_cul_faut'):
+                return self._m_cul_faut if hasattr(self, '_m_cul_faut') else None
 
-            self._m_up_time_int = int(self.up_time)
-            return self._m_up_time_int if hasattr(self, '_m_up_time_int') else None
+            self._m_cul_faut = ((int(self.flags, 16) & 131072) >> 17)
+            return self._m_cul_faut if hasattr(self, '_m_cul_faut') else None
 
+        @property
+        def tm_log(self):
+            if hasattr(self, '_m_tm_log'):
+                return self._m_tm_log if hasattr(self, '_m_tm_log') else None
 
-    class CallsignRaw(KaitaiStruct):
-        def __init__(self, _io, _parent=None, _root=None):
-            self._io = _io
-            self._parent = _parent
-            self._root = _root if _root else self
-            self._read()
+            self._m_tm_log = ((int(self.flags, 16) & 8192) >> 13)
+            return self._m_tm_log if hasattr(self, '_m_tm_log') else None
 
-        def _read(self):
-            self._raw__raw_callsign_ror = self._io.read_bytes(6)
-            self._raw_callsign_ror = KaitaiStream.process_rotate_left(self._raw__raw_callsign_ror, 8 - (1), 1)
-            io = KaitaiStream(BytesIO(self._raw_callsign_ror))
-            self.callsign_ror = self._root.Callsign(io, self, self._root)
+        @property
+        def long_log(self):
+            if hasattr(self, '_m_long_log'):
+                return self._m_long_log if hasattr(self, '_m_long_log') else None
+
+            self._m_long_log = ((int(self.flags, 16) & 35184372088832) >> 45)
+            return self._m_long_log if hasattr(self, '_m_long_log') else None
+
+        @property
+        def imc_uhf2_ok(self):
+            if hasattr(self, '_m_imc_uhf2_ok'):
+                return self._m_imc_uhf2_ok if hasattr(self, '_m_imc_uhf2_ok') else None
+
+            self._m_imc_uhf2_ok = ((int(self.flags, 16) & 16) >> 4)
+            return self._m_imc_uhf2_ok if hasattr(self, '_m_imc_uhf2_ok') else None
+
+        @property
+        def imc_check(self):
+            if hasattr(self, '_m_imc_check'):
+                return self._m_imc_check if hasattr(self, '_m_imc_check') else None
+
+            self._m_imc_check = ((int(self.flags, 16) & 128) >> 7)
+            return self._m_imc_check if hasattr(self, '_m_imc_check') else None
+
+        @property
+        def charge_m(self):
+            if hasattr(self, '_m_charge_m'):
+                return self._m_charge_m if hasattr(self, '_m_charge_m') else None
+
+            self._m_charge_m = ((int(self.flags, 16) & 8796093022208) >> 43)
+            return self._m_charge_m if hasattr(self, '_m_charge_m') else None
+
+        @property
+        def survival_end(self):
+            if hasattr(self, '_m_survival_end'):
+                return self._m_survival_end if hasattr(self, '_m_survival_end') else None
+
+            self._m_survival_end = ((int(self.flags, 16) & 4503599627370496) >> 52)
+            return self._m_survival_end if hasattr(self, '_m_survival_end') else None
+
+        @property
+        def fault_3v_r(self):
+            if hasattr(self, '_m_fault_3v_r'):
+                return self._m_fault_3v_r if hasattr(self, '_m_fault_3v_r') else None
+
+            self._m_fault_3v_r = ((int(self.flags, 16) & 1099511627776) >> 40)
+            return self._m_fault_3v_r if hasattr(self, '_m_fault_3v_r') else None
+
+        @property
+        def survival_mode(self):
+            if hasattr(self, '_m_survival_mode'):
+                return self._m_survival_mode if hasattr(self, '_m_survival_mode') else None
+
+            self._m_survival_mode = ((int(self.flags, 16) & 1024) >> 10)
+            return self._m_survival_mode if hasattr(self, '_m_survival_mode') else None
+
+        @property
+        def imc_cu_r_ok(self):
+            if hasattr(self, '_m_imc_cu_r_ok'):
+                return self._m_imc_cu_r_ok if hasattr(self, '_m_imc_cu_r_ok') else None
+
+            self._m_imc_cu_r_ok = ((int(self.flags, 16) & 4) >> 2)
+            return self._m_imc_cu_r_ok if hasattr(self, '_m_imc_cu_r_ok') else None
+
+        @property
+        def cul_dead(self):
+            if hasattr(self, '_m_cul_dead'):
+                return self._m_cul_dead if hasattr(self, '_m_cul_dead') else None
+
+            self._m_cul_dead = ((int(self.flags, 16) & 251658240) >> 24)
+            return self._m_cul_dead if hasattr(self, '_m_cul_dead') else None
+
+        @property
+        def charge_r(self):
+            if hasattr(self, '_m_charge_r'):
+                return self._m_charge_r if hasattr(self, '_m_charge_r') else None
+
+            self._m_charge_r = ((int(self.flags, 16) & 4398046511104) >> 42)
+            return self._m_charge_r if hasattr(self, '_m_charge_r') else None
+
+        @property
+        def imc_vhf1_ok(self):
+            if hasattr(self, '_m_imc_vhf1_ok'):
+                return self._m_imc_vhf1_ok if hasattr(self, '_m_imc_vhf1_ok') else None
+
+            self._m_imc_vhf1_ok = ((int(self.flags, 16) & 8) >> 3)
+            return self._m_imc_vhf1_ok if hasattr(self, '_m_imc_vhf1_ok') else None
+
+        @property
+        def cu_on(self):
+            if hasattr(self, '_m_cu_on'):
+                return self._m_cu_on if hasattr(self, '_m_cu_on') else None
+
+            self._m_cu_on = ((int(self.flags, 16) & 1048576) >> 20)
+            return self._m_cu_on if hasattr(self, '_m_cu_on') else None
+
+        @property
+        def log_to_flash(self):
+            if hasattr(self, '_m_log_to_flash'):
+                return self._m_log_to_flash if hasattr(self, '_m_log_to_flash') else None
+
+            self._m_log_to_flash = ((int(self.flags, 16) & 70368744177664) >> 46)
+            return self._m_log_to_flash if hasattr(self, '_m_log_to_flash') else None
+
+        @property
+        def imc_cu_l_ok(self):
+            if hasattr(self, '_m_imc_cu_l_ok'):
+                return self._m_imc_cu_l_ok if hasattr(self, '_m_imc_cu_l_ok') else None
+
+            self._m_imc_cu_l_ok = ((int(self.flags, 16) & 2) >> 1)
+            return self._m_imc_cu_l_ok if hasattr(self, '_m_imc_cu_l_ok') else None
 
 
     class V1Type(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            _on = self._parent.tlm_type
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
             if _on == u"RL":
-                self.tlmsw = self._root.V1RlType(self._io, self, self._root)
+                self.v1 = self._root.V1RlType(self._io, self, self._root)
             elif _on == u"MS":
-                self.tlmsw = self._root.MsType(self._io, self, self._root)
+                self.v1 = self._root.V1MsType(self._io, self, self._root)
 
 
     class U2Type(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
-            _on = self._parent.tlm_type
+            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            _on = self.tlm_type
             if _on == u"RL":
-                self.tlmsw = self._root.U2RlType(self._io, self, self._root)
+                self.u2 = self._root.U2RlType(self._io, self, self._root)
             elif _on == u"MS":
-                self.tlmsw = self._root.MsType(self._io, self, self._root)
+                self.u2 = self._root.U2MsType(self._io, self, self._root)
 
 
     class Ax25InfoData(KaitaiStruct):
         def __init__(self, _io, _parent=None, _root=None):
             self._io = _io
             self._parent = _parent
             self._root = _root if _root else self
             self._read()
 
         def _read(self):
             self.start = self._io.read_u1()
             self.tlm_area = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
-            self.tlm_type = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
             _on = self.tlm_area
             if _on == u"EM":
-                self.tlm_area_switch = self._root.EmerType(self._io, self, self._root)
+                self.tlm_area_switch = self._root.EmType(self._io, self, self._root)
             elif _on == u"M1":
                 self.tlm_area_switch = self._root.M1Type(self._io, self, self._root)
             elif _on == u"V1":
                 self.tlm_area_switch = self._root.V1Type(self._io, self, self._root)
             elif _on == u"U2":
                 self.tlm_area_switch = self._root.U2Type(self._io, self, self._root)
             elif _on == u"A1":
                 self.tlm_area_switch = self._root.A1Type(self._io, self, self._root)
             elif _on == u"CU_L":
-                self.tlm_area_switch = self._root.CuType(self._io, self, self._root)
+                self.tlm_area_switch = self._root.CuLType(self._io, self, self._root)
             elif _on == u"CU_R":
-                self.tlm_area_switch = self._root.CuType(self._io, self, self._root)
+                self.tlm_area_switch = self._root.CuRType(self._io, self, self._root)
             elif _on == u"ER":
-                self.tlm_area_switch = self._root.EmerType(self._io, self, self._root)
+                self.tlm_area_switch = self._root.ErType(self._io, self, self._root)
 
         @property
         def aprs_message(self):
             if hasattr(self, '_m_aprs_message'):
                 return self._m_aprs_message if hasattr(self, '_m_aprs_message') else None
 
             _pos = self._io.pos()
             self._io.seek(0)
             self._m_aprs_message = (self._io.read_bytes_full()).decode(u"utf-8")
             self._io.seek(_pos)
             return self._m_aprs_message if hasattr(self, '_m_aprs_message') else None
 
 
+    class CuROnyxType(KaitaiStruct):
+        """CU_R;ONYX SENSOR T;[Timestamp];[Return value]
+        """
+        def __init__(self, _io, _parent=None, _root=None):
+            self._io = _io
+            self._parent = _parent
+            self._root = _root if _root else self
+            self._read()
+
+        def _read(self):
+            self.timestamp = (self._io.read_bytes_term(59, False, True, True)).decode(u"ASCII")
+            self.return_value = (self._io.read_bytes_full()).decode(u"ASCII")
+
+        @property
+        def return_value_int(self):
+            if hasattr(self, '_m_return_value_int'):
+                return self._m_return_value_int if hasattr(self, '_m_return_value_int') else None
+
+            self._m_return_value_int = int(self.return_value)
+            return self._m_return_value_int if hasattr(self, '_m_return_value_int') else None
+
+        @property
+        def timestamp_int(self):
+            if hasattr(self, '_m_timestamp_int'):
+                return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+            self._m_timestamp_int = int(self.timestamp)
+            return self._m_timestamp_int if hasattr(self, '_m_timestamp_int') else None
+
+
```

## Comparing `satnogs_decoders-1.9.0.dist-info/LICENSE` & `satnogs_decoders-1.9.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `satnogs_decoders-1.9.0.dist-info/METADATA` & `satnogs_decoders-1.9.1.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: satnogs-decoders
-Version: 1.9.0
+Version: 1.9.1
 Summary: SatNOGS Decoders
 Home-page: https://gitlab.com/librespacefoundation/satnogs/satnogs-decoders
 Author: SatNOGS project
 Author-email: dev@satnogs.org
 License: AGPLv3
 Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
```

## Comparing `satnogs_decoders-1.9.0.dist-info/RECORD` & `satnogs_decoders-1.9.1.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 satnogsdecoders/__init__.py,sha256=IlL-Z69OWSvTxAbYu-MpXDVYC7ONCvLo_vQdTJszoaw,208
-satnogsdecoders/_version.py,sha256=3W2u5x254ShoWmKW-r1IVcy-nsOPU6yxVnyEmG8bjMo,497
+satnogsdecoders/_version.py,sha256=WXt_rkEFcv8GcOuS34Am5helee2tIwvvu3MGWYKYgk0,497
 satnogsdecoders/decode_frame.py,sha256=xpjf74UibZ6Tkf2RzvR3SGp7DUH_cXqShu-TtMuUTH0,1186
 satnogsdecoders/decode_multiple.py,sha256=LQVeW57xqehxkVeS941eRtCbp_dMXIxa8si7_BrOgPA,5597
 satnogsdecoders/decoder/__init__.py,sha256=vf4-MnUiYf7y8UdQa-tn560lkdQGrEIghkLiEHhx-Pk,2614
 satnogsdecoders/decoder/aausat4.py,sha256=P7VcWSh8OSaheTT4w3AP-9snVFw3JBbfU-bLHAa1s2k,11218
 satnogsdecoders/decoder/acrux1.py,sha256=YwFg5_T8S1mSgFD5_R12IoitXlTD9weyfqs6cnP8PI4,9619
 satnogsdecoders/decoder/alsat1n.py,sha256=yv_ZbrzQLSWz0m9h6LqxQhFXepdBeRHmmd7EENowT9o,15739
-satnogsdecoders/decoder/amicalsat.py,sha256=Qrepqa6uybCrhIKa39TCJDKGH1xYWEfG-qtc1fHvVjM,75019
+satnogsdecoders/decoder/amicalsat.py,sha256=z7b0N6KuisNmnVzxl049H_h-HBCQrphMQW-My-rfyB0,100162
 satnogsdecoders/decoder/armadillo.py,sha256=7QcI1BzeGZzLsUHBrtc3CQxvxvCXAI4dme9oDd6PmZM,12289
 satnogsdecoders/decoder/ascii85test.py,sha256=b9tmSq1MW2yEGPQ5mAxXU0Yl6oKtMTwxqiBS30aBR4s,3062
 satnogsdecoders/decoder/asuphoenix.py,sha256=JXa07eLikBK8SPu91lYlF6gHiFy93tLF4DoEbnrqYLA,25498
 satnogsdecoders/decoder/ax25frames.py,sha256=uF16BpPadDqOabrtQLAvAKpUYb9KoZcFrSPnllDEmUc,4958
 satnogsdecoders/decoder/ax25monitor.py,sha256=QUgK9zzI7-RNEJg_UKJWlfzcr-aHqUlGy32Deip-iNA,7047
 satnogsdecoders/decoder/bisonsat.py,sha256=t-9Kx79lmqS_jNkHpaEIB6eP-Ub-52tmKNv6H_Tr6dw,15040
 satnogsdecoders/decoder/bobcat1.py,sha256=FAvX8a2v3XDI4RV76ndTc_W3nZqjnQhEUmDEjsDLo4k,15999
@@ -55,13 +55,13 @@
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/shared_methods.py,sha256=OWy0mP6JQSjW_NeLpvC_vR9dBd6g-5IWbM3fCc9aCBA,725
 tests/test_ascii85process.py,sha256=n8vOj7OIXnc0XGRozsPhTE94CIjFhkxd4sMjrFharG8,955
 tests/test_cape1.py,sha256=r6ovPWnU3utt79EntgwHL3KEdBPFfOgSDg_ukB06JBc,3245
 tests/test_elfin_pp.py,sha256=dUOw5jXbzDG65lCrGWzxG22lz9SBVIyyJCr58XaFdIA,634
 tests/test_entrysat.py,sha256=fP_-pnPCH2yPr9GBJMyKKRFj7uulo9fIdhzhwmaDypY,895
 tests/test_equisat.py,sha256=nE6ZSOs7hfvdvlZUpcN6zCnhNUc8XM4-9BQAcTsJTJ4,14939
-satnogs_decoders-1.9.0.dist-info/LICENSE,sha256=DZak_2itbUtvHzD3E7GNUYSRK6jdOJ-GqncQ2weavLA,34523
-satnogs_decoders-1.9.0.dist-info/METADATA,sha256=uGJiJ_wcYFod39v19nMhriQOzP4mVGn9gDiiafrxNlQ,792
-satnogs_decoders-1.9.0.dist-info/WHEEL,sha256=EVRjI69F5qVjm_YgqcTXPnTAv3BfSUr0WVAHuSP3Xoo,92
-satnogs_decoders-1.9.0.dist-info/entry_points.txt,sha256=vpK5Dcagou_pndPyrAMvAvDsATCWxNGxEtLPgzgFGOM,123
-satnogs_decoders-1.9.0.dist-info/top_level.txt,sha256=GSel9hvyLSU8WBvfz13FKh3Am4WzR7PNQhn63mN-gfo,22
-satnogs_decoders-1.9.0.dist-info/RECORD,,
+satnogs_decoders-1.9.1.dist-info/LICENSE,sha256=DZak_2itbUtvHzD3E7GNUYSRK6jdOJ-GqncQ2weavLA,34523
+satnogs_decoders-1.9.1.dist-info/METADATA,sha256=axCsHtfng3ZN_UfshDhKMHYINbilGRkQjnPYX-wFMEc,792
+satnogs_decoders-1.9.1.dist-info/WHEEL,sha256=EVRjI69F5qVjm_YgqcTXPnTAv3BfSUr0WVAHuSP3Xoo,92
+satnogs_decoders-1.9.1.dist-info/entry_points.txt,sha256=vpK5Dcagou_pndPyrAMvAvDsATCWxNGxEtLPgzgFGOM,123
+satnogs_decoders-1.9.1.dist-info/top_level.txt,sha256=GSel9hvyLSU8WBvfz13FKh3Am4WzR7PNQhn63mN-gfo,22
+satnogs_decoders-1.9.1.dist-info/RECORD,,
```

