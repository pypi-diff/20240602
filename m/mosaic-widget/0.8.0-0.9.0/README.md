# Comparing `tmp/mosaic_widget-0.8.0.tar.gz` & `tmp/mosaic_widget-0.9.0.tar.gz`

## Comparing `mosaic_widget-0.8.0.tar` & `mosaic_widget-0.9.0.tar`

### file list

```diff
@@ -1,12 +1,12 @@
--rw-r--r--   0        0        0      178 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/jsconfig.json
--rw-r--r--   0        0        0      752 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/package.json
--rw-r--r--   0        0        0      262 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/vite.config.mjs
--rw-r--r--   0        0        0     3524 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/mosaic_widget/__init__.py
--rw-r--r--   0        0        0  1222101 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/mosaic_widget/static/index.js
--rw-r--r--   0        0        0      830 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/mosaic_widget/static/style.css
--rw-r--r--   0        0        0     4174 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/src/index.js
--rw-r--r--   0        0        0     1069 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/src/style.css
--rw-r--r--   0        0        0       50 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/.gitignore
--rw-r--r--   0        0        0     1666 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/README.md
--rw-r--r--   0        0        0      766 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/pyproject.toml
--rw-r--r--   0        0        0     2103 2020-02-02 00:00:00.000000 mosaic_widget-0.8.0/PKG-INFO
+-rw-r--r--   0        0        0      178 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/jsconfig.json
+-rw-r--r--   0        0        0      812 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/package.json
+-rw-r--r--   0        0        0      262 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/vite.config.mjs
+-rw-r--r--   0        0        0     3524 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/mosaic_widget/__init__.py
+-rw-r--r--   0        0        0  1038228 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/mosaic_widget/static/index.js
+-rw-r--r--   0        0        0      830 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/mosaic_widget/static/style.css
+-rw-r--r--   0        0        0     4174 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/src/index.js
+-rw-r--r--   0        0        0     1069 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/src/style.css
+-rw-r--r--   0        0        0       50 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/.gitignore
+-rw-r--r--   0        0        0     1666 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/README.md
+-rw-r--r--   0        0        0      766 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/pyproject.toml
+-rw-r--r--   0        0        0     2103 2020-02-02 00:00:00.000000 mosaic_widget-0.9.0/PKG-INFO
```

### Comparing `mosaic_widget-0.8.0/package.json` & `mosaic_widget-0.9.0/package.json`

 * *Files 19% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9303571428571429%*

 * *Differences: {"'dependencies'": "{'@uwdata/mosaic-spec': '^0.9.0', '@uwdata/vgplot': '^0.9.0'}",*

 * * "'scripts'": "{'release': 'npm run prepublishOnly && npm run publish'}",*

 * * "'version'": "'0.9.0'"}*

```diff
@@ -1,12 +1,12 @@
 {
     "author": "Dominik Moritz (https://www.domoritz.de)",
     "dependencies": {
-        "@uwdata/mosaic-spec": "^0.8.0",
-        "@uwdata/vgplot": "^0.8.0",
+        "@uwdata/mosaic-spec": "^0.9.0",
+        "@uwdata/vgplot": "^0.9.0",
         "apache-arrow": "^15.0.2",
         "uuid": "^9.0.1"
     },
     "devDependencies": {
         "anywidget": "^0.9.10"
     },
     "license": "BSD-3-Clause",
@@ -18,12 +18,13 @@
     },
     "scripts": {
         "build": "vite build",
         "dev": "vite",
         "lint": "eslint src",
         "prepublishOnly": "npm run test && npm run lint && hatch fmt --check && npm run build && hatch build",
         "publish": "hatch publish --user __token__",
+        "release": "npm run prepublishOnly && npm run publish",
         "test": "tsc -p jsconfig.json"
     },
     "type": "module",
-    "version": "0.8.0"
+    "version": "0.9.0"
 }
```

### Comparing `mosaic_widget-0.8.0/mosaic_widget/__init__.py` & `mosaic_widget-0.9.0/mosaic_widget/__init__.py`

 * *Files identical despite different names*

### Comparing `mosaic_widget-0.8.0/mosaic_widget/static/index.js` & `mosaic_widget-0.9.0/mosaic_widget/static/index.js`

 * *Files 10% similar despite different names*

#### js-beautify {}

```diff
@@ -1,51 +1,51 @@
-const A_ = {};
+const z1 = {};
 
-function OI(e, t = !1) {
-    let n, i, r = A_;
+function xv(e, t = !1) {
+    let n, r, i = z1;
 
-    function s(l) {
-        n = e(l).then(() => {
-            if (i) {
+    function s(u) {
+        n = e(u).then(() => {
+            if (r) {
                 const {
-                    value: u
-                } = i;
-                i = null, s(u);
+                    value: l
+                } = r;
+                r = null, s(l);
             } else
                 n = null;
         });
     }
 
-    function o(l) {
-        i = {
-            event: l
+    function o(u) {
+        r = {
+            event: u
         };
     }
 
-    function a(l) {
-        n ? o(l) : s(l);
+    function a(u) {
+        n ? o(u) : s(u);
     }
 
-    function c(l) {
-        r !== l && requestAnimationFrame(() => {
-            const u = r;
-            r = A_, a(u);
-        }), r = l;
+    function c(u) {
+        i !== u && requestAnimationFrame(() => {
+            const l = i;
+            i = z1, a(l);
+        }), i = u;
     }
     return t ? c : a;
 }
-class af {
+class Kc {
     /**
      * Constructor.
      * @param {*} filterSelection An optional selection to interactively filter
      *  this client's data. If provided, a coordinator will re-query and update
      *  the client when the selection updates.
      */
     constructor(t) {
-        this._filterBy = t, this._requestUpdate = OI(() => this.requestQuery(), !0), this._coordinator = null;
+        this._filterBy = t, this._requestUpdate = xv(() => this.requestQuery(), !0), this._coordinator = null;
     }
     /**
      * Return this client's connected coordinator.
      */
     get coordinator() {
         return this._coordinator;
     }
@@ -67,634 +67,642 @@
      * groupby domain of the client query.
      */
     get filterIndexable() {
         return !0;
     }
     /**
      * Return an array of fields queried by this client.
+     * @returns {object[]|null} The fields to retrieve info for.
      */
     fields() {
         return null;
     }
     /**
      * Called by the coordinator to set the field info for this client.
+     * @param {*} info The field info result.
      * @returns {this}
      */
-    fieldInfo() {
+    fieldInfo(t) {
         return this;
     }
     /**
      * Return a query specifying the data needed by this client.
+     * @param {*} [filter] The filtering criteria to apply in the query.
+     * @returns {*} The client query
      */
-    query() {
+    query(t) {
         return null;
     }
     /**
      * Called by the coordinator to inform the client that a query is pending.
+     * @returns {this}
      */
     queryPending() {
         return this;
     }
     /**
      * Called by the coordinator to return a query result.
-     *
-     * @param {*} data the query result
+     * @param {*} data The query result.
      * @returns {this}
      */
-    queryResult() {
+    queryResult(t) {
         return this;
     }
     /**
      * Called by the coordinator to report a query execution error.
+     * @param {*} error
+     * @returns {this}
      */
     queryError(t) {
         return console.error(t), this;
     }
     /**
      * Request the coordinator to execute a query for this client.
      * If an explicit query is not provided, the client query method will
      * be called, filtered by the current filterBy selection.
      */
     requestQuery(t) {
-        var i;
-        const n = t || this.query((i = this.filterBy) == null ? void 0 : i.predicate(this));
+        var r;
+        const n = t || this.query((r = this.filterBy) == null ? void 0 : r.predicate(this));
         return this._coordinator.requestQuery(this, n);
     }
     /**
      * Request that the coordinator perform a throttled update of this client
      * using the default query. Unlike requestQuery, for which every call will
      * result in an executed query, multiple calls to requestUpdate may be
      * consolidated into a single update.
      */
     requestUpdate() {
         this._requestUpdate();
     }
     /**
      * Requests a client update.
      * For example to (re-)render an interface component.
+     * 
+     * @returns {this | Promise<any>}
      */
     update() {
         return this;
     }
 }
 
-function W(e, t, n, i) {
-    function r(s) {
+function bt(e, t, n, r) {
+    function i(s) {
         return s instanceof n ? s : new n(function(o) {
             o(s);
         });
     }
     return new(n || (n = Promise))(function(s, o) {
-        function a(u) {
+        function a(l) {
             try {
-                l(i.next(u));
+                u(r.next(l));
             } catch (f) {
                 o(f);
             }
         }
 
-        function c(u) {
+        function c(l) {
             try {
-                l(i.throw(u));
+                u(r.throw(l));
             } catch (f) {
                 o(f);
             }
         }
 
-        function l(u) {
-            u.done ? s(u.value) : r(u.value).then(a, c);
+        function u(l) {
+            l.done ? s(l.value) : i(l.value).then(a, c);
         }
-        l((i = i.apply(e, t || [])).next());
+        u((r = r.apply(e, t || [])).next());
     });
 }
 
-function M_(e) {
+function q1(e) {
     var t = typeof Symbol == "function" && Symbol.iterator,
         n = t && e[t],
-        i = 0;
+        r = 0;
     if (n)
         return n.call(e);
     if (e && typeof e.length == "number")
         return {
             next: function() {
-                return e && i >= e.length && (e = void 0), {
-                    value: e && e[i++],
+                return e && r >= e.length && (e = void 0), {
+                    value: e && e[r++],
                     done: !e
                 };
             }
         };
     throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
 }
 
-function H(e) {
-    return this instanceof H ? (this.v = e, this) : new H(e);
+function _t(e) {
+    return this instanceof _t ? (this.v = e, this) : new _t(e);
 }
 
-function Re(e, t, n) {
+function lr(e, t, n) {
     if (!Symbol.asyncIterator)
         throw new TypeError("Symbol.asyncIterator is not defined.");
-    var i = n.apply(e, t || []),
-        r, s = [];
-    return r = {}, o("next"), o("throw"), o("return"), r[Symbol.asyncIterator] = function() {
+    var r = n.apply(e, t || []),
+        i, s = [];
+    return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
         return this;
-    }, r;
+    }, i;
 
     function o(h) {
-        i[h] && (r[h] = function(d) {
-            return new Promise(function(p, m) {
-                s.push([h, d, p, m]) > 1 || a(h, d);
+        r[h] && (i[h] = function(d) {
+            return new Promise(function(p, y) {
+                s.push([h, d, p, y]) > 1 || a(h, d);
             });
         });
     }
 
     function a(h, d) {
         try {
-            c(i[h](d));
+            c(r[h](d));
         } catch (p) {
             f(s[0][3], p);
         }
     }
 
     function c(h) {
-        h.value instanceof H ? Promise.resolve(h.value.v).then(l, u) : f(s[0][2], h);
+        h.value instanceof _t ? Promise.resolve(h.value.v).then(u, l) : f(s[0][2], h);
     }
 
-    function l(h) {
+    function u(h) {
         a("next", h);
     }
 
-    function u(h) {
+    function l(h) {
         a("throw", h);
     }
 
     function f(h, d) {
         h(d), s.shift(), s.length && a(s[0][0], s[0][1]);
     }
 }
 
-function ks(e) {
+function vl(e) {
     var t, n;
-    return t = {}, i("next"), i("throw", function(r) {
-        throw r;
-    }), i("return"), t[Symbol.iterator] = function() {
+    return t = {}, r("next"), r("throw", function(i) {
+        throw i;
+    }), r("return"), t[Symbol.iterator] = function() {
         return this;
     }, t;
 
-    function i(r, s) {
-        t[r] = e[r] ? function(o) {
+    function r(i, s) {
+        t[i] = e[i] ? function(o) {
             return (n = !n) ? {
-                value: H(e[r](o)),
+                value: _t(e[i](o)),
                 done: !1
             } : s ? s(o) : o;
         } : s;
     }
 }
 
-function ai(e) {
+function xo(e) {
     if (!Symbol.asyncIterator)
         throw new TypeError("Symbol.asyncIterator is not defined.");
     var t = e[Symbol.asyncIterator],
         n;
-    return t ? t.call(e) : (e = typeof M_ == "function" ? M_(e) : e[Symbol.iterator](), n = {}, i("next"), i("throw"), i("return"), n[Symbol.asyncIterator] = function() {
+    return t ? t.call(e) : (e = typeof q1 == "function" ? q1(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
         return this;
     }, n);
 
-    function i(s) {
+    function r(s) {
         n[s] = e[s] && function(o) {
             return new Promise(function(a, c) {
-                o = e[s](o), r(a, c, o.done, o.value);
+                o = e[s](o), i(a, c, o.done, o.value);
             });
         };
     }
 
-    function r(s, o, a, c) {
-        Promise.resolve(c).then(function(l) {
+    function i(s, o, a, c) {
+        Promise.resolve(c).then(function(u) {
             s({
-                value: l,
+                value: u,
                 done: a
             });
         }, o);
     }
 }
-const BC = new TextDecoder("utf-8"),
-    dg = (e) => BC.decode(e),
-    OC = new TextEncoder(),
-    fb = (e) => OC.encode(e),
-    FC = (e) => typeof e == "number",
-    EC = (e) => typeof e == "boolean",
-    on = (e) => typeof e == "function",
-    Si = (e) => e != null && Object(e) === e,
-    vu = (e) => Si(e) && on(e.then),
-    Ry = (e) => Si(e) && on(e[Symbol.iterator]),
-    hb = (e) => Si(e) && on(e[Symbol.asyncIterator]),
-    pg = (e) => Si(e) && Si(e.schema),
-    FI = (e) => Si(e) && "done" in e && "value" in e,
-    EI = (e) => Si(e) && on(e.stat) && FC(e.fd),
-    LI = (e) => Si(e) && db(e.body),
-    RI = (e) => "_getDOMStream" in e && "_getNodeStream" in e,
-    db = (e) => Si(e) && on(e.cancel) && on(e.getReader) && !RI(e),
-    CI = (e) => Si(e) && on(e.read) && on(e.pipe) && EC(e.readable) && !RI(e),
-    LC = (e) => Si(e) && on(e.clear) && on(e.bytes) && on(e.position) && on(e.setPosition) && on(e.capacity) && on(e.getBufferIdentifier) && on(e.createLong),
-    pb = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
+const FN = new TextDecoder("utf-8"),
+    i0 = (e) => FN.decode(e),
+    BN = new TextEncoder(),
+    jy = (e) => BN.encode(e),
+    CN = (e) => typeof e == "number",
+    PN = (e) => typeof e == "boolean",
+    Le = (e) => typeof e == "function",
+    Cn = (e) => e != null && Object(e) === e,
+    yc = (e) => Cn(e) && Le(e.then),
+    Lh = (e) => Cn(e) && Le(e[Symbol.iterator]),
+    Vy = (e) => Cn(e) && Le(e[Symbol.asyncIterator]),
+    s0 = (e) => Cn(e) && Cn(e.schema),
+    Sv = (e) => Cn(e) && "done" in e && "value" in e,
+    Mv = (e) => Cn(e) && Le(e.stat) && CN(e.fd),
+    Av = (e) => Cn(e) && Yy(e.body),
+    $v = (e) => "_getDOMStream" in e && "_getNodeStream" in e,
+    Yy = (e) => Cn(e) && Le(e.cancel) && Le(e.getReader) && !$v(e),
+    Iv = (e) => Cn(e) && Le(e.read) && Le(e.pipe) && PN(e.readable) && !$v(e),
+    UN = (e) => Cn(e) && Le(e.clear) && Le(e.bytes) && Le(e.position) && Le(e.setPosition) && Le(e.capacity) && Le(e.getBufferIdentifier) && Le(e.createLong),
+    Wy = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
 
-function RC(e) {
+function zN(e) {
     const t = e[0] ? [e[0]] : [];
-    let n, i, r, s;
-    for (let o, a, c = 0, l = 0, u = e.length; ++c < u;) {
-        if (o = t[l], a = e[c], !o || !a || o.buffer !== a.buffer || a.byteOffset < o.byteOffset) {
-            a && (t[++l] = a);
+    let n, r, i, s;
+    for (let o, a, c = 0, u = 0, l = e.length; ++c < l;) {
+        if (o = t[u], a = e[c], !o || !a || o.buffer !== a.buffer || a.byteOffset < o.byteOffset) {
+            a && (t[++u] = a);
             continue;
         }
         if ({
                 byteOffset: n,
-                byteLength: r
+                byteLength: i
             } = o, {
-                byteOffset: i,
+                byteOffset: r,
                 byteLength: s
-            } = a, n + r < i || i + s < n) {
-            a && (t[++l] = a);
+            } = a, n + i < r || r + s < n) {
+            a && (t[++u] = a);
             continue;
         }
-        t[l] = new Uint8Array(o.buffer, n, i - n + s);
+        t[u] = new Uint8Array(o.buffer, n, r - n + s);
     }
     return t;
 }
 
-function $_(e, t, n = 0, i = t.byteLength) {
-    const r = e.byteLength,
-        s = new Uint8Array(e.buffer, e.byteOffset, r),
-        o = new Uint8Array(t.buffer, t.byteOffset, Math.min(i, r));
+function j1(e, t, n = 0, r = t.byteLength) {
+    const i = e.byteLength,
+        s = new Uint8Array(e.buffer, e.byteOffset, i),
+        o = new Uint8Array(t.buffer, t.byteOffset, Math.min(r, i));
     return s.set(o, n), e;
 }
 
-function cr(e, t) {
-    const n = RC(e),
-        i = n.reduce((u, f) => u + f.byteLength, 0);
-    let r, s, o, a = 0,
+function gr(e, t) {
+    const n = zN(e),
+        r = n.reduce((l, f) => l + f.byteLength, 0);
+    let i, s, o, a = 0,
         c = -1;
-    const l = Math.min(t || Number.POSITIVE_INFINITY, i);
-    for (const u = n.length; ++c < u;) {
-        if (r = n[c], s = r.subarray(0, Math.min(r.length, l - a)), l <= a + s.length) {
-            s.length < r.length ? n[c] = r.subarray(s.length) : s.length === r.length && c++, o ? $_(o, s, a) : o = s;
+    const u = Math.min(t || Number.POSITIVE_INFINITY, r);
+    for (const l = n.length; ++c < l;) {
+        if (i = n[c], s = i.subarray(0, Math.min(i.length, u - a)), u <= a + s.length) {
+            s.length < i.length ? n[c] = i.subarray(s.length) : s.length === i.length && c++, o ? j1(o, s, a) : o = s;
             break;
         }
-        $_(o || (o = new Uint8Array(l)), s, a), a += s.length;
+        j1(o || (o = new Uint8Array(u)), s, a), a += s.length;
     }
-    return [o || new Uint8Array(0), n.slice(c), i - (o ? o.byteLength : 0)];
+    return [o || new Uint8Array(0), n.slice(c), r - (o ? o.byteLength : 0)];
 }
 
-function re(e, t) {
-    let n = FI(t) ? t.value : t;
-    return n instanceof e ? e === Uint8Array ? new e(n.buffer, n.byteOffset, n.byteLength) : n : n ? (typeof n == "string" && (n = fb(n)), n instanceof ArrayBuffer ? new e(n) : n instanceof pb ? new e(n) : LC(n) ? re(e, n.bytes()) : ArrayBuffer.isView(n) ? n.byteLength <= 0 ? new e(0) : new e(n.buffer, n.byteOffset, n.byteLength / e.BYTES_PER_ELEMENT) : e.from(n)) : new e(0);
+function Yt(e, t) {
+    let n = Sv(t) ? t.value : t;
+    return n instanceof e ? e === Uint8Array ? new e(n.buffer, n.byteOffset, n.byteLength) : n : n ? (typeof n == "string" && (n = jy(n)), n instanceof ArrayBuffer ? new e(n) : n instanceof Wy ? new e(n) : UN(n) ? Yt(e, n.bytes()) : ArrayBuffer.isView(n) ? n.byteLength <= 0 ? new e(0) : new e(n.buffer, n.byteOffset, n.byteLength / e.BYTES_PER_ELEMENT) : e.from(n)) : new e(0);
 }
-const bl = (e) => re(Int32Array, e),
-    T_ = (e) => re(BigInt64Array, e),
-    Yt = (e) => re(Uint8Array, e),
-    yg = (e) => (e.next(), e);
+const Ea = (e) => Yt(Int32Array, e),
+    V1 = (e) => Yt(BigInt64Array, e),
+    Dt = (e) => Yt(Uint8Array, e),
+    o0 = (e) => (e.next(), e);
 
-function* CC(e, t) {
-    const n = function*(r) {
-            yield r;
+function* qN(e, t) {
+    const n = function*(i) {
+            yield i;
         },
-        i = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof pb ? n(t) : Ry(t) ? t : n(t);
-    return yield* yg(function*(r) {
+        r = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof Wy ? n(t) : Lh(t) ? t : n(t);
+    return yield* o0(function*(i) {
         let s = null;
         do
-            s = r.next(yield re(e, s));
+            s = i.next(yield Yt(e, s));
         while (!s.done);
-    }(i[Symbol.iterator]())), new e();
+    }(r[Symbol.iterator]())), new e();
 }
-const kC = (e) => CC(Uint8Array, e);
+const jN = (e) => qN(Uint8Array, e);
 
-function kI(e, t) {
-    return Re(this, arguments, function*() {
-        if (vu(t))
-            return yield H(yield H(yield* ks(ai(kI(e, yield H(t))))));
-        const i = function(o) {
-                return Re(this, arguments, function*() {
-                    yield yield H(yield H(o));
+function Tv(e, t) {
+    return lr(this, arguments, function*() {
+        if (yc(t))
+            return yield _t(yield _t(yield* vl(xo(Tv(e, yield _t(t))))));
+        const r = function(o) {
+                return lr(this, arguments, function*() {
+                    yield yield _t(yield _t(o));
                 });
             },
-            r = function(o) {
-                return Re(this, arguments, function*() {
-                    yield H(yield* ks(ai(yg(function*(a) {
+            i = function(o) {
+                return lr(this, arguments, function*() {
+                    yield _t(yield* vl(xo(o0(function*(a) {
                         let c = null;
                         do
                             c = a.next(yield c == null ? void 0 : c.value);
                         while (!c.done);
                     }(o[Symbol.iterator]())))));
                 });
             },
-            s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof pb ? i(t) : Ry(t) ? r(t) : hb(t) ? t : i(t);
-        return yield H(
+            s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof Wy ? r(t) : Lh(t) ? i(t) : Vy(t) ? t : r(t);
+        return yield _t(
             // otherwise if AsyncIterable, use it
-            yield* ks(ai(yg(function(o) {
-                return Re(this, arguments, function*() {
+            yield* vl(xo(o0(function(o) {
+                return lr(this, arguments, function*() {
                     let a = null;
                     do
-                        a = yield H(o.next(yield yield H(re(e, a))));
+                        a = yield _t(o.next(yield yield _t(Yt(e, a))));
                     while (!a.done);
                 });
             }(s[Symbol.asyncIterator]()))))
-        ), yield H(new e());
+        ), yield _t(new e());
     });
 }
-const UC = (e) => kI(Uint8Array, e);
+const VN = (e) => Tv(Uint8Array, e);
 
-function zC(e, t) {
+function YN(e, t) {
     let n = 0;
-    const i = e.length;
-    if (i !== t.length)
+    const r = e.length;
+    if (r !== t.length)
         return !1;
-    if (i > 0)
+    if (r > 0)
         do
             if (e[n] !== t[n])
                 return !1;
-        while (++n < i);
+        while (++n < r);
     return !0;
 }
-const Hn = {
+const mn = {
         fromIterable(e) {
-            return eh(PC(e));
+            return Pu(WN(e));
         },
         fromAsyncIterable(e) {
-            return eh(VC(e));
+            return Pu(XN(e));
         },
         fromDOMStream(e) {
-            return eh(jC(e));
+            return Pu(GN(e));
         },
         fromNodeStream(e) {
-            return eh(YC(e));
+            return Pu(JN(e));
         },
         // @ts-ignore
         toDOMStream(e, t) {
             throw new Error('"toDOMStream" not available in this environment');
         },
         // @ts-ignore
         toNodeStream(e, t) {
             throw new Error('"toNodeStream" not available in this environment');
         }
     },
-    eh = (e) => (e.next(), e);
+    Pu = (e) => (e.next(), e);
 
-function* PC(e) {
+function* WN(e) {
     let t, n = !1,
-        i = [],
-        r, s, o, a = 0;
+        r = [],
+        i, s, o, a = 0;
 
     function c() {
-        return s === "peek" ? cr(i, o)[0] : ([r, i, a] = cr(i, o), r);
+        return s === "peek" ? gr(r, o)[0] : ([i, r, a] = gr(r, o), i);
     }
     ({
         cmd: s,
         size: o
     } = (yield null) || {
         cmd: "read",
         size: 0
     });
-    const l = kC(e)[Symbol.iterator]();
+    const u = jN(e)[Symbol.iterator]();
     try {
         do
             if ({
                     done: t,
-                    value: r
-                } = Number.isNaN(o - a) ? l.next() : l.next(o - a), !t && r.byteLength > 0 && (i.push(r), a += r.byteLength), t || o <= a)
+                    value: i
+                } = Number.isNaN(o - a) ? u.next() : u.next(o - a), !t && i.byteLength > 0 && (r.push(i), a += i.byteLength), t || o <= a)
                 do
                     ({
                         cmd: s,
                         size: o
                     } = yield c());
                 while (o < a);
         while (!t);
-    } catch (u) {
-        (n = !0) && typeof l.throw == "function" && l.throw(u);
+    } catch (l) {
+        (n = !0) && typeof u.throw == "function" && u.throw(l);
     } finally {
-        n === !1 && typeof l.return == "function" && l.return(null);
+        n === !1 && typeof u.return == "function" && u.return(null);
     }
     return null;
 }
 
-function VC(e) {
-    return Re(this, arguments, function*() {
-        let n, i = !1,
-            r = [],
+function XN(e) {
+    return lr(this, arguments, function*() {
+        let n, r = !1,
+            i = [],
             s, o, a, c = 0;
 
-        function l() {
-            return o === "peek" ? cr(r, a)[0] : ([s, r, c] = cr(r, a), s);
+        function u() {
+            return o === "peek" ? gr(i, a)[0] : ([s, i, c] = gr(i, a), s);
         }
         ({
             cmd: o,
             size: a
-        } = (yield yield H(null)) || {
+        } = (yield yield _t(null)) || {
             cmd: "read",
             size: 0
         });
-        const u = UC(e)[Symbol.asyncIterator]();
+        const l = VN(e)[Symbol.asyncIterator]();
         try {
             do
                 if ({
                         done: n,
                         value: s
-                    } = Number.isNaN(a - c) ? yield H(u.next()): yield H(u.next(a - c)), !n && s.byteLength > 0 && (r.push(s), c += s.byteLength), n || a <= c)
+                    } = Number.isNaN(a - c) ? yield _t(l.next()): yield _t(l.next(a - c)), !n && s.byteLength > 0 && (i.push(s), c += s.byteLength), n || a <= c)
                     do
                         ({
                             cmd: o,
                             size: a
-                        } = yield yield H(l()));
+                        } = yield yield _t(u()));
                     while (a < c);
             while (!n);
         } catch (f) {
-            (i = !0) && typeof u.throw == "function" && (yield H(u.throw(f)));
+            (r = !0) && typeof l.throw == "function" && (yield _t(l.throw(f)));
         } finally {
-            i === !1 && typeof u.return == "function" && (yield H(u.return(new Uint8Array(0))));
+            r === !1 && typeof l.return == "function" && (yield _t(l.return(new Uint8Array(0))));
         }
-        return yield H(null);
+        return yield _t(null);
     });
 }
 
-function jC(e) {
-    return Re(this, arguments, function*() {
+function GN(e) {
+    return lr(this, arguments, function*() {
         let n = !1,
-            i = !1,
-            r = [],
+            r = !1,
+            i = [],
             s, o, a, c = 0;
 
-        function l() {
-            return o === "peek" ? cr(r, a)[0] : ([s, r, c] = cr(r, a), s);
+        function u() {
+            return o === "peek" ? gr(i, a)[0] : ([s, i, c] = gr(i, a), s);
         }
         ({
             cmd: o,
             size: a
-        } = (yield yield H(null)) || {
+        } = (yield yield _t(null)) || {
             cmd: "read",
             size: 0
         });
-        const u = new qC(e);
+        const l = new HN(e);
         try {
             do
                 if ({
                         done: n,
                         value: s
-                    } = Number.isNaN(a - c) ? yield H(u.read()): yield H(u.read(a - c)), !n && s.byteLength > 0 && (r.push(Yt(s)), c += s.byteLength), n || a <= c)
+                    } = Number.isNaN(a - c) ? yield _t(l.read()): yield _t(l.read(a - c)), !n && s.byteLength > 0 && (i.push(Dt(s)), c += s.byteLength), n || a <= c)
                     do
                         ({
                             cmd: o,
                             size: a
-                        } = yield yield H(l()));
+                        } = yield yield _t(u()));
                     while (a < c);
             while (!n);
         } catch (f) {
-            (i = !0) && (yield H(u.cancel(f)));
+            (r = !0) && (yield _t(l.cancel(f)));
         } finally {
-            i === !1 ? yield H(u.cancel()): e.locked && u.releaseLock();
+            r === !1 ? yield _t(l.cancel()): e.locked && l.releaseLock();
         }
-        return yield H(null);
+        return yield _t(null);
     });
 }
-let qC = class {
+class HN {
     constructor(t) {
         this.source = t, this.reader = null, this.reader = this.source.getReader(), this.reader.closed.catch(() => {});
     }
     get closed() {
         return this.reader ? this.reader.closed.catch(() => {}) : Promise.resolve();
     }
     releaseLock() {
         this.reader && this.reader.releaseLock(), this.reader = null;
     }
     cancel(t) {
-        return W(this, void 0, void 0, function*() {
+        return bt(this, void 0, void 0, function*() {
             const {
                 reader: n,
-                source: i
+                source: r
             } = this;
-            n && (yield n.cancel(t).catch(() => {})), i && i.locked && this.releaseLock();
+            n && (yield n.cancel(t).catch(() => {})), r && r.locked && this.releaseLock();
         });
     }
     read(t) {
-        return W(this, void 0, void 0, function*() {
+        return bt(this, void 0, void 0, function*() {
             if (t === 0)
                 return {
                     done: this.reader == null,
                     value: new Uint8Array(0)
                 };
             const n = yield this.reader.read();
-            return !n.done && (n.value = Yt(n)), n;
+            return !n.done && (n.value = Dt(n)), n;
         });
     }
-};
-const tm = (e, t) => {
-    const n = (r) => i([t, r]);
-    let i;
-    return [t, n, new Promise((r) => (i = r) && e.once(t, n))];
+}
+const Hd = (e, t) => {
+    const n = (i) => r([t, i]);
+    let r;
+    return [t, n, new Promise((i) => (r = i) && e.once(t, n))];
 };
 
-function YC(e) {
-    return Re(this, arguments, function*() {
+function JN(e) {
+    return lr(this, arguments, function*() {
         const n = [];
-        let i = "error",
-            r = !1,
+        let r = "error",
+            i = !1,
             s = null,
             o, a, c = 0,
-            l = [],
-            u;
+            u = [],
+            l;
 
         function f() {
-            return o === "peek" ? cr(l, a)[0] : ([u, l, c] = cr(l, a), u);
+            return o === "peek" ? gr(u, a)[0] : ([l, u, c] = gr(u, a), l);
         }
         if ({
                 cmd: o,
                 size: a
-            } = (yield yield H(null)) || {
+            } = (yield yield _t(null)) || {
                 cmd: "read",
                 size: 0
             }, e.isTTY)
-            return yield yield H(new Uint8Array(0)), yield H(null);
+            return yield yield _t(new Uint8Array(0)), yield _t(null);
         try {
-            n[0] = tm(e, "end"), n[1] = tm(e, "error");
+            n[0] = Hd(e, "end"), n[1] = Hd(e, "error");
             do {
-                if (n[2] = tm(e, "readable"), [i, s] = yield H(Promise.race(n.map((d) => d[2]))), i === "error")
+                if (n[2] = Hd(e, "readable"), [r, s] = yield _t(Promise.race(n.map((d) => d[2]))), r === "error")
                     break;
-                if ((r = i === "end") || (Number.isFinite(a - c) ? (u = Yt(e.read(a - c)), u.byteLength < a - c && (u = Yt(e.read()))) : u = Yt(e.read()), u.byteLength > 0 && (l.push(u), c += u.byteLength)), r || a <= c)
+                if ((i = r === "end") || (Number.isFinite(a - c) ? (l = Dt(e.read(a - c)), l.byteLength < a - c && (l = Dt(e.read()))) : l = Dt(e.read()), l.byteLength > 0 && (u.push(l), c += l.byteLength)), i || a <= c)
                     do
                         ({
                             cmd: o,
                             size: a
-                        } = yield yield H(f()));
+                        } = yield yield _t(f()));
                     while (a < c);
-            } while (!r);
+            } while (!i);
         } finally {
-            yield H(h(n, i === "error" ? s : null));
+            yield _t(h(n, r === "error" ? s : null));
         }
-        return yield H(null);
+        return yield _t(null);
 
         function h(d, p) {
-            return u = l = null, new Promise((m, g) => {
-                for (const [y, b] of d)
-                    e.off(y, b);
+            return l = u = null, new Promise((y, m) => {
+                for (const [g, b] of d)
+                    e.off(g, b);
                 try {
-                    const y = e.destroy;
-                    y && y.call(e, p), p = void 0;
-                } catch (y) {
-                    p = y || p;
+                    const g = e.destroy;
+                    g && g.call(e, p), p = void 0;
+                } catch (g) {
+                    p = g || p;
                 } finally {
-                    p != null ? g(p) : m();
+                    p != null ? m(p) : y();
                 }
             });
         }
     });
 }
-var Ee;
+var fe;
 (function(e) {
     e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5";
-})(Ee || (Ee = {}));
-var Mn;
+})(fe || (fe = {}));
+var Je;
 (function(e) {
     e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense";
-})(Mn || (Mn = {}));
-var nn;
+})(Je || (Je = {}));
+var De;
 (function(e) {
     e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE";
-})(nn || (nn = {}));
-var Ii;
+})(De || (De = {}));
+var Pn;
 (function(e) {
     e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND";
-})(Ii || (Ii = {}));
-var mt;
+})(Pn || (Pn = {}));
+var ct;
 (function(e) {
     e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND";
-})(mt || (mt = {}));
-var lr;
+})(ct || (ct = {}));
+var br;
 (function(e) {
     e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO";
-})(lr || (lr = {}));
-const em = 2,
-    Ji = 4,
-    Vr = 4,
-    nt = 4,
-    As = new Int32Array(2),
-    D_ = new Float32Array(As.buffer),
-    N_ = new Float64Array(As.buffer),
-    nh = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
-var mg;
+})(br || (br = {}));
+const Jd = 2,
+    ir = 4,
+    qr = 4,
+    qt = 4,
+    wi = new Int32Array(2),
+    Y1 = new Float32Array(wi.buffer),
+    W1 = new Float64Array(wi.buffer),
+    Uu = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
+var a0;
 (function(e) {
     e[e.UTF8_BYTES = 1] = "UTF8_BYTES", e[e.UTF16_STRING = 2] = "UTF16_STRING";
-})(mg || (mg = {}));
-let ur = class UI {
+})(a0 || (a0 = {}));
+let Fo = class Ev {
         /**
          * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
          */
         constructor(t) {
             this.bytes_ = t, this.position_ = 0, this.text_decoder_ = new TextDecoder();
         }
         /**
          * Create and allocate a new ByteBuffer with a given size.
          */
         static allocate(t) {
-            return new UI(new Uint8Array(t));
+            return new Ev(new Uint8Array(t));
         }
         clear() {
             this.position_ = 0;
         }
         /**
          * Get the underlying `Uint8Array`.
          */
@@ -740,18 +748,18 @@
         readInt64(t) {
             return BigInt.asIntN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
         }
         readUint64(t) {
             return BigInt.asUintN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
         }
         readFloat32(t) {
-            return As[0] = this.readInt32(t), D_[0];
+            return wi[0] = this.readInt32(t), Y1[0];
         }
         readFloat64(t) {
-            return As[nh ? 0 : 1] = this.readInt32(t), As[nh ? 1 : 0] = this.readInt32(t + 4), N_[0];
+            return wi[Uu ? 0 : 1] = this.readInt32(t), wi[Uu ? 1 : 0] = this.readInt32(t + 4), W1[0];
         }
         writeInt8(t, n) {
             this.bytes_[t] = n;
         }
         writeUint8(t, n) {
             this.bytes_[t] = n;
         }
@@ -770,39 +778,39 @@
         writeInt64(t, n) {
             this.writeInt32(t, Number(BigInt.asIntN(32, n))), this.writeInt32(t + 4, Number(BigInt.asIntN(32, n >> BigInt(32))));
         }
         writeUint64(t, n) {
             this.writeUint32(t, Number(BigInt.asUintN(32, n))), this.writeUint32(t + 4, Number(BigInt.asUintN(32, n >> BigInt(32))));
         }
         writeFloat32(t, n) {
-            D_[0] = n, this.writeInt32(t, As[0]);
+            Y1[0] = n, this.writeInt32(t, wi[0]);
         }
         writeFloat64(t, n) {
-            N_[0] = n, this.writeInt32(t, As[nh ? 0 : 1]), this.writeInt32(t + 4, As[nh ? 1 : 0]);
+            W1[0] = n, this.writeInt32(t, wi[Uu ? 0 : 1]), this.writeInt32(t + 4, wi[Uu ? 1 : 0]);
         }
         /**
          * Return the file identifier.   Behavior is undefined for FlatBuffers whose
          * schema does not include a file_identifier (likely points at padding or the
          * start of a the root vtable).
          */
         getBufferIdentifier() {
-            if (this.bytes_.length < this.position_ + Ji + Vr)
+            if (this.bytes_.length < this.position_ + ir + qr)
                 throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
             let t = "";
-            for (let n = 0; n < Vr; n++)
-                t += String.fromCharCode(this.readInt8(this.position_ + Ji + n));
+            for (let n = 0; n < qr; n++)
+                t += String.fromCharCode(this.readInt8(this.position_ + ir + n));
             return t;
         }
         /**
          * Look up a field in the vtable, return an offset into the object, or 0 if the
          * field is not present.
          */
         __offset(t, n) {
-            const i = t - this.readInt32(t);
-            return n < this.readInt16(i) ? this.readInt16(i + n) : 0;
+            const r = t - this.readInt32(t);
+            return n < this.readInt16(r) ? this.readInt16(r + n) : 0;
         }
         /**
          * Initialize any Table-derived type to point to the union at the given offset.
          */
         __union(t, n) {
             return t.bb_pos = n + this.readInt32(n), t.bb = this, t;
         }
@@ -815,18 +823,18 @@
          * the data will just be packaged back up in another FlatBuffer later on.
          *
          * @param offset
          * @param opt_encoding Defaults to UTF16_STRING
          */
         __string(t, n) {
             t += this.readInt32(t);
-            const i = this.readInt32(t);
-            t += Ji;
-            const r = this.bytes_.subarray(t, t + i);
-            return n === mg.UTF8_BYTES ? r : this.text_decoder_.decode(r);
+            const r = this.readInt32(t);
+            t += ir;
+            const i = this.bytes_.subarray(t, t + r);
+            return n === a0.UTF8_BYTES ? i : this.text_decoder_.decode(i);
         }
         /**
          * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
          * if a string then return a new one
          *
          * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
          * makes the behaviour of __union_with_string different compared to __union
@@ -840,64 +848,64 @@
         __indirect(t) {
             return t + this.readInt32(t);
         }
         /**
          * Get the start of data of a vector whose offset is stored at "offset" in this object.
          */
         __vector(t) {
-            return t + this.readInt32(t) + Ji;
+            return t + this.readInt32(t) + ir;
         }
         /**
          * Get the length of a vector whose offset is stored at "offset" in this object.
          */
         __vector_len(t) {
             return this.readInt32(t + this.readInt32(t));
         }
         __has_identifier(t) {
-            if (t.length != Vr)
-                throw new Error("FlatBuffers: file identifier must be length " + Vr);
-            for (let n = 0; n < Vr; n++)
-                if (t.charCodeAt(n) != this.readInt8(this.position() + Ji + n))
+            if (t.length != qr)
+                throw new Error("FlatBuffers: file identifier must be length " + qr);
+            for (let n = 0; n < qr; n++)
+                if (t.charCodeAt(n) != this.readInt8(this.position() + ir + n))
                     return !1;
             return !0;
         }
         /**
          * A helper function for generating list for obj api
          */
         createScalarList(t, n) {
-            const i = [];
-            for (let r = 0; r < n; ++r) {
-                const s = t(r);
-                s !== null && i.push(s);
+            const r = [];
+            for (let i = 0; i < n; ++i) {
+                const s = t(i);
+                s !== null && r.push(s);
             }
-            return i;
+            return r;
         }
         /**
          * A helper function for generating list for obj api
          * @param listAccessor function that accepts an index and return data at that index
          * @param listLength listLength
          * @param res result list
          */
         createObjList(t, n) {
-            const i = [];
-            for (let r = 0; r < n; ++r) {
-                const s = t(r);
-                s !== null && i.push(s.unpack());
+            const r = [];
+            for (let i = 0; i < n; ++i) {
+                const s = t(i);
+                s !== null && r.push(s.unpack());
             }
-            return i;
+            return r;
         }
     },
-    Cy = class zI {
+    Nv = class Dv {
         /**
          * Create a FlatBufferBuilder.
          */
         constructor(t) {
             this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null, this.text_encoder = new TextEncoder();
             let n;
-            t ? n = t : n = 1024, this.bb = ur.allocate(n), this.space = n;
+            t ? n = t : n = 1024, this.bb = Fo.allocate(n), this.space = n;
         }
         clear() {
             this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
         }
         /**
          * In order to save space, fields that are set to their default value
          * don't get serialized into the buffer. Forcing defaults provides a
@@ -930,20 +938,20 @@
          * you need to do is alignment, `additional_bytes` will be 0.
          *
          * @param size This is the of the new element to write
          * @param additional_bytes The padding size
          */
         prep(t, n) {
             t > this.minalign && (this.minalign = t);
-            const i = ~(this.bb.capacity() - this.space + n) + 1 & t - 1;
-            for (; this.space < i + t + n;) {
-                const r = this.bb.capacity();
-                this.bb = zI.growByteBuffer(this.bb), this.space += this.bb.capacity() - r;
+            const r = ~(this.bb.capacity() - this.space + n) + 1 & t - 1;
+            for (; this.space < r + t + n;) {
+                const i = this.bb.capacity();
+                this.bb = Dv.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
             }
-            this.pad(i);
+            this.pad(r);
         }
         pad(t) {
             for (let n = 0; n < t; n++)
                 this.bb.writeInt8(--this.space, 0);
         }
         writeInt8(t) {
             this.bb.writeInt8(this.space -= 1, t);
@@ -1001,40 +1009,40 @@
         /**
          * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
          * @param value The `float64` to add the buffer.
          */
         addFloat64(t) {
             this.prep(8, 0), this.writeFloat64(t);
         }
-        addFieldInt8(t, n, i) {
-            (this.force_defaults || n != i) && (this.addInt8(n), this.slot(t));
+        addFieldInt8(t, n, r) {
+            (this.force_defaults || n != r) && (this.addInt8(n), this.slot(t));
         }
-        addFieldInt16(t, n, i) {
-            (this.force_defaults || n != i) && (this.addInt16(n), this.slot(t));
+        addFieldInt16(t, n, r) {
+            (this.force_defaults || n != r) && (this.addInt16(n), this.slot(t));
         }
-        addFieldInt32(t, n, i) {
-            (this.force_defaults || n != i) && (this.addInt32(n), this.slot(t));
+        addFieldInt32(t, n, r) {
+            (this.force_defaults || n != r) && (this.addInt32(n), this.slot(t));
         }
-        addFieldInt64(t, n, i) {
-            (this.force_defaults || n !== i) && (this.addInt64(n), this.slot(t));
+        addFieldInt64(t, n, r) {
+            (this.force_defaults || n !== r) && (this.addInt64(n), this.slot(t));
         }
-        addFieldFloat32(t, n, i) {
-            (this.force_defaults || n != i) && (this.addFloat32(n), this.slot(t));
+        addFieldFloat32(t, n, r) {
+            (this.force_defaults || n != r) && (this.addFloat32(n), this.slot(t));
         }
-        addFieldFloat64(t, n, i) {
-            (this.force_defaults || n != i) && (this.addFloat64(n), this.slot(t));
+        addFieldFloat64(t, n, r) {
+            (this.force_defaults || n != r) && (this.addFloat64(n), this.slot(t));
         }
-        addFieldOffset(t, n, i) {
-            (this.force_defaults || n != i) && (this.addOffset(n), this.slot(t));
+        addFieldOffset(t, n, r) {
+            (this.force_defaults || n != r) && (this.addOffset(n), this.slot(t));
         }
         /**
          * Structs are stored inline, so nothing additional is being added. `d` is always 0.
          */
-        addFieldStruct(t, n, i) {
-            n != i && (this.nested(n), this.slot(t));
+        addFieldStruct(t, n, r) {
+            n != r && (this.nested(n), this.slot(t));
         }
         /**
          * Structures are always stored inline, they need to be created right
          * where they're used.  You'll get this assertion failure if you
          * created it elsewhere.
          */
         nested(t) {
@@ -1073,25 +1081,25 @@
          * it a uint8Array we need to suppress the type check:
          * @suppress {checkTypes}
          */
         static growByteBuffer(t) {
             const n = t.capacity();
             if (n & 3221225472)
                 throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
-            const i = n << 1,
-                r = ur.allocate(i);
-            return r.setPosition(i - n), r.bytes().set(t.bytes(), i - n), r;
+            const r = n << 1,
+                i = Fo.allocate(r);
+            return i.setPosition(r - n), i.bytes().set(t.bytes(), r - n), i;
         }
         /**
          * Adds on offset, relative to where it will be written.
          *
          * @param offset The offset to add.
          */
         addOffset(t) {
-            this.prep(Ji, 0), this.writeInt32(this.offset() - t + Ji);
+            this.prep(ir, 0), this.writeInt32(this.offset() - t + ir);
         }
         /**
          * Start encoding a new object in the buffer.  Users will not usually need to
          * call this directly. The FlatBuffers compiler will generate helper methods
          * that call this method internally.
          */
         startObject(t) {
@@ -1109,77 +1117,77 @@
             if (this.vtable == null || !this.isNested)
                 throw new Error("FlatBuffers: endObject called without startObject");
             this.addInt32(0);
             const t = this.offset();
             let n = this.vtable_in_use - 1;
             for (; n >= 0 && this.vtable[n] == 0; n--)
             ;
-            const i = n + 1;
+            const r = n + 1;
             for (; n >= 0; n--)
                 this.addInt16(this.vtable[n] != 0 ? t - this.vtable[n] : 0);
-            const r = 2;
+            const i = 2;
             this.addInt16(t - this.object_start);
-            const s = (i + r) * em;
+            const s = (r + i) * Jd;
             this.addInt16(s);
             let o = 0;
             const a = this.space;
             t:
                 for (n = 0; n < this.vtables.length; n++) {
                     const c = this.bb.capacity() - this.vtables[n];
                     if (s == this.bb.readInt16(c)) {
-                        for (let l = em; l < s; l += em)
-                            if (this.bb.readInt16(a + l) != this.bb.readInt16(c + l))
+                        for (let u = Jd; u < s; u += Jd)
+                            if (this.bb.readInt16(a + u) != this.bb.readInt16(c + u))
                                 continue t;
                         o = this.vtables[n];
                         break;
                     }
                 }
             return o ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, o - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;
         }
         /**
          * Finalize a buffer, poiting to the given `root_table`.
          */
-        finish(t, n, i) {
-            const r = i ? nt : 0;
+        finish(t, n, r) {
+            const i = r ? qt : 0;
             if (n) {
                 const s = n;
-                if (this.prep(this.minalign, Ji + Vr + r), s.length != Vr)
-                    throw new TypeError("FlatBuffers: file identifier must be length " + Vr);
-                for (let o = Vr - 1; o >= 0; o--)
+                if (this.prep(this.minalign, ir + qr + i), s.length != qr)
+                    throw new TypeError("FlatBuffers: file identifier must be length " + qr);
+                for (let o = qr - 1; o >= 0; o--)
                     this.writeInt8(s.charCodeAt(o));
             }
-            this.prep(this.minalign, Ji + r), this.addOffset(t), r && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
+            this.prep(this.minalign, ir + i), this.addOffset(t), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
         }
         /**
          * Finalize a size prefixed buffer, pointing to the given `root_table`.
          */
         finishSizePrefixed(t, n) {
             this.finish(t, n, !0);
         }
         /**
          * This checks a required field has been set in a given table that has
          * just been constructed.
          */
         requiredField(t, n) {
-            const i = this.bb.capacity() - t,
-                r = i - this.bb.readInt32(i);
-            if (!(n < this.bb.readInt16(r) && this.bb.readInt16(r + n) != 0))
+            const r = this.bb.capacity() - t,
+                i = r - this.bb.readInt32(r);
+            if (!(n < this.bb.readInt16(i) && this.bb.readInt16(i + n) != 0))
                 throw new TypeError("FlatBuffers: field " + n + " must be set");
         }
         /**
          * Start a new array/vector of objects.  Users usually will not call
          * this directly. The FlatBuffers compiler will create a start/end
          * method for vector types in generated code.
          *
          * @param elem_size The size of each element in the array
          * @param num_elems The number of elements in the array
          * @param alignment The alignment of the array
          */
-        startVector(t, n, i) {
-            this.notNested(), this.vector_num_elems = n, this.prep(Ji, t * n), this.prep(i, t * n);
+        startVector(t, n, r) {
+            this.notNested(), this.vector_num_elems = n, this.prep(ir, t * n), this.prep(r, t * n);
         }
         /**
          * Finish off the creation of an array and all its elements. The array must be
          * created with `startVector`.
          *
          * @returns The offset at which the newly created array
          * starts.
@@ -1210,16 +1218,16 @@
          * @return The offset in the buffer where the encoded string starts
          */
         createString(t) {
             if (t == null)
                 return 0;
             let n;
             t instanceof Uint8Array ? n = t : n = this.text_encoder.encode(t), this.addInt8(0), this.startVector(1, n.length, 1), this.bb.setPosition(this.space -= n.length);
-            for (let i = 0, r = this.space, s = this.bb.bytes(); i < n.length; i++)
-                s[r++] = n[i];
+            for (let r = 0, i = this.space, s = this.bb.bytes(); r < n.length; r++)
+                s[i++] = n[r];
             return this.endVector();
         }
         /**
          * A helper function to pack an object
          *
          * @returns offset of obj
          */
@@ -1229,111 +1237,111 @@
         /**
          * A helper function to pack a list of object
          *
          * @returns list of offsets of each non null object
          */
         createObjectOffsetList(t) {
             const n = [];
-            for (let i = 0; i < t.length; ++i) {
-                const r = t[i];
-                if (r !== null)
-                    n.push(this.createObjectOffset(r));
+            for (let r = 0; r < t.length; ++r) {
+                const i = t[r];
+                if (i !== null)
+                    n.push(this.createObjectOffset(i));
                 else
                     throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
             }
             return n;
         }
         createStructOffsetList(t, n) {
             return n(this, t.length), this.createObjectOffsetList(t.slice().reverse()), this.endVector();
         }
     };
-var gd;
+var Yl;
 (function(e) {
     e[e.BUFFER = 0] = "BUFFER";
-})(gd || (gd = {}));
-var bd;
+})(Yl || (Yl = {}));
+var Wl;
 (function(e) {
     e[e.LZ4_FRAME = 0] = "LZ4_FRAME", e[e.ZSTD = 1] = "ZSTD";
-})(bd || (bd = {}));
-let WC = class bo {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsBodyCompression(t, n) {
-            return (n || new bo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsBodyCompression(t, n) {
-            return t.setPosition(t.position() + nt), (n || new bo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * Compressor library.
-         * For LZ4_FRAME, each compressed buffer must consist of a single frame.
-         */
-        codec() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt8(this.bb_pos + t) : bd.LZ4_FRAME;
-        }
-        /**
-         * Indicates the way the record batch body was compressed
-         */
-        method() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? this.bb.readInt8(this.bb_pos + t) : gd.BUFFER;
-        }
-        static startBodyCompression(t) {
-            t.startObject(2);
-        }
-        static addCodec(t, n) {
-            t.addFieldInt8(0, n, bd.LZ4_FRAME);
-        }
-        static addMethod(t, n) {
-            t.addFieldInt8(1, n, gd.BUFFER);
-        }
-        static endBodyCompression(t) {
-            return t.endObject();
-        }
-        static createBodyCompression(t, n, i) {
-            return bo.startBodyCompression(t), bo.addCodec(t, n), bo.addMethod(t, i), bo.endBodyCompression(t);
-        }
-    },
-    PI = class {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        /**
-         * The relative offset into the shared memory page where the bytes for this
-         * buffer starts
-         */
-        offset() {
-            return this.bb.readInt64(this.bb_pos);
-        }
-        /**
-         * The absolute length (in bytes) of the memory buffer. The memory is found
-         * from offset (inclusive) to offset + length (non-inclusive). When building
-         * messages using the encapsulated IPC message, padding bytes may be written
-         * after a buffer, but such padding bytes do not need to be accounted for in
-         * the size here.
-         */
-        length() {
-            return this.bb.readInt64(this.bb_pos + 8);
-        }
-        static sizeOf() {
-            return 16;
-        }
-        static createBuffer(t, n, i) {
-            return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
-        }
-    },
-    VI = class {
+})(Wl || (Wl = {}));
+class vi {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsBodyCompression(t, n) {
+        return (n || new vi()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsBodyCompression(t, n) {
+        return t.setPosition(t.position() + qt), (n || new vi()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    /**
+     * Compressor library.
+     * For LZ4_FRAME, each compressed buffer must consist of a single frame.
+     */
+    codec() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt8(this.bb_pos + t) : Wl.LZ4_FRAME;
+    }
+    /**
+     * Indicates the way the record batch body was compressed
+     */
+    method() {
+        const t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.readInt8(this.bb_pos + t) : Yl.BUFFER;
+    }
+    static startBodyCompression(t) {
+        t.startObject(2);
+    }
+    static addCodec(t, n) {
+        t.addFieldInt8(0, n, Wl.LZ4_FRAME);
+    }
+    static addMethod(t, n) {
+        t.addFieldInt8(1, n, Yl.BUFFER);
+    }
+    static endBodyCompression(t) {
+        return t.endObject();
+    }
+    static createBodyCompression(t, n, r) {
+        return vi.startBodyCompression(t), vi.addCodec(t, n), vi.addMethod(t, r), vi.endBodyCompression(t);
+    }
+}
+class Ov {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    /**
+     * The relative offset into the shared memory page where the bytes for this
+     * buffer starts
+     */
+    offset() {
+        return this.bb.readInt64(this.bb_pos);
+    }
+    /**
+     * The absolute length (in bytes) of the memory buffer. The memory is found
+     * from offset (inclusive) to offset + length (non-inclusive). When building
+     * messages using the encapsulated IPC message, padding bytes may be written
+     * after a buffer, but such padding bytes do not need to be accounted for in
+     * the size here.
+     */
+    length() {
+        return this.bb.readInt64(this.bb_pos + 8);
+    }
+    static sizeOf() {
+        return 16;
+    }
+    static createBuffer(t, n, r) {
+        return t.prep(8, 16), t.writeInt64(BigInt(r ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
+    }
+}
+let Lv = class {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         /**
@@ -1350,72 +1358,72 @@
          */
         nullCount() {
             return this.bb.readInt64(this.bb_pos + 8);
         }
         static sizeOf() {
             return 16;
         }
-        static createFieldNode(t, n, i) {
-            return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
+        static createFieldNode(t, n, r) {
+            return t.prep(8, 16), t.writeInt64(BigInt(r ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
         }
     },
-    Lr = class gg {
+    Cr = class c0 {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsRecordBatch(t, n) {
-            return (n || new gg()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new c0()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsRecordBatch(t, n) {
-            return t.setPosition(t.position() + nt), (n || new gg()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new c0()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         /**
          * number of records / rows. The arrays in the batch should all have this
          * length
          */
         length() {
             const t = this.bb.__offset(this.bb_pos, 4);
             return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
         }
         /**
          * Nodes correspond to the pre-ordered flattened logical schema
          */
         nodes(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 6);
-            return i ? (n || new VI()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
+            const r = this.bb.__offset(this.bb_pos, 6);
+            return r ? (n || new Lv()).__init(this.bb.__vector(this.bb_pos + r) + t * 16, this.bb) : null;
         }
         nodesLength() {
             const t = this.bb.__offset(this.bb_pos, 6);
             return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
         }
         /**
          * Buffers correspond to the pre-ordered flattened buffer tree
          *
          * The number of buffers appended to this list depends on the schema. For
          * example, most primitive arrays will have 2 buffers, 1 for the validity
          * bitmap and 1 for the values. For struct arrays, there will only be a
          * single buffer for the validity (nulls) bitmap
          */
         buffers(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 8);
-            return i ? (n || new PI()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
+            const r = this.bb.__offset(this.bb_pos, 8);
+            return r ? (n || new Ov()).__init(this.bb.__vector(this.bb_pos + r) + t * 16, this.bb) : null;
         }
         buffersLength() {
             const t = this.bb.__offset(this.bb_pos, 8);
             return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
         }
         /**
          * Optional compression of the message body
          */
         compression(t) {
             const n = this.bb.__offset(this.bb_pos, 10);
-            return n ? (t || new WC()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
+            return n ? (t || new vi()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
         }
         static startRecordBatch(t) {
             t.startObject(4);
         }
         static addLength(t, n) {
             t.addFieldInt64(0, n, BigInt("0"));
         }
@@ -1434,34 +1442,34 @@
         static addCompression(t, n) {
             t.addFieldOffset(3, n, 0);
         }
         static endRecordBatch(t) {
             return t.endObject();
         }
     },
-    Da = class bg {
+    io = class u0 {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsDictionaryBatch(t, n) {
-            return (n || new bg()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new u0()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsDictionaryBatch(t, n) {
-            return t.setPosition(t.position() + nt), (n || new bg()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new u0()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         id() {
             const t = this.bb.__offset(this.bb_pos, 4);
             return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
         }
         data(t) {
             const n = this.bb.__offset(this.bb_pos, 6);
-            return n ? (t || new Lr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
+            return n ? (t || new Cr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
         }
         /**
          * If isDelta is true the values in the dictionary are to be appended to a
          * dictionary with the indicated id. If isDelta is false this dictionary
          * should replace the existing dictionary.
          */
         isDelta() {
@@ -1480,250 +1488,250 @@
         static addIsDelta(t, n) {
             t.addFieldInt8(2, +n, 0);
         }
         static endDictionaryBatch(t) {
             return t.endObject();
         }
     };
-var Sc;
+var Bo;
 (function(e) {
     e[e.Little = 0] = "Little", e[e.Big = 1] = "Big";
-})(Sc || (Sc = {}));
-var wd;
+})(Bo || (Bo = {}));
+var Xl;
 (function(e) {
     e[e.DenseArray = 0] = "DenseArray";
-})(wd || (wd = {}));
-let Ja = class wo {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsInt(t, n) {
-            return (n || new wo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsInt(t, n) {
-            return t.setPosition(t.position() + nt), (n || new wo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        bitWidth() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt32(this.bb_pos + t) : 0;
-        }
-        isSigned() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
-        }
-        static startInt(t) {
-            t.startObject(2);
-        }
-        static addBitWidth(t, n) {
-            t.addFieldInt32(0, n, 0);
-        }
-        static addIsSigned(t, n) {
-            t.addFieldInt8(1, +n, 0);
-        }
-        static endInt(t) {
-            return t.endObject();
-        }
-        static createInt(t, n, i) {
-            return wo.startInt(t), wo.addBitWidth(t, n), wo.addIsSigned(t, i), wo.endInt(t);
-        }
-    },
-    Na = class wg {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsDictionaryEncoding(t, n) {
-            return (n || new wg()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsDictionaryEncoding(t, n) {
-            return t.setPosition(t.position() + nt), (n || new wg()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * The known dictionary id in the application where this data is used. In
-         * the file or streaming formats, the dictionary ids are found in the
-         * DictionaryBatch messages
-         */
-        id() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
-        }
-        /**
-         * The dictionary indices are constrained to be non-negative integers. If
-         * this field is null, the indices must be signed int32. To maximize
-         * cross-language compatibility and performance, implementations are
-         * recommended to prefer signed integer types over unsigned integer types
-         * and to avoid uint64 indices unless they are required by an application.
-         */
-        indexType(t) {
-            const n = this.bb.__offset(this.bb_pos, 6);
-            return n ? (t || new Ja()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
-        }
-        /**
-         * By default, dictionaries are not ordered, or the order does not have
-         * semantic meaning. In some statistical, applications, dictionary-encoding
-         * is used to represent ordered categorical data, and we provide a way to
-         * preserve that metadata here
-         */
-        isOrdered() {
-            const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
-        }
-        dictionaryKind() {
-            const t = this.bb.__offset(this.bb_pos, 10);
-            return t ? this.bb.readInt16(this.bb_pos + t) : wd.DenseArray;
-        }
-        static startDictionaryEncoding(t) {
-            t.startObject(4);
-        }
-        static addId(t, n) {
-            t.addFieldInt64(0, n, BigInt("0"));
-        }
-        static addIndexType(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static addIsOrdered(t, n) {
-            t.addFieldInt8(2, +n, 0);
-        }
-        static addDictionaryKind(t, n) {
-            t.addFieldInt16(3, n, wd.DenseArray);
-        }
-        static endDictionaryEncoding(t) {
-            return t.endObject();
-        }
-    },
-    ni = class vo {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsKeyValue(t, n) {
-            return (n || new vo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsKeyValue(t, n) {
-            return t.setPosition(t.position() + nt), (n || new vo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        key(t) {
-            const n = this.bb.__offset(this.bb_pos, 4);
-            return n ? this.bb.__string(this.bb_pos + n, t) : null;
-        }
-        value(t) {
-            const n = this.bb.__offset(this.bb_pos, 6);
-            return n ? this.bb.__string(this.bb_pos + n, t) : null;
-        }
-        static startKeyValue(t) {
-            t.startObject(2);
-        }
-        static addKey(t, n) {
-            t.addFieldOffset(0, n, 0);
-        }
-        static addValue(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static endKeyValue(t) {
-            return t.endObject();
-        }
-        static createKeyValue(t, n, i) {
-            return vo.startKeyValue(t), vo.addKey(t, n), vo.addValue(t, i), vo.endKeyValue(t);
-        }
-    },
-    B_ = class El {
+})(Xl || (Xl = {}));
+class rn {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsInt(t, n) {
+        return (n || new rn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsInt(t, n) {
+        return t.setPosition(t.position() + qt), (n || new rn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    bitWidth() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 0;
+    }
+    isSigned() {
+        const t = this.bb.__offset(this.bb_pos, 6);
+        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
+    }
+    static startInt(t) {
+        t.startObject(2);
+    }
+    static addBitWidth(t, n) {
+        t.addFieldInt32(0, n, 0);
+    }
+    static addIsSigned(t, n) {
+        t.addFieldInt8(1, +n, 0);
+    }
+    static endInt(t) {
+        return t.endObject();
+    }
+    static createInt(t, n, r) {
+        return rn.startInt(t), rn.addBitWidth(t, n), rn.addIsSigned(t, r), rn.endInt(t);
+    }
+}
+class jr {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsDictionaryEncoding(t, n) {
+        return (n || new jr()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsDictionaryEncoding(t, n) {
+        return t.setPosition(t.position() + qt), (n || new jr()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    /**
+     * The known dictionary id in the application where this data is used. In
+     * the file or streaming formats, the dictionary ids are found in the
+     * DictionaryBatch messages
+     */
+    id() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
+    }
+    /**
+     * The dictionary indices are constrained to be non-negative integers. If
+     * this field is null, the indices must be signed int32. To maximize
+     * cross-language compatibility and performance, implementations are
+     * recommended to prefer signed integer types over unsigned integer types
+     * and to avoid uint64 indices unless they are required by an application.
+     */
+    indexType(t) {
+        const n = this.bb.__offset(this.bb_pos, 6);
+        return n ? (t || new rn()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
+    }
+    /**
+     * By default, dictionaries are not ordered, or the order does not have
+     * semantic meaning. In some statistical, applications, dictionary-encoding
+     * is used to represent ordered categorical data, and we provide a way to
+     * preserve that metadata here
+     */
+    isOrdered() {
+        const t = this.bb.__offset(this.bb_pos, 8);
+        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
+    }
+    dictionaryKind() {
+        const t = this.bb.__offset(this.bb_pos, 10);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Xl.DenseArray;
+    }
+    static startDictionaryEncoding(t) {
+        t.startObject(4);
+    }
+    static addId(t, n) {
+        t.addFieldInt64(0, n, BigInt("0"));
+    }
+    static addIndexType(t, n) {
+        t.addFieldOffset(1, n, 0);
+    }
+    static addIsOrdered(t, n) {
+        t.addFieldInt8(2, +n, 0);
+    }
+    static addDictionaryKind(t, n) {
+        t.addFieldInt16(3, n, Xl.DenseArray);
+    }
+    static endDictionaryEncoding(t) {
+        return t.endObject();
+    }
+}
+class he {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsKeyValue(t, n) {
+        return (n || new he()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsKeyValue(t, n) {
+        return t.setPosition(t.position() + qt), (n || new he()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    key(t) {
+        const n = this.bb.__offset(this.bb_pos, 4);
+        return n ? this.bb.__string(this.bb_pos + n, t) : null;
+    }
+    value(t) {
+        const n = this.bb.__offset(this.bb_pos, 6);
+        return n ? this.bb.__string(this.bb_pos + n, t) : null;
+    }
+    static startKeyValue(t) {
+        t.startObject(2);
+    }
+    static addKey(t, n) {
+        t.addFieldOffset(0, n, 0);
+    }
+    static addValue(t, n) {
+        t.addFieldOffset(1, n, 0);
+    }
+    static endKeyValue(t) {
+        return t.endObject();
+    }
+    static createKeyValue(t, n, r) {
+        return he.startKeyValue(t), he.addKey(t, n), he.addValue(t, r), he.endKeyValue(t);
+    }
+}
+let X1 = class ja {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsBinary(t, n) {
-            return (n || new El()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new ja()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsBinary(t, n) {
-            return t.setPosition(t.position() + nt), (n || new El()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new ja()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static startBinary(t) {
             t.startObject(0);
         }
         static endBinary(t) {
             return t.endObject();
         }
         static createBinary(t) {
-            return El.startBinary(t), El.endBinary(t);
+            return ja.startBinary(t), ja.endBinary(t);
         }
     },
-    O_ = class Ll {
+    G1 = class Va {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsBool(t, n) {
-            return (n || new Ll()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new Va()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsBool(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ll()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new Va()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static startBool(t) {
             t.startObject(0);
         }
         static endBool(t) {
             return t.endObject();
         }
         static createBool(t) {
-            return Ll.startBool(t), Ll.endBool(t);
+            return Va.startBool(t), Va.endBool(t);
         }
     },
-    kh = class Ba {
+    _l = class so {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsDate(t, n) {
-            return (n || new Ba()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new so()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsDate(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ba()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new so()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         unit() {
             const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : Ii.MILLISECOND;
+            return t ? this.bb.readInt16(this.bb_pos + t) : Pn.MILLISECOND;
         }
         static startDate(t) {
             t.startObject(1);
         }
         static addUnit(t, n) {
-            t.addFieldInt16(0, n, Ii.MILLISECOND);
+            t.addFieldInt16(0, n, Pn.MILLISECOND);
         }
         static endDate(t) {
             return t.endObject();
         }
         static createDate(t, n) {
-            return Ba.startDate(t), Ba.addUnit(t, n), Ba.endDate(t);
+            return so.startDate(t), so.addUnit(t, n), so.endDate(t);
         }
     },
-    Oa = class _s {
+    oo = class mi {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsDecimal(t, n) {
-            return (n || new _s()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new mi()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsDecimal(t, n) {
-            return t.setPosition(t.position() + nt), (n || new _s()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new mi()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         /**
          * Total number of decimal digits
          */
         precision() {
             const t = this.bb.__offset(this.bb_pos, 4);
             return t ? this.bb.readInt32(this.bb_pos + t) : 0;
@@ -1754,60 +1762,60 @@
         }
         static addBitWidth(t, n) {
             t.addFieldInt32(2, n, 128);
         }
         static endDecimal(t) {
             return t.endObject();
         }
-        static createDecimal(t, n, i, r) {
-            return _s.startDecimal(t), _s.addPrecision(t, n), _s.addScale(t, i), _s.addBitWidth(t, r), _s.endDecimal(t);
+        static createDecimal(t, n, r, i) {
+            return mi.startDecimal(t), mi.addPrecision(t, n), mi.addScale(t, r), mi.addBitWidth(t, i), mi.endDecimal(t);
         }
     },
-    Uh = class Fa {
+    xl = class ao {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsDuration(t, n) {
-            return (n || new Fa()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new ao()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsDuration(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Fa()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new ao()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         unit() {
             const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : mt.MILLISECOND;
+            return t ? this.bb.readInt16(this.bb_pos + t) : ct.MILLISECOND;
         }
         static startDuration(t) {
             t.startObject(1);
         }
         static addUnit(t, n) {
-            t.addFieldInt16(0, n, mt.MILLISECOND);
+            t.addFieldInt16(0, n, ct.MILLISECOND);
         }
         static endDuration(t) {
             return t.endObject();
         }
         static createDuration(t, n) {
-            return Fa.startDuration(t), Fa.addUnit(t, n), Fa.endDuration(t);
+            return ao.startDuration(t), ao.addUnit(t, n), ao.endDuration(t);
         }
     },
-    zh = class Ea {
+    Sl = class co {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsFixedSizeBinary(t, n) {
-            return (n || new Ea()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new co()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsFixedSizeBinary(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ea()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new co()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         /**
          * Number of bytes per value
          */
         byteWidth() {
             const t = this.bb.__offset(this.bb_pos, 4);
             return t ? this.bb.readInt32(this.bb_pos + t) : 0;
@@ -1818,29 +1826,29 @@
         static addByteWidth(t, n) {
             t.addFieldInt32(0, n, 0);
         }
         static endFixedSizeBinary(t) {
             return t.endObject();
         }
         static createFixedSizeBinary(t, n) {
-            return Ea.startFixedSizeBinary(t), Ea.addByteWidth(t, n), Ea.endFixedSizeBinary(t);
+            return co.startFixedSizeBinary(t), co.addByteWidth(t, n), co.endFixedSizeBinary(t);
         }
     },
-    Ph = class La {
+    Ml = class uo {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsFixedSizeList(t, n) {
-            return (n || new La()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new uo()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsFixedSizeList(t, n) {
-            return t.setPosition(t.position() + nt), (n || new La()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new uo()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         /**
          * Number of list items per value
          */
         listSize() {
             const t = this.bb.__offset(this.bb_pos, 4);
             return t ? this.bb.readInt32(this.bb_pos + t) : 0;
@@ -1851,158 +1859,158 @@
         static addListSize(t, n) {
             t.addFieldInt32(0, n, 0);
         }
         static endFixedSizeList(t) {
             return t.endObject();
         }
         static createFixedSizeList(t, n) {
-            return La.startFixedSizeList(t), La.addListSize(t, n), La.endFixedSizeList(t);
-        }
-    },
-    Vh = class Ra {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsFloatingPoint(t, n) {
-            return (n || new Ra()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsFloatingPoint(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ra()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        precision() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : nn.HALF;
-        }
-        static startFloatingPoint(t) {
-            t.startObject(1);
-        }
-        static addPrecision(t, n) {
-            t.addFieldInt16(0, n, nn.HALF);
-        }
-        static endFloatingPoint(t) {
-            return t.endObject();
-        }
-        static createFloatingPoint(t, n) {
-            return Ra.startFloatingPoint(t), Ra.addPrecision(t, n), Ra.endFloatingPoint(t);
-        }
-    },
-    jh = class Ca {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsInterval(t, n) {
-            return (n || new Ca()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsInterval(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ca()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        unit() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : lr.YEAR_MONTH;
-        }
-        static startInterval(t) {
-            t.startObject(1);
-        }
-        static addUnit(t, n) {
-            t.addFieldInt16(0, n, lr.YEAR_MONTH);
-        }
-        static endInterval(t) {
-            return t.endObject();
+            return uo.startFixedSizeList(t), uo.addListSize(t, n), uo.endFixedSizeList(t);
         }
-        static createInterval(t, n) {
-            return Ca.startInterval(t), Ca.addUnit(t, n), Ca.endInterval(t);
-        }
-    },
-    F_ = class Rl {
+    };
+class sr {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsFloatingPoint(t, n) {
+        return (n || new sr()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsFloatingPoint(t, n) {
+        return t.setPosition(t.position() + qt), (n || new sr()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    precision() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : De.HALF;
+    }
+    static startFloatingPoint(t) {
+        t.startObject(1);
+    }
+    static addPrecision(t, n) {
+        t.addFieldInt16(0, n, De.HALF);
+    }
+    static endFloatingPoint(t) {
+        return t.endObject();
+    }
+    static createFloatingPoint(t, n) {
+        return sr.startFloatingPoint(t), sr.addPrecision(t, n), sr.endFloatingPoint(t);
+    }
+}
+class or {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsInterval(t, n) {
+        return (n || new or()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsInterval(t, n) {
+        return t.setPosition(t.position() + qt), (n || new or()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    unit() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : br.YEAR_MONTH;
+    }
+    static startInterval(t) {
+        t.startObject(1);
+    }
+    static addUnit(t, n) {
+        t.addFieldInt16(0, n, br.YEAR_MONTH);
+    }
+    static endInterval(t) {
+        return t.endObject();
+    }
+    static createInterval(t, n) {
+        return or.startInterval(t), or.addUnit(t, n), or.endInterval(t);
+    }
+}
+let H1 = class Ya {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsLargeBinary(t, n) {
-            return (n || new Rl()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new Ya()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsLargeBinary(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Rl()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new Ya()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static startLargeBinary(t) {
             t.startObject(0);
         }
         static endLargeBinary(t) {
             return t.endObject();
         }
         static createLargeBinary(t) {
-            return Rl.startLargeBinary(t), Rl.endLargeBinary(t);
+            return Ya.startLargeBinary(t), Ya.endLargeBinary(t);
         }
     },
-    E_ = class Cl {
+    J1 = class Wa {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsLargeUtf8(t, n) {
-            return (n || new Cl()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new Wa()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsLargeUtf8(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Cl()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new Wa()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static startLargeUtf8(t) {
             t.startObject(0);
         }
         static endLargeUtf8(t) {
             return t.endObject();
         }
         static createLargeUtf8(t) {
-            return Cl.startLargeUtf8(t), Cl.endLargeUtf8(t);
+            return Wa.startLargeUtf8(t), Wa.endLargeUtf8(t);
         }
     },
-    L_ = class kl {
+    Z1 = class Xa {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsList(t, n) {
-            return (n || new kl()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new Xa()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsList(t, n) {
-            return t.setPosition(t.position() + nt), (n || new kl()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new Xa()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static startList(t) {
             t.startObject(0);
         }
         static endList(t) {
             return t.endObject();
         }
         static createList(t) {
-            return kl.startList(t), kl.endList(t);
+            return Xa.startList(t), Xa.endList(t);
         }
     },
-    qh = class ka {
+    Al = class lo {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsMap(t, n) {
-            return (n || new ka()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new lo()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsMap(t, n) {
-            return t.setPosition(t.position() + nt), (n || new ka()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new lo()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         /**
          * Set to true if the keys within each value are sorted
          */
         keysSorted() {
             const t = this.bb.__offset(this.bb_pos, 4);
             return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
@@ -2013,278 +2021,278 @@
         static addKeysSorted(t, n) {
             t.addFieldInt8(0, +n, 0);
         }
         static endMap(t) {
             return t.endObject();
         }
         static createMap(t, n) {
-            return ka.startMap(t), ka.addKeysSorted(t, n), ka.endMap(t);
+            return lo.startMap(t), lo.addKeysSorted(t, n), lo.endMap(t);
         }
     },
-    R_ = class Ul {
+    K1 = class Ga {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsNull(t, n) {
-            return (n || new Ul()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new Ga()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsNull(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ul()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new Ga()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static startNull(t) {
             t.startObject(0);
         }
         static endNull(t) {
             return t.endObject();
         }
         static createNull(t) {
-            return Ul.startNull(t), Ul.endNull(t);
-        }
-    },
-    C_ = class zl {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsStruct_(t, n) {
-            return (n || new zl()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsStruct_(t, n) {
-            return t.setPosition(t.position() + nt), (n || new zl()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startStruct_(t) {
-            t.startObject(0);
-        }
-        static endStruct_(t) {
-            return t.endObject();
-        }
-        static createStruct_(t) {
-            return zl.startStruct_(t), zl.endStruct_(t);
-        }
-    },
-    Pl = class _o {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsTime(t, n) {
-            return (n || new _o()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsTime(t, n) {
-            return t.setPosition(t.position() + nt), (n || new _o()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        unit() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : mt.MILLISECOND;
-        }
-        bitWidth() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? this.bb.readInt32(this.bb_pos + t) : 32;
-        }
-        static startTime(t) {
-            t.startObject(2);
-        }
-        static addUnit(t, n) {
-            t.addFieldInt16(0, n, mt.MILLISECOND);
-        }
-        static addBitWidth(t, n) {
-            t.addFieldInt32(1, n, 32);
-        }
-        static endTime(t) {
-            return t.endObject();
-        }
-        static createTime(t, n, i) {
-            return _o.startTime(t), _o.addUnit(t, n), _o.addBitWidth(t, i), _o.endTime(t);
-        }
-    },
-    Vl = class xo {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsTimestamp(t, n) {
-            return (n || new xo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsTimestamp(t, n) {
-            return t.setPosition(t.position() + nt), (n || new xo()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        unit() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : mt.SECOND;
-        }
-        timezone(t) {
-            const n = this.bb.__offset(this.bb_pos, 6);
-            return n ? this.bb.__string(this.bb_pos + n, t) : null;
-        }
-        static startTimestamp(t) {
-            t.startObject(2);
-        }
-        static addUnit(t, n) {
-            t.addFieldInt16(0, n, mt.SECOND);
-        }
-        static addTimezone(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static endTimestamp(t) {
-            return t.endObject();
-        }
-        static createTimestamp(t, n, i) {
-            return xo.startTimestamp(t), xo.addUnit(t, n), xo.addTimezone(t, i), xo.endTimestamp(t);
-        }
-    },
-    So = class Io {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsUnion(t, n) {
-            return (n || new Io()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsUnion(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Io()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        mode() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : Mn.Sparse;
-        }
-        typeIds(t) {
-            const n = this.bb.__offset(this.bb_pos, 6);
-            return n ? this.bb.readInt32(this.bb.__vector(this.bb_pos + n) + t * 4) : 0;
-        }
-        typeIdsLength() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        typeIdsArray() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
-        }
-        static startUnion(t) {
-            t.startObject(2);
-        }
-        static addMode(t, n) {
-            t.addFieldInt16(0, n, Mn.Sparse);
-        }
-        static addTypeIds(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static createTypeIdsVector(t, n) {
-            t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addInt32(n[i]);
-            return t.endVector();
-        }
-        static startTypeIdsVector(t, n) {
-            t.startVector(4, n, 4);
-        }
-        static endUnion(t) {
-            return t.endObject();
-        }
-        static createUnion(t, n, i) {
-            return Io.startUnion(t), Io.addMode(t, n), Io.addTypeIds(t, i), Io.endUnion(t);
-        }
-    },
-    k_ = class jl {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsUtf8(t, n) {
-            return (n || new jl()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsUtf8(t, n) {
-            return t.setPosition(t.position() + nt), (n || new jl()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startUtf8(t) {
-            t.startObject(0);
-        }
-        static endUtf8(t) {
-            return t.endObject();
-        }
-        static createUtf8(t) {
-            return jl.startUtf8(t), jl.endUtf8(t);
+            return Ga.startNull(t), Ga.endNull(t);
         }
     };
-var he;
+class fs {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsStruct_(t, n) {
+        return (n || new fs()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsStruct_(t, n) {
+        return t.setPosition(t.position() + qt), (n || new fs()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static startStruct_(t) {
+        t.startObject(0);
+    }
+    static endStruct_(t) {
+        return t.endObject();
+    }
+    static createStruct_(t) {
+        return fs.startStruct_(t), fs.endStruct_(t);
+    }
+}
+class bn {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsTime(t, n) {
+        return (n || new bn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsTime(t, n) {
+        return t.setPosition(t.position() + qt), (n || new bn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    unit() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : ct.MILLISECOND;
+    }
+    bitWidth() {
+        const t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 32;
+    }
+    static startTime(t) {
+        t.startObject(2);
+    }
+    static addUnit(t, n) {
+        t.addFieldInt16(0, n, ct.MILLISECOND);
+    }
+    static addBitWidth(t, n) {
+        t.addFieldInt32(1, n, 32);
+    }
+    static endTime(t) {
+        return t.endObject();
+    }
+    static createTime(t, n, r) {
+        return bn.startTime(t), bn.addUnit(t, n), bn.addBitWidth(t, r), bn.endTime(t);
+    }
+}
+class wn {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsTimestamp(t, n) {
+        return (n || new wn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsTimestamp(t, n) {
+        return t.setPosition(t.position() + qt), (n || new wn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    unit() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : ct.SECOND;
+    }
+    timezone(t) {
+        const n = this.bb.__offset(this.bb_pos, 6);
+        return n ? this.bb.__string(this.bb_pos + n, t) : null;
+    }
+    static startTimestamp(t) {
+        t.startObject(2);
+    }
+    static addUnit(t, n) {
+        t.addFieldInt16(0, n, ct.SECOND);
+    }
+    static addTimezone(t, n) {
+        t.addFieldOffset(1, n, 0);
+    }
+    static endTimestamp(t) {
+        return t.endObject();
+    }
+    static createTimestamp(t, n, r) {
+        return wn.startTimestamp(t), wn.addUnit(t, n), wn.addTimezone(t, r), wn.endTimestamp(t);
+    }
+}
+class Xe {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsUnion(t, n) {
+        return (n || new Xe()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsUnion(t, n) {
+        return t.setPosition(t.position() + qt), (n || new Xe()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    mode() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Je.Sparse;
+    }
+    typeIds(t) {
+        const n = this.bb.__offset(this.bb_pos, 6);
+        return n ? this.bb.readInt32(this.bb.__vector(this.bb_pos + n) + t * 4) : 0;
+    }
+    typeIdsLength() {
+        const t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
+    }
+    typeIdsArray() {
+        const t = this.bb.__offset(this.bb_pos, 6);
+        return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
+    }
+    static startUnion(t) {
+        t.startObject(2);
+    }
+    static addMode(t, n) {
+        t.addFieldInt16(0, n, Je.Sparse);
+    }
+    static addTypeIds(t, n) {
+        t.addFieldOffset(1, n, 0);
+    }
+    static createTypeIdsVector(t, n) {
+        t.startVector(4, n.length, 4);
+        for (let r = n.length - 1; r >= 0; r--)
+            t.addInt32(n[r]);
+        return t.endVector();
+    }
+    static startTypeIdsVector(t, n) {
+        t.startVector(4, n, 4);
+    }
+    static endUnion(t) {
+        return t.endObject();
+    }
+    static createUnion(t, n, r) {
+        return Xe.startUnion(t), Xe.addMode(t, n), Xe.addTypeIds(t, r), Xe.endUnion(t);
+    }
+}
+let Q1 = class Ha {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsUtf8(t, n) {
+        return (n || new Ha()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsUtf8(t, n) {
+        return t.setPosition(t.position() + qt), (n || new Ha()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static startUtf8(t) {
+        t.startObject(0);
+    }
+    static endUtf8(t) {
+        return t.endObject();
+    }
+    static createUtf8(t) {
+        return Ha.startUtf8(t), Ha.endUtf8(t);
+    }
+};
+var Jt;
 (function(e) {
     e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.FloatingPoint = 3] = "FloatingPoint", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct_ = 13] = "Struct_", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.LargeList = 21] = "LargeList", e[e.RunEndEncoded = 22] = "RunEndEncoded";
-})(he || (he = {}));
-let Gn = class Yh {
+})(Jt || (Jt = {}));
+let yn = class $l {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsField(t, n) {
-            return (n || new Yh()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new $l()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsField(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Yh()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new $l()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         name(t) {
             const n = this.bb.__offset(this.bb_pos, 4);
             return n ? this.bb.__string(this.bb_pos + n, t) : null;
         }
         /**
          * Whether or not this field can contain nulls. Should be true in general.
          */
         nullable() {
             const t = this.bb.__offset(this.bb_pos, 6);
             return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
         }
         typeType() {
             const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? this.bb.readUint8(this.bb_pos + t) : he.NONE;
+            return t ? this.bb.readUint8(this.bb_pos + t) : Jt.NONE;
         }
         /**
          * This is the type of the decoded value if the field is dictionary encoded.
          */
         type(t) {
             const n = this.bb.__offset(this.bb_pos, 10);
             return n ? this.bb.__union(t, this.bb_pos + n) : null;
         }
         /**
          * Present only if the field is dictionary encoded.
          */
         dictionary(t) {
             const n = this.bb.__offset(this.bb_pos, 12);
-            return n ? (t || new Na()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
+            return n ? (t || new jr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
         }
         /**
          * children apply only to nested data types like Struct, List and Union. For
          * primitive types children will have length 0.
          */
         children(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 14);
-            return i ? (n || new Yh()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
+            const r = this.bb.__offset(this.bb_pos, 14);
+            return r ? (n || new $l()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
         }
         childrenLength() {
             const t = this.bb.__offset(this.bb_pos, 14);
             return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
         }
         /**
          * User-defined metadata
          */
         customMetadata(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 16);
-            return i ? (n || new ni()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
+            const r = this.bb.__offset(this.bb_pos, 16);
+            return r ? (n || new he()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
         }
         customMetadataLength() {
             const t = this.bb.__offset(this.bb_pos, 16);
             return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
         }
         static startField(t) {
             t.startObject(7);
@@ -2292,83 +2300,83 @@
         static addName(t, n) {
             t.addFieldOffset(0, n, 0);
         }
         static addNullable(t, n) {
             t.addFieldInt8(1, +n, 0);
         }
         static addTypeType(t, n) {
-            t.addFieldInt8(2, n, he.NONE);
+            t.addFieldInt8(2, n, Jt.NONE);
         }
         static addType(t, n) {
             t.addFieldOffset(3, n, 0);
         }
         static addDictionary(t, n) {
             t.addFieldOffset(4, n, 0);
         }
         static addChildren(t, n) {
             t.addFieldOffset(5, n, 0);
         }
         static createChildrenVector(t, n) {
             t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
+            for (let r = n.length - 1; r >= 0; r--)
+                t.addOffset(n[r]);
             return t.endVector();
         }
         static startChildrenVector(t, n) {
             t.startVector(4, n, 4);
         }
         static addCustomMetadata(t, n) {
             t.addFieldOffset(6, n, 0);
         }
         static createCustomMetadataVector(t, n) {
             t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
+            for (let r = n.length - 1; r >= 0; r--)
+                t.addOffset(n[r]);
             return t.endVector();
         }
         static startCustomMetadataVector(t, n) {
             t.startVector(4, n, 4);
         }
         static endField(t) {
             return t.endObject();
         }
     },
-    Yi = class Dr {
+    tr = class Fr {
         constructor() {
             this.bb = null, this.bb_pos = 0;
         }
         __init(t, n) {
             return this.bb_pos = t, this.bb = n, this;
         }
         static getRootAsSchema(t, n) {
-            return (n || new Dr()).__init(t.readInt32(t.position()) + t.position(), t);
+            return (n || new Fr()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         static getSizePrefixedRootAsSchema(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Dr()).__init(t.readInt32(t.position()) + t.position(), t);
+            return t.setPosition(t.position() + qt), (n || new Fr()).__init(t.readInt32(t.position()) + t.position(), t);
         }
         /**
          * endianness of the buffer
          * it is Little Endian by default
          * if endianness doesn't match the underlying system then the vectors need to be converted
          */
         endianness() {
             const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : Sc.Little;
+            return t ? this.bb.readInt16(this.bb_pos + t) : Bo.Little;
         }
         fields(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 6);
-            return i ? (n || new Gn()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
+            const r = this.bb.__offset(this.bb_pos, 6);
+            return r ? (n || new yn()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
         }
         fieldsLength() {
             const t = this.bb.__offset(this.bb_pos, 6);
             return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
         }
         customMetadata(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 8);
-            return i ? (n || new ni()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
+            const r = this.bb.__offset(this.bb_pos, 8);
+            return r ? (n || new he()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
         }
         customMetadataLength() {
             const t = this.bb.__offset(this.bb_pos, 8);
             return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
         }
         /**
          * Features used in the stream/file.
@@ -2381,358 +2389,358 @@
             const t = this.bb.__offset(this.bb_pos, 10);
             return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
         }
         static startSchema(t) {
             t.startObject(4);
         }
         static addEndianness(t, n) {
-            t.addFieldInt16(0, n, Sc.Little);
+            t.addFieldInt16(0, n, Bo.Little);
         }
         static addFields(t, n) {
             t.addFieldOffset(1, n, 0);
         }
         static createFieldsVector(t, n) {
             t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
+            for (let r = n.length - 1; r >= 0; r--)
+                t.addOffset(n[r]);
             return t.endVector();
         }
         static startFieldsVector(t, n) {
             t.startVector(4, n, 4);
         }
         static addCustomMetadata(t, n) {
             t.addFieldOffset(2, n, 0);
         }
         static createCustomMetadataVector(t, n) {
             t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
+            for (let r = n.length - 1; r >= 0; r--)
+                t.addOffset(n[r]);
             return t.endVector();
         }
         static startCustomMetadataVector(t, n) {
             t.startVector(4, n, 4);
         }
         static addFeatures(t, n) {
             t.addFieldOffset(3, n, 0);
         }
         static createFeaturesVector(t, n) {
             t.startVector(8, n.length, 8);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addInt64(n[i]);
+            for (let r = n.length - 1; r >= 0; r--)
+                t.addInt64(n[r]);
             return t.endVector();
         }
         static startFeaturesVector(t, n) {
             t.startVector(8, n, 8);
         }
         static endSchema(t) {
             return t.endObject();
         }
         static finishSchemaBuffer(t, n) {
             t.finish(n);
         }
         static finishSizePrefixedSchemaBuffer(t, n) {
             t.finish(n, void 0, !0);
         }
-        static createSchema(t, n, i, r, s) {
-            return Dr.startSchema(t), Dr.addEndianness(t, n), Dr.addFields(t, i), Dr.addCustomMetadata(t, r), Dr.addFeatures(t, s), Dr.endSchema(t);
+        static createSchema(t, n, r, i, s) {
+            return Fr.startSchema(t), Fr.addEndianness(t, n), Fr.addFields(t, r), Fr.addCustomMetadata(t, i), Fr.addFeatures(t, s), Fr.endSchema(t);
         }
     };
-var Qt;
+var Ct;
 (function(e) {
     e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor";
-})(Qt || (Qt = {}));
-var F;
+})(Ct || (Ct = {}));
+var L;
 (function(e) {
     e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth", e[e.DurationSecond = -27] = "DurationSecond", e[e.DurationMillisecond = -28] = "DurationMillisecond", e[e.DurationMicrosecond = -29] = "DurationMicrosecond", e[e.DurationNanosecond = -30] = "DurationNanosecond";
-})(F || (F = {}));
-var Rr;
+})(L || (L = {}));
+var Pr;
 (function(e) {
     e[e.OFFSET = 0] = "OFFSET", e[e.DATA = 1] = "DATA", e[e.VALIDITY = 2] = "VALIDITY", e[e.TYPE = 3] = "TYPE";
-})(Rr || (Rr = {}));
-const GC = void 0;
+})(Pr || (Pr = {}));
+const ZN = void 0;
 
-function _u(e) {
+function mc(e) {
     if (e === null)
         return "null";
-    if (e === GC)
+    if (e === ZN)
         return "undefined";
     switch (typeof e) {
         case "number":
             return `${e}`;
         case "bigint":
             return `${e}`;
         case "string":
             return `"${e}"`;
     }
-    return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map((t) => _u(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, n) => typeof n == "bigint" ? `${n}` : n);
+    return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map((t) => mc(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, n) => typeof n == "bigint" ? `${n}` : n);
 }
-const XC = Symbol.for("isArrowBigNum");
+const KN = Symbol.for("isArrowBigNum");
 
-function Ei(e, ...t) {
-    return t.length === 0 ? Object.setPrototypeOf(re(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype);
+function Xn(e, ...t) {
+    return t.length === 0 ? Object.setPrototypeOf(Yt(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype);
 }
-Ei.prototype[XC] = !0;
-Ei.prototype.toJSON = function() {
-    return `"${Su(this)}"`;
+Xn.prototype[KN] = !0;
+Xn.prototype.toJSON = function() {
+    return `"${bc(this)}"`;
 };
-Ei.prototype.valueOf = function() {
-    return jI(this);
+Xn.prototype.valueOf = function() {
+    return kv(this);
 };
-Ei.prototype.toString = function() {
-    return Su(this);
+Xn.prototype.toString = function() {
+    return bc(this);
 };
-Ei.prototype[Symbol.toPrimitive] = function(e = "default") {
+Xn.prototype[Symbol.toPrimitive] = function(e = "default") {
     switch (e) {
         case "number":
-            return jI(this);
+            return kv(this);
         case "string":
-            return Su(this);
+            return bc(this);
         case "default":
-            return HC(this);
+            return QN(this);
     }
-    return Su(this);
+    return bc(this);
 };
 
-function oc(...e) {
-    return Ei.apply(this, e);
+function So(...e) {
+    return Xn.apply(this, e);
 }
 
-function ac(...e) {
-    return Ei.apply(this, e);
+function Mo(...e) {
+    return Xn.apply(this, e);
 }
 
-function xu(...e) {
-    return Ei.apply(this, e);
+function gc(...e) {
+    return Xn.apply(this, e);
 }
-Object.setPrototypeOf(oc.prototype, Object.create(Int32Array.prototype));
-Object.setPrototypeOf(ac.prototype, Object.create(Uint32Array.prototype));
-Object.setPrototypeOf(xu.prototype, Object.create(Uint32Array.prototype));
-Object.assign(oc.prototype, Ei.prototype, {
-    constructor: oc,
+Object.setPrototypeOf(So.prototype, Object.create(Int32Array.prototype));
+Object.setPrototypeOf(Mo.prototype, Object.create(Uint32Array.prototype));
+Object.setPrototypeOf(gc.prototype, Object.create(Uint32Array.prototype));
+Object.assign(So.prototype, Xn.prototype, {
+    constructor: So,
     signed: !0,
     TypedArray: Int32Array,
     BigIntArray: BigInt64Array
 });
-Object.assign(ac.prototype, Ei.prototype, {
-    constructor: ac,
+Object.assign(Mo.prototype, Xn.prototype, {
+    constructor: Mo,
     signed: !1,
     TypedArray: Uint32Array,
     BigIntArray: BigUint64Array
 });
-Object.assign(xu.prototype, Ei.prototype, {
-    constructor: xu,
+Object.assign(gc.prototype, Xn.prototype, {
+    constructor: gc,
     signed: !0,
     TypedArray: Uint32Array,
     BigIntArray: BigUint64Array
 });
 
-function jI(e) {
+function kv(e) {
     const {
         buffer: t,
         byteOffset: n,
-        length: i,
-        signed: r
-    } = e, s = new BigUint64Array(t, n, i), o = r && s.at(-1) & BigInt(1) << BigInt(63);
+        length: r,
+        signed: i
+    } = e, s = new BigUint64Array(t, n, r), o = i && s.at(-1) & BigInt(1) << BigInt(63);
     let a = BigInt(o ? 1 : 0),
         c = BigInt(0);
     if (o) {
-        for (const l of s)
-            a += ~l * (BigInt(1) << BigInt(32) * c++);
+        for (const u of s)
+            a += ~u * (BigInt(1) << BigInt(32) * c++);
         a *= BigInt(-1);
     } else
-        for (const l of s)
-            a += l * (BigInt(1) << BigInt(32) * c++);
+        for (const u of s)
+            a += u * (BigInt(1) << BigInt(32) * c++);
     return a;
 }
-const Su = (e) => {
+const bc = (e) => {
         if (e.byteLength === 8)
             return `${new e.BigIntArray(e.buffer, e.byteOffset, 1)[0]}`;
         if (!e.signed)
-            return nm(e);
+            return Zd(e);
         let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
         if (new Int16Array([t.at(-1)])[0] >= 0)
-            return nm(e);
+            return Zd(e);
         t = t.slice();
-        let i = 1;
+        let r = 1;
         for (let s = 0; s < t.length; s++) {
             const o = t[s],
-                a = ~o + i;
-            t[s] = a, i &= o === 0 ? 1 : 0;
+                a = ~o + r;
+            t[s] = a, r &= o === 0 ? 1 : 0;
         }
-        return `-${nm(t)}`;
+        return `-${Zd(t)}`;
     },
-    HC = (e) => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : Su(e);
+    QN = (e) => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : bc(e);
 
-function nm(e) {
+function Zd(e) {
     let t = "";
     const n = new Uint32Array(2);
-    let i = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
-    const r = new Uint32Array((i = new Uint16Array(i).reverse()).buffer);
+    let r = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
+    const i = new Uint32Array((r = new Uint16Array(r).reverse()).buffer);
     let s = -1;
-    const o = i.length - 1;
+    const o = r.length - 1;
     do {
-        for (n[0] = i[s = 0]; s < o;)
-            i[s++] = n[1] = n[0] / 10, n[0] = (n[0] - n[1] * 10 << 16) + i[s];
-        i[s] = n[1] = n[0] / 10, n[0] = n[0] - n[1] * 10, t = `${n[0]}${t}`;
-    } while (r[0] || r[1] || r[2] || r[3]);
+        for (n[0] = r[s = 0]; s < o;)
+            r[s++] = n[1] = n[0] / 10, n[0] = (n[0] - n[1] * 10 << 16) + r[s];
+        r[s] = n[1] = n[0] / 10, n[0] = n[0] - n[1] * 10, t = `${n[0]}${t}`;
+    } while (i[0] || i[1] || i[2] || i[3]);
     return t ?? "0";
 }
-let JC = class qI {
+class Xy {
     /** @nocollapse */
     static new(t, n) {
         switch (n) {
             case !0:
-                return new oc(t);
+                return new So(t);
             case !1:
-                return new ac(t);
+                return new Mo(t);
         }
         switch (t.constructor) {
             case Int8Array:
             case Int16Array:
             case Int32Array:
             case BigInt64Array:
-                return new oc(t);
+                return new So(t);
         }
-        return t.byteLength === 16 ? new xu(t) : new ac(t);
+        return t.byteLength === 16 ? new gc(t) : new Mo(t);
     }
     /** @nocollapse */
     static signed(t) {
-        return new oc(t);
+        return new So(t);
     }
     /** @nocollapse */
     static unsigned(t) {
-        return new ac(t);
+        return new Mo(t);
     }
     /** @nocollapse */
     static decimal(t) {
-        return new xu(t);
+        return new gc(t);
     }
     constructor(t, n) {
-        return qI.new(t, n);
+        return Xy.new(t, n);
     }
-};
+}
 
-function pn(e) {
+function Pe(e) {
     if (typeof e == "bigint" && (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER))
         throw new TypeError(`${e} is not safe to convert to a number.`);
     return Number(e);
 }
-var YI, WI, GI, XI, HI, JI, KI, ZI, QI, tA, eA, nA, iA, rA, sA, oA, aA, cA, lA, uA, fA, hA;
-let gt = class vg {
+var Rv, Fv, Bv, Cv, Pv, Uv, zv, qv, jv, Vv, Yv, Wv, Xv, Gv, Hv, Jv, Zv, Kv, Qv, t_, e_, n_;
+class Q {
     /** @nocollapse */
     static isNull(t) {
-        return (t == null ? void 0 : t.typeId) === F.Null;
+        return (t == null ? void 0 : t.typeId) === L.Null;
     }
     /** @nocollapse */
     static isInt(t) {
-        return (t == null ? void 0 : t.typeId) === F.Int;
+        return (t == null ? void 0 : t.typeId) === L.Int;
     }
     /** @nocollapse */
     static isFloat(t) {
-        return (t == null ? void 0 : t.typeId) === F.Float;
+        return (t == null ? void 0 : t.typeId) === L.Float;
     }
     /** @nocollapse */
     static isBinary(t) {
-        return (t == null ? void 0 : t.typeId) === F.Binary;
+        return (t == null ? void 0 : t.typeId) === L.Binary;
     }
     /** @nocollapse */
     static isLargeBinary(t) {
-        return (t == null ? void 0 : t.typeId) === F.LargeBinary;
+        return (t == null ? void 0 : t.typeId) === L.LargeBinary;
     }
     /** @nocollapse */
     static isUtf8(t) {
-        return (t == null ? void 0 : t.typeId) === F.Utf8;
+        return (t == null ? void 0 : t.typeId) === L.Utf8;
     }
     /** @nocollapse */
     static isLargeUtf8(t) {
-        return (t == null ? void 0 : t.typeId) === F.LargeUtf8;
+        return (t == null ? void 0 : t.typeId) === L.LargeUtf8;
     }
     /** @nocollapse */
     static isBool(t) {
-        return (t == null ? void 0 : t.typeId) === F.Bool;
+        return (t == null ? void 0 : t.typeId) === L.Bool;
     }
     /** @nocollapse */
     static isDecimal(t) {
-        return (t == null ? void 0 : t.typeId) === F.Decimal;
+        return (t == null ? void 0 : t.typeId) === L.Decimal;
     }
     /** @nocollapse */
     static isDate(t) {
-        return (t == null ? void 0 : t.typeId) === F.Date;
+        return (t == null ? void 0 : t.typeId) === L.Date;
     }
     /** @nocollapse */
     static isTime(t) {
-        return (t == null ? void 0 : t.typeId) === F.Time;
+        return (t == null ? void 0 : t.typeId) === L.Time;
     }
     /** @nocollapse */
     static isTimestamp(t) {
-        return (t == null ? void 0 : t.typeId) === F.Timestamp;
+        return (t == null ? void 0 : t.typeId) === L.Timestamp;
     }
     /** @nocollapse */
     static isInterval(t) {
-        return (t == null ? void 0 : t.typeId) === F.Interval;
+        return (t == null ? void 0 : t.typeId) === L.Interval;
     }
     /** @nocollapse */
     static isDuration(t) {
-        return (t == null ? void 0 : t.typeId) === F.Duration;
+        return (t == null ? void 0 : t.typeId) === L.Duration;
     }
     /** @nocollapse */
     static isList(t) {
-        return (t == null ? void 0 : t.typeId) === F.List;
+        return (t == null ? void 0 : t.typeId) === L.List;
     }
     /** @nocollapse */
     static isStruct(t) {
-        return (t == null ? void 0 : t.typeId) === F.Struct;
+        return (t == null ? void 0 : t.typeId) === L.Struct;
     }
     /** @nocollapse */
     static isUnion(t) {
-        return (t == null ? void 0 : t.typeId) === F.Union;
+        return (t == null ? void 0 : t.typeId) === L.Union;
     }
     /** @nocollapse */
     static isFixedSizeBinary(t) {
-        return (t == null ? void 0 : t.typeId) === F.FixedSizeBinary;
+        return (t == null ? void 0 : t.typeId) === L.FixedSizeBinary;
     }
     /** @nocollapse */
     static isFixedSizeList(t) {
-        return (t == null ? void 0 : t.typeId) === F.FixedSizeList;
+        return (t == null ? void 0 : t.typeId) === L.FixedSizeList;
     }
     /** @nocollapse */
     static isMap(t) {
-        return (t == null ? void 0 : t.typeId) === F.Map;
+        return (t == null ? void 0 : t.typeId) === L.Map;
     }
     /** @nocollapse */
     static isDictionary(t) {
-        return (t == null ? void 0 : t.typeId) === F.Dictionary;
+        return (t == null ? void 0 : t.typeId) === L.Dictionary;
     }
     /** @nocollapse */
     static isDenseUnion(t) {
-        return vg.isUnion(t) && t.mode === Mn.Dense;
+        return Q.isUnion(t) && t.mode === Je.Dense;
     }
     /** @nocollapse */
     static isSparseUnion(t) {
-        return vg.isUnion(t) && t.mode === Mn.Sparse;
+        return Q.isUnion(t) && t.mode === Je.Sparse;
     }
     constructor(t) {
         this.typeId = t;
     }
-};
-YI = Symbol.toStringTag;
-gt[YI] = ((e) => (e.children = null, e.ArrayType = Array, e.OffsetArrayType = Int32Array, e[Symbol.toStringTag] = "DataType"))(gt.prototype);
-let zs = class extends gt {
+}
+Rv = Symbol.toStringTag;
+Q[Rv] = ((e) => (e.children = null, e.ArrayType = Array, e.OffsetArrayType = Int32Array, e[Symbol.toStringTag] = "DataType"))(Q.prototype);
+class Li extends Q {
     constructor() {
-        super(F.Null);
+        super(L.Null);
     }
     toString() {
         return "Null";
     }
-};
-WI = Symbol.toStringTag;
-zs[WI] = ((e) => e[Symbol.toStringTag] = "Null")(zs.prototype);
-let Ps = class extends gt {
+}
+Fv = Symbol.toStringTag;
+Li[Fv] = ((e) => e[Symbol.toStringTag] = "Null")(Li.prototype);
+class ki extends Q {
     constructor(t, n) {
-        super(F.Int), this.isSigned = t, this.bitWidth = n;
+        super(L.Int), this.isSigned = t, this.bitWidth = n;
     }
     get ArrayType() {
         switch (this.bitWidth) {
             case 8:
                 return this.isSigned ? Int8Array : Uint8Array;
             case 16:
                 return this.isSigned ? Int16Array : Uint16Array;
@@ -2742,241 +2750,241 @@
                 return this.isSigned ? BigInt64Array : BigUint64Array;
         }
         throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
     }
     toString() {
         return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
     }
-};
-GI = Symbol.toStringTag;
-Ps[GI] = ((e) => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(Ps.prototype);
-let Iu = class extends Ps {
+}
+Bv = Symbol.toStringTag;
+ki[Bv] = ((e) => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(ki.prototype);
+class wc extends ki {
     constructor() {
         super(!0, 32);
     }
     get ArrayType() {
         return Int32Array;
     }
-};
-Object.defineProperty(Iu.prototype, "ArrayType", {
+}
+Object.defineProperty(wc.prototype, "ArrayType", {
     value: Int32Array
 });
-let Au = class extends gt {
+class vc extends Q {
     constructor(t) {
-        super(F.Float), this.precision = t;
+        super(L.Float), this.precision = t;
     }
     get ArrayType() {
         switch (this.precision) {
-            case nn.HALF:
+            case De.HALF:
                 return Uint16Array;
-            case nn.SINGLE:
+            case De.SINGLE:
                 return Float32Array;
-            case nn.DOUBLE:
+            case De.DOUBLE:
                 return Float64Array;
         }
         throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
     }
     toString() {
         return `Float${this.precision << 5 || 16}`;
     }
-};
-XI = Symbol.toStringTag;
-Au[XI] = ((e) => (e.precision = null, e[Symbol.toStringTag] = "Float"))(Au.prototype);
-let vd = class extends gt {
+}
+Cv = Symbol.toStringTag;
+vc[Cv] = ((e) => (e.precision = null, e[Symbol.toStringTag] = "Float"))(vc.prototype);
+class Gl extends Q {
     constructor() {
-        super(F.Binary);
+        super(L.Binary);
     }
     toString() {
         return "Binary";
     }
-};
-HI = Symbol.toStringTag;
-vd[HI] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))(vd.prototype);
-let _d = class extends gt {
+}
+Pv = Symbol.toStringTag;
+Gl[Pv] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))(Gl.prototype);
+class Hl extends Q {
     constructor() {
-        super(F.LargeBinary);
+        super(L.LargeBinary);
     }
     toString() {
         return "LargeBinary";
     }
-};
-JI = Symbol.toStringTag;
-_d[JI] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeBinary"))(_d.prototype);
-let xd = class extends gt {
+}
+Uv = Symbol.toStringTag;
+Hl[Uv] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeBinary"))(Hl.prototype);
+class Jl extends Q {
     constructor() {
-        super(F.Utf8);
+        super(L.Utf8);
     }
     toString() {
         return "Utf8";
     }
-};
-KI = Symbol.toStringTag;
-xd[KI] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(xd.prototype);
-let Sd = class extends gt {
+}
+zv = Symbol.toStringTag;
+Jl[zv] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(Jl.prototype);
+class Zl extends Q {
     constructor() {
-        super(F.LargeUtf8);
+        super(L.LargeUtf8);
     }
     toString() {
         return "LargeUtf8";
     }
-};
-ZI = Symbol.toStringTag;
-Sd[ZI] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeUtf8"))(Sd.prototype);
-let Id = class extends gt {
+}
+qv = Symbol.toStringTag;
+Zl[qv] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeUtf8"))(Zl.prototype);
+class Kl extends Q {
     constructor() {
-        super(F.Bool);
+        super(L.Bool);
     }
     toString() {
         return "Bool";
     }
-};
-QI = Symbol.toStringTag;
-Id[QI] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(Id.prototype);
-let Ad = class extends gt {
-    constructor(t, n, i = 128) {
-        super(F.Decimal), this.scale = t, this.precision = n, this.bitWidth = i;
+}
+jv = Symbol.toStringTag;
+Kl[jv] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(Kl.prototype);
+class Ql extends Q {
+    constructor(t, n, r = 128) {
+        super(L.Decimal), this.scale = t, this.precision = n, this.bitWidth = r;
     }
     toString() {
         return `Decimal[${this.precision}e${this.scale > 0 ? "+" : ""}${this.scale}]`;
     }
-};
-tA = Symbol.toStringTag;
-Ad[tA] = ((e) => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(Ad.prototype);
-let Md = class extends gt {
+}
+Vv = Symbol.toStringTag;
+Ql[Vv] = ((e) => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(Ql.prototype);
+class tf extends Q {
     constructor(t) {
-        super(F.Date), this.unit = t;
+        super(L.Date), this.unit = t;
     }
     toString() {
-        return `Date${(this.unit + 1) * 32}<${Ii[this.unit]}>`;
+        return `Date${(this.unit + 1) * 32}<${Pn[this.unit]}>`;
     }
-};
-eA = Symbol.toStringTag;
-Md[eA] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))(Md.prototype);
-let Mu = class extends gt {
+}
+Yv = Symbol.toStringTag;
+tf[Yv] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))(tf.prototype);
+class _c extends Q {
     constructor(t, n) {
-        super(F.Time), this.unit = t, this.bitWidth = n;
+        super(L.Time), this.unit = t, this.bitWidth = n;
     }
     toString() {
-        return `Time${this.bitWidth}<${mt[this.unit]}>`;
+        return `Time${this.bitWidth}<${ct[this.unit]}>`;
     }
     get ArrayType() {
         switch (this.bitWidth) {
             case 32:
                 return Int32Array;
             case 64:
                 return BigInt64Array;
         }
         throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
     }
-};
-nA = Symbol.toStringTag;
-Mu[nA] = ((e) => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(Mu.prototype);
-let $d = class extends gt {
+}
+Wv = Symbol.toStringTag;
+_c[Wv] = ((e) => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(_c.prototype);
+class ef extends Q {
     constructor(t, n) {
-        super(F.Timestamp), this.unit = t, this.timezone = n;
+        super(L.Timestamp), this.unit = t, this.timezone = n;
     }
     toString() {
-        return `Timestamp<${mt[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
+        return `Timestamp<${ct[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
     }
-};
-iA = Symbol.toStringTag;
-$d[iA] = ((e) => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))($d.prototype);
-let Td = class extends gt {
+}
+Xv = Symbol.toStringTag;
+ef[Xv] = ((e) => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))(ef.prototype);
+class nf extends Q {
     constructor(t) {
-        super(F.Interval), this.unit = t;
+        super(L.Interval), this.unit = t;
     }
     toString() {
-        return `Interval<${lr[this.unit]}>`;
+        return `Interval<${br[this.unit]}>`;
     }
-};
-rA = Symbol.toStringTag;
-Td[rA] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(Td.prototype);
-let Dd = class extends gt {
+}
+Gv = Symbol.toStringTag;
+nf[Gv] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(nf.prototype);
+class rf extends Q {
     constructor(t) {
-        super(F.Duration), this.unit = t;
+        super(L.Duration), this.unit = t;
     }
     toString() {
-        return `Duration<${mt[this.unit]}>`;
+        return `Duration<${ct[this.unit]}>`;
     }
-};
-sA = Symbol.toStringTag;
-Dd[sA] = ((e) => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))(Dd.prototype);
-let Nd = class extends gt {
+}
+Hv = Symbol.toStringTag;
+rf[Hv] = ((e) => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))(rf.prototype);
+class sf extends Q {
     constructor(t) {
-        super(F.List), this.children = [t];
+        super(L.List), this.children = [t];
     }
     toString() {
         return `List<${this.valueType}>`;
     }
     get valueType() {
         return this.children[0].type;
     }
     get valueField() {
         return this.children[0];
     }
     get ArrayType() {
         return this.valueType.ArrayType;
     }
-};
-oA = Symbol.toStringTag;
-Nd[oA] = ((e) => (e.children = null, e[Symbol.toStringTag] = "List"))(Nd.prototype);
-let fn = class extends gt {
+}
+Jv = Symbol.toStringTag;
+sf[Jv] = ((e) => (e.children = null, e[Symbol.toStringTag] = "List"))(sf.prototype);
+class Be extends Q {
     constructor(t) {
-        super(F.Struct), this.children = t;
+        super(L.Struct), this.children = t;
     }
     toString() {
         return `Struct<{${this.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
     }
-};
-aA = Symbol.toStringTag;
-fn[aA] = ((e) => (e.children = null, e[Symbol.toStringTag] = "Struct"))(fn.prototype);
-let Bd = class extends gt {
-    constructor(t, n, i) {
-        super(F.Union), this.mode = t, this.children = i, this.typeIds = n = Int32Array.from(n), this.typeIdToChildIndex = n.reduce((r, s, o) => (r[s] = o) && r || r, /* @__PURE__ */ Object.create(null));
+}
+Zv = Symbol.toStringTag;
+Be[Zv] = ((e) => (e.children = null, e[Symbol.toStringTag] = "Struct"))(Be.prototype);
+class of extends Q {
+    constructor(t, n, r) {
+        super(L.Union), this.mode = t, this.children = r, this.typeIds = n = Int32Array.from(n), this.typeIdToChildIndex = n.reduce((i, s, o) => (i[s] = o) && i || i, /* @__PURE__ */ Object.create(null));
     }
     toString() {
         return `${this[Symbol.toStringTag]}<${this.children.map((t) => `${t.type}`).join(" | ")}>`;
     }
-};
-cA = Symbol.toStringTag;
-Bd[cA] = ((e) => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(Bd.prototype);
-let Od = class extends gt {
+}
+Kv = Symbol.toStringTag;
+of [Kv] = ((e) => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(of.prototype);
+class af extends Q {
     constructor(t) {
-        super(F.FixedSizeBinary), this.byteWidth = t;
+        super(L.FixedSizeBinary), this.byteWidth = t;
     }
     toString() {
         return `FixedSizeBinary[${this.byteWidth}]`;
     }
-};
-lA = Symbol.toStringTag;
-Od[lA] = ((e) => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(Od.prototype);
-let Fd = class extends gt {
+}
+Qv = Symbol.toStringTag;
+af[Qv] = ((e) => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(af.prototype);
+class cf extends Q {
     constructor(t, n) {
-        super(F.FixedSizeList), this.listSize = t, this.children = [n];
+        super(L.FixedSizeList), this.listSize = t, this.children = [n];
     }
     get valueType() {
         return this.children[0].type;
     }
     get valueField() {
         return this.children[0];
     }
     get ArrayType() {
         return this.valueType.ArrayType;
     }
     toString() {
         return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
     }
-};
-uA = Symbol.toStringTag;
-Fd[uA] = ((e) => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(Fd.prototype);
-let Ed = class extends gt {
+}
+t_ = Symbol.toStringTag;
+cf[t_] = ((e) => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(cf.prototype);
+class uf extends Q {
     constructor(t, n = !1) {
-        var i, r, s;
-        if (super(F.Map), this.children = [t], this.keysSorted = n, t && (t.name = "entries", !((i = t == null ? void 0 : t.type) === null || i === void 0) && i.children)) {
-            const o = (r = t == null ? void 0 : t.type) === null || r === void 0 ? void 0 : r.children[0];
+        var r, i, s;
+        if (super(L.Map), this.children = [t], this.keysSorted = n, t && (t.name = "entries", !((r = t == null ? void 0 : t.type) === null || r === void 0) && r.children)) {
+            const o = (i = t == null ? void 0 : t.type) === null || i === void 0 ? void 0 : i.children[0];
             o && (o.name = "key");
             const a = (s = t == null ? void 0 : t.type) === null || s === void 0 ? void 0 : s.children[1];
             a && (a.name = "value");
         }
     }
     get keyType() {
         return this.children[0].type.children[0].type;
@@ -2986,69 +2994,69 @@
     }
     get childType() {
         return this.children[0].type;
     }
     toString() {
         return `Map<{${this.children[0].type.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
     }
-};
-fA = Symbol.toStringTag;
-Ed[fA] = ((e) => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))(Ed.prototype);
-const KC = /* @__PURE__ */ ((e) => () => ++e)(-1);
-let Ic = class extends gt {
-    constructor(t, n, i, r) {
-        super(F.Dictionary), this.indices = n, this.dictionary = t, this.isOrdered = r || !1, this.id = i == null ? KC() : pn(i);
+}
+e_ = Symbol.toStringTag;
+uf[e_] = ((e) => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))(uf.prototype);
+const tD = /* @__PURE__ */ ((e) => () => ++e)(-1);
+class Co extends Q {
+    constructor(t, n, r, i) {
+        super(L.Dictionary), this.indices = n, this.dictionary = t, this.isOrdered = i || !1, this.id = r == null ? tD() : Pe(r);
     }
     get children() {
         return this.dictionary.children;
     }
     get valueType() {
         return this.dictionary;
     }
     get ArrayType() {
         return this.dictionary.ArrayType;
     }
     toString() {
         return `Dictionary<${this.indices}, ${this.dictionary}>`;
     }
-};
-hA = Symbol.toStringTag;
-Ic[hA] = ((e) => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Ic.prototype);
+}
+n_ = Symbol.toStringTag;
+Co[n_] = ((e) => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Co.prototype);
 
-function Cr(e) {
+function Ur(e) {
     const t = e;
     switch (e.typeId) {
-        case F.Decimal:
+        case L.Decimal:
             return e.bitWidth / 32;
-        case F.Timestamp:
+        case L.Timestamp:
             return 2;
-        case F.Date:
+        case L.Date:
             return 1 + t.unit;
-        case F.Interval:
+        case L.Interval:
             return 1 + t.unit;
-        case F.FixedSizeList:
+        case L.FixedSizeList:
             return t.listSize;
-        case F.FixedSizeBinary:
+        case L.FixedSizeBinary:
             return t.byteWidth;
         default:
             return 1;
     }
 }
-let Ut = class {
+class At {
     visitMany(t, ...n) {
-        return t.map((i, r) => this.visit(i, ...n.map((s) => s[r])));
+        return t.map((r, i) => this.visit(r, ...n.map((s) => s[i])));
     }
     visit(...t) {
         return this.getVisitFn(t[0], !1).apply(this, t);
     }
     getVisitFn(t, n = !0) {
-        return ZC(this, t, n);
+        return eD(this, t, n);
     }
     getVisitFnByTypeId(t, n = !0) {
-        return Ua(this, t, n);
+        return fo(this, t, n);
     }
     visitNull(t, ...n) {
         return null;
     }
     visitBool(t, ...n) {
         return null;
     }
@@ -3105,1651 +3113,1651 @@
     }
     visitFixedSizeList(t, ...n) {
         return null;
     }
     visitMap(t, ...n) {
         return null;
     }
-};
+}
 
-function ZC(e, t, n = !0) {
-    return typeof t == "number" ? Ua(e, t, n) : typeof t == "string" && t in F ? Ua(e, F[t], n) : t && t instanceof gt ? Ua(e, U_(t), n) : t != null && t.type && t.type instanceof gt ? Ua(e, U_(t.type), n) : Ua(e, F.NONE, n);
+function eD(e, t, n = !0) {
+    return typeof t == "number" ? fo(e, t, n) : typeof t == "string" && t in L ? fo(e, L[t], n) : t && t instanceof Q ? fo(e, tb(t), n) : t != null && t.type && t.type instanceof Q ? fo(e, tb(t.type), n) : fo(e, L.NONE, n);
 }
 
-function Ua(e, t, n = !0) {
-    let i = null;
+function fo(e, t, n = !0) {
+    let r = null;
     switch (t) {
-        case F.Null:
-            i = e.visitNull;
+        case L.Null:
+            r = e.visitNull;
             break;
-        case F.Bool:
-            i = e.visitBool;
+        case L.Bool:
+            r = e.visitBool;
             break;
-        case F.Int:
-            i = e.visitInt;
+        case L.Int:
+            r = e.visitInt;
             break;
-        case F.Int8:
-            i = e.visitInt8 || e.visitInt;
+        case L.Int8:
+            r = e.visitInt8 || e.visitInt;
             break;
-        case F.Int16:
-            i = e.visitInt16 || e.visitInt;
+        case L.Int16:
+            r = e.visitInt16 || e.visitInt;
             break;
-        case F.Int32:
-            i = e.visitInt32 || e.visitInt;
+        case L.Int32:
+            r = e.visitInt32 || e.visitInt;
             break;
-        case F.Int64:
-            i = e.visitInt64 || e.visitInt;
+        case L.Int64:
+            r = e.visitInt64 || e.visitInt;
             break;
-        case F.Uint8:
-            i = e.visitUint8 || e.visitInt;
+        case L.Uint8:
+            r = e.visitUint8 || e.visitInt;
             break;
-        case F.Uint16:
-            i = e.visitUint16 || e.visitInt;
+        case L.Uint16:
+            r = e.visitUint16 || e.visitInt;
             break;
-        case F.Uint32:
-            i = e.visitUint32 || e.visitInt;
+        case L.Uint32:
+            r = e.visitUint32 || e.visitInt;
             break;
-        case F.Uint64:
-            i = e.visitUint64 || e.visitInt;
+        case L.Uint64:
+            r = e.visitUint64 || e.visitInt;
             break;
-        case F.Float:
-            i = e.visitFloat;
+        case L.Float:
+            r = e.visitFloat;
             break;
-        case F.Float16:
-            i = e.visitFloat16 || e.visitFloat;
+        case L.Float16:
+            r = e.visitFloat16 || e.visitFloat;
             break;
-        case F.Float32:
-            i = e.visitFloat32 || e.visitFloat;
+        case L.Float32:
+            r = e.visitFloat32 || e.visitFloat;
             break;
-        case F.Float64:
-            i = e.visitFloat64 || e.visitFloat;
+        case L.Float64:
+            r = e.visitFloat64 || e.visitFloat;
             break;
-        case F.Utf8:
-            i = e.visitUtf8;
+        case L.Utf8:
+            r = e.visitUtf8;
             break;
-        case F.LargeUtf8:
-            i = e.visitLargeUtf8;
+        case L.LargeUtf8:
+            r = e.visitLargeUtf8;
             break;
-        case F.Binary:
-            i = e.visitBinary;
+        case L.Binary:
+            r = e.visitBinary;
             break;
-        case F.LargeBinary:
-            i = e.visitLargeBinary;
+        case L.LargeBinary:
+            r = e.visitLargeBinary;
             break;
-        case F.FixedSizeBinary:
-            i = e.visitFixedSizeBinary;
+        case L.FixedSizeBinary:
+            r = e.visitFixedSizeBinary;
             break;
-        case F.Date:
-            i = e.visitDate;
+        case L.Date:
+            r = e.visitDate;
             break;
-        case F.DateDay:
-            i = e.visitDateDay || e.visitDate;
+        case L.DateDay:
+            r = e.visitDateDay || e.visitDate;
             break;
-        case F.DateMillisecond:
-            i = e.visitDateMillisecond || e.visitDate;
+        case L.DateMillisecond:
+            r = e.visitDateMillisecond || e.visitDate;
             break;
-        case F.Timestamp:
-            i = e.visitTimestamp;
+        case L.Timestamp:
+            r = e.visitTimestamp;
             break;
-        case F.TimestampSecond:
-            i = e.visitTimestampSecond || e.visitTimestamp;
+        case L.TimestampSecond:
+            r = e.visitTimestampSecond || e.visitTimestamp;
             break;
-        case F.TimestampMillisecond:
-            i = e.visitTimestampMillisecond || e.visitTimestamp;
+        case L.TimestampMillisecond:
+            r = e.visitTimestampMillisecond || e.visitTimestamp;
             break;
-        case F.TimestampMicrosecond:
-            i = e.visitTimestampMicrosecond || e.visitTimestamp;
+        case L.TimestampMicrosecond:
+            r = e.visitTimestampMicrosecond || e.visitTimestamp;
             break;
-        case F.TimestampNanosecond:
-            i = e.visitTimestampNanosecond || e.visitTimestamp;
+        case L.TimestampNanosecond:
+            r = e.visitTimestampNanosecond || e.visitTimestamp;
             break;
-        case F.Time:
-            i = e.visitTime;
+        case L.Time:
+            r = e.visitTime;
             break;
-        case F.TimeSecond:
-            i = e.visitTimeSecond || e.visitTime;
+        case L.TimeSecond:
+            r = e.visitTimeSecond || e.visitTime;
             break;
-        case F.TimeMillisecond:
-            i = e.visitTimeMillisecond || e.visitTime;
+        case L.TimeMillisecond:
+            r = e.visitTimeMillisecond || e.visitTime;
             break;
-        case F.TimeMicrosecond:
-            i = e.visitTimeMicrosecond || e.visitTime;
+        case L.TimeMicrosecond:
+            r = e.visitTimeMicrosecond || e.visitTime;
             break;
-        case F.TimeNanosecond:
-            i = e.visitTimeNanosecond || e.visitTime;
+        case L.TimeNanosecond:
+            r = e.visitTimeNanosecond || e.visitTime;
             break;
-        case F.Decimal:
-            i = e.visitDecimal;
+        case L.Decimal:
+            r = e.visitDecimal;
             break;
-        case F.List:
-            i = e.visitList;
+        case L.List:
+            r = e.visitList;
             break;
-        case F.Struct:
-            i = e.visitStruct;
+        case L.Struct:
+            r = e.visitStruct;
             break;
-        case F.Union:
-            i = e.visitUnion;
+        case L.Union:
+            r = e.visitUnion;
             break;
-        case F.DenseUnion:
-            i = e.visitDenseUnion || e.visitUnion;
+        case L.DenseUnion:
+            r = e.visitDenseUnion || e.visitUnion;
             break;
-        case F.SparseUnion:
-            i = e.visitSparseUnion || e.visitUnion;
+        case L.SparseUnion:
+            r = e.visitSparseUnion || e.visitUnion;
             break;
-        case F.Dictionary:
-            i = e.visitDictionary;
+        case L.Dictionary:
+            r = e.visitDictionary;
             break;
-        case F.Interval:
-            i = e.visitInterval;
+        case L.Interval:
+            r = e.visitInterval;
             break;
-        case F.IntervalDayTime:
-            i = e.visitIntervalDayTime || e.visitInterval;
+        case L.IntervalDayTime:
+            r = e.visitIntervalDayTime || e.visitInterval;
             break;
-        case F.IntervalYearMonth:
-            i = e.visitIntervalYearMonth || e.visitInterval;
+        case L.IntervalYearMonth:
+            r = e.visitIntervalYearMonth || e.visitInterval;
             break;
-        case F.Duration:
-            i = e.visitDuration;
+        case L.Duration:
+            r = e.visitDuration;
             break;
-        case F.DurationSecond:
-            i = e.visitDurationSecond || e.visitDuration;
+        case L.DurationSecond:
+            r = e.visitDurationSecond || e.visitDuration;
             break;
-        case F.DurationMillisecond:
-            i = e.visitDurationMillisecond || e.visitDuration;
+        case L.DurationMillisecond:
+            r = e.visitDurationMillisecond || e.visitDuration;
             break;
-        case F.DurationMicrosecond:
-            i = e.visitDurationMicrosecond || e.visitDuration;
+        case L.DurationMicrosecond:
+            r = e.visitDurationMicrosecond || e.visitDuration;
             break;
-        case F.DurationNanosecond:
-            i = e.visitDurationNanosecond || e.visitDuration;
+        case L.DurationNanosecond:
+            r = e.visitDurationNanosecond || e.visitDuration;
             break;
-        case F.FixedSizeList:
-            i = e.visitFixedSizeList;
+        case L.FixedSizeList:
+            r = e.visitFixedSizeList;
             break;
-        case F.Map:
-            i = e.visitMap;
+        case L.Map:
+            r = e.visitMap;
             break;
     }
-    if (typeof i == "function")
-        return i;
+    if (typeof r == "function")
+        return r;
     if (!n)
         return () => null;
-    throw new Error(`Unrecognized type '${F[t]}'`);
+    throw new Error(`Unrecognized type '${L[t]}'`);
 }
 
-function U_(e) {
+function tb(e) {
     switch (e.typeId) {
-        case F.Null:
-            return F.Null;
-        case F.Int: {
+        case L.Null:
+            return L.Null;
+        case L.Int: {
             const {
                 bitWidth: t,
                 isSigned: n
             } = e;
             switch (t) {
                 case 8:
-                    return n ? F.Int8 : F.Uint8;
+                    return n ? L.Int8 : L.Uint8;
                 case 16:
-                    return n ? F.Int16 : F.Uint16;
+                    return n ? L.Int16 : L.Uint16;
                 case 32:
-                    return n ? F.Int32 : F.Uint32;
+                    return n ? L.Int32 : L.Uint32;
                 case 64:
-                    return n ? F.Int64 : F.Uint64;
+                    return n ? L.Int64 : L.Uint64;
             }
-            return F.Int;
+            return L.Int;
         }
-        case F.Float:
+        case L.Float:
             switch (e.precision) {
-                case nn.HALF:
-                    return F.Float16;
-                case nn.SINGLE:
-                    return F.Float32;
-                case nn.DOUBLE:
-                    return F.Float64;
-            }
-            return F.Float;
-        case F.Binary:
-            return F.Binary;
-        case F.LargeBinary:
-            return F.LargeBinary;
-        case F.Utf8:
-            return F.Utf8;
-        case F.LargeUtf8:
-            return F.LargeUtf8;
-        case F.Bool:
-            return F.Bool;
-        case F.Decimal:
-            return F.Decimal;
-        case F.Time:
+                case De.HALF:
+                    return L.Float16;
+                case De.SINGLE:
+                    return L.Float32;
+                case De.DOUBLE:
+                    return L.Float64;
+            }
+            return L.Float;
+        case L.Binary:
+            return L.Binary;
+        case L.LargeBinary:
+            return L.LargeBinary;
+        case L.Utf8:
+            return L.Utf8;
+        case L.LargeUtf8:
+            return L.LargeUtf8;
+        case L.Bool:
+            return L.Bool;
+        case L.Decimal:
+            return L.Decimal;
+        case L.Time:
             switch (e.unit) {
-                case mt.SECOND:
-                    return F.TimeSecond;
-                case mt.MILLISECOND:
-                    return F.TimeMillisecond;
-                case mt.MICROSECOND:
-                    return F.TimeMicrosecond;
-                case mt.NANOSECOND:
-                    return F.TimeNanosecond;
+                case ct.SECOND:
+                    return L.TimeSecond;
+                case ct.MILLISECOND:
+                    return L.TimeMillisecond;
+                case ct.MICROSECOND:
+                    return L.TimeMicrosecond;
+                case ct.NANOSECOND:
+                    return L.TimeNanosecond;
             }
-            return F.Time;
-        case F.Timestamp:
+            return L.Time;
+        case L.Timestamp:
             switch (e.unit) {
-                case mt.SECOND:
-                    return F.TimestampSecond;
-                case mt.MILLISECOND:
-                    return F.TimestampMillisecond;
-                case mt.MICROSECOND:
-                    return F.TimestampMicrosecond;
-                case mt.NANOSECOND:
-                    return F.TimestampNanosecond;
+                case ct.SECOND:
+                    return L.TimestampSecond;
+                case ct.MILLISECOND:
+                    return L.TimestampMillisecond;
+                case ct.MICROSECOND:
+                    return L.TimestampMicrosecond;
+                case ct.NANOSECOND:
+                    return L.TimestampNanosecond;
             }
-            return F.Timestamp;
-        case F.Date:
+            return L.Timestamp;
+        case L.Date:
             switch (e.unit) {
-                case Ii.DAY:
-                    return F.DateDay;
-                case Ii.MILLISECOND:
-                    return F.DateMillisecond;
+                case Pn.DAY:
+                    return L.DateDay;
+                case Pn.MILLISECOND:
+                    return L.DateMillisecond;
             }
-            return F.Date;
-        case F.Interval:
+            return L.Date;
+        case L.Interval:
             switch (e.unit) {
-                case lr.DAY_TIME:
-                    return F.IntervalDayTime;
-                case lr.YEAR_MONTH:
-                    return F.IntervalYearMonth;
+                case br.DAY_TIME:
+                    return L.IntervalDayTime;
+                case br.YEAR_MONTH:
+                    return L.IntervalYearMonth;
             }
-            return F.Interval;
-        case F.Duration:
+            return L.Interval;
+        case L.Duration:
             switch (e.unit) {
-                case mt.SECOND:
-                    return F.DurationSecond;
-                case mt.MILLISECOND:
-                    return F.DurationMillisecond;
-                case mt.MICROSECOND:
-                    return F.DurationMicrosecond;
-                case mt.NANOSECOND:
-                    return F.DurationNanosecond;
-            }
-            return F.Duration;
-        case F.Map:
-            return F.Map;
-        case F.List:
-            return F.List;
-        case F.Struct:
-            return F.Struct;
-        case F.Union:
+                case ct.SECOND:
+                    return L.DurationSecond;
+                case ct.MILLISECOND:
+                    return L.DurationMillisecond;
+                case ct.MICROSECOND:
+                    return L.DurationMicrosecond;
+                case ct.NANOSECOND:
+                    return L.DurationNanosecond;
+            }
+            return L.Duration;
+        case L.Map:
+            return L.Map;
+        case L.List:
+            return L.List;
+        case L.Struct:
+            return L.Struct;
+        case L.Union:
             switch (e.mode) {
-                case Mn.Dense:
-                    return F.DenseUnion;
-                case Mn.Sparse:
-                    return F.SparseUnion;
-            }
-            return F.Union;
-        case F.FixedSizeBinary:
-            return F.FixedSizeBinary;
-        case F.FixedSizeList:
-            return F.FixedSizeList;
-        case F.Dictionary:
-            return F.Dictionary;
-    }
-    throw new Error(`Unrecognized type '${F[e.typeId]}'`);
-}
-Ut.prototype.visitInt8 = null;
-Ut.prototype.visitInt16 = null;
-Ut.prototype.visitInt32 = null;
-Ut.prototype.visitInt64 = null;
-Ut.prototype.visitUint8 = null;
-Ut.prototype.visitUint16 = null;
-Ut.prototype.visitUint32 = null;
-Ut.prototype.visitUint64 = null;
-Ut.prototype.visitFloat16 = null;
-Ut.prototype.visitFloat32 = null;
-Ut.prototype.visitFloat64 = null;
-Ut.prototype.visitDateDay = null;
-Ut.prototype.visitDateMillisecond = null;
-Ut.prototype.visitTimestampSecond = null;
-Ut.prototype.visitTimestampMillisecond = null;
-Ut.prototype.visitTimestampMicrosecond = null;
-Ut.prototype.visitTimestampNanosecond = null;
-Ut.prototype.visitTimeSecond = null;
-Ut.prototype.visitTimeMillisecond = null;
-Ut.prototype.visitTimeMicrosecond = null;
-Ut.prototype.visitTimeNanosecond = null;
-Ut.prototype.visitDenseUnion = null;
-Ut.prototype.visitSparseUnion = null;
-Ut.prototype.visitIntervalDayTime = null;
-Ut.prototype.visitIntervalYearMonth = null;
-Ut.prototype.visitDuration = null;
-Ut.prototype.visitDurationSecond = null;
-Ut.prototype.visitDurationMillisecond = null;
-Ut.prototype.visitDurationMicrosecond = null;
-Ut.prototype.visitDurationNanosecond = null;
-const dA = new Float64Array(1),
-    ma = new Uint32Array(dA.buffer);
+                case Je.Dense:
+                    return L.DenseUnion;
+                case Je.Sparse:
+                    return L.SparseUnion;
+            }
+            return L.Union;
+        case L.FixedSizeBinary:
+            return L.FixedSizeBinary;
+        case L.FixedSizeList:
+            return L.FixedSizeList;
+        case L.Dictionary:
+            return L.Dictionary;
+    }
+    throw new Error(`Unrecognized type '${L[e.typeId]}'`);
+}
+At.prototype.visitInt8 = null;
+At.prototype.visitInt16 = null;
+At.prototype.visitInt32 = null;
+At.prototype.visitInt64 = null;
+At.prototype.visitUint8 = null;
+At.prototype.visitUint16 = null;
+At.prototype.visitUint32 = null;
+At.prototype.visitUint64 = null;
+At.prototype.visitFloat16 = null;
+At.prototype.visitFloat32 = null;
+At.prototype.visitFloat64 = null;
+At.prototype.visitDateDay = null;
+At.prototype.visitDateMillisecond = null;
+At.prototype.visitTimestampSecond = null;
+At.prototype.visitTimestampMillisecond = null;
+At.prototype.visitTimestampMicrosecond = null;
+At.prototype.visitTimestampNanosecond = null;
+At.prototype.visitTimeSecond = null;
+At.prototype.visitTimeMillisecond = null;
+At.prototype.visitTimeMicrosecond = null;
+At.prototype.visitTimeNanosecond = null;
+At.prototype.visitDenseUnion = null;
+At.prototype.visitSparseUnion = null;
+At.prototype.visitIntervalDayTime = null;
+At.prototype.visitIntervalYearMonth = null;
+At.prototype.visitDuration = null;
+At.prototype.visitDurationSecond = null;
+At.prototype.visitDurationMillisecond = null;
+At.prototype.visitDurationMicrosecond = null;
+At.prototype.visitDurationNanosecond = null;
+const r_ = new Float64Array(1),
+    Ws = new Uint32Array(r_.buffer);
 
-function pA(e) {
+function i_(e) {
     const t = (e & 31744) >> 10,
         n = (e & 1023) / 1024,
-        i = Math.pow(-1, (e & 32768) >> 15);
+        r = Math.pow(-1, (e & 32768) >> 15);
     switch (t) {
         case 31:
-            return i * (n ? Number.NaN : 1 / 0);
+            return r * (n ? Number.NaN : 1 / 0);
         case 0:
-            return i * (n ? 6103515625e-14 * n : 0);
+            return r * (n ? 6103515625e-14 * n : 0);
     }
-    return i * Math.pow(2, t - 15) * (1 + n);
+    return r * Math.pow(2, t - 15) * (1 + n);
 }
 
-function QC(e) {
+function nD(e) {
     if (e !== e)
         return 32256;
-    dA[0] = e;
-    const t = (ma[1] & 2147483648) >> 16 & 65535;
-    let n = ma[1] & 2146435072,
-        i = 0;
-    return n >= 1089470464 ? ma[0] > 0 ? n = 31744 : (n = (n & 2080374784) >> 16, i = (ma[1] & 1048575) >> 10) : n <= 1056964608 ? (i = 1048576 + (ma[1] & 1048575), i = 1048576 + (i << (n >> 20) - 998) >> 21, n = 0) : (n = n - 1056964608 >> 10, i = (ma[1] & 1048575) + 512 >> 10), t | n | i & 65535;
+    r_[0] = e;
+    const t = (Ws[1] & 2147483648) >> 16 & 65535;
+    let n = Ws[1] & 2146435072,
+        r = 0;
+    return n >= 1089470464 ? Ws[0] > 0 ? n = 31744 : (n = (n & 2080374784) >> 16, r = (Ws[1] & 1048575) >> 10) : n <= 1056964608 ? (r = 1048576 + (Ws[1] & 1048575), r = 1048576 + (r << (n >> 20) - 998) >> 21, n = 0) : (n = n - 1056964608 >> 10, r = (Ws[1] & 1048575) + 512 >> 10), t | n | r & 65535;
 }
-let vt = class extends Ut {};
+class lt extends At {}
 
-function Dt(e) {
-    return (t, n, i) => {
-        if (t.setValid(n, i != null))
-            return e(t, n, i);
+function mt(e) {
+    return (t, n, r) => {
+        if (t.setValid(n, r != null))
+            return e(t, n, r);
     };
 }
-const tk = (e, t, n) => {
+const rD = (e, t, n) => {
         e[t] = Math.trunc(n / 864e5);
     },
-    yb = (e, t, n) => {
+    Gy = (e, t, n) => {
         e[t] = Math.trunc(n % 4294967296), e[t + 1] = Math.trunc(n / 4294967296);
     },
-    ek = (e, t, n) => {
+    iD = (e, t, n) => {
         e[t] = Math.trunc(n * 1e3 % 4294967296), e[t + 1] = Math.trunc(n * 1e3 / 4294967296);
     },
-    nk = (e, t, n) => {
+    sD = (e, t, n) => {
         e[t] = Math.trunc(n * 1e6 % 4294967296), e[t + 1] = Math.trunc(n * 1e6 / 4294967296);
     },
-    yA = (e, t, n, i) => {
+    s_ = (e, t, n, r) => {
         if (n + 1 < t.length) {
-            const r = pn(t[n]),
-                s = pn(t[n + 1]);
-            e.set(i.subarray(0, s - r), r);
+            const i = Pe(t[n]),
+                s = Pe(t[n + 1]);
+            e.set(r.subarray(0, s - i), i);
         }
     },
-    ik = ({
+    oD = ({
         offset: e,
         values: t
-    }, n, i) => {
-        const r = e + n;
-        i ? t[r >> 3] |= 1 << r % 8 : t[r >> 3] &= ~(1 << r % 8);
+    }, n, r) => {
+        const i = e + n;
+        r ? t[i >> 3] |= 1 << i % 8 : t[i >> 3] &= ~(1 << i % 8);
     },
-    as = ({
+    si = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    mb = ({
+    Hy = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    mA = ({
+    o_ = ({
         values: e
     }, t, n) => {
-        e[t] = QC(n);
+        e[t] = nD(n);
     },
-    rk = (e, t, n) => {
+    aD = (e, t, n) => {
         switch (e.type.precision) {
-            case nn.HALF:
-                return mA(e, t, n);
-            case nn.SINGLE:
-            case nn.DOUBLE:
-                return mb(e, t, n);
+            case De.HALF:
+                return o_(e, t, n);
+            case De.SINGLE:
+            case De.DOUBLE:
+                return Hy(e, t, n);
         }
     },
-    gA = ({
+    a_ = ({
         values: e
     }, t, n) => {
-        tk(e, t, n.valueOf());
+        rD(e, t, n.valueOf());
     },
-    bA = ({
+    c_ = ({
         values: e
     }, t, n) => {
-        yb(e, t * 2, n.valueOf());
+        Gy(e, t * 2, n.valueOf());
     },
-    sk = ({
+    cD = ({
         stride: e,
         values: t
-    }, n, i) => {
-        t.set(i.subarray(0, e), e * n);
+    }, n, r) => {
+        t.set(r.subarray(0, e), e * n);
     },
-    wA = ({
+    u_ = ({
         values: e,
         valueOffsets: t
-    }, n, i) => yA(e, t, n, i),
-    vA = ({
+    }, n, r) => s_(e, t, n, r),
+    l_ = ({
         values: e,
         valueOffsets: t
-    }, n, i) => yA(e, t, n, fb(i)),
-    ok = (e, t, n) => {
-        e.type.unit === Ii.DAY ? gA(e, t, n) : bA(e, t, n);
+    }, n, r) => s_(e, t, n, jy(r)),
+    uD = (e, t, n) => {
+        e.type.unit === Pn.DAY ? a_(e, t, n) : c_(e, t, n);
     },
-    _A = ({
+    f_ = ({
         values: e
-    }, t, n) => yb(e, t * 2, n / 1e3),
-    xA = ({
+    }, t, n) => Gy(e, t * 2, n / 1e3),
+    h_ = ({
         values: e
-    }, t, n) => yb(e, t * 2, n),
-    SA = ({
+    }, t, n) => Gy(e, t * 2, n),
+    d_ = ({
         values: e
-    }, t, n) => ek(e, t * 2, n),
-    IA = ({
+    }, t, n) => iD(e, t * 2, n),
+    p_ = ({
         values: e
-    }, t, n) => nk(e, t * 2, n),
-    ak = (e, t, n) => {
+    }, t, n) => sD(e, t * 2, n),
+    lD = (e, t, n) => {
         switch (e.type.unit) {
-            case mt.SECOND:
-                return _A(e, t, n);
-            case mt.MILLISECOND:
-                return xA(e, t, n);
-            case mt.MICROSECOND:
-                return SA(e, t, n);
-            case mt.NANOSECOND:
-                return IA(e, t, n);
+            case ct.SECOND:
+                return f_(e, t, n);
+            case ct.MILLISECOND:
+                return h_(e, t, n);
+            case ct.MICROSECOND:
+                return d_(e, t, n);
+            case ct.NANOSECOND:
+                return p_(e, t, n);
         }
     },
-    AA = ({
+    y_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    MA = ({
+    m_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    $A = ({
+    g_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    TA = ({
+    b_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    ck = (e, t, n) => {
+    fD = (e, t, n) => {
         switch (e.type.unit) {
-            case mt.SECOND:
-                return AA(e, t, n);
-            case mt.MILLISECOND:
-                return MA(e, t, n);
-            case mt.MICROSECOND:
-                return $A(e, t, n);
-            case mt.NANOSECOND:
-                return TA(e, t, n);
+            case ct.SECOND:
+                return y_(e, t, n);
+            case ct.MILLISECOND:
+                return m_(e, t, n);
+            case ct.MICROSECOND:
+                return g_(e, t, n);
+            case ct.NANOSECOND:
+                return b_(e, t, n);
         }
     },
-    lk = ({
+    hD = ({
         values: e,
         stride: t
-    }, n, i) => {
-        e.set(i.subarray(0, t), t * n);
+    }, n, r) => {
+        e.set(r.subarray(0, t), t * n);
     },
-    uk = (e, t, n) => {
-        const i = e.children[0],
-            r = e.valueOffsets,
-            s = ci.getVisitFn(i);
+    dD = (e, t, n) => {
+        const r = e.children[0],
+            i = e.valueOffsets,
+            s = An.getVisitFn(r);
         if (Array.isArray(n))
-            for (let o = -1, a = r[t], c = r[t + 1]; a < c;)
-                s(i, a++, n[++o]);
+            for (let o = -1, a = i[t], c = i[t + 1]; a < c;)
+                s(r, a++, n[++o]);
         else
-            for (let o = -1, a = r[t], c = r[t + 1]; a < c;)
-                s(i, a++, n.get(++o));
+            for (let o = -1, a = i[t], c = i[t + 1]; a < c;)
+                s(r, a++, n.get(++o));
     },
-    fk = (e, t, n) => {
-        const i = e.children[0],
+    pD = (e, t, n) => {
+        const r = e.children[0],
             {
-                valueOffsets: r
+                valueOffsets: i
             } = e,
-            s = ci.getVisitFn(i);
+            s = An.getVisitFn(r);
         let {
             [t]: o, [t + 1]: a
-        } = r;
+        } = i;
         const c = n instanceof Map ? n.entries() : Object.entries(n);
-        for (const l of c)
-            if (s(i, o, l), ++o >= a)
+        for (const u of c)
+            if (s(r, o, u), ++o >= a)
                 break;
     },
-    hk = (e, t) => (n, i, r, s) => i && n(i, e, t[s]),
-    dk = (e, t) => (n, i, r, s) => i && n(i, e, t.get(s)),
-    pk = (e, t) => (n, i, r, s) => i && n(i, e, t.get(r.name)),
-    yk = (e, t) => (n, i, r, s) => i && n(i, e, t[r.name]),
-    mk = (e, t, n) => {
-        const i = e.type.children.map((s) => ci.getVisitFn(s.type)),
-            r = n instanceof Map ? pk(t, n) : n instanceof Ne ? dk(t, n) : Array.isArray(n) ? hk(t, n) : yk(t, n);
-        e.type.children.forEach((s, o) => r(i[o], e.children[o], s, o));
-    },
-    gk = (e, t, n) => {
-        e.type.mode === Mn.Dense ? DA(e, t, n) : NA(e, t, n);
-    },
-    DA = (e, t, n) => {
-        const i = e.type.typeIdToChildIndex[e.typeIds[t]],
-            r = e.children[i];
-        ci.visit(r, e.valueOffsets[t], n);
-    },
-    NA = (e, t, n) => {
-        const i = e.type.typeIdToChildIndex[e.typeIds[t]],
-            r = e.children[i];
-        ci.visit(r, t, n);
+    yD = (e, t) => (n, r, i, s) => r && n(r, e, t[s]),
+    mD = (e, t) => (n, r, i, s) => r && n(r, e, t.get(s)),
+    gD = (e, t) => (n, r, i, s) => r && n(r, e, t.get(i.name)),
+    bD = (e, t) => (n, r, i, s) => r && n(r, e, t[i.name]),
+    wD = (e, t, n) => {
+        const r = e.type.children.map((s) => An.getVisitFn(s.type)),
+            i = n instanceof Map ? gD(t, n) : n instanceof ce ? mD(t, n) : Array.isArray(n) ? yD(t, n) : bD(t, n);
+        e.type.children.forEach((s, o) => i(r[o], e.children[o], s, o));
+    },
+    vD = (e, t, n) => {
+        e.type.mode === Je.Dense ? w_(e, t, n) : v_(e, t, n);
+    },
+    w_ = (e, t, n) => {
+        const r = e.type.typeIdToChildIndex[e.typeIds[t]],
+            i = e.children[r];
+        An.visit(i, e.valueOffsets[t], n);
+    },
+    v_ = (e, t, n) => {
+        const r = e.type.typeIdToChildIndex[e.typeIds[t]],
+            i = e.children[r];
+        An.visit(i, t, n);
     },
-    bk = (e, t, n) => {
-        var i;
-        (i = e.dictionary) === null || i === void 0 || i.set(e.values[t], n);
+    _D = (e, t, n) => {
+        var r;
+        (r = e.dictionary) === null || r === void 0 || r.set(e.values[t], n);
     },
-    wk = (e, t, n) => {
-        e.type.unit === lr.DAY_TIME ? BA(e, t, n) : OA(e, t, n);
+    xD = (e, t, n) => {
+        e.type.unit === br.DAY_TIME ? __(e, t, n) : x_(e, t, n);
     },
-    BA = ({
+    __ = ({
         values: e
     }, t, n) => {
         e.set(n.subarray(0, 2), 2 * t);
     },
-    OA = ({
+    x_ = ({
         values: e
     }, t, n) => {
         e[t] = n[0] * 12 + n[1] % 12;
     },
-    FA = ({
+    S_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    EA = ({
+    M_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    LA = ({
+    A_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    RA = ({
+    $_ = ({
         values: e
     }, t, n) => {
         e[t] = n;
     },
-    vk = (e, t, n) => {
+    SD = (e, t, n) => {
         switch (e.type.unit) {
-            case mt.SECOND:
-                return FA(e, t, n);
-            case mt.MILLISECOND:
-                return EA(e, t, n);
-            case mt.MICROSECOND:
-                return LA(e, t, n);
-            case mt.NANOSECOND:
-                return RA(e, t, n);
+            case ct.SECOND:
+                return S_(e, t, n);
+            case ct.MILLISECOND:
+                return M_(e, t, n);
+            case ct.MICROSECOND:
+                return A_(e, t, n);
+            case ct.NANOSECOND:
+                return $_(e, t, n);
         }
     },
-    _k = (e, t, n) => {
+    MD = (e, t, n) => {
         const {
-            stride: i
-        } = e, r = e.children[0], s = ci.getVisitFn(r);
+            stride: r
+        } = e, i = e.children[0], s = An.getVisitFn(i);
         if (Array.isArray(n))
-            for (let o = -1, a = t * i; ++o < i;)
-                s(r, a + o, n[o]);
+            for (let o = -1, a = t * r; ++o < r;)
+                s(i, a + o, n[o]);
         else
-            for (let o = -1, a = t * i; ++o < i;)
-                s(r, a + o, n.get(o));
+            for (let o = -1, a = t * r; ++o < r;)
+                s(i, a + o, n.get(o));
     };
-vt.prototype.visitBool = Dt(ik);
-vt.prototype.visitInt = Dt(as);
-vt.prototype.visitInt8 = Dt(as);
-vt.prototype.visitInt16 = Dt(as);
-vt.prototype.visitInt32 = Dt(as);
-vt.prototype.visitInt64 = Dt(as);
-vt.prototype.visitUint8 = Dt(as);
-vt.prototype.visitUint16 = Dt(as);
-vt.prototype.visitUint32 = Dt(as);
-vt.prototype.visitUint64 = Dt(as);
-vt.prototype.visitFloat = Dt(rk);
-vt.prototype.visitFloat16 = Dt(mA);
-vt.prototype.visitFloat32 = Dt(mb);
-vt.prototype.visitFloat64 = Dt(mb);
-vt.prototype.visitUtf8 = Dt(vA);
-vt.prototype.visitLargeUtf8 = Dt(vA);
-vt.prototype.visitBinary = Dt(wA);
-vt.prototype.visitLargeBinary = Dt(wA);
-vt.prototype.visitFixedSizeBinary = Dt(sk);
-vt.prototype.visitDate = Dt(ok);
-vt.prototype.visitDateDay = Dt(gA);
-vt.prototype.visitDateMillisecond = Dt(bA);
-vt.prototype.visitTimestamp = Dt(ak);
-vt.prototype.visitTimestampSecond = Dt(_A);
-vt.prototype.visitTimestampMillisecond = Dt(xA);
-vt.prototype.visitTimestampMicrosecond = Dt(SA);
-vt.prototype.visitTimestampNanosecond = Dt(IA);
-vt.prototype.visitTime = Dt(ck);
-vt.prototype.visitTimeSecond = Dt(AA);
-vt.prototype.visitTimeMillisecond = Dt(MA);
-vt.prototype.visitTimeMicrosecond = Dt($A);
-vt.prototype.visitTimeNanosecond = Dt(TA);
-vt.prototype.visitDecimal = Dt(lk);
-vt.prototype.visitList = Dt(uk);
-vt.prototype.visitStruct = Dt(mk);
-vt.prototype.visitUnion = Dt(gk);
-vt.prototype.visitDenseUnion = Dt(DA);
-vt.prototype.visitSparseUnion = Dt(NA);
-vt.prototype.visitDictionary = Dt(bk);
-vt.prototype.visitInterval = Dt(wk);
-vt.prototype.visitIntervalDayTime = Dt(BA);
-vt.prototype.visitIntervalYearMonth = Dt(OA);
-vt.prototype.visitDuration = Dt(vk);
-vt.prototype.visitDurationSecond = Dt(FA);
-vt.prototype.visitDurationMillisecond = Dt(EA);
-vt.prototype.visitDurationMicrosecond = Dt(LA);
-vt.prototype.visitDurationNanosecond = Dt(RA);
-vt.prototype.visitFixedSizeList = Dt(_k);
-vt.prototype.visitMap = Dt(fk);
-const ci = new vt(),
-    pi = Symbol.for("parent"),
-    cc = Symbol.for("rowIndex");
-let gb = class {
-        constructor(t, n) {
-            return this[pi] = t, this[cc] = n, new Proxy(this, new Sk());
-        }
-        toArray() {
-            return Object.values(this.toJSON());
-        }
-        toJSON() {
-            const t = this[cc],
-                n = this[pi],
-                i = n.type.children,
-                r = {};
-            for (let s = -1, o = i.length; ++s < o;)
-                r[i[s].name] = $n.visit(n.children[s], t);
-            return r;
+lt.prototype.visitBool = mt(oD);
+lt.prototype.visitInt = mt(si);
+lt.prototype.visitInt8 = mt(si);
+lt.prototype.visitInt16 = mt(si);
+lt.prototype.visitInt32 = mt(si);
+lt.prototype.visitInt64 = mt(si);
+lt.prototype.visitUint8 = mt(si);
+lt.prototype.visitUint16 = mt(si);
+lt.prototype.visitUint32 = mt(si);
+lt.prototype.visitUint64 = mt(si);
+lt.prototype.visitFloat = mt(aD);
+lt.prototype.visitFloat16 = mt(o_);
+lt.prototype.visitFloat32 = mt(Hy);
+lt.prototype.visitFloat64 = mt(Hy);
+lt.prototype.visitUtf8 = mt(l_);
+lt.prototype.visitLargeUtf8 = mt(l_);
+lt.prototype.visitBinary = mt(u_);
+lt.prototype.visitLargeBinary = mt(u_);
+lt.prototype.visitFixedSizeBinary = mt(cD);
+lt.prototype.visitDate = mt(uD);
+lt.prototype.visitDateDay = mt(a_);
+lt.prototype.visitDateMillisecond = mt(c_);
+lt.prototype.visitTimestamp = mt(lD);
+lt.prototype.visitTimestampSecond = mt(f_);
+lt.prototype.visitTimestampMillisecond = mt(h_);
+lt.prototype.visitTimestampMicrosecond = mt(d_);
+lt.prototype.visitTimestampNanosecond = mt(p_);
+lt.prototype.visitTime = mt(fD);
+lt.prototype.visitTimeSecond = mt(y_);
+lt.prototype.visitTimeMillisecond = mt(m_);
+lt.prototype.visitTimeMicrosecond = mt(g_);
+lt.prototype.visitTimeNanosecond = mt(b_);
+lt.prototype.visitDecimal = mt(hD);
+lt.prototype.visitList = mt(dD);
+lt.prototype.visitStruct = mt(wD);
+lt.prototype.visitUnion = mt(vD);
+lt.prototype.visitDenseUnion = mt(w_);
+lt.prototype.visitSparseUnion = mt(v_);
+lt.prototype.visitDictionary = mt(_D);
+lt.prototype.visitInterval = mt(xD);
+lt.prototype.visitIntervalDayTime = mt(__);
+lt.prototype.visitIntervalYearMonth = mt(x_);
+lt.prototype.visitDuration = mt(SD);
+lt.prototype.visitDurationSecond = mt(S_);
+lt.prototype.visitDurationMillisecond = mt(M_);
+lt.prototype.visitDurationMicrosecond = mt(A_);
+lt.prototype.visitDurationNanosecond = mt($_);
+lt.prototype.visitFixedSizeList = mt(MD);
+lt.prototype.visitMap = mt(pD);
+const An = new lt(),
+    Dn = Symbol.for("parent"),
+    Ao = Symbol.for("rowIndex");
+class Jy {
+    constructor(t, n) {
+        return this[Dn] = t, this[Ao] = n, new Proxy(this, new $D());
+    }
+    toArray() {
+        return Object.values(this.toJSON());
+    }
+    toJSON() {
+        const t = this[Ao],
+            n = this[Dn],
+            r = n.type.children,
+            i = {};
+        for (let s = -1, o = r.length; ++s < o;)
+            i[r[s].name] = Ze.visit(n.children[s], t);
+        return i;
+    }
+    toString() {
+            return `{${[...this].map(([t, n]) => `${mc(t)}: ${mc(n)}`).join(", ")}}`;
         }
-        toString() {
-                return `{${[...this].map(([t, n]) => `${_u(t)}: ${_u(n)}`).join(", ")}}`;
-            }
-            [Symbol.for("nodejs.util.inspect.custom")]() {
-                return this.toString();
-            }
-            [Symbol.iterator]() {
-                return new xk(this[pi], this[cc]);
-            }
-    },
-    xk = class {
-        constructor(t, n) {
-                this.childIndex = 0, this.children = t.children, this.rowIndex = n, this.childFields = t.type.children, this.numChildren = this.childFields.length;
-            }
-            [Symbol.iterator]() {
-                return this;
-            }
-        next() {
-            const t = this.childIndex;
-            return t < this.numChildren ? (this.childIndex = t + 1, {
-                done: !1,
-                value: [
-                    this.childFields[t].name,
-                    $n.visit(this.children[t], this.rowIndex)
-                ]
-            }) : {
-                done: !0,
-                value: null
-            };
+        [Symbol.for("nodejs.util.inspect.custom")]() {
+            return this.toString();
         }
-    };
-Object.defineProperties(gb.prototype, {
+        [Symbol.iterator]() {
+            return new AD(this[Dn], this[Ao]);
+        }
+}
+class AD {
+    constructor(t, n) {
+            this.childIndex = 0, this.children = t.children, this.rowIndex = n, this.childFields = t.type.children, this.numChildren = this.childFields.length;
+        }
+        [Symbol.iterator]() {
+            return this;
+        }
+    next() {
+        const t = this.childIndex;
+        return t < this.numChildren ? (this.childIndex = t + 1, {
+            done: !1,
+            value: [
+                this.childFields[t].name,
+                Ze.visit(this.children[t], this.rowIndex)
+            ]
+        }) : {
+            done: !0,
+            value: null
+        };
+    }
+}
+Object.defineProperties(Jy.prototype, {
     [Symbol.toStringTag]: {
         enumerable: !1,
         configurable: !1,
         value: "Row"
     },
-    [pi]: {
+    [Dn]: {
         writable: !0,
         enumerable: !1,
         configurable: !1,
         value: null
     },
-    [cc]: {
+    [Ao]: {
         writable: !0,
         enumerable: !1,
         configurable: !1,
         value: -1
     }
 });
-let Sk = class {
-        isExtensible() {
-            return !1;
-        }
-        deleteProperty() {
-            return !1;
-        }
-        preventExtensions() {
-            return !0;
-        }
-        ownKeys(t) {
-            return t[pi].type.children.map((n) => n.name);
-        }
-        has(t, n) {
-            return t[pi].type.children.findIndex((i) => i.name === n) !== -1;
-        }
-        getOwnPropertyDescriptor(t, n) {
-            if (t[pi].type.children.findIndex((i) => i.name === n) !== -1)
-                return {
-                    writable: !0,
-                    enumerable: !0,
-                    configurable: !0
-                };
-        }
-        get(t, n) {
-            if (Reflect.has(t, n))
-                return t[n];
-            const i = t[pi].type.children.findIndex((r) => r.name === n);
-            if (i !== -1) {
-                const r = $n.visit(t[pi].children[i], t[cc]);
-                return Reflect.set(t, n, r), r;
-            }
-        }
-        set(t, n, i) {
-            const r = t[pi].type.children.findIndex((s) => s.name === n);
-            return r !== -1 ? (ci.visit(t[pi].children[r], t[cc], i), Reflect.set(t, n, i)) : Reflect.has(t, n) || typeof n == "symbol" ? Reflect.set(t, n, i) : !1;
+class $D {
+    isExtensible() {
+        return !1;
+    }
+    deleteProperty() {
+        return !1;
+    }
+    preventExtensions() {
+        return !0;
+    }
+    ownKeys(t) {
+        return t[Dn].type.children.map((n) => n.name);
+    }
+    has(t, n) {
+        return t[Dn].type.children.findIndex((r) => r.name === n) !== -1;
+    }
+    getOwnPropertyDescriptor(t, n) {
+        if (t[Dn].type.children.findIndex((r) => r.name === n) !== -1)
+            return {
+                writable: !0,
+                enumerable: !0,
+                configurable: !0
+            };
+    }
+    get(t, n) {
+        if (Reflect.has(t, n))
+            return t[n];
+        const r = t[Dn].type.children.findIndex((i) => i.name === n);
+        if (r !== -1) {
+            const i = Ze.visit(t[Dn].children[r], t[Ao]);
+            return Reflect.set(t, n, i), i;
         }
-    },
-    at = class extends Ut {};
+    }
+    set(t, n, r) {
+        const i = t[Dn].type.children.findIndex((s) => s.name === n);
+        return i !== -1 ? (An.visit(t[Dn].children[i], t[Ao], r), Reflect.set(t, n, r)) : Reflect.has(t, n) || typeof n == "symbol" ? Reflect.set(t, n, r) : !1;
+    }
+}
+class nt extends At {}
 
-function _t(e) {
+function ft(e) {
     return (t, n) => t.getValid(n) ? e(t, n) : null;
 }
-const Ik = (e, t) => 864e5 * e[t],
-    bb = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0),
-    Ak = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3,
-    Mk = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6,
-    CA = (e) => new Date(e),
-    $k = (e, t) => CA(Ik(e, t)),
-    Tk = (e, t) => CA(bb(e, t)),
-    Dk = (e, t) => null,
-    kA = (e, t, n) => {
+const ID = (e, t) => 864e5 * e[t],
+    Zy = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0),
+    TD = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3,
+    ED = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6,
+    I_ = (e) => new Date(e),
+    ND = (e, t) => I_(ID(e, t)),
+    DD = (e, t) => I_(Zy(e, t)),
+    OD = (e, t) => null,
+    T_ = (e, t, n) => {
         if (n + 1 >= t.length)
             return null;
-        const i = pn(t[n]),
-            r = pn(t[n + 1]);
-        return e.subarray(i, r);
+        const r = Pe(t[n]),
+            i = Pe(t[n + 1]);
+        return e.subarray(r, i);
     },
-    Nk = ({
+    LD = ({
         offset: e,
         values: t
     }, n) => {
-        const i = e + n;
-        return (t[i >> 3] & 1 << i % 8) !== 0;
+        const r = e + n;
+        return (t[r >> 3] & 1 << r % 8) !== 0;
     },
-    UA = ({
+    E_ = ({
         values: e
-    }, t) => $k(e, t),
-    zA = ({
+    }, t) => ND(e, t),
+    N_ = ({
         values: e
-    }, t) => Tk(e, t * 2),
-    io = ({
+    }, t) => DD(e, t * 2),
+    Xi = ({
         stride: e,
         values: t
     }, n) => t[e * n],
-    Bk = ({
+    kD = ({
         stride: e,
         values: t
-    }, n) => pA(t[e * n]),
-    PA = ({
+    }, n) => i_(t[e * n]),
+    D_ = ({
         values: e
     }, t) => e[t],
-    Ok = ({
+    RD = ({
         stride: e,
         values: t
     }, n) => t.subarray(e * n, e * (n + 1)),
-    VA = ({
+    O_ = ({
         values: e,
         valueOffsets: t
-    }, n) => kA(e, t, n),
-    jA = ({
+    }, n) => T_(e, t, n),
+    L_ = ({
         values: e,
         valueOffsets: t
     }, n) => {
-        const i = kA(e, t, n);
-        return i !== null ? dg(i) : null;
+        const r = T_(e, t, n);
+        return r !== null ? i0(r) : null;
     },
-    Fk = ({
+    FD = ({
         values: e
     }, t) => e[t],
-    Ek = ({
+    BD = ({
         type: e,
         values: t
-    }, n) => e.precision !== nn.HALF ? t[n] : pA(t[n]),
-    Lk = (e, t) => e.type.unit === Ii.DAY ? UA(e, t) : zA(e, t),
-    qA = ({
+    }, n) => e.precision !== De.HALF ? t[n] : i_(t[n]),
+    CD = (e, t) => e.type.unit === Pn.DAY ? E_(e, t) : N_(e, t),
+    k_ = ({
         values: e
-    }, t) => 1e3 * bb(e, t * 2),
-    YA = ({
+    }, t) => 1e3 * Zy(e, t * 2),
+    R_ = ({
         values: e
-    }, t) => bb(e, t * 2),
-    WA = ({
+    }, t) => Zy(e, t * 2),
+    F_ = ({
         values: e
-    }, t) => Ak(e, t * 2),
-    GA = ({
+    }, t) => TD(e, t * 2),
+    B_ = ({
         values: e
-    }, t) => Mk(e, t * 2),
-    Rk = (e, t) => {
+    }, t) => ED(e, t * 2),
+    PD = (e, t) => {
         switch (e.type.unit) {
-            case mt.SECOND:
-                return qA(e, t);
-            case mt.MILLISECOND:
-                return YA(e, t);
-            case mt.MICROSECOND:
-                return WA(e, t);
-            case mt.NANOSECOND:
-                return GA(e, t);
+            case ct.SECOND:
+                return k_(e, t);
+            case ct.MILLISECOND:
+                return R_(e, t);
+            case ct.MICROSECOND:
+                return F_(e, t);
+            case ct.NANOSECOND:
+                return B_(e, t);
         }
     },
-    XA = ({
+    C_ = ({
         values: e
     }, t) => e[t],
-    HA = ({
+    P_ = ({
         values: e
     }, t) => e[t],
-    JA = ({
+    U_ = ({
         values: e
     }, t) => e[t],
-    KA = ({
+    z_ = ({
         values: e
     }, t) => e[t],
-    Ck = (e, t) => {
+    UD = (e, t) => {
         switch (e.type.unit) {
-            case mt.SECOND:
-                return XA(e, t);
-            case mt.MILLISECOND:
-                return HA(e, t);
-            case mt.MICROSECOND:
-                return JA(e, t);
-            case mt.NANOSECOND:
-                return KA(e, t);
+            case ct.SECOND:
+                return C_(e, t);
+            case ct.MILLISECOND:
+                return P_(e, t);
+            case ct.MICROSECOND:
+                return U_(e, t);
+            case ct.NANOSECOND:
+                return z_(e, t);
         }
     },
-    kk = ({
+    zD = ({
         values: e,
         stride: t
-    }, n) => JC.decimal(e.subarray(t * n, t * (n + 1))),
-    Uk = (e, t) => {
+    }, n) => Xy.decimal(e.subarray(t * n, t * (n + 1))),
+    qD = (e, t) => {
         const {
             valueOffsets: n,
-            stride: i,
-            children: r
+            stride: r,
+            children: i
         } = e, {
-            [t * i]: s,
-            [t * i + 1]: o
-        } = n, c = r[0].slice(s, o - s);
-        return new Ne([c]);
+            [t * r]: s,
+            [t * r + 1]: o
+        } = n, c = i[0].slice(s, o - s);
+        return new ce([c]);
     },
-    zk = (e, t) => {
+    jD = (e, t) => {
         const {
             valueOffsets: n,
-            children: i
+            children: r
         } = e, {
-            [t]: r,
+            [t]: i,
             [t + 1]: s
-        } = n, o = i[0];
-        return new wb(o.slice(r, s - r));
+        } = n, o = r[0];
+        return new Ky(o.slice(i, s - i));
     },
-    Pk = (e, t) => new gb(e, t),
-    Vk = (e, t) => e.type.mode === Mn.Dense ? ZA(e, t) : QA(e, t),
-    ZA = (e, t) => {
+    VD = (e, t) => new Jy(e, t),
+    YD = (e, t) => e.type.mode === Je.Dense ? q_(e, t) : j_(e, t),
+    q_ = (e, t) => {
         const n = e.type.typeIdToChildIndex[e.typeIds[t]],
-            i = e.children[n];
-        return $n.visit(i, e.valueOffsets[t]);
+            r = e.children[n];
+        return Ze.visit(r, e.valueOffsets[t]);
     },
-    QA = (e, t) => {
+    j_ = (e, t) => {
         const n = e.type.typeIdToChildIndex[e.typeIds[t]],
-            i = e.children[n];
-        return $n.visit(i, t);
+            r = e.children[n];
+        return Ze.visit(r, t);
     },
-    jk = (e, t) => {
+    WD = (e, t) => {
         var n;
         return (n = e.dictionary) === null || n === void 0 ? void 0 : n.get(e.values[t]);
     },
-    qk = (e, t) => e.type.unit === lr.DAY_TIME ? tM(e, t) : eM(e, t),
-    tM = ({
+    XD = (e, t) => e.type.unit === br.DAY_TIME ? V_(e, t) : Y_(e, t),
+    V_ = ({
         values: e
     }, t) => e.subarray(2 * t, 2 * (t + 1)),
-    eM = ({
+    Y_ = ({
         values: e
     }, t) => {
         const n = e[t],
-            i = new Int32Array(2);
-        return i[0] = Math.trunc(n / 12), i[1] = Math.trunc(n % 12), i;
+            r = new Int32Array(2);
+        return r[0] = Math.trunc(n / 12), r[1] = Math.trunc(n % 12), r;
     },
-    nM = ({
+    W_ = ({
         values: e
     }, t) => e[t],
-    iM = ({
+    X_ = ({
         values: e
     }, t) => e[t],
-    rM = ({
+    G_ = ({
         values: e
     }, t) => e[t],
-    sM = ({
+    H_ = ({
         values: e
     }, t) => e[t],
-    Yk = (e, t) => {
+    GD = (e, t) => {
         switch (e.type.unit) {
-            case mt.SECOND:
-                return nM(e, t);
-            case mt.MILLISECOND:
-                return iM(e, t);
-            case mt.MICROSECOND:
-                return rM(e, t);
-            case mt.NANOSECOND:
-                return sM(e, t);
+            case ct.SECOND:
+                return W_(e, t);
+            case ct.MILLISECOND:
+                return X_(e, t);
+            case ct.MICROSECOND:
+                return G_(e, t);
+            case ct.NANOSECOND:
+                return H_(e, t);
         }
     },
-    Wk = (e, t) => {
+    HD = (e, t) => {
         const {
             stride: n,
-            children: i
-        } = e, s = i[0].slice(t * n, n);
-        return new Ne([s]);
+            children: r
+        } = e, s = r[0].slice(t * n, n);
+        return new ce([s]);
     };
-at.prototype.visitNull = _t(Dk);
-at.prototype.visitBool = _t(Nk);
-at.prototype.visitInt = _t(Fk);
-at.prototype.visitInt8 = _t(io);
-at.prototype.visitInt16 = _t(io);
-at.prototype.visitInt32 = _t(io);
-at.prototype.visitInt64 = _t(PA);
-at.prototype.visitUint8 = _t(io);
-at.prototype.visitUint16 = _t(io);
-at.prototype.visitUint32 = _t(io);
-at.prototype.visitUint64 = _t(PA);
-at.prototype.visitFloat = _t(Ek);
-at.prototype.visitFloat16 = _t(Bk);
-at.prototype.visitFloat32 = _t(io);
-at.prototype.visitFloat64 = _t(io);
-at.prototype.visitUtf8 = _t(jA);
-at.prototype.visitLargeUtf8 = _t(jA);
-at.prototype.visitBinary = _t(VA);
-at.prototype.visitLargeBinary = _t(VA);
-at.prototype.visitFixedSizeBinary = _t(Ok);
-at.prototype.visitDate = _t(Lk);
-at.prototype.visitDateDay = _t(UA);
-at.prototype.visitDateMillisecond = _t(zA);
-at.prototype.visitTimestamp = _t(Rk);
-at.prototype.visitTimestampSecond = _t(qA);
-at.prototype.visitTimestampMillisecond = _t(YA);
-at.prototype.visitTimestampMicrosecond = _t(WA);
-at.prototype.visitTimestampNanosecond = _t(GA);
-at.prototype.visitTime = _t(Ck);
-at.prototype.visitTimeSecond = _t(XA);
-at.prototype.visitTimeMillisecond = _t(HA);
-at.prototype.visitTimeMicrosecond = _t(JA);
-at.prototype.visitTimeNanosecond = _t(KA);
-at.prototype.visitDecimal = _t(kk);
-at.prototype.visitList = _t(Uk);
-at.prototype.visitStruct = _t(Pk);
-at.prototype.visitUnion = _t(Vk);
-at.prototype.visitDenseUnion = _t(ZA);
-at.prototype.visitSparseUnion = _t(QA);
-at.prototype.visitDictionary = _t(jk);
-at.prototype.visitInterval = _t(qk);
-at.prototype.visitIntervalDayTime = _t(tM);
-at.prototype.visitIntervalYearMonth = _t(eM);
-at.prototype.visitDuration = _t(Yk);
-at.prototype.visitDurationSecond = _t(nM);
-at.prototype.visitDurationMillisecond = _t(iM);
-at.prototype.visitDurationMicrosecond = _t(rM);
-at.prototype.visitDurationNanosecond = _t(sM);
-at.prototype.visitFixedSizeList = _t(Wk);
-at.prototype.visitMap = _t(zk);
-const $n = new at(),
-    Ki = Symbol.for("keys"),
-    lc = Symbol.for("vals");
-let wb = class {
-        constructor(t) {
-                return this[Ki] = new Ne([t.children[0]]).memoize(), this[lc] = t.children[1], new Proxy(this, new Xk());
-            }
-            [Symbol.iterator]() {
-                return new Gk(this[Ki], this[lc]);
-            }
-        get size() {
-            return this[Ki].length;
-        }
-        toArray() {
-            return Object.values(this.toJSON());
-        }
-        toJSON() {
-            const t = this[Ki],
-                n = this[lc],
-                i = {};
-            for (let r = -1, s = t.length; ++r < s;)
-                i[t.get(r)] = $n.visit(n, r);
-            return i;
-        }
-        toString() {
-                return `{${[...this].map(([t, n]) => `${_u(t)}: ${_u(n)}`).join(", ")}}`;
-            }
-            [Symbol.for("nodejs.util.inspect.custom")]() {
-                return this.toString();
-            }
-    },
-    Gk = class {
-        constructor(t, n) {
-                this.keys = t, this.vals = n, this.keyIndex = 0, this.numKeys = t.length;
-            }
-            [Symbol.iterator]() {
-                return this;
-            }
-        next() {
-            const t = this.keyIndex;
-            return t === this.numKeys ? {
-                done: !0,
-                value: null
-            } : (this.keyIndex++, {
-                done: !1,
-                value: [
-                    this.keys.get(t),
-                    $n.visit(this.vals, t)
-                ]
-            });
-        }
-    },
-    Xk = class {
-        isExtensible() {
-            return !1;
-        }
-        deleteProperty() {
-            return !1;
+nt.prototype.visitNull = ft(OD);
+nt.prototype.visitBool = ft(LD);
+nt.prototype.visitInt = ft(FD);
+nt.prototype.visitInt8 = ft(Xi);
+nt.prototype.visitInt16 = ft(Xi);
+nt.prototype.visitInt32 = ft(Xi);
+nt.prototype.visitInt64 = ft(D_);
+nt.prototype.visitUint8 = ft(Xi);
+nt.prototype.visitUint16 = ft(Xi);
+nt.prototype.visitUint32 = ft(Xi);
+nt.prototype.visitUint64 = ft(D_);
+nt.prototype.visitFloat = ft(BD);
+nt.prototype.visitFloat16 = ft(kD);
+nt.prototype.visitFloat32 = ft(Xi);
+nt.prototype.visitFloat64 = ft(Xi);
+nt.prototype.visitUtf8 = ft(L_);
+nt.prototype.visitLargeUtf8 = ft(L_);
+nt.prototype.visitBinary = ft(O_);
+nt.prototype.visitLargeBinary = ft(O_);
+nt.prototype.visitFixedSizeBinary = ft(RD);
+nt.prototype.visitDate = ft(CD);
+nt.prototype.visitDateDay = ft(E_);
+nt.prototype.visitDateMillisecond = ft(N_);
+nt.prototype.visitTimestamp = ft(PD);
+nt.prototype.visitTimestampSecond = ft(k_);
+nt.prototype.visitTimestampMillisecond = ft(R_);
+nt.prototype.visitTimestampMicrosecond = ft(F_);
+nt.prototype.visitTimestampNanosecond = ft(B_);
+nt.prototype.visitTime = ft(UD);
+nt.prototype.visitTimeSecond = ft(C_);
+nt.prototype.visitTimeMillisecond = ft(P_);
+nt.prototype.visitTimeMicrosecond = ft(U_);
+nt.prototype.visitTimeNanosecond = ft(z_);
+nt.prototype.visitDecimal = ft(zD);
+nt.prototype.visitList = ft(qD);
+nt.prototype.visitStruct = ft(VD);
+nt.prototype.visitUnion = ft(YD);
+nt.prototype.visitDenseUnion = ft(q_);
+nt.prototype.visitSparseUnion = ft(j_);
+nt.prototype.visitDictionary = ft(WD);
+nt.prototype.visitInterval = ft(XD);
+nt.prototype.visitIntervalDayTime = ft(V_);
+nt.prototype.visitIntervalYearMonth = ft(Y_);
+nt.prototype.visitDuration = ft(GD);
+nt.prototype.visitDurationSecond = ft(W_);
+nt.prototype.visitDurationMillisecond = ft(X_);
+nt.prototype.visitDurationMicrosecond = ft(G_);
+nt.prototype.visitDurationNanosecond = ft(H_);
+nt.prototype.visitFixedSizeList = ft(HD);
+nt.prototype.visitMap = ft(jD);
+const Ze = new nt(),
+    ar = Symbol.for("keys"),
+    $o = Symbol.for("vals");
+class Ky {
+    constructor(t) {
+            return this[ar] = new ce([t.children[0]]).memoize(), this[$o] = t.children[1], new Proxy(this, new ZD());
         }
-        preventExtensions() {
-            return !0;
+        [Symbol.iterator]() {
+            return new JD(this[ar], this[$o]);
         }
-        ownKeys(t) {
-            return t[Ki].toArray().map(String);
+    get size() {
+        return this[ar].length;
+    }
+    toArray() {
+        return Object.values(this.toJSON());
+    }
+    toJSON() {
+        const t = this[ar],
+            n = this[$o],
+            r = {};
+        for (let i = -1, s = t.length; ++i < s;)
+            r[t.get(i)] = Ze.visit(n, i);
+        return r;
+    }
+    toString() {
+            return `{${[...this].map(([t, n]) => `${mc(t)}: ${mc(n)}`).join(", ")}}`;
         }
-        has(t, n) {
-            return t[Ki].includes(n);
+        [Symbol.for("nodejs.util.inspect.custom")]() {
+            return this.toString();
         }
-        getOwnPropertyDescriptor(t, n) {
-            if (t[Ki].indexOf(n) !== -1)
-                return {
-                    writable: !0,
-                    enumerable: !0,
-                    configurable: !0
-                };
+}
+class JD {
+    constructor(t, n) {
+            this.keys = t, this.vals = n, this.keyIndex = 0, this.numKeys = t.length;
         }
-        get(t, n) {
-            if (Reflect.has(t, n))
-                return t[n];
-            const i = t[Ki].indexOf(n);
-            if (i !== -1) {
-                const r = $n.visit(Reflect.get(t, lc), i);
-                return Reflect.set(t, n, r), r;
-            }
+        [Symbol.iterator]() {
+            return this;
         }
-        set(t, n, i) {
-            const r = t[Ki].indexOf(n);
-            return r !== -1 ? (ci.visit(Reflect.get(t, lc), r, i), Reflect.set(t, n, i)) : Reflect.has(t, n) ? Reflect.set(t, n, i) : !1;
+    next() {
+        const t = this.keyIndex;
+        return t === this.numKeys ? {
+            done: !0,
+            value: null
+        } : (this.keyIndex++, {
+            done: !1,
+            value: [
+                this.keys.get(t),
+                Ze.visit(this.vals, t)
+            ]
+        });
+    }
+}
+class ZD {
+    isExtensible() {
+        return !1;
+    }
+    deleteProperty() {
+        return !1;
+    }
+    preventExtensions() {
+        return !0;
+    }
+    ownKeys(t) {
+        return t[ar].toArray().map(String);
+    }
+    has(t, n) {
+        return t[ar].includes(n);
+    }
+    getOwnPropertyDescriptor(t, n) {
+        if (t[ar].indexOf(n) !== -1)
+            return {
+                writable: !0,
+                enumerable: !0,
+                configurable: !0
+            };
+    }
+    get(t, n) {
+        if (Reflect.has(t, n))
+            return t[n];
+        const r = t[ar].indexOf(n);
+        if (r !== -1) {
+            const i = Ze.visit(Reflect.get(t, $o), r);
+            return Reflect.set(t, n, i), i;
         }
-    };
-Object.defineProperties(wb.prototype, {
+    }
+    set(t, n, r) {
+        const i = t[ar].indexOf(n);
+        return i !== -1 ? (An.visit(Reflect.get(t, $o), i, r), Reflect.set(t, n, r)) : Reflect.has(t, n) ? Reflect.set(t, n, r) : !1;
+    }
+}
+Object.defineProperties(Ky.prototype, {
     [Symbol.toStringTag]: {
         enumerable: !1,
         configurable: !1,
         value: "Row"
     },
-    [Ki]: {
+    [ar]: {
         writable: !0,
         enumerable: !1,
         configurable: !1,
         value: null
     },
-    [lc]: {
+    [$o]: {
         writable: !0,
         enumerable: !1,
         configurable: !1,
         value: null
     }
 });
-let z_;
+let eb;
 
-function oM(e, t, n, i) {
+function J_(e, t, n, r) {
     const {
-        length: r = 0
+        length: i = 0
     } = e;
     let s = typeof t != "number" ? 0 : t,
-        o = typeof n != "number" ? r : n;
-    return s < 0 && (s = (s % r + r) % r), o < 0 && (o = (o % r + r) % r), o < s && (z_ = s, s = o, o = z_), o > r && (o = r), i ? i(e, s, o) : [s, o];
+        o = typeof n != "number" ? i : n;
+    return s < 0 && (s = (s % i + i) % i), o < 0 && (o = (o % i + i) % i), o < s && (eb = s, s = o, o = eb), o > i && (o = i), r ? r(e, s, o) : [s, o];
 }
-const P_ = (e) => e !== e;
+const nb = (e) => e !== e;
 
-function Zc(e) {
+function la(e) {
     if (typeof e !== "object" || e === null)
-        return P_(e) ? P_ : (n) => n === e;
+        return nb(e) ? nb : (n) => n === e;
     if (e instanceof Date) {
         const n = e.valueOf();
-        return (i) => i instanceof Date ? i.valueOf() === n : !1;
+        return (r) => r instanceof Date ? r.valueOf() === n : !1;
     }
-    return ArrayBuffer.isView(e) ? (n) => n ? zC(e, n) : !1 : e instanceof Map ? Jk(e) : Array.isArray(e) ? Hk(e) : e instanceof Ne ? Kk(e) : Zk(e, !0);
+    return ArrayBuffer.isView(e) ? (n) => n ? YN(e, n) : !1 : e instanceof Map ? QD(e) : Array.isArray(e) ? KD(e) : e instanceof ce ? t9(e) : e9(e, !0);
 }
 
-function Hk(e) {
+function KD(e) {
     const t = [];
-    for (let n = -1, i = e.length; ++n < i;)
-        t[n] = Zc(e[n]);
-    return ky(t);
+    for (let n = -1, r = e.length; ++n < r;)
+        t[n] = la(e[n]);
+    return kh(t);
 }
 
-function Jk(e) {
+function QD(e) {
     let t = -1;
     const n = [];
-    for (const i of e.values())
-        n[++t] = Zc(i);
-    return ky(n);
+    for (const r of e.values())
+        n[++t] = la(r);
+    return kh(n);
 }
 
-function Kk(e) {
+function t9(e) {
     const t = [];
-    for (let n = -1, i = e.length; ++n < i;)
-        t[n] = Zc(e.get(n));
-    return ky(t);
+    for (let n = -1, r = e.length; ++n < r;)
+        t[n] = la(e.get(n));
+    return kh(t);
 }
 
-function Zk(e, t = !1) {
+function e9(e, t = !1) {
     const n = Object.keys(e);
     if (!t && n.length === 0)
         return () => !1;
-    const i = [];
-    for (let r = -1, s = n.length; ++r < s;)
-        i[r] = Zc(e[n[r]]);
-    return ky(i, n);
+    const r = [];
+    for (let i = -1, s = n.length; ++i < s;)
+        r[i] = la(e[n[i]]);
+    return kh(r, n);
 }
 
-function ky(e, t) {
+function kh(e, t) {
     return (n) => {
         if (!n || typeof n != "object")
             return !1;
         switch (n.constructor) {
             case Array:
-                return Qk(e, n);
+                return n9(e, n);
             case Map:
-                return V_(e, n, n.keys());
-            case wb:
-            case gb:
+                return rb(e, n, n.keys());
+            case Ky:
+            case Jy:
             case Object:
             case void 0:
-                return V_(e, n, t || Object.keys(n));
+                return rb(e, n, t || Object.keys(n));
         }
-        return n instanceof Ne ? t7(e, n) : !1;
+        return n instanceof ce ? r9(e, n) : !1;
     };
 }
 
-function Qk(e, t) {
+function n9(e, t) {
     const n = e.length;
     if (t.length !== n)
         return !1;
-    for (let i = -1; ++i < n;)
-        if (!e[i](t[i]))
+    for (let r = -1; ++r < n;)
+        if (!e[r](t[r]))
             return !1;
     return !0;
 }
 
-function t7(e, t) {
+function r9(e, t) {
     const n = e.length;
     if (t.length !== n)
         return !1;
-    for (let i = -1; ++i < n;)
-        if (!e[i](t.get(i)))
+    for (let r = -1; ++r < n;)
+        if (!e[r](t.get(r)))
             return !1;
     return !0;
 }
 
-function V_(e, t, n) {
-    const i = n[Symbol.iterator](),
-        r = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](),
+function rb(e, t, n) {
+    const r = n[Symbol.iterator](),
+        i = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](),
         s = t instanceof Map ? t.values() : Object.values(t)[Symbol.iterator]();
     let o = 0;
     const a = e.length;
     let c = s.next(),
-        l = i.next(),
-        u = r.next();
-    for (; o < a && !l.done && !u.done && !c.done && !(l.value !== u.value || !e[o](c.value)); ++o, l = i.next(), u = r.next(), c = s.next())
+        u = r.next(),
+        l = i.next();
+    for (; o < a && !u.done && !l.done && !c.done && !(u.value !== l.value || !e[o](c.value)); ++o, u = r.next(), l = i.next(), c = s.next())
     ;
-    return o === a && l.done && u.done && c.done ? !0 : (i.return && i.return(), r.return && r.return(), s.return && s.return(), !1);
+    return o === a && u.done && l.done && c.done ? !0 : (r.return && r.return(), i.return && i.return(), s.return && s.return(), !1);
 }
 
-function aM(e, t, n, i) {
-    return (n & 1 << i) !== 0;
+function Z_(e, t, n, r) {
+    return (n & 1 << r) !== 0;
 }
 
-function e7(e, t, n, i) {
-    return (n & 1 << i) >> i;
+function i9(e, t, n, r) {
+    return (n & 1 << r) >> r;
 }
 
-function j_(e, t, n) {
-    const i = n.byteLength + 7 & -8;
-    if (e > 0 || n.byteLength < i) {
-        const r = new Uint8Array(i);
-        return r.set(e % 8 === 0 ? n.subarray(e >> 3) : (
+function ib(e, t, n) {
+    const r = n.byteLength + 7 & -8;
+    if (e > 0 || n.byteLength < r) {
+        const i = new Uint8Array(r);
+        return i.set(e % 8 === 0 ? n.subarray(e >> 3) : (
             // Otherwise iterate each bit from the offset and return a new one
-            _g(new vb(n, e, t, null, aM)).subarray(0, i)
-        )), r;
+            l0(new Qy(n, e, t, null, Z_)).subarray(0, r)
+        )), i;
     }
     return n;
 }
 
-function _g(e) {
+function l0(e) {
     const t = [];
     let n = 0,
-        i = 0,
-        r = 0;
+        r = 0,
+        i = 0;
     for (const o of e)
-        o && (r |= 1 << i), ++i === 8 && (t[n++] = r, r = i = 0);
-    (n === 0 || i > 0) && (t[n++] = r);
+        o && (i |= 1 << r), ++r === 8 && (t[n++] = i, i = r = 0);
+    (n === 0 || r > 0) && (t[n++] = i);
     const s = new Uint8Array(t.length + 7 & -8);
     return s.set(t), s;
 }
-let vb = class {
-    constructor(t, n, i, r, s) {
-        this.bytes = t, this.length = i, this.context = r, this.get = s, this.bit = n % 8, this.byteIndex = n >> 3, this.byte = t[this.byteIndex++], this.index = 0;
+class Qy {
+    constructor(t, n, r, i, s) {
+        this.bytes = t, this.length = r, this.context = i, this.get = s, this.bit = n % 8, this.byteIndex = n >> 3, this.byte = t[this.byteIndex++], this.index = 0;
     }
     next() {
             return this.index < this.length ? (this.bit === 8 && (this.bit = 0, this.byte = this.bytes[this.byteIndex++]), {
                 value: this.get(this.context, this.index++, this.byte, this.bit++)
             }) : {
                 done: !0,
                 value: null
             };
         }
         [Symbol.iterator]() {
             return this;
         }
-};
+}
 
-function xg(e, t, n) {
+function f0(e, t, n) {
     if (n - t <= 0)
         return 0;
     if (n - t < 8) {
         let s = 0;
-        for (const o of new vb(e, t, n - t, e, e7))
+        for (const o of new Qy(e, t, n - t, e, i9))
             s += o;
         return s;
     }
-    const i = n >> 3 << 3,
-        r = t + (t % 8 === 0 ? 0 : 8 - t % 8);
+    const r = n >> 3 << 3,
+        i = t + (t % 8 === 0 ? 0 : 8 - t % 8);
     return (
         // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
-        xg(e, t, r) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
-        xg(e, i, n) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
-        n7(e, r >> 3, i - r >> 3)
+        f0(e, t, i) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
+        f0(e, r, n) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
+        s9(e, i >> 3, r - i >> 3)
     );
 }
 
-function n7(e, t, n) {
-    let i = 0,
-        r = Math.trunc(t);
+function s9(e, t, n) {
+    let r = 0,
+        i = Math.trunc(t);
     const s = new DataView(e.buffer, e.byteOffset, e.byteLength),
-        o = n === void 0 ? e.byteLength : r + n;
-    for (; o - r >= 4;)
-        i += im(s.getUint32(r)), r += 4;
-    for (; o - r >= 2;)
-        i += im(s.getUint16(r)), r += 2;
-    for (; o - r >= 1;)
-        i += im(s.getUint8(r)), r += 1;
-    return i;
+        o = n === void 0 ? e.byteLength : i + n;
+    for (; o - i >= 4;)
+        r += Kd(s.getUint32(i)), i += 4;
+    for (; o - i >= 2;)
+        r += Kd(s.getUint16(i)), i += 2;
+    for (; o - i >= 1;)
+        r += Kd(s.getUint8(i)), i += 1;
+    return r;
 }
 
-function im(e) {
+function Kd(e) {
     let t = Math.trunc(e);
     return t = t - (t >>> 1 & 1431655765), t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
 }
-const i7 = -1;
-let de = class Sg {
+const o9 = -1;
+class jt {
     get typeId() {
         return this.type.typeId;
     }
     get ArrayType() {
         return this.type.ArrayType;
     }
     get buffers() {
         return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
     }
     get nullable() {
         if (this._nullCount !== 0) {
             const {
                 type: t
             } = this;
-            return gt.isSparseUnion(t) ? this.children.some((n) => n.nullable) : gt.isDenseUnion(t) ? this.children.some((n) => n.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0;
+            return Q.isSparseUnion(t) ? this.children.some((n) => n.nullable) : Q.isDenseUnion(t) ? this.children.some((n) => n.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0;
         }
         return !0;
     }
     get byteLength() {
         let t = 0;
         const {
             valueOffsets: n,
-            values: i,
-            nullBitmap: r,
+            values: r,
+            nullBitmap: i,
             typeIds: s
         } = this;
-        return n && (t += n.byteLength), i && (t += i.byteLength), r && (t += r.byteLength), s && (t += s.byteLength), this.children.reduce((o, a) => o + a.byteLength, t);
+        return n && (t += n.byteLength), r && (t += r.byteLength), i && (t += i.byteLength), s && (t += s.byteLength), this.children.reduce((o, a) => o + a.byteLength, t);
     }
     get nullCount() {
-        if (gt.isUnion(this.type))
-            return this.children.reduce((i, r) => i + r.nullCount, 0);
+        if (Q.isUnion(this.type))
+            return this.children.reduce((r, i) => r + i.nullCount, 0);
         let t = this._nullCount,
             n;
-        return t <= i7 && (n = this.nullBitmap) && (this._nullCount = t = this.length - xg(n, this.offset, this.offset + this.length)), t;
+        return t <= o9 && (n = this.nullBitmap) && (this._nullCount = t = this.length - f0(n, this.offset, this.offset + this.length)), t;
     }
-    constructor(t, n, i, r, s, o = [], a) {
-        this.type = t, this.children = o, this.dictionary = a, this.offset = Math.floor(Math.max(n || 0, 0)), this.length = Math.floor(Math.max(i || 0, 0)), this._nullCount = Math.floor(Math.max(r || 0, -1));
+    constructor(t, n, r, i, s, o = [], a) {
+        this.type = t, this.children = o, this.dictionary = a, this.offset = Math.floor(Math.max(n || 0, 0)), this.length = Math.floor(Math.max(r || 0, 0)), this._nullCount = Math.floor(Math.max(i || 0, -1));
         let c;
-        s instanceof Sg ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = Cr(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)));
+        s instanceof jt ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = Ur(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)));
     }
     getValid(t) {
         const {
             type: n
         } = this;
-        if (gt.isUnion(n)) {
-            const i = n,
-                r = this.children[i.typeIdToChildIndex[this.typeIds[t]]],
-                s = i.mode === Mn.Dense ? this.valueOffsets[t] : t;
-            return r.getValid(s);
+        if (Q.isUnion(n)) {
+            const r = n,
+                i = this.children[r.typeIdToChildIndex[this.typeIds[t]]],
+                s = r.mode === Je.Dense ? this.valueOffsets[t] : t;
+            return i.getValid(s);
         }
         if (this.nullable && this.nullCount > 0) {
-            const i = this.offset + t;
-            return (this.nullBitmap[i >> 3] & 1 << i % 8) !== 0;
+            const r = this.offset + t;
+            return (this.nullBitmap[r >> 3] & 1 << r % 8) !== 0;
         }
         return !0;
     }
     setValid(t, n) {
-        let i;
+        let r;
         const {
-            type: r
+            type: i
         } = this;
-        if (gt.isUnion(r)) {
-            const s = r,
+        if (Q.isUnion(i)) {
+            const s = i,
                 o = this.children[s.typeIdToChildIndex[this.typeIds[t]]],
-                a = s.mode === Mn.Dense ? this.valueOffsets[t] : t;
-            i = o.getValid(a), o.setValid(a, n);
+                a = s.mode === Je.Dense ? this.valueOffsets[t] : t;
+            r = o.getValid(a), o.setValid(a, n);
         } else {
             let {
                 nullBitmap: s
             } = this;
             const {
                 offset: o,
                 length: a
-            } = this, c = o + t, l = 1 << c % 8, u = c >> 3;
-            (!s || s.byteLength <= u) && (s = new Uint8Array((o + a + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(j_(o, a, this.nullBitmap), 0), Object.assign(this, {
+            } = this, c = o + t, u = 1 << c % 8, l = c >> 3;
+            (!s || s.byteLength <= l) && (s = new Uint8Array((o + a + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(ib(o, a, this.nullBitmap), 0), Object.assign(this, {
                 nullBitmap: s,
                 _nullCount: -1
             }));
-            const f = s[u];
-            i = (f & l) !== 0, n ? s[u] = f | l : s[u] = f & ~l;
+            const f = s[l];
+            r = (f & u) !== 0, n ? s[l] = f | u : s[l] = f & ~u;
         }
-        return i !== !!n && (this._nullCount = this.nullCount + (n ? -1 : 1)), n;
+        return r !== !!n && (this._nullCount = this.nullCount + (n ? -1 : 1)), n;
     }
-    clone(t = this.type, n = this.offset, i = this.length, r = this._nullCount, s = this, o = this.children) {
-        return new Sg(t, n, i, r, s, o, this.dictionary);
+    clone(t = this.type, n = this.offset, r = this.length, i = this._nullCount, s = this, o = this.children) {
+        return new jt(t, n, r, i, s, o, this.dictionary);
     }
     slice(t, n) {
         const {
-            stride: i,
-            typeId: r,
+            stride: r,
+            typeId: i,
             children: s
-        } = this, o = +(this._nullCount === 0) - 1, a = r === 16 ? i : 1, c = this._sliceBuffers(t, n, i, r);
+        } = this, o = +(this._nullCount === 0) - 1, a = i === 16 ? r : 1, c = this._sliceBuffers(t, n, r, i);
         return this.clone(
             this.type,
             this.offset + t,
             n,
             o,
             c,
             // Don't slice children if we have value offsets (the variable-width types)
             s.length === 0 || this.valueOffsets ? s : this._sliceChildren(s, a * t, a * n)
         );
     }
     _changeLengthAndBackfillNullBitmap(t) {
-        if (this.typeId === F.Null)
+        if (this.typeId === L.Null)
             return this.clone(this.type, 0, t, 0);
         const {
             length: n,
-            nullCount: i
-        } = this, r = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, n >> 3);
-        r[n >> 3] = (1 << n - (n & -8)) - 1, i > 0 && r.set(j_(this.offset, n, this.nullBitmap), 0);
+            nullCount: r
+        } = this, i = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, n >> 3);
+        i[n >> 3] = (1 << n - (n & -8)) - 1, r > 0 && i.set(ib(this.offset, n, this.nullBitmap), 0);
         const s = this.buffers;
-        return s[Rr.VALIDITY] = r, this.clone(this.type, 0, t, i + (t - n), s);
+        return s[Pr.VALIDITY] = i, this.clone(this.type, 0, t, r + (t - n), s);
     }
-    _sliceBuffers(t, n, i, r) {
+    _sliceBuffers(t, n, r, i) {
         let s;
         const {
             buffers: o
         } = this;
-        return (s = o[Rr.TYPE]) && (o[Rr.TYPE] = s.subarray(t, t + n)), (s = o[Rr.OFFSET]) && (o[Rr.OFFSET] = s.subarray(t, t + n + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
-            (s = o[Rr.DATA]) && (o[Rr.DATA] = r === 6 ? s : s.subarray(i * t, i * (t + n))), o;
+        return (s = o[Pr.TYPE]) && (o[Pr.TYPE] = s.subarray(t, t + n)), (s = o[Pr.OFFSET]) && (o[Pr.OFFSET] = s.subarray(t, t + n + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
+            (s = o[Pr.DATA]) && (o[Pr.DATA] = i === 6 ? s : s.subarray(r * t, r * (t + n))), o;
     }
-    _sliceChildren(t, n, i) {
-        return t.map((r) => r.slice(n, i));
+    _sliceChildren(t, n, r) {
+        return t.map((i) => i.slice(n, r));
     }
-};
-de.prototype.children = Object.freeze([]);
-let r7 = class Wh extends Ut {
+}
+jt.prototype.children = Object.freeze([]);
+class oc extends At {
     visit(t) {
         return this.getVisitFn(t.type).call(this, t);
     }
     visitNull(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0, ["length"]: r = 0
+            ["type"]: n, ["offset"]: r = 0, ["length"]: i = 0
         } = t;
-        return new de(n, i, r, r);
+        return new jt(n, r, i, i);
     }
     visitBool(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
             ["length"]: o = s.length >> 3,
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitInt(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
             ["length"]: o = s.length,
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitFloat(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
             ["length"]: o = s.length,
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitUtf8(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = bl(t.valueOffsets), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.data), s = Dt(t.nullBitmap), o = Ea(t.valueOffsets), {
             ["length"]: a = o.length - 1,
             ["nullCount"]: c = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, a, c, [o, r, s]);
+        return new jt(n, r, a, c, [o, i, s]);
     }
     visitLargeUtf8(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = T_(t.valueOffsets), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.data), s = Dt(t.nullBitmap), o = V1(t.valueOffsets), {
             ["length"]: a = o.length - 1,
             ["nullCount"]: c = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, a, c, [o, r, s]);
+        return new jt(n, r, a, c, [o, i, s]);
     }
     visitBinary(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = bl(t.valueOffsets), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.data), s = Dt(t.nullBitmap), o = Ea(t.valueOffsets), {
             ["length"]: a = o.length - 1,
             ["nullCount"]: c = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, a, c, [o, r, s]);
+        return new jt(n, r, a, c, [o, i, s]);
     }
     visitLargeBinary(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.data), s = Yt(t.nullBitmap), o = T_(t.valueOffsets), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.data), s = Dt(t.nullBitmap), o = V1(t.valueOffsets), {
             ["length"]: a = o.length - 1,
             ["nullCount"]: c = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, a, c, [o, r, s]);
+        return new jt(n, r, a, c, [o, i, s]);
     }
     visitFixedSizeBinary(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
-            ["length"]: o = s.length / Cr(n),
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
+            ["length"]: o = s.length / Ur(n),
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitDate(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
-            ["length"]: o = s.length / Cr(n),
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
+            ["length"]: o = s.length / Ur(n),
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitTimestamp(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
-            ["length"]: o = s.length / Cr(n),
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
+            ["length"]: o = s.length / Ur(n),
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitTime(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
-            ["length"]: o = s.length / Cr(n),
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
+            ["length"]: o = s.length / Ur(n),
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitDecimal(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
-            ["length"]: o = s.length / Cr(n),
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
+            ["length"]: o = s.length / Ur(n),
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitList(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0, ["child"]: r
-        } = t, s = Yt(t.nullBitmap), o = bl(t.valueOffsets), {
+            ["type"]: n, ["offset"]: r = 0, ["child"]: i
+        } = t, s = Dt(t.nullBitmap), o = Ea(t.valueOffsets), {
             ["length"]: a = o.length - 1,
             ["nullCount"]: c = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, a, c, [o, void 0, s], [r]);
+        return new jt(n, r, a, c, [o, void 0, s], [i]);
     }
     visitStruct(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0, ["children"]: r = []
-        } = t, s = Yt(t.nullBitmap), {
-            length: o = r.reduce((c, {
-                length: l
-            }) => Math.max(c, l), 0),
+            ["type"]: n, ["offset"]: r = 0, ["children"]: i = []
+        } = t, s = Dt(t.nullBitmap), {
+            length: o = i.reduce((c, {
+                length: u
+            }) => Math.max(c, u), 0),
             nullCount: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, void 0, s], r);
+        return new jt(n, r, o, a, [void 0, void 0, s], i);
     }
     visitUnion(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0, ["children"]: r = []
-        } = t, s = re(n.ArrayType, t.typeIds), {
+            ["type"]: n, ["offset"]: r = 0, ["children"]: i = []
+        } = t, s = Yt(n.ArrayType, t.typeIds), {
             ["length"]: o = s.length,
             ["nullCount"]: a = -1
         } = t;
-        if (gt.isSparseUnion(n))
-            return new de(n, i, o, a, [void 0, void 0, void 0, s], r);
-        const c = bl(t.valueOffsets);
-        return new de(n, i, o, a, [c, void 0, void 0, s], r);
+        if (Q.isSparseUnion(n))
+            return new jt(n, r, o, a, [void 0, void 0, void 0, s], i);
+        const c = Ea(t.valueOffsets);
+        return new jt(n, r, o, a, [c, void 0, void 0, s], i);
     }
     visitDictionary(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.indices.ArrayType, t.data), {
-            ["dictionary"]: o = new Ne([new Wh().visit({
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.indices.ArrayType, t.data), {
+            ["dictionary"]: o = new ce([new oc().visit({
                 type: n.dictionary
             })])
         } = t, {
             ["length"]: a = s.length,
             ["nullCount"]: c = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, a, c, [void 0, s, r], [], o);
+        return new jt(n, r, a, c, [void 0, s, i], [], o);
     }
     visitInterval(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
-            ["length"]: o = s.length / Cr(n),
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
+            ["length"]: o = s.length / Ur(n),
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitDuration(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Yt(t.nullBitmap), s = re(n.ArrayType, t.data), {
+            ["type"]: n, ["offset"]: r = 0
+        } = t, i = Dt(t.nullBitmap), s = Yt(n.ArrayType, t.data), {
             ["length"]: o = s.length,
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, s, r]);
+        return new jt(n, r, o, a, [void 0, s, i]);
     }
     visitFixedSizeList(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0, ["child"]: r = new Wh().visit({
+            ["type"]: n, ["offset"]: r = 0, ["child"]: i = new oc().visit({
                 type: n.valueType
             })
-        } = t, s = Yt(t.nullBitmap), {
-            ["length"]: o = r.length / Cr(n),
+        } = t, s = Dt(t.nullBitmap), {
+            ["length"]: o = i.length / Ur(n),
             ["nullCount"]: a = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, o, a, [void 0, void 0, s], [r]);
+        return new jt(n, r, o, a, [void 0, void 0, s], [i]);
     }
     visitMap(t) {
         const {
-            ["type"]: n, ["offset"]: i = 0, ["child"]: r = new Wh().visit({
+            ["type"]: n, ["offset"]: r = 0, ["child"]: i = new oc().visit({
                 type: n.childType
             })
-        } = t, s = Yt(t.nullBitmap), o = bl(t.valueOffsets), {
+        } = t, s = Dt(t.nullBitmap), o = Ea(t.valueOffsets), {
             ["length"]: a = o.length - 1,
             ["nullCount"]: c = t.nullBitmap ? -1 : 0
         } = t;
-        return new de(n, i, a, c, [o, void 0, s], [r]);
+        return new jt(n, r, a, c, [o, void 0, s], [i]);
     }
-};
-const s7 = new r7();
+}
+const a9 = new oc();
 
-function Rt(e) {
-    return s7.visit(e);
+function St(e) {
+    return a9.visit(e);
 }
-let q_ = class {
+class sb {
     constructor(t = 0, n) {
         this.numChunks = t, this.getChunkIterator = n, this.chunkIndex = 0, this.chunkIterator = this.getChunkIterator(0);
     }
     next() {
             for (; this.chunkIndex < this.numChunks;) {
                 const t = this.chunkIterator.next();
                 if (!t.done)
@@ -4760,343 +4768,343 @@
                 done: !0,
                 value: null
             };
         }
         [Symbol.iterator]() {
             return this;
         }
-};
+}
 
-function o7(e) {
+function c9(e) {
     return e.some((t) => t.nullable);
 }
 
-function cM(e) {
+function K_(e) {
     return e.reduce((t, n) => t + n.nullCount, 0);
 }
 
-function lM(e) {
-    return e.reduce((t, n, i) => (t[i + 1] = t[i] + n.length, t), new Uint32Array(e.length + 1));
+function Q_(e) {
+    return e.reduce((t, n, r) => (t[r + 1] = t[r] + n.length, t), new Uint32Array(e.length + 1));
 }
 
-function uM(e, t, n, i) {
-    const r = [];
+function tx(e, t, n, r) {
+    const i = [];
     for (let s = -1, o = e.length; ++s < o;) {
         const a = e[s],
             c = t[s],
             {
-                length: l
+                length: u
             } = a;
-        if (c >= i)
+        if (c >= r)
             break;
-        if (n >= c + l)
+        if (n >= c + u)
             continue;
-        if (c >= n && c + l <= i) {
-            r.push(a);
+        if (c >= n && c + u <= r) {
+            i.push(a);
             continue;
         }
-        const u = Math.max(0, n - c),
-            f = Math.min(i - c, l);
-        r.push(a.slice(u, f - u));
+        const l = Math.max(0, n - c),
+            f = Math.min(r - c, u);
+        i.push(a.slice(l, f - l));
     }
-    return r.length === 0 && r.push(e[0].slice(0, 0)), r;
+    return i.length === 0 && i.push(e[0].slice(0, 0)), i;
 }
 
-function _b(e, t, n, i) {
-    let r = 0,
+function tm(e, t, n, r) {
+    let i = 0,
         s = 0,
         o = t.length - 1;
     do {
-        if (r >= o - 1)
-            return n < t[o] ? i(e, r, n - t[r]) : null;
-        s = r + Math.trunc((o - r) * 0.5), n < t[s] ? o = s : r = s;
-    } while (r < o);
+        if (i >= o - 1)
+            return n < t[o] ? r(e, i, n - t[i]) : null;
+        s = i + Math.trunc((o - i) * 0.5), n < t[s] ? o = s : i = s;
+    } while (i < o);
 }
 
-function xb(e, t) {
+function em(e, t) {
     return e.getValid(t);
 }
 
-function Ld(e) {
-    function t(n, i, r) {
-        return e(n[i], r);
+function lf(e) {
+    function t(n, r, i) {
+        return e(n[r], i);
     }
     return function(n) {
-        const i = this.data;
-        return _b(i, this._offsets, n, t);
+        const r = this.data;
+        return tm(r, this._offsets, n, t);
     };
 }
 
-function fM(e) {
+function ex(e) {
     let t;
 
-    function n(i, r, s) {
-        return e(i[r], s, t);
+    function n(r, i, s) {
+        return e(r[i], s, t);
     }
-    return function(i, r) {
+    return function(r, i) {
         const s = this.data;
-        t = r;
-        const o = _b(s, this._offsets, i, n);
+        t = i;
+        const o = tm(s, this._offsets, r, n);
         return t = void 0, o;
     };
 }
 
-function hM(e) {
+function nx(e) {
     let t;
 
-    function n(i, r, s) {
+    function n(r, i, s) {
         let o = s,
             a = 0,
             c = 0;
-        for (let l = r - 1, u = i.length; ++l < u;) {
-            const f = i[l];
+        for (let u = i - 1, l = r.length; ++u < l;) {
+            const f = r[u];
             if (~(a = e(f, t, o)))
                 return c + a;
             o = 0, c += f.length;
         }
         return -1;
     }
-    return function(i, r) {
-        t = i;
+    return function(r, i) {
+        t = r;
         const s = this.data,
-            o = typeof r != "number" ? n(s, 0, 0) : _b(s, this._offsets, r, n);
+            o = typeof i != "number" ? n(s, 0, 0) : tm(s, this._offsets, i, n);
         return t = void 0, o;
     };
 }
-let ct = class extends Ut {};
+class rt extends At {}
 
-function a7(e, t) {
+function u9(e, t) {
     return t === null && e.length > 0 ? 0 : -1;
 }
 
-function c7(e, t) {
+function l9(e, t) {
     const {
         nullBitmap: n
     } = e;
     if (!n || e.nullCount <= 0)
         return -1;
-    let i = 0;
-    for (const r of new vb(n, e.offset + (t || 0), e.length, n, aM)) {
-        if (!r)
-            return i;
-        ++i;
+    let r = 0;
+    for (const i of new Qy(n, e.offset + (t || 0), e.length, n, Z_)) {
+        if (!i)
+            return r;
+        ++r;
     }
     return -1;
 }
 
-function Bt(e, t, n) {
+function gt(e, t, n) {
     if (t === void 0)
         return -1;
     if (t === null)
         switch (e.typeId) {
-            case F.Union:
+            case L.Union:
                 break;
-            case F.Dictionary:
+            case L.Dictionary:
                 break;
             default:
-                return c7(e, n);
+                return l9(e, n);
         }
-    const i = $n.getVisitFn(e),
-        r = Zc(t);
+    const r = Ze.getVisitFn(e),
+        i = la(t);
     for (let s = (n || 0) - 1, o = e.length; ++s < o;)
-        if (r(i(e, s)))
+        if (i(r(e, s)))
             return s;
     return -1;
 }
 
-function dM(e, t, n) {
-    const i = $n.getVisitFn(e),
-        r = Zc(t);
+function rx(e, t, n) {
+    const r = Ze.getVisitFn(e),
+        i = la(t);
     for (let s = (n || 0) - 1, o = e.length; ++s < o;)
-        if (r(i(e, s)))
+        if (i(r(e, s)))
             return s;
     return -1;
 }
-ct.prototype.visitNull = a7;
-ct.prototype.visitBool = Bt;
-ct.prototype.visitInt = Bt;
-ct.prototype.visitInt8 = Bt;
-ct.prototype.visitInt16 = Bt;
-ct.prototype.visitInt32 = Bt;
-ct.prototype.visitInt64 = Bt;
-ct.prototype.visitUint8 = Bt;
-ct.prototype.visitUint16 = Bt;
-ct.prototype.visitUint32 = Bt;
-ct.prototype.visitUint64 = Bt;
-ct.prototype.visitFloat = Bt;
-ct.prototype.visitFloat16 = Bt;
-ct.prototype.visitFloat32 = Bt;
-ct.prototype.visitFloat64 = Bt;
-ct.prototype.visitUtf8 = Bt;
-ct.prototype.visitLargeUtf8 = Bt;
-ct.prototype.visitBinary = Bt;
-ct.prototype.visitLargeBinary = Bt;
-ct.prototype.visitFixedSizeBinary = Bt;
-ct.prototype.visitDate = Bt;
-ct.prototype.visitDateDay = Bt;
-ct.prototype.visitDateMillisecond = Bt;
-ct.prototype.visitTimestamp = Bt;
-ct.prototype.visitTimestampSecond = Bt;
-ct.prototype.visitTimestampMillisecond = Bt;
-ct.prototype.visitTimestampMicrosecond = Bt;
-ct.prototype.visitTimestampNanosecond = Bt;
-ct.prototype.visitTime = Bt;
-ct.prototype.visitTimeSecond = Bt;
-ct.prototype.visitTimeMillisecond = Bt;
-ct.prototype.visitTimeMicrosecond = Bt;
-ct.prototype.visitTimeNanosecond = Bt;
-ct.prototype.visitDecimal = Bt;
-ct.prototype.visitList = Bt;
-ct.prototype.visitStruct = Bt;
-ct.prototype.visitUnion = Bt;
-ct.prototype.visitDenseUnion = dM;
-ct.prototype.visitSparseUnion = dM;
-ct.prototype.visitDictionary = Bt;
-ct.prototype.visitInterval = Bt;
-ct.prototype.visitIntervalDayTime = Bt;
-ct.prototype.visitIntervalYearMonth = Bt;
-ct.prototype.visitDuration = Bt;
-ct.prototype.visitDurationSecond = Bt;
-ct.prototype.visitDurationMillisecond = Bt;
-ct.prototype.visitDurationMicrosecond = Bt;
-ct.prototype.visitDurationNanosecond = Bt;
-ct.prototype.visitFixedSizeList = Bt;
-ct.prototype.visitMap = Bt;
-const Rd = new ct();
-let lt = class extends Ut {};
+rt.prototype.visitNull = u9;
+rt.prototype.visitBool = gt;
+rt.prototype.visitInt = gt;
+rt.prototype.visitInt8 = gt;
+rt.prototype.visitInt16 = gt;
+rt.prototype.visitInt32 = gt;
+rt.prototype.visitInt64 = gt;
+rt.prototype.visitUint8 = gt;
+rt.prototype.visitUint16 = gt;
+rt.prototype.visitUint32 = gt;
+rt.prototype.visitUint64 = gt;
+rt.prototype.visitFloat = gt;
+rt.prototype.visitFloat16 = gt;
+rt.prototype.visitFloat32 = gt;
+rt.prototype.visitFloat64 = gt;
+rt.prototype.visitUtf8 = gt;
+rt.prototype.visitLargeUtf8 = gt;
+rt.prototype.visitBinary = gt;
+rt.prototype.visitLargeBinary = gt;
+rt.prototype.visitFixedSizeBinary = gt;
+rt.prototype.visitDate = gt;
+rt.prototype.visitDateDay = gt;
+rt.prototype.visitDateMillisecond = gt;
+rt.prototype.visitTimestamp = gt;
+rt.prototype.visitTimestampSecond = gt;
+rt.prototype.visitTimestampMillisecond = gt;
+rt.prototype.visitTimestampMicrosecond = gt;
+rt.prototype.visitTimestampNanosecond = gt;
+rt.prototype.visitTime = gt;
+rt.prototype.visitTimeSecond = gt;
+rt.prototype.visitTimeMillisecond = gt;
+rt.prototype.visitTimeMicrosecond = gt;
+rt.prototype.visitTimeNanosecond = gt;
+rt.prototype.visitDecimal = gt;
+rt.prototype.visitList = gt;
+rt.prototype.visitStruct = gt;
+rt.prototype.visitUnion = gt;
+rt.prototype.visitDenseUnion = rx;
+rt.prototype.visitSparseUnion = rx;
+rt.prototype.visitDictionary = gt;
+rt.prototype.visitInterval = gt;
+rt.prototype.visitIntervalDayTime = gt;
+rt.prototype.visitIntervalYearMonth = gt;
+rt.prototype.visitDuration = gt;
+rt.prototype.visitDurationSecond = gt;
+rt.prototype.visitDurationMillisecond = gt;
+rt.prototype.visitDurationMicrosecond = gt;
+rt.prototype.visitDurationNanosecond = gt;
+rt.prototype.visitFixedSizeList = gt;
+rt.prototype.visitMap = gt;
+const ff = new rt();
+class st extends At {}
 
-function xt(e) {
+function ht(e) {
     const {
         type: t
     } = e;
-    if (e.nullCount === 0 && e.stride === 1 && (t.typeId === F.Timestamp || t instanceof Ps && t.bitWidth !== 64 || t instanceof Mu && t.bitWidth !== 64 || t instanceof Au && t.precision !== nn.HALF))
-        return new q_(e.data.length, (i) => {
-            const r = e.data[i];
-            return r.values.subarray(0, r.length)[Symbol.iterator]();
+    if (e.nullCount === 0 && e.stride === 1 && (t.typeId === L.Timestamp || t instanceof ki && t.bitWidth !== 64 || t instanceof _c && t.bitWidth !== 64 || t instanceof vc && t.precision !== De.HALF))
+        return new sb(e.data.length, (r) => {
+            const i = e.data[r];
+            return i.values.subarray(0, i.length)[Symbol.iterator]();
         });
     let n = 0;
-    return new q_(e.data.length, (i) => {
-        const s = e.data[i].length,
+    return new sb(e.data.length, (r) => {
+        const s = e.data[r].length,
             o = e.slice(n, n + s);
-        return n += s, new l7(o);
+        return n += s, new f9(o);
     });
 }
-let l7 = class {
+class f9 {
     constructor(t) {
         this.vector = t, this.index = 0;
     }
     next() {
             return this.index < this.vector.length ? {
                 value: this.vector.get(this.index++)
             } : {
                 done: !0,
                 value: null
             };
         }
         [Symbol.iterator]() {
             return this;
         }
-};
-lt.prototype.visitNull = xt;
-lt.prototype.visitBool = xt;
-lt.prototype.visitInt = xt;
-lt.prototype.visitInt8 = xt;
-lt.prototype.visitInt16 = xt;
-lt.prototype.visitInt32 = xt;
-lt.prototype.visitInt64 = xt;
-lt.prototype.visitUint8 = xt;
-lt.prototype.visitUint16 = xt;
-lt.prototype.visitUint32 = xt;
-lt.prototype.visitUint64 = xt;
-lt.prototype.visitFloat = xt;
-lt.prototype.visitFloat16 = xt;
-lt.prototype.visitFloat32 = xt;
-lt.prototype.visitFloat64 = xt;
-lt.prototype.visitUtf8 = xt;
-lt.prototype.visitLargeUtf8 = xt;
-lt.prototype.visitBinary = xt;
-lt.prototype.visitLargeBinary = xt;
-lt.prototype.visitFixedSizeBinary = xt;
-lt.prototype.visitDate = xt;
-lt.prototype.visitDateDay = xt;
-lt.prototype.visitDateMillisecond = xt;
-lt.prototype.visitTimestamp = xt;
-lt.prototype.visitTimestampSecond = xt;
-lt.prototype.visitTimestampMillisecond = xt;
-lt.prototype.visitTimestampMicrosecond = xt;
-lt.prototype.visitTimestampNanosecond = xt;
-lt.prototype.visitTime = xt;
-lt.prototype.visitTimeSecond = xt;
-lt.prototype.visitTimeMillisecond = xt;
-lt.prototype.visitTimeMicrosecond = xt;
-lt.prototype.visitTimeNanosecond = xt;
-lt.prototype.visitDecimal = xt;
-lt.prototype.visitList = xt;
-lt.prototype.visitStruct = xt;
-lt.prototype.visitUnion = xt;
-lt.prototype.visitDenseUnion = xt;
-lt.prototype.visitSparseUnion = xt;
-lt.prototype.visitDictionary = xt;
-lt.prototype.visitInterval = xt;
-lt.prototype.visitIntervalDayTime = xt;
-lt.prototype.visitIntervalYearMonth = xt;
-lt.prototype.visitDuration = xt;
-lt.prototype.visitDurationSecond = xt;
-lt.prototype.visitDurationMillisecond = xt;
-lt.prototype.visitDurationMicrosecond = xt;
-lt.prototype.visitDurationNanosecond = xt;
-lt.prototype.visitFixedSizeList = xt;
-lt.prototype.visitMap = xt;
-const Sb = new lt();
-var pM;
-const yM = {},
-    mM = {};
-let Ne = class Ao {
+}
+st.prototype.visitNull = ht;
+st.prototype.visitBool = ht;
+st.prototype.visitInt = ht;
+st.prototype.visitInt8 = ht;
+st.prototype.visitInt16 = ht;
+st.prototype.visitInt32 = ht;
+st.prototype.visitInt64 = ht;
+st.prototype.visitUint8 = ht;
+st.prototype.visitUint16 = ht;
+st.prototype.visitUint32 = ht;
+st.prototype.visitUint64 = ht;
+st.prototype.visitFloat = ht;
+st.prototype.visitFloat16 = ht;
+st.prototype.visitFloat32 = ht;
+st.prototype.visitFloat64 = ht;
+st.prototype.visitUtf8 = ht;
+st.prototype.visitLargeUtf8 = ht;
+st.prototype.visitBinary = ht;
+st.prototype.visitLargeBinary = ht;
+st.prototype.visitFixedSizeBinary = ht;
+st.prototype.visitDate = ht;
+st.prototype.visitDateDay = ht;
+st.prototype.visitDateMillisecond = ht;
+st.prototype.visitTimestamp = ht;
+st.prototype.visitTimestampSecond = ht;
+st.prototype.visitTimestampMillisecond = ht;
+st.prototype.visitTimestampMicrosecond = ht;
+st.prototype.visitTimestampNanosecond = ht;
+st.prototype.visitTime = ht;
+st.prototype.visitTimeSecond = ht;
+st.prototype.visitTimeMillisecond = ht;
+st.prototype.visitTimeMicrosecond = ht;
+st.prototype.visitTimeNanosecond = ht;
+st.prototype.visitDecimal = ht;
+st.prototype.visitList = ht;
+st.prototype.visitStruct = ht;
+st.prototype.visitUnion = ht;
+st.prototype.visitDenseUnion = ht;
+st.prototype.visitSparseUnion = ht;
+st.prototype.visitDictionary = ht;
+st.prototype.visitInterval = ht;
+st.prototype.visitIntervalDayTime = ht;
+st.prototype.visitIntervalYearMonth = ht;
+st.prototype.visitDuration = ht;
+st.prototype.visitDurationSecond = ht;
+st.prototype.visitDurationMillisecond = ht;
+st.prototype.visitDurationMicrosecond = ht;
+st.prototype.visitDurationNanosecond = ht;
+st.prototype.visitFixedSizeList = ht;
+st.prototype.visitMap = ht;
+const nm = new st();
+var ix;
+const sx = {},
+    ox = {};
+let ce = class os {
     constructor(t) {
-        var n, i, r;
-        const s = t[0] instanceof Ao ? t.flatMap((a) => a.data) : t;
-        if (s.length === 0 || s.some((a) => !(a instanceof de)))
+        var n, r, i;
+        const s = t[0] instanceof os ? t.flatMap((a) => a.data) : t;
+        if (s.length === 0 || s.some((a) => !(a instanceof jt)))
             throw new TypeError("Vector constructor expects an Array of Data instances.");
         const o = (n = s[0]) === null || n === void 0 ? void 0 : n.type;
         switch (s.length) {
             case 0:
                 this._offsets = [0];
                 break;
             case 1: {
                 const {
                     get: a,
                     set: c,
-                    indexOf: l
-                } = yM[o.typeId], u = s[0];
-                this.isValid = (f) => xb(u, f), this.get = (f) => a(u, f), this.set = (f, h) => c(u, f, h), this.indexOf = (f) => l(u, f), this._offsets = [0, u.length];
+                    indexOf: u
+                } = sx[o.typeId], l = s[0];
+                this.isValid = (f) => em(l, f), this.get = (f) => a(l, f), this.set = (f, h) => c(l, f, h), this.indexOf = (f) => u(l, f), this._offsets = [0, l.length];
                 break;
             }
             default:
-                Object.setPrototypeOf(this, mM[o.typeId]), this._offsets = lM(s);
+                Object.setPrototypeOf(this, ox[o.typeId]), this._offsets = Q_(s);
                 break;
         }
-        this.data = s, this.type = o, this.stride = Cr(o), this.numChildren = (r = (i = o.children) === null || i === void 0 ? void 0 : i.length) !== null && r !== void 0 ? r : 0, this.length = this._offsets.at(-1);
+        this.data = s, this.type = o, this.stride = Ur(o), this.numChildren = (i = (r = o.children) === null || r === void 0 ? void 0 : r.length) !== null && i !== void 0 ? i : 0, this.length = this._offsets.at(-1);
     }
     /**
      * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
      */
     get byteLength() {
         return this.data.reduce((t, n) => t + n.byteLength, 0);
     }
     /**
      * Whether this Vector's elements can contain null values.
      */
     get nullable() {
-        return o7(this.data);
+        return c9(this.data);
     }
     /**
      * The number of null elements in this Vector.
      */
     get nullCount() {
-        return cM(this.data);
+        return K_(this.data);
     }
     /**
      * The Array or TypedArray constructor used for the JS representation
      *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
      */
     get ArrayType() {
         return this.type.ArrayType;
@@ -5107,15 +5115,15 @@
     get[Symbol.toStringTag]() {
         return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
     }
     /**
      * The name of this Vector.
      */
     get VectorName() {
-        return `${F[this.type.typeId]}Vector`;
+        return `${L[this.type.typeId]}Vector`;
     }
     /**
      * Check whether an element is null.
      * @param index The index at which to read the validity bitmap.
      */
     // @ts-ignore
     isValid(t) {
@@ -5148,33 +5156,33 @@
     includes(t, n) {
         return this.indexOf(t, n) > -1;
     }
     /**
      * Iterator for the Vector's elements.
      */
     [Symbol.iterator]() {
-        return Sb.visit(this);
+        return nm.visit(this);
     }
     /**
      * Combines two or more Vectors of the same type.
      * @param others Additional Vectors to add to the end of this Vector.
      */
     concat(...t) {
-        return new Ao(this.data.concat(t.flatMap((n) => n.data).flat(Number.POSITIVE_INFINITY)));
+        return new os(this.data.concat(t.flatMap((n) => n.data).flat(Number.POSITIVE_INFINITY)));
     }
     /**
      * Return a zero-copy sub-section of this Vector.
      * @param start The beginning of the specified portion of the Vector.
      * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
      */
     slice(t, n) {
-        return new Ao(oM(this, t, n, ({
-            data: i,
-            _offsets: r
-        }, s, o) => uM(i, r, s, o)));
+        return new os(J_(this, t, n, ({
+            data: r,
+            _offsets: i
+        }, s, o) => tx(r, i, s, o)));
     }
     toJSON() {
         return [...this];
     }
     /**
      * Return a JavaScript Array or TypedArray of the Vector's elements.
      *
@@ -5186,35 +5194,35 @@
      *
      * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
      */
     toArray() {
         const {
             type: t,
             data: n,
-            length: i,
-            stride: r,
+            length: r,
+            stride: i,
             ArrayType: s
         } = this;
         switch (t.typeId) {
-            case F.Int:
-            case F.Float:
-            case F.Decimal:
-            case F.Time:
-            case F.Timestamp:
+            case L.Int:
+            case L.Float:
+            case L.Decimal:
+            case L.Time:
+            case L.Timestamp:
                 switch (n.length) {
                     case 0:
                         return new s();
                     case 1:
-                        return n[0].values.subarray(0, i * r);
+                        return n[0].values.subarray(0, r * i);
                     default:
                         return n.reduce((o, {
                             values: a,
                             length: c
-                        }) => (o.array.set(a.subarray(0, c * r), o.offset), o.offset += c * r, o), {
-                            array: new s(i * r),
+                        }) => (o.array.set(a.subarray(0, c * i), o.offset), o.offset += c * i, o), {
+                            array: new s(r * i),
                             offset: 0
                         }).array;
                 }
         }
         return [...this];
     }
     /**
@@ -5227,1653 +5235,1653 @@
     }
     /**
      * Returns a child Vector by name, or null if this Vector has no child with the given name.
      * @param name The name of the child to retrieve.
      */
     getChild(t) {
         var n;
-        return this.getChildAt((n = this.type.children) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
+        return this.getChildAt((n = this.type.children) === null || n === void 0 ? void 0 : n.findIndex((r) => r.name === t));
     }
     /**
      * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
      * @param index The index of the child to retrieve.
      */
     getChildAt(t) {
-        return t > -1 && t < this.numChildren ? new Ao(this.data.map(({
+        return t > -1 && t < this.numChildren ? new os(this.data.map(({
             children: n
         }) => n[t])) : null;
     }
     get isMemoized() {
-        return gt.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1;
+        return Q.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1;
     }
     /**
      * Adds memoization to the Vector's {@link get} method. For dictionary
      * vectors, this method return a vector that memoizes only the dictionary
      * values.
      *
      * Memoization is very useful when decoding a value is expensive such as
      * Utf8. The memoization creates a cache of the size of the Vector and
      * therefore increases memory usage.
      *
      * @returns A new vector that memoizes calls to {@link get}.
      */
     memoize() {
-        if (gt.isDictionary(this.type)) {
-            const t = new Y_(this.data[0].dictionary),
-                n = this.data.map((i) => {
-                    const r = i.clone();
-                    return r.dictionary = t, r;
+        if (Q.isDictionary(this.type)) {
+            const t = new hf(this.data[0].dictionary),
+                n = this.data.map((r) => {
+                    const i = r.clone();
+                    return i.dictionary = t, i;
                 });
-            return new Ao(n);
+            return new os(n);
         }
-        return new Y_(this);
+        return new hf(this);
     }
     /**
      * Returns a vector without memoization of the {@link get} method. If this
      * vector is not memoized, this method returns this vector.
      *
      * @returns A new vector without memoization.
      */
     unmemoize() {
-        if (gt.isDictionary(this.type) && this.isMemoized) {
+        if (Q.isDictionary(this.type) && this.isMemoized) {
             const t = this.data[0].dictionary.unmemoize(),
-                n = this.data.map((i) => {
-                    const r = i.clone();
-                    return r.dictionary = t, r;
+                n = this.data.map((r) => {
+                    const i = r.clone();
+                    return i.dictionary = t, i;
                 });
-            return new Ao(n);
+            return new os(n);
         }
         return this;
     }
 };
-pM = Symbol.toStringTag;
-Ne[pM] = ((e) => {
-    e.type = gt.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
-    const t = Object.keys(F).map((n) => F[n]).filter((n) => typeof n == "number" && n !== F.NONE);
+ix = Symbol.toStringTag;
+ce[ix] = ((e) => {
+    e.type = Q.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
+    const t = Object.keys(L).map((n) => L[n]).filter((n) => typeof n == "number" && n !== L.NONE);
     for (const n of t) {
-        const i = $n.getVisitFnByTypeId(n),
-            r = ci.getVisitFnByTypeId(n),
-            s = Rd.getVisitFnByTypeId(n);
-        yM[n] = {
-            get: i,
-            set: r,
+        const r = Ze.getVisitFnByTypeId(n),
+            i = An.getVisitFnByTypeId(n),
+            s = ff.getVisitFnByTypeId(n);
+        sx[n] = {
+            get: r,
+            set: i,
             indexOf: s
-        }, mM[n] = Object.create(e, {
+        }, ox[n] = Object.create(e, {
             isValid: {
-                value: Ld(xb)
+                value: lf(em)
             },
             get: {
-                value: Ld($n.getVisitFnByTypeId(n))
+                value: lf(Ze.getVisitFnByTypeId(n))
             },
             set: {
-                value: fM(ci.getVisitFnByTypeId(n))
+                value: ex(An.getVisitFnByTypeId(n))
             },
             indexOf: {
-                value: hM(Rd.getVisitFnByTypeId(n))
+                value: nx(ff.getVisitFnByTypeId(n))
             }
         });
     }
     return "Vector";
-})(Ne.prototype);
-let Y_ = class gM extends Ne {
-        constructor(t) {
-            super(t.data);
-            const n = this.get,
-                i = this.set,
-                r = this.slice,
-                s = new Array(this.length);
-            Object.defineProperty(this, "get", {
-                value(o) {
-                    const a = s[o];
-                    if (a !== void 0)
-                        return a;
-                    const c = n.call(this, o);
-                    return s[o] = c, c;
-                }
-            }), Object.defineProperty(this, "set", {
-                value(o, a) {
-                    i.call(this, o, a), s[o] = a;
-                }
-            }), Object.defineProperty(this, "slice", {
-                value: (o, a) => new gM(r.call(this, o, a))
-            }), Object.defineProperty(this, "isMemoized", {
-                value: !0
-            }), Object.defineProperty(this, "unmemoize", {
-                value: () => new Ne(this.data)
-            }), Object.defineProperty(this, "memoize", {
-                value: () => this
-            });
-        }
-    },
-    Ig = class {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        /**
-         * Index to the start of the RecordBlock (note this is past the Message header)
-         */
-        offset() {
-            return this.bb.readInt64(this.bb_pos);
-        }
-        /**
-         * Length of the metadata
-         */
-        metaDataLength() {
-            return this.bb.readInt32(this.bb_pos + 8);
-        }
-        /**
-         * Length of the data (this is aligned so there can be a gap between this and
-         * the metadata).
-         */
-        bodyLength() {
-            return this.bb.readInt64(this.bb_pos + 16);
-        }
-        static sizeOf() {
-            return 24;
-        }
-        static createBlock(t, n, i, r) {
-            return t.prep(8, 24), t.writeInt64(BigInt(r ?? 0)), t.pad(4), t.writeInt32(i), t.writeInt64(BigInt(n ?? 0)), t.offset();
-        }
-    },
-    Vi = class Ag {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsFooter(t, n) {
-            return (n || new Ag()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsFooter(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ag()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        version() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : Ee.V1;
-        }
-        schema(t) {
-            const n = this.bb.__offset(this.bb_pos, 6);
-            return n ? (t || new Yi()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
-        }
-        dictionaries(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 8);
-            return i ? (n || new Ig()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
-        }
-        dictionariesLength() {
-            const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        recordBatches(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 10);
-            return i ? (n || new Ig()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
-        }
-        recordBatchesLength() {
-            const t = this.bb.__offset(this.bb_pos, 10);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        /**
-         * User-defined metadata
-         */
-        customMetadata(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 12);
-            return i ? (n || new ni()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-        }
-        customMetadataLength() {
-            const t = this.bb.__offset(this.bb_pos, 12);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        static startFooter(t) {
-            t.startObject(5);
-        }
-        static addVersion(t, n) {
-            t.addFieldInt16(0, n, Ee.V1);
-        }
-        static addSchema(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static addDictionaries(t, n) {
-            t.addFieldOffset(2, n, 0);
-        }
-        static startDictionariesVector(t, n) {
-            t.startVector(24, n, 8);
-        }
-        static addRecordBatches(t, n) {
-            t.addFieldOffset(3, n, 0);
-        }
-        static startRecordBatchesVector(t, n) {
-            t.startVector(24, n, 8);
-        }
-        static addCustomMetadata(t, n) {
-            t.addFieldOffset(4, n, 0);
-        }
-        static createCustomMetadataVector(t, n) {
-            t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
-            return t.endVector();
-        }
-        static startCustomMetadataVector(t, n) {
-            t.startVector(4, n, 4);
-        }
-        static endFooter(t) {
-            return t.endObject();
-        }
-        static finishFooterBuffer(t, n) {
-            t.finish(n);
-        }
-        static finishSizePrefixedFooterBuffer(t, n) {
-            t.finish(n, void 0, !0);
-        }
-    },
-    _e = class Mo {
-        constructor(t = [], n, i, r = Ee.V5) {
-            this.fields = t || [], this.metadata = n || /* @__PURE__ */ new Map(), i || (i = $g(t)), this.dictionaries = i, this.metadataVersion = r;
-        }
-        get[Symbol.toStringTag]() {
-            return "Schema";
-        }
-        get names() {
-            return this.fields.map((t) => t.name);
-        }
-        toString() {
-            return `Schema<{ ${this.fields.map((t, n) => `${n}: ${t}`).join(", ")} }>`;
-        }
-        /**
-         * Construct a new Schema containing only specified fields.
-         *
-         * @param fieldNames Names of fields to keep.
-         * @returns A new Schema of fields matching the specified names.
-         */
-        select(t) {
-            const n = new Set(t),
-                i = this.fields.filter((r) => n.has(r.name));
-            return new Mo(i, this.metadata);
-        }
-        /**
-         * Construct a new Schema containing only fields at the specified indices.
-         *
-         * @param fieldIndices Indices of fields to keep.
-         * @returns A new Schema of fields at the specified indices.
-         */
-        selectAt(t) {
-            const n = t.map((i) => this.fields[i]).filter(Boolean);
-            return new Mo(n, this.metadata);
-        }
-        assign(...t) {
-            const n = t[0] instanceof Mo ? t[0] : Array.isArray(t[0]) ? new Mo(t[0]) : new Mo(t),
-                i = [...this.fields],
-                r = ih(ih( /* @__PURE__ */ new Map(), this.metadata), n.metadata),
-                s = n.fields.filter((a) => {
-                    const c = i.findIndex((l) => l.name === a.name);
-                    return ~c ? (i[c] = a.clone({
-                        metadata: ih(ih( /* @__PURE__ */ new Map(), i[c].metadata), a.metadata)
-                    })) && !1 : !0;
-                }),
-                o = $g(s, /* @__PURE__ */ new Map());
-            return new Mo([...i, ...s], r, new Map([...this.dictionaries, ...o]));
-        }
-    };
-_e.prototype.fields = null;
-_e.prototype.metadata = null;
-_e.prototype.dictionaries = null;
-let Te = class Mg {
+})(ce.prototype);
+class hf extends ce {
+    constructor(t) {
+        super(t.data);
+        const n = this.get,
+            r = this.set,
+            i = this.slice,
+            s = new Array(this.length);
+        Object.defineProperty(this, "get", {
+            value(o) {
+                const a = s[o];
+                if (a !== void 0)
+                    return a;
+                const c = n.call(this, o);
+                return s[o] = c, c;
+            }
+        }), Object.defineProperty(this, "set", {
+            value(o, a) {
+                r.call(this, o, a), s[o] = a;
+            }
+        }), Object.defineProperty(this, "slice", {
+            value: (o, a) => new hf(i.call(this, o, a))
+        }), Object.defineProperty(this, "isMemoized", {
+            value: !0
+        }), Object.defineProperty(this, "unmemoize", {
+            value: () => new ce(this.data)
+        }), Object.defineProperty(this, "memoize", {
+            value: () => this
+        });
+    }
+}
+class h0 {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    /**
+     * Index to the start of the RecordBlock (note this is past the Message header)
+     */
+    offset() {
+        return this.bb.readInt64(this.bb_pos);
+    }
+    /**
+     * Length of the metadata
+     */
+    metaDataLength() {
+        return this.bb.readInt32(this.bb_pos + 8);
+    }
+    /**
+     * Length of the data (this is aligned so there can be a gap between this and
+     * the metadata).
+     */
+    bodyLength() {
+        return this.bb.readInt64(this.bb_pos + 16);
+    }
+    static sizeOf() {
+        return 24;
+    }
+    static createBlock(t, n, r, i) {
+        return t.prep(8, 24), t.writeInt64(BigInt(i ?? 0)), t.pad(4), t.writeInt32(r), t.writeInt64(BigInt(n ?? 0)), t.offset();
+    }
+}
+class nn {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsFooter(t, n) {
+        return (n || new nn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsFooter(t, n) {
+        return t.setPosition(t.position() + qt), (n || new nn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    version() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : fe.V1;
+    }
+    schema(t) {
+        const n = this.bb.__offset(this.bb_pos, 6);
+        return n ? (t || new tr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
+    }
+    dictionaries(t, n) {
+        const r = this.bb.__offset(this.bb_pos, 8);
+        return r ? (n || new h0()).__init(this.bb.__vector(this.bb_pos + r) + t * 24, this.bb) : null;
+    }
+    dictionariesLength() {
+        const t = this.bb.__offset(this.bb_pos, 8);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
+    }
+    recordBatches(t, n) {
+        const r = this.bb.__offset(this.bb_pos, 10);
+        return r ? (n || new h0()).__init(this.bb.__vector(this.bb_pos + r) + t * 24, this.bb) : null;
+    }
+    recordBatchesLength() {
+        const t = this.bb.__offset(this.bb_pos, 10);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
+    }
+    /**
+     * User-defined metadata
+     */
+    customMetadata(t, n) {
+        const r = this.bb.__offset(this.bb_pos, 12);
+        return r ? (n || new he()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
+    }
+    customMetadataLength() {
+        const t = this.bb.__offset(this.bb_pos, 12);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
+    }
+    static startFooter(t) {
+        t.startObject(5);
+    }
+    static addVersion(t, n) {
+        t.addFieldInt16(0, n, fe.V1);
+    }
+    static addSchema(t, n) {
+        t.addFieldOffset(1, n, 0);
+    }
+    static addDictionaries(t, n) {
+        t.addFieldOffset(2, n, 0);
+    }
+    static startDictionariesVector(t, n) {
+        t.startVector(24, n, 8);
+    }
+    static addRecordBatches(t, n) {
+        t.addFieldOffset(3, n, 0);
+    }
+    static startRecordBatchesVector(t, n) {
+        t.startVector(24, n, 8);
+    }
+    static addCustomMetadata(t, n) {
+        t.addFieldOffset(4, n, 0);
+    }
+    static createCustomMetadataVector(t, n) {
+        t.startVector(4, n.length, 4);
+        for (let r = n.length - 1; r >= 0; r--)
+            t.addOffset(n[r]);
+        return t.endVector();
+    }
+    static startCustomMetadataVector(t, n) {
+        t.startVector(4, n, 4);
+    }
+    static endFooter(t) {
+        return t.endObject();
+    }
+    static finishFooterBuffer(t, n) {
+        t.finish(n);
+    }
+    static finishSizePrefixedFooterBuffer(t, n) {
+        t.finish(n, void 0, !0);
+    }
+}
+class Pt {
+    constructor(t = [], n, r, i = fe.V5) {
+        this.fields = t || [], this.metadata = n || /* @__PURE__ */ new Map(), r || (r = d0(t)), this.dictionaries = r, this.metadataVersion = i;
+    }
+    get[Symbol.toStringTag]() {
+        return "Schema";
+    }
+    get names() {
+        return this.fields.map((t) => t.name);
+    }
+    toString() {
+        return `Schema<{ ${this.fields.map((t, n) => `${n}: ${t}`).join(", ")} }>`;
+    }
+    /**
+     * Construct a new Schema containing only specified fields.
+     *
+     * @param fieldNames Names of fields to keep.
+     * @returns A new Schema of fields matching the specified names.
+     */
+    select(t) {
+        const n = new Set(t),
+            r = this.fields.filter((i) => n.has(i.name));
+        return new Pt(r, this.metadata);
+    }
+    /**
+     * Construct a new Schema containing only fields at the specified indices.
+     *
+     * @param fieldIndices Indices of fields to keep.
+     * @returns A new Schema of fields at the specified indices.
+     */
+    selectAt(t) {
+        const n = t.map((r) => this.fields[r]).filter(Boolean);
+        return new Pt(n, this.metadata);
+    }
+    assign(...t) {
+        const n = t[0] instanceof Pt ? t[0] : Array.isArray(t[0]) ? new Pt(t[0]) : new Pt(t),
+            r = [...this.fields],
+            i = zu(zu( /* @__PURE__ */ new Map(), this.metadata), n.metadata),
+            s = n.fields.filter((a) => {
+                const c = r.findIndex((u) => u.name === a.name);
+                return ~c ? (r[c] = a.clone({
+                    metadata: zu(zu( /* @__PURE__ */ new Map(), r[c].metadata), a.metadata)
+                })) && !1 : !0;
+            }),
+            o = d0(s, /* @__PURE__ */ new Map());
+        return new Pt([...r, ...s], i, new Map([...this.dictionaries, ...o]));
+    }
+}
+Pt.prototype.fields = null;
+Pt.prototype.metadata = null;
+Pt.prototype.dictionaries = null;
+class Kt {
     /** @nocollapse */
     static new(...t) {
-        let [n, i, r, s] = t;
+        let [n, r, i, s] = t;
         return t[0] && typeof t[0] == "object" && ({
             name: n
-        } = t[0], i === void 0 && (i = t[0].type), r === void 0 && (r = t[0].nullable), s === void 0 && (s = t[0].metadata)), new Mg(`${n}`, i, r, s);
+        } = t[0], r === void 0 && (r = t[0].type), i === void 0 && (i = t[0].nullable), s === void 0 && (s = t[0].metadata)), new Kt(`${n}`, r, i, s);
     }
-    constructor(t, n, i = !1, r) {
-        this.name = t, this.type = n, this.nullable = i, this.metadata = r || /* @__PURE__ */ new Map();
+    constructor(t, n, r = !1, i) {
+        this.name = t, this.type = n, this.nullable = r, this.metadata = i || /* @__PURE__ */ new Map();
     }
     get typeId() {
         return this.type.typeId;
     }
     get[Symbol.toStringTag]() {
         return "Field";
     }
     toString() {
         return `${this.name}: ${this.type}`;
     }
     clone(...t) {
-        let [n, i, r, s] = t;
-        return !t[0] || typeof t[0] != "object" ? [n = this.name, i = this.type, r = this.nullable, s = this.metadata] = t : {
+        let [n, r, i, s] = t;
+        return !t[0] || typeof t[0] != "object" ? [n = this.name, r = this.type, i = this.nullable, s = this.metadata] = t : {
             name: n = this.name,
-            type: i = this.type,
-            nullable: r = this.nullable,
+            type: r = this.type,
+            nullable: i = this.nullable,
             metadata: s = this.metadata
-        } = t[0], Mg.new(n, i, r, s);
+        } = t[0], Kt.new(n, r, i, s);
     }
-};
-Te.prototype.type = null;
-Te.prototype.name = null;
-Te.prototype.nullable = null;
-Te.prototype.metadata = null;
+}
+Kt.prototype.type = null;
+Kt.prototype.name = null;
+Kt.prototype.nullable = null;
+Kt.prototype.metadata = null;
 
-function ih(e, t) {
+function zu(e, t) {
     return new Map([...e || /* @__PURE__ */ new Map(), ...t || /* @__PURE__ */ new Map()]);
 }
 
-function $g(e, t = /* @__PURE__ */ new Map()) {
-    for (let n = -1, i = e.length; ++n < i;) {
+function d0(e, t = /* @__PURE__ */ new Map()) {
+    for (let n = -1, r = e.length; ++n < r;) {
         const s = e[n].type;
-        if (gt.isDictionary(s)) {
+        if (Q.isDictionary(s)) {
             if (!t.has(s.id))
                 t.set(s.id, s.dictionary);
             else if (t.get(s.id) !== s.dictionary)
                 throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
         }
-        s.children && s.children.length > 0 && $g(s.children, t);
+        s.children && s.children.length > 0 && d0(s.children, t);
     }
     return t;
 }
-var u7 = Cy,
-    f7 = ur;
-let Ib = class {
-        /** @nocollapse */
-        static decode(t) {
-            t = new f7(Yt(t));
-            const n = Vi.getRootAsFooter(t),
-                i = _e.decode(n.schema(), /* @__PURE__ */ new Map(), n.version());
-            return new h7(i, n);
-        }
-        /** @nocollapse */
-        static encode(t) {
-            const n = new u7(),
-                i = _e.encode(n, t.schema);
-            Vi.startRecordBatchesVector(n, t.numRecordBatches);
-            for (const o of [...t.recordBatches()].slice().reverse())
-                Cd.encode(n, o);
-            const r = n.endVector();
-            Vi.startDictionariesVector(n, t.numDictionaries);
-            for (const o of [...t.dictionaryBatches()].slice().reverse())
-                Cd.encode(n, o);
-            const s = n.endVector();
-            return Vi.startFooter(n), Vi.addSchema(n, i), Vi.addVersion(n, Ee.V5), Vi.addRecordBatches(n, r), Vi.addDictionaries(n, s), Vi.finishFooterBuffer(n, Vi.endFooter(n)), n.asUint8Array();
-        }
-        get numRecordBatches() {
-            return this._recordBatches.length;
-        }
-        get numDictionaries() {
-            return this._dictionaryBatches.length;
-        }
-        constructor(t, n = Ee.V5, i, r) {
-                this.schema = t, this.version = n, i && (this._recordBatches = i), r && (this._dictionaryBatches = r);
-            }
-            * recordBatches() {
-                for (let t, n = -1, i = this.numRecordBatches; ++n < i;)
-                    (t = this.getRecordBatch(n)) && (yield t);
-            }
-            * dictionaryBatches() {
-                for (let t, n = -1, i = this.numDictionaries; ++n < i;)
-                    (t = this.getDictionaryBatch(n)) && (yield t);
-            }
-        getRecordBatch(t) {
-            return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null;
-        }
-        getDictionaryBatch(t) {
-            return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null;
-        }
-    },
-    h7 = class extends Ib {
-        get numRecordBatches() {
-            return this._footer.recordBatchesLength();
-        }
-        get numDictionaries() {
-            return this._footer.dictionariesLength();
-        }
-        constructor(t, n) {
-            super(t, n.version()), this._footer = n;
-        }
-        getRecordBatch(t) {
-            if (t >= 0 && t < this.numRecordBatches) {
-                const n = this._footer.recordBatches(t);
-                if (n)
-                    return Cd.decode(n);
-            }
-            return null;
+var h9 = Nv,
+    d9 = Fo;
+class rm {
+    /** @nocollapse */
+    static decode(t) {
+        t = new d9(Dt(t));
+        const n = nn.getRootAsFooter(t),
+            r = Pt.decode(n.schema(), /* @__PURE__ */ new Map(), n.version());
+        return new p9(r, n);
+    }
+    /** @nocollapse */
+    static encode(t) {
+        const n = new h9(),
+            r = Pt.encode(n, t.schema);
+        nn.startRecordBatchesVector(n, t.numRecordBatches);
+        for (const o of [...t.recordBatches()].slice().reverse())
+            Po.encode(n, o);
+        const i = n.endVector();
+        nn.startDictionariesVector(n, t.numDictionaries);
+        for (const o of [...t.dictionaryBatches()].slice().reverse())
+            Po.encode(n, o);
+        const s = n.endVector();
+        return nn.startFooter(n), nn.addSchema(n, r), nn.addVersion(n, fe.V5), nn.addRecordBatches(n, i), nn.addDictionaries(n, s), nn.finishFooterBuffer(n, nn.endFooter(n)), n.asUint8Array();
+    }
+    get numRecordBatches() {
+        return this._recordBatches.length;
+    }
+    get numDictionaries() {
+        return this._dictionaryBatches.length;
+    }
+    constructor(t, n = fe.V5, r, i) {
+            this.schema = t, this.version = n, r && (this._recordBatches = r), i && (this._dictionaryBatches = i);
         }
-        getDictionaryBatch(t) {
-            if (t >= 0 && t < this.numDictionaries) {
-                const n = this._footer.dictionaries(t);
-                if (n)
-                    return Cd.decode(n);
-            }
-            return null;
+        * recordBatches() {
+            for (let t, n = -1, r = this.numRecordBatches; ++n < r;)
+                (t = this.getRecordBatch(n)) && (yield t);
         }
-    },
-    Cd = class bM {
-        /** @nocollapse */
-        static decode(t) {
-            return new bM(t.metaDataLength(), t.bodyLength(), t.offset());
+        * dictionaryBatches() {
+            for (let t, n = -1, r = this.numDictionaries; ++n < r;)
+                (t = this.getDictionaryBatch(n)) && (yield t);
         }
-        /** @nocollapse */
-        static encode(t, n) {
-            const {
-                metaDataLength: i
-            } = n, r = BigInt(n.offset), s = BigInt(n.bodyLength);
-            return Ig.createBlock(t, r, i, s);
+    getRecordBatch(t) {
+        return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null;
+    }
+    getDictionaryBatch(t) {
+        return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null;
+    }
+}
+class p9 extends rm {
+    get numRecordBatches() {
+        return this._footer.recordBatchesLength();
+    }
+    get numDictionaries() {
+        return this._footer.dictionariesLength();
+    }
+    constructor(t, n) {
+        super(t, n.version()), this._footer = n;
+    }
+    getRecordBatch(t) {
+        if (t >= 0 && t < this.numRecordBatches) {
+            const n = this._footer.recordBatches(t);
+            if (n)
+                return Po.decode(n);
         }
-        constructor(t, n, i) {
-            this.metaDataLength = t, this.offset = pn(i), this.bodyLength = pn(n);
+        return null;
+    }
+    getDictionaryBatch(t) {
+        if (t >= 0 && t < this.numDictionaries) {
+            const n = this._footer.dictionaries(t);
+            if (n)
+                return Po.decode(n);
         }
-    };
-const xe = Object.freeze({
+        return null;
+    }
+}
+class Po {
+    /** @nocollapse */
+    static decode(t) {
+        return new Po(t.metaDataLength(), t.bodyLength(), t.offset());
+    }
+    /** @nocollapse */
+    static encode(t, n) {
+        const {
+            metaDataLength: r
+        } = n, i = BigInt(n.offset), s = BigInt(n.bodyLength);
+        return h0.createBlock(t, i, r, s);
+    }
+    constructor(t, n, r) {
+        this.metaDataLength = t, this.offset = Pe(r), this.bodyLength = Pe(n);
+    }
+}
+const ne = Object.freeze({
     done: !0,
     value: void 0
 });
-let W_ = class {
-        constructor(t) {
-            this._json = t;
-        }
-        get schema() {
-            return this._json.schema;
-        }
-        get batches() {
-            return this._json.batches || [];
-        }
-        get dictionaries() {
-            return this._json.dictionaries || [];
-        }
-    },
-    wM = class {
-        tee() {
-            return this._getDOMStream().tee();
-        }
-        pipe(t, n) {
-            return this._getNodeStream().pipe(t, n);
-        }
-        pipeTo(t, n) {
-            return this._getDOMStream().pipeTo(t, n);
-        }
-        pipeThrough(t, n) {
-            return this._getDOMStream().pipeThrough(t, n);
-        }
-        _getDOMStream() {
-            return this._DOMStream || (this._DOMStream = this.toDOMStream());
-        }
-        _getNodeStream() {
-            return this._nodeStream || (this._nodeStream = this.toNodeStream());
-        }
-    },
-    d7 = class extends wM {
-        constructor() {
-            super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise((t) => this._closedPromiseResolve = t);
-        }
-        get closed() {
-            return this._closedPromise;
-        }
-        cancel(t) {
-            return W(this, void 0, void 0, function*() {
-                yield this.return(t);
-            });
-        }
-        write(t) {
-            this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({
-                done: !1,
-                value: t
-            }));
-        }
-        abort(t) {
-            this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = {
-                error: t
-            } : this.resolvers.shift().reject({
-                done: !0,
-                value: t
-            }));
-        }
-        close() {
-                if (this._closedPromiseResolve) {
-                    const {
-                        resolvers: t
-                    } = this;
-                    for (; t.length > 0;)
-                        t.shift().resolve(xe);
-                    this._closedPromiseResolve(), this._closedPromiseResolve = void 0;
-                }
-            }
-            [Symbol.asyncIterator]() {
-                return this;
+class ob {
+    constructor(t) {
+        this._json = t;
+    }
+    get schema() {
+        return this._json.schema;
+    }
+    get batches() {
+        return this._json.batches || [];
+    }
+    get dictionaries() {
+        return this._json.dictionaries || [];
+    }
+}
+class ax {
+    tee() {
+        return this._getDOMStream().tee();
+    }
+    pipe(t, n) {
+        return this._getNodeStream().pipe(t, n);
+    }
+    pipeTo(t, n) {
+        return this._getDOMStream().pipeTo(t, n);
+    }
+    pipeThrough(t, n) {
+        return this._getDOMStream().pipeThrough(t, n);
+    }
+    _getDOMStream() {
+        return this._DOMStream || (this._DOMStream = this.toDOMStream());
+    }
+    _getNodeStream() {
+        return this._nodeStream || (this._nodeStream = this.toNodeStream());
+    }
+}
+class y9 extends ax {
+    constructor() {
+        super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise((t) => this._closedPromiseResolve = t);
+    }
+    get closed() {
+        return this._closedPromise;
+    }
+    cancel(t) {
+        return bt(this, void 0, void 0, function*() {
+            yield this.return(t);
+        });
+    }
+    write(t) {
+        this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({
+            done: !1,
+            value: t
+        }));
+    }
+    abort(t) {
+        this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = {
+            error: t
+        } : this.resolvers.shift().reject({
+            done: !0,
+            value: t
+        }));
+    }
+    close() {
+            if (this._closedPromiseResolve) {
+                const {
+                    resolvers: t
+                } = this;
+                for (; t.length > 0;)
+                    t.shift().resolve(ne);
+                this._closedPromiseResolve(), this._closedPromiseResolve = void 0;
             }
-        toDOMStream(t) {
-            return Hn.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t);
-        }
-        toNodeStream(t) {
-            return Hn.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t);
-        }
-        throw (t) {
-            return W(this, void 0, void 0, function*() {
-                return yield this.abort(t), xe;
-            });
-        }
-        return (t) {
-            return W(this, void 0, void 0, function*() {
-                return yield this.close(), xe;
-            });
         }
-        read(t) {
-            return W(this, void 0, void 0, function*() {
-                return (yield this.next(t, "read")).value;
-            });
+        [Symbol.asyncIterator]() {
+            return this;
         }
-        peek(t) {
-            return W(this, void 0, void 0, function*() {
-                return (yield this.next(t, "peek")).value;
+    toDOMStream(t) {
+        return mn.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t);
+    }
+    toNodeStream(t) {
+        return mn.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t);
+    }
+    throw (t) {
+        return bt(this, void 0, void 0, function*() {
+            return yield this.abort(t), ne;
+        });
+    }
+    return (t) {
+        return bt(this, void 0, void 0, function*() {
+            return yield this.close(), ne;
+        });
+    }
+    read(t) {
+        return bt(this, void 0, void 0, function*() {
+            return (yield this.next(t, "read")).value;
+        });
+    }
+    peek(t) {
+        return bt(this, void 0, void 0, function*() {
+            return (yield this.next(t, "peek")).value;
+        });
+    }
+    next(...t) {
+        return this._values.length > 0 ? Promise.resolve({
+            done: !1,
+            value: this._values.shift()
+        }) : this._error ? Promise.reject({
+            done: !0,
+            value: this._error.error
+        }) : this._closedPromiseResolve ? new Promise((n, r) => {
+            this.resolvers.push({
+                resolve: n,
+                reject: r
             });
-        }
-        next(...t) {
-            return this._values.length > 0 ? Promise.resolve({
-                done: !1,
-                value: this._values.shift()
-            }) : this._error ? Promise.reject({
-                done: !0,
-                value: this._error.error
-            }) : this._closedPromiseResolve ? new Promise((n, i) => {
-                this.resolvers.push({
-                    resolve: n,
-                    reject: i
-                });
-            }) : Promise.resolve(xe);
-        }
-        _ensureOpen() {
-            if (this._closedPromiseResolve)
-                return !0;
-            throw new Error("AsyncQueue is closed");
-        }
-    },
-    p7 = class extends d7 {
-        write(t) {
-            if ((t = Yt(t)).byteLength > 0)
-                return super.write(t);
-        }
-        toString(t = !1) {
-            return t ? dg(this.toUint8Array(!0)) : this.toUint8Array(!1).then(dg);
-        }
-        toUint8Array(t = !1) {
-            return t ? cr(this._values)[0] : W(this, void 0, void 0, function*() {
-                var n, i, r, s;
-                const o = [];
-                let a = 0;
+        }) : Promise.resolve(ne);
+    }
+    _ensureOpen() {
+        if (this._closedPromiseResolve)
+            return !0;
+        throw new Error("AsyncQueue is closed");
+    }
+}
+class m9 extends y9 {
+    write(t) {
+        if ((t = Dt(t)).byteLength > 0)
+            return super.write(t);
+    }
+    toString(t = !1) {
+        return t ? i0(this.toUint8Array(!0)) : this.toUint8Array(!1).then(i0);
+    }
+    toUint8Array(t = !1) {
+        return t ? gr(this._values)[0] : bt(this, void 0, void 0, function*() {
+            var n, r, i, s;
+            const o = [];
+            let a = 0;
+            try {
+                for (var c = !0, u = xo(this), l; l = yield u.next(), n = l.done, !n; c = !0) {
+                    s = l.value, c = !1;
+                    const f = s;
+                    o.push(f), a += f.byteLength;
+                }
+            } catch (f) {
+                r = {
+                    error: f
+                };
+            } finally {
                 try {
-                    for (var c = !0, l = ai(this), u; u = yield l.next(), n = u.done, !n; c = !0) {
-                        s = u.value, c = !1;
-                        const f = s;
-                        o.push(f), a += f.byteLength;
-                    }
-                } catch (f) {
-                    i = {
-                        error: f
-                    };
+                    !c && !n && (i = u.return) && (yield i.call(u));
                 } finally {
-                    try {
-                        !c && !n && (r = l.return) && (yield r.call(l));
-                    } finally {
-                        if (i)
-                            throw i.error;
-                    }
+                    if (r)
+                        throw r.error;
                 }
-                return cr(o, a)[0];
-            });
-        }
-    },
-    kd = class {
-        constructor(t) {
-                t && (this.source = new y7(Hn.fromIterable(t)));
-            }
-            [Symbol.iterator]() {
-                return this;
-            }
-        next(t) {
-            return this.source.next(t);
-        }
-        throw (t) {
-            return this.source.throw(t);
-        }
-        return (t) {
-            return this.source.return(t);
-        }
-        peek(t) {
-            return this.source.peek(t);
-        }
-        read(t) {
-            return this.source.read(t);
-        }
-    },
-    Ud = class vM {
-        constructor(t) {
-                t instanceof vM ? this.source = t.source : t instanceof p7 ? this.source = new yo(Hn.fromAsyncIterable(t)) : CI(t) ? this.source = new yo(Hn.fromNodeStream(t)) : db(t) ? this.source = new yo(Hn.fromDOMStream(t)) : LI(t) ? this.source = new yo(Hn.fromDOMStream(t.body)) : Ry(t) ? this.source = new yo(Hn.fromIterable(t)) : vu(t) ? this.source = new yo(Hn.fromAsyncIterable(t)) : hb(t) && (this.source = new yo(Hn.fromAsyncIterable(t)));
             }
-            [Symbol.asyncIterator]() {
-                return this;
-            }
-        next(t) {
-            return this.source.next(t);
-        }
-        throw (t) {
-            return this.source.throw(t);
-        }
-        return (t) {
-            return this.source.return(t);
-        }
-        get closed() {
-            return this.source.closed;
-        }
-        cancel(t) {
-            return this.source.cancel(t);
-        }
-        peek(t) {
-            return this.source.peek(t);
-        }
-        read(t) {
-            return this.source.read(t);
-        }
-    },
-    y7 = class {
-        constructor(t) {
-            this.source = t;
+            return gr(o, a)[0];
+        });
+    }
+}
+class df {
+    constructor(t) {
+            t && (this.source = new g9(mn.fromIterable(t)));
         }
-        cancel(t) {
-            this.return(t);
+        [Symbol.iterator]() {
+            return this;
         }
-        peek(t) {
-            return this.next(t, "peek").value;
+    next(t) {
+        return this.source.next(t);
+    }
+    throw (t) {
+        return this.source.throw(t);
+    }
+    return (t) {
+        return this.source.return(t);
+    }
+    peek(t) {
+        return this.source.peek(t);
+    }
+    read(t) {
+        return this.source.read(t);
+    }
+}
+class Uo {
+    constructor(t) {
+            t instanceof Uo ? this.source = t.source : t instanceof m9 ? this.source = new is(mn.fromAsyncIterable(t)) : Iv(t) ? this.source = new is(mn.fromNodeStream(t)) : Yy(t) ? this.source = new is(mn.fromDOMStream(t)) : Av(t) ? this.source = new is(mn.fromDOMStream(t.body)) : Lh(t) ? this.source = new is(mn.fromIterable(t)) : yc(t) ? this.source = new is(mn.fromAsyncIterable(t)) : Vy(t) && (this.source = new is(mn.fromAsyncIterable(t)));
         }
-        read(t) {
-            return this.next(t, "read").value;
+        [Symbol.asyncIterator]() {
+            return this;
         }
-        next(t, n = "read") {
-            return this.source.next({
+    next(t) {
+        return this.source.next(t);
+    }
+    throw (t) {
+        return this.source.throw(t);
+    }
+    return (t) {
+        return this.source.return(t);
+    }
+    get closed() {
+        return this.source.closed;
+    }
+    cancel(t) {
+        return this.source.cancel(t);
+    }
+    peek(t) {
+        return this.source.peek(t);
+    }
+    read(t) {
+        return this.source.read(t);
+    }
+}
+class g9 {
+    constructor(t) {
+        this.source = t;
+    }
+    cancel(t) {
+        this.return(t);
+    }
+    peek(t) {
+        return this.next(t, "peek").value;
+    }
+    read(t) {
+        return this.next(t, "read").value;
+    }
+    next(t, n = "read") {
+        return this.source.next({
+            cmd: n,
+            size: t
+        });
+    }
+    throw (t) {
+        return Object.create(this.source.throw && this.source.throw(t) || ne);
+    }
+    return (t) {
+        return Object.create(this.source.return && this.source.return(t) || ne);
+    }
+}
+class is {
+    constructor(t) {
+        this.source = t, this._closedPromise = new Promise((n) => this._closedPromiseResolve = n);
+    }
+    cancel(t) {
+        return bt(this, void 0, void 0, function*() {
+            yield this.return(t);
+        });
+    }
+    get closed() {
+        return this._closedPromise;
+    }
+    read(t) {
+        return bt(this, void 0, void 0, function*() {
+            return (yield this.next(t, "read")).value;
+        });
+    }
+    peek(t) {
+        return bt(this, void 0, void 0, function*() {
+            return (yield this.next(t, "peek")).value;
+        });
+    }
+    next(t, n = "read") {
+        return bt(this, void 0, void 0, function*() {
+            return yield this.source.next({
                 cmd: n,
                 size: t
             });
-        }
-        throw (t) {
-            return Object.create(this.source.throw && this.source.throw(t) || xe);
-        }
-        return (t) {
-            return Object.create(this.source.return && this.source.return(t) || xe);
-        }
-    },
-    yo = class {
-        constructor(t) {
-            this.source = t, this._closedPromise = new Promise((n) => this._closedPromiseResolve = n);
-        }
-        cancel(t) {
-            return W(this, void 0, void 0, function*() {
-                yield this.return(t);
-            });
-        }
-        get closed() {
-            return this._closedPromise;
-        }
-        read(t) {
-            return W(this, void 0, void 0, function*() {
-                return (yield this.next(t, "read")).value;
-            });
-        }
-        peek(t) {
-            return W(this, void 0, void 0, function*() {
-                return (yield this.next(t, "peek")).value;
-            });
-        }
-        next(t, n = "read") {
-            return W(this, void 0, void 0, function*() {
-                return yield this.source.next({
-                    cmd: n,
-                    size: t
-                });
-            });
-        }
-        throw (t) {
-            return W(this, void 0, void 0, function*() {
-                const n = this.source.throw && (yield this.source.throw(t)) || xe;
-                return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
-            });
-        }
-        return (t) {
-            return W(this, void 0, void 0, function*() {
-                const n = this.source.return && (yield this.source.return(t)) || xe;
-                return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
-            });
-        }
-    },
-    G_ = class extends kd {
-        constructor(t, n) {
-            super(), this.position = 0, this.buffer = Yt(t), this.size = n === void 0 ? this.buffer.byteLength : n;
-        }
-        readInt32(t) {
+        });
+    }
+    throw (t) {
+        return bt(this, void 0, void 0, function*() {
+            const n = this.source.throw && (yield this.source.throw(t)) || ne;
+            return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
+        });
+    }
+    return (t) {
+        return bt(this, void 0, void 0, function*() {
+            const n = this.source.return && (yield this.source.return(t)) || ne;
+            return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
+        });
+    }
+}
+class ab extends df {
+    constructor(t, n) {
+        super(), this.position = 0, this.buffer = Dt(t), this.size = n === void 0 ? this.buffer.byteLength : n;
+    }
+    readInt32(t) {
+        const {
+            buffer: n,
+            byteOffset: r
+        } = this.readAt(t, 4);
+        return new DataView(n, r).getInt32(0, !0);
+    }
+    seek(t) {
+        return this.position = Math.min(t, this.size), t < this.size;
+    }
+    read(t) {
+        const {
+            buffer: n,
+            size: r,
+            position: i
+        } = this;
+        return n && i < r ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(r, i + Math.min(r - i, t)), n.subarray(i, this.position)) : null;
+    }
+    readAt(t, n) {
+        const r = this.buffer,
+            i = Math.min(this.size, t + n);
+        return r ? r.subarray(t, i) : new Uint8Array(n);
+    }
+    close() {
+        this.buffer && (this.buffer = null);
+    }
+    throw (t) {
+        return this.close(), {
+            done: !0,
+            value: t
+        };
+    }
+    return (t) {
+        return this.close(), {
+            done: !0,
+            value: t
+        };
+    }
+}
+class pf extends Uo {
+    constructor(t, n) {
+        super(), this.position = 0, this._handle = t, typeof n == "number" ? this.size = n : this._pending = bt(this, void 0, void 0, function*() {
+            this.size = (yield t.stat()).size, delete this._pending;
+        });
+    }
+    readInt32(t) {
+        return bt(this, void 0, void 0, function*() {
             const {
                 buffer: n,
-                byteOffset: i
-            } = this.readAt(t, 4);
-            return new DataView(n, i).getInt32(0, !0);
-        }
-        seek(t) {
-            return this.position = Math.min(t, this.size), t < this.size;
-        }
-        read(t) {
+                byteOffset: r
+            } = yield this.readAt(t, 4);
+            return new DataView(n, r).getInt32(0, !0);
+        });
+    }
+    seek(t) {
+        return bt(this, void 0, void 0, function*() {
+            return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size;
+        });
+    }
+    read(t) {
+        return bt(this, void 0, void 0, function*() {
+            this._pending && (yield this._pending);
             const {
-                buffer: n,
-                size: i,
-                position: r
+                _handle: n,
+                size: r,
+                position: i
             } = this;
-            return n && r < i ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(i, r + Math.min(i - r, t)), n.subarray(r, this.position)) : null;
-        }
-        readAt(t, n) {
-            const i = this.buffer,
-                r = Math.min(this.size, t + n);
-            return i ? i.subarray(t, r) : new Uint8Array(n);
-        }
-        close() {
-            this.buffer && (this.buffer = null);
-        }
-        throw (t) {
-            return this.close(), {
+            if (n && i < r) {
+                typeof t != "number" && (t = Number.POSITIVE_INFINITY);
+                let s = i,
+                    o = 0,
+                    a = 0;
+                const c = Math.min(r, s + Math.min(r - s, t)),
+                    u = new Uint8Array(Math.max(0, (this.position = c) - s));
+                for (;
+                    (s += a) < c && (o += a) < u.byteLength;)
+                    ({
+                        bytesRead: a
+                    } = yield n.read(u, o, u.byteLength - o, s));
+                return u;
+            }
+            return null;
+        });
+    }
+    readAt(t, n) {
+        return bt(this, void 0, void 0, function*() {
+            this._pending && (yield this._pending);
+            const {
+                _handle: r,
+                size: i
+            } = this;
+            if (r && t + n < i) {
+                const s = Math.min(i, t + n),
+                    o = new Uint8Array(s - t);
+                return (yield r.read(o, 0, n, t)).buffer;
+            }
+            return new Uint8Array(n);
+        });
+    }
+    close() {
+        return bt(this, void 0, void 0, function*() {
+            const t = this._handle;
+            this._handle = null, t && (yield t.close());
+        });
+    }
+    throw (t) {
+        return bt(this, void 0, void 0, function*() {
+            return yield this.close(), {
                 done: !0,
                 value: t
             };
-        }
-        return (t) {
-            return this.close(), {
+        });
+    }
+    return (t) {
+        return bt(this, void 0, void 0, function*() {
+            return yield this.close(), {
                 done: !0,
                 value: t
             };
-        }
-    },
-    zd = class extends Ud {
-        constructor(t, n) {
-            super(), this.position = 0, this._handle = t, typeof n == "number" ? this.size = n : this._pending = W(this, void 0, void 0, function*() {
-                this.size = (yield t.stat()).size, delete this._pending;
-            });
-        }
-        readInt32(t) {
-            return W(this, void 0, void 0, function*() {
-                const {
-                    buffer: n,
-                    byteOffset: i
-                } = yield this.readAt(t, 4);
-                return new DataView(n, i).getInt32(0, !0);
-            });
-        }
-        seek(t) {
-            return W(this, void 0, void 0, function*() {
-                return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size;
-            });
-        }
-        read(t) {
-            return W(this, void 0, void 0, function*() {
-                this._pending && (yield this._pending);
-                const {
-                    _handle: n,
-                    size: i,
-                    position: r
-                } = this;
-                if (n && r < i) {
-                    typeof t != "number" && (t = Number.POSITIVE_INFINITY);
-                    let s = r,
-                        o = 0,
-                        a = 0;
-                    const c = Math.min(i, s + Math.min(i - s, t)),
-                        l = new Uint8Array(Math.max(0, (this.position = c) - s));
-                    for (;
-                        (s += a) < c && (o += a) < l.byteLength;)
-                        ({
-                            bytesRead: a
-                        } = yield n.read(l, o, l.byteLength - o, s));
-                    return l;
-                }
-                return null;
-            });
-        }
-        readAt(t, n) {
-            return W(this, void 0, void 0, function*() {
-                this._pending && (yield this._pending);
-                const {
-                    _handle: i,
-                    size: r
-                } = this;
-                if (i && t + n < r) {
-                    const s = Math.min(r, t + n),
-                        o = new Uint8Array(s - t);
-                    return (yield i.read(o, 0, n, t)).buffer;
-                }
-                return new Uint8Array(n);
-            });
-        }
-        close() {
-            return W(this, void 0, void 0, function*() {
-                const t = this._handle;
-                this._handle = null, t && (yield t.close());
-            });
-        }
-        throw (t) {
-            return W(this, void 0, void 0, function*() {
-                return yield this.close(), {
-                    done: !0,
-                    value: t
-                };
-            });
-        }
-        return (t) {
-            return W(this, void 0, void 0, function*() {
-                return yield this.close(), {
-                    done: !0,
-                    value: t
-                };
-            });
-        }
-    };
-const m7 = 65536;
+        });
+    }
+}
+const b9 = 65536;
 
-function Ka(e) {
+function po(e) {
     return e < 0 && (e = 4294967295 + e + 1), `0x${e.toString(16)}`;
 }
-const Ac = 8,
-    Ab = [
+const zo = 8,
+    im = [
         1,
         10,
         100,
         1e3,
         1e4,
         1e5,
         1e6,
         1e7,
         1e8
     ];
-let _M = class {
-        constructor(t) {
-            this.buffer = t;
-        }
-        high() {
-            return this.buffer[1];
-        }
-        low() {
-            return this.buffer[0];
-        }
-        _times(t) {
-            const n = new Uint32Array([
-                    this.buffer[1] >>> 16,
-                    this.buffer[1] & 65535,
-                    this.buffer[0] >>> 16,
-                    this.buffer[0] & 65535
-                ]),
-                i = new Uint32Array([
-                    t.buffer[1] >>> 16,
-                    t.buffer[1] & 65535,
-                    t.buffer[0] >>> 16,
-                    t.buffer[0] & 65535
-                ]);
-            let r = n[3] * i[3];
-            this.buffer[0] = r & 65535;
-            let s = r >>> 16;
-            return r = n[2] * i[3], s += r, r = n[3] * i[2] >>> 0, s += r, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < r ? m7 : 0, this.buffer[1] += s >>> 16, this.buffer[1] += n[1] * i[3] + n[2] * i[2] + n[3] * i[1], this.buffer[1] += n[0] * i[3] + n[1] * i[2] + n[2] * i[1] + n[3] * i[0] << 16, this;
-        }
-        _plus(t) {
-            const n = this.buffer[0] + t.buffer[0] >>> 0;
-            this.buffer[1] += t.buffer[1], n < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = n;
-        }
-        lessThan(t) {
-            return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0];
-        }
-        equals(t) {
-            return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0];
-        }
-        greaterThan(t) {
-            return t.lessThan(this);
-        }
-        hex() {
-            return `${Ka(this.buffer[1])} ${Ka(this.buffer[0])}`;
-        }
-    },
-    Fe = class Nr extends _M {
-        times(t) {
-            return this._times(t), this;
-        }
-        plus(t) {
-            return this._plus(t), this;
-        }
-        /** @nocollapse */
-        static from(t, n = new Uint32Array(2)) {
-            return Nr.fromString(typeof t == "string" ? t : t.toString(), n);
-        }
-        /** @nocollapse */
-        static fromNumber(t, n = new Uint32Array(2)) {
-            return Nr.fromString(t.toString(), n);
-        }
-        /** @nocollapse */
-        static fromString(t, n = new Uint32Array(2)) {
-            const i = t.length,
-                r = new Nr(n);
-            for (let s = 0; s < i;) {
-                const o = Ac < i - s ? Ac : i - s,
-                    a = new Nr(new Uint32Array([Number.parseInt(t.slice(s, s + o), 10), 0])),
-                    c = new Nr(new Uint32Array([Ab[o], 0]));
-                r.times(c), r.plus(a), s += o;
-            }
-            return r;
-        }
-        /** @nocollapse */
-        static convertArray(t) {
-            const n = new Uint32Array(t.length * 2);
-            for (let i = -1, r = t.length; ++i < r;)
-                Nr.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
-            return n;
-        }
-        /** @nocollapse */
-        static multiply(t, n) {
-            return new Nr(new Uint32Array(t.buffer)).times(n);
-        }
-        /** @nocollapse */
-        static add(t, n) {
-            return new Nr(new Uint32Array(t.buffer)).plus(n);
-        }
-    },
-    cu = class Br extends _M {
-        negate() {
-            return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this;
-        }
-        times(t) {
-            return this._times(t), this;
-        }
-        plus(t) {
-            return this._plus(t), this;
-        }
-        lessThan(t) {
-            const n = this.buffer[1] << 0,
-                i = t.buffer[1] << 0;
-            return n < i || n === i && this.buffer[0] < t.buffer[0];
-        }
-        /** @nocollapse */
-        static from(t, n = new Uint32Array(2)) {
-            return Br.fromString(typeof t == "string" ? t : t.toString(), n);
-        }
-        /** @nocollapse */
-        static fromNumber(t, n = new Uint32Array(2)) {
-            return Br.fromString(t.toString(), n);
-        }
-        /** @nocollapse */
-        static fromString(t, n = new Uint32Array(2)) {
-            const i = t.startsWith("-"),
-                r = t.length,
-                s = new Br(n);
-            for (let o = i ? 1 : 0; o < r;) {
-                const a = Ac < r - o ? Ac : r - o,
-                    c = new Br(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0])),
-                    l = new Br(new Uint32Array([Ab[a], 0]));
-                s.times(l), s.plus(c), o += a;
-            }
-            return i ? s.negate() : s;
-        }
-        /** @nocollapse */
-        static convertArray(t) {
-            const n = new Uint32Array(t.length * 2);
-            for (let i = -1, r = t.length; ++i < r;)
-                Br.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
-            return n;
-        }
-        /** @nocollapse */
-        static multiply(t, n) {
-            return new Br(new Uint32Array(t.buffer)).times(n);
-        }
-        /** @nocollapse */
-        static add(t, n) {
-            return new Br(new Uint32Array(t.buffer)).plus(n);
-        }
-    },
-    g7 = class Or {
-        constructor(t) {
-            this.buffer = t;
-        }
-        high() {
-            return new cu(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
-        }
-        low() {
-            return new cu(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
-        }
-        negate() {
-            return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this;
-        }
-        times(t) {
-            const n = new Fe(new Uint32Array([this.buffer[3], 0])),
-                i = new Fe(new Uint32Array([this.buffer[2], 0])),
-                r = new Fe(new Uint32Array([this.buffer[1], 0])),
-                s = new Fe(new Uint32Array([this.buffer[0], 0])),
-                o = new Fe(new Uint32Array([t.buffer[3], 0])),
-                a = new Fe(new Uint32Array([t.buffer[2], 0])),
-                c = new Fe(new Uint32Array([t.buffer[1], 0])),
-                l = new Fe(new Uint32Array([t.buffer[0], 0]));
-            let u = Fe.multiply(s, l);
-            this.buffer[0] = u.low();
-            const f = new Fe(new Uint32Array([u.high(), 0]));
-            return u = Fe.multiply(r, l), f.plus(u), u = Fe.multiply(s, c), f.plus(u), this.buffer[1] = f.low(), this.buffer[3] = f.lessThan(u) ? 1 : 0, this.buffer[2] = f.high(), new Fe(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(Fe.multiply(i, l)).plus(Fe.multiply(r, c)).plus(Fe.multiply(s, a)), this.buffer[3] += Fe.multiply(n, l).plus(Fe.multiply(i, c)).plus(Fe.multiply(r, a)).plus(Fe.multiply(s, o)).low(), this;
-        }
-        plus(t) {
-            const n = new Uint32Array(4);
-            return n[3] = this.buffer[3] + t.buffer[3] >>> 0, n[2] = this.buffer[2] + t.buffer[2] >>> 0, n[1] = this.buffer[1] + t.buffer[1] >>> 0, n[0] = this.buffer[0] + t.buffer[0] >>> 0, n[0] < this.buffer[0] >>> 0 && ++n[1], n[1] < this.buffer[1] >>> 0 && ++n[2], n[2] < this.buffer[2] >>> 0 && ++n[3], this.buffer[3] = n[3], this.buffer[2] = n[2], this.buffer[1] = n[1], this.buffer[0] = n[0], this;
-        }
-        hex() {
-            return `${Ka(this.buffer[3])} ${Ka(this.buffer[2])} ${Ka(this.buffer[1])} ${Ka(this.buffer[0])}`;
-        }
-        /** @nocollapse */
-        static multiply(t, n) {
-            return new Or(new Uint32Array(t.buffer)).times(n);
-        }
-        /** @nocollapse */
-        static add(t, n) {
-            return new Or(new Uint32Array(t.buffer)).plus(n);
-        }
-        /** @nocollapse */
-        static from(t, n = new Uint32Array(4)) {
-            return Or.fromString(typeof t == "string" ? t : t.toString(), n);
-        }
-        /** @nocollapse */
-        static fromNumber(t, n = new Uint32Array(4)) {
-            return Or.fromString(t.toString(), n);
-        }
-        /** @nocollapse */
-        static fromString(t, n = new Uint32Array(4)) {
-            const i = t.startsWith("-"),
-                r = t.length,
-                s = new Or(n);
-            for (let o = i ? 1 : 0; o < r;) {
-                const a = Ac < r - o ? Ac : r - o,
-                    c = new Or(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0, 0, 0])),
-                    l = new Or(new Uint32Array([Ab[a], 0, 0, 0]));
-                s.times(l), s.plus(c), o += a;
-            }
-            return i ? s.negate() : s;
-        }
-        /** @nocollapse */
-        static convertArray(t) {
-            const n = new Uint32Array(t.length * 4);
-            for (let i = -1, r = t.length; ++i < r;)
-                Or.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 4 * 4 * i, 4));
-            return n;
+class cx {
+    constructor(t) {
+        this.buffer = t;
+    }
+    high() {
+        return this.buffer[1];
+    }
+    low() {
+        return this.buffer[0];
+    }
+    _times(t) {
+        const n = new Uint32Array([
+                this.buffer[1] >>> 16,
+                this.buffer[1] & 65535,
+                this.buffer[0] >>> 16,
+                this.buffer[0] & 65535
+            ]),
+            r = new Uint32Array([
+                t.buffer[1] >>> 16,
+                t.buffer[1] & 65535,
+                t.buffer[0] >>> 16,
+                t.buffer[0] & 65535
+            ]);
+        let i = n[3] * r[3];
+        this.buffer[0] = i & 65535;
+        let s = i >>> 16;
+        return i = n[2] * r[3], s += i, i = n[3] * r[2] >>> 0, s += i, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < i ? b9 : 0, this.buffer[1] += s >>> 16, this.buffer[1] += n[1] * r[3] + n[2] * r[2] + n[3] * r[1], this.buffer[1] += n[0] * r[3] + n[1] * r[2] + n[2] * r[1] + n[3] * r[0] << 16, this;
+    }
+    _plus(t) {
+        const n = this.buffer[0] + t.buffer[0] >>> 0;
+        this.buffer[1] += t.buffer[1], n < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = n;
+    }
+    lessThan(t) {
+        return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0];
+    }
+    equals(t) {
+        return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0];
+    }
+    greaterThan(t) {
+        return t.lessThan(this);
+    }
+    hex() {
+        return `${po(this.buffer[1])} ${po(this.buffer[0])}`;
+    }
+}
+class Vt extends cx {
+    times(t) {
+        return this._times(t), this;
+    }
+    plus(t) {
+        return this._plus(t), this;
+    }
+    /** @nocollapse */
+    static from(t, n = new Uint32Array(2)) {
+        return Vt.fromString(typeof t == "string" ? t : t.toString(), n);
+    }
+    /** @nocollapse */
+    static fromNumber(t, n = new Uint32Array(2)) {
+        return Vt.fromString(t.toString(), n);
+    }
+    /** @nocollapse */
+    static fromString(t, n = new Uint32Array(2)) {
+        const r = t.length,
+            i = new Vt(n);
+        for (let s = 0; s < r;) {
+            const o = zo < r - s ? zo : r - s,
+                a = new Vt(new Uint32Array([Number.parseInt(t.slice(s, s + o), 10), 0])),
+                c = new Vt(new Uint32Array([im[o], 0]));
+            i.times(c), i.plus(a), s += o;
         }
-    },
-    xM = class extends Ut {
-        constructor(t, n, i, r, s = Ee.V5) {
-            super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = n, this.buffers = i, this.dictionaries = r, this.metadataVersion = s;
+        return i;
+    }
+    /** @nocollapse */
+    static convertArray(t) {
+        const n = new Uint32Array(t.length * 2);
+        for (let r = -1, i = t.length; ++r < i;)
+            Vt.from(t[r], new Uint32Array(n.buffer, n.byteOffset + 2 * r * 4, 2));
+        return n;
+    }
+    /** @nocollapse */
+    static multiply(t, n) {
+        return new Vt(new Uint32Array(t.buffer)).times(n);
+    }
+    /** @nocollapse */
+    static add(t, n) {
+        return new Vt(new Uint32Array(t.buffer)).plus(n);
+    }
+}
+class Ye extends cx {
+    negate() {
+        return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this;
+    }
+    times(t) {
+        return this._times(t), this;
+    }
+    plus(t) {
+        return this._plus(t), this;
+    }
+    lessThan(t) {
+        const n = this.buffer[1] << 0,
+            r = t.buffer[1] << 0;
+        return n < r || n === r && this.buffer[0] < t.buffer[0];
+    }
+    /** @nocollapse */
+    static from(t, n = new Uint32Array(2)) {
+        return Ye.fromString(typeof t == "string" ? t : t.toString(), n);
+    }
+    /** @nocollapse */
+    static fromNumber(t, n = new Uint32Array(2)) {
+        return Ye.fromString(t.toString(), n);
+    }
+    /** @nocollapse */
+    static fromString(t, n = new Uint32Array(2)) {
+        const r = t.startsWith("-"),
+            i = t.length,
+            s = new Ye(n);
+        for (let o = r ? 1 : 0; o < i;) {
+            const a = zo < i - o ? zo : i - o,
+                c = new Ye(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0])),
+                u = new Ye(new Uint32Array([im[a], 0]));
+            s.times(u), s.plus(c), o += a;
         }
-        visit(t) {
-            return super.visit(t instanceof Te ? t.type : t);
+        return r ? s.negate() : s;
+    }
+    /** @nocollapse */
+    static convertArray(t) {
+        const n = new Uint32Array(t.length * 2);
+        for (let r = -1, i = t.length; ++r < i;)
+            Ye.from(t[r], new Uint32Array(n.buffer, n.byteOffset + 2 * r * 4, 2));
+        return n;
+    }
+    /** @nocollapse */
+    static multiply(t, n) {
+        return new Ye(new Uint32Array(t.buffer)).times(n);
+    }
+    /** @nocollapse */
+    static add(t, n) {
+        return new Ye(new Uint32Array(t.buffer)).plus(n);
+    }
+}
+class er {
+    constructor(t) {
+        this.buffer = t;
+    }
+    high() {
+        return new Ye(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
+    }
+    low() {
+        return new Ye(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
+    }
+    negate() {
+        return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this;
+    }
+    times(t) {
+        const n = new Vt(new Uint32Array([this.buffer[3], 0])),
+            r = new Vt(new Uint32Array([this.buffer[2], 0])),
+            i = new Vt(new Uint32Array([this.buffer[1], 0])),
+            s = new Vt(new Uint32Array([this.buffer[0], 0])),
+            o = new Vt(new Uint32Array([t.buffer[3], 0])),
+            a = new Vt(new Uint32Array([t.buffer[2], 0])),
+            c = new Vt(new Uint32Array([t.buffer[1], 0])),
+            u = new Vt(new Uint32Array([t.buffer[0], 0]));
+        let l = Vt.multiply(s, u);
+        this.buffer[0] = l.low();
+        const f = new Vt(new Uint32Array([l.high(), 0]));
+        return l = Vt.multiply(i, u), f.plus(l), l = Vt.multiply(s, c), f.plus(l), this.buffer[1] = f.low(), this.buffer[3] = f.lessThan(l) ? 1 : 0, this.buffer[2] = f.high(), new Vt(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(Vt.multiply(r, u)).plus(Vt.multiply(i, c)).plus(Vt.multiply(s, a)), this.buffer[3] += Vt.multiply(n, u).plus(Vt.multiply(r, c)).plus(Vt.multiply(i, a)).plus(Vt.multiply(s, o)).low(), this;
+    }
+    plus(t) {
+        const n = new Uint32Array(4);
+        return n[3] = this.buffer[3] + t.buffer[3] >>> 0, n[2] = this.buffer[2] + t.buffer[2] >>> 0, n[1] = this.buffer[1] + t.buffer[1] >>> 0, n[0] = this.buffer[0] + t.buffer[0] >>> 0, n[0] < this.buffer[0] >>> 0 && ++n[1], n[1] < this.buffer[1] >>> 0 && ++n[2], n[2] < this.buffer[2] >>> 0 && ++n[3], this.buffer[3] = n[3], this.buffer[2] = n[2], this.buffer[1] = n[1], this.buffer[0] = n[0], this;
+    }
+    hex() {
+        return `${po(this.buffer[3])} ${po(this.buffer[2])} ${po(this.buffer[1])} ${po(this.buffer[0])}`;
+    }
+    /** @nocollapse */
+    static multiply(t, n) {
+        return new er(new Uint32Array(t.buffer)).times(n);
+    }
+    /** @nocollapse */
+    static add(t, n) {
+        return new er(new Uint32Array(t.buffer)).plus(n);
+    }
+    /** @nocollapse */
+    static from(t, n = new Uint32Array(4)) {
+        return er.fromString(typeof t == "string" ? t : t.toString(), n);
+    }
+    /** @nocollapse */
+    static fromNumber(t, n = new Uint32Array(4)) {
+        return er.fromString(t.toString(), n);
+    }
+    /** @nocollapse */
+    static fromString(t, n = new Uint32Array(4)) {
+        const r = t.startsWith("-"),
+            i = t.length,
+            s = new er(n);
+        for (let o = r ? 1 : 0; o < i;) {
+            const a = zo < i - o ? zo : i - o,
+                c = new er(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0, 0, 0])),
+                u = new er(new Uint32Array([im[a], 0, 0, 0]));
+            s.times(u), s.plus(c), o += a;
         }
-        visitNull(t, {
+        return r ? s.negate() : s;
+    }
+    /** @nocollapse */
+    static convertArray(t) {
+        const n = new Uint32Array(t.length * 4);
+        for (let r = -1, i = t.length; ++r < i;)
+            er.from(t[r], new Uint32Array(n.buffer, n.byteOffset + 4 * 4 * r, 4));
+        return n;
+    }
+}
+class ux extends At {
+    constructor(t, n, r, i, s = fe.V5) {
+        super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = n, this.buffers = r, this.dictionaries = i, this.metadataVersion = s;
+    }
+    visit(t) {
+        return super.visit(t instanceof Kt ? t.type : t);
+    }
+    visitNull(t, {
+        length: n
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n
-            });
-        }
-        visitBool(t, {
+        });
+    }
+    visitBool(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitInt(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitInt(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitFloat(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitFloat(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitUtf8(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitUtf8(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                valueOffsets: this.readOffsets(t),
-                data: this.readData(t)
-            });
-        }
-        visitLargeUtf8(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            valueOffsets: this.readOffsets(t),
+            data: this.readData(t)
+        });
+    }
+    visitLargeUtf8(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                valueOffsets: this.readOffsets(t),
-                data: this.readData(t)
-            });
-        }
-        visitBinary(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            valueOffsets: this.readOffsets(t),
+            data: this.readData(t)
+        });
+    }
+    visitBinary(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                valueOffsets: this.readOffsets(t),
-                data: this.readData(t)
-            });
-        }
-        visitLargeBinary(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            valueOffsets: this.readOffsets(t),
+            data: this.readData(t)
+        });
+    }
+    visitLargeBinary(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                valueOffsets: this.readOffsets(t),
-                data: this.readData(t)
-            });
-        }
-        visitFixedSizeBinary(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            valueOffsets: this.readOffsets(t),
+            data: this.readData(t)
+        });
+    }
+    visitFixedSizeBinary(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitDate(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitDate(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitTimestamp(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitTimestamp(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitTime(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitTime(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitDecimal(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitDecimal(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitList(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitList(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                valueOffsets: this.readOffsets(t),
-                child: this.visit(t.children[0])
-            });
-        }
-        visitStruct(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            valueOffsets: this.readOffsets(t),
+            child: this.visit(t.children[0])
+        });
+    }
+    visitStruct(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                children: this.visitMany(t.children)
-            });
-        }
-        visitUnion(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            children: this.visitMany(t.children)
+        });
+    }
+    visitUnion(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return this.metadataVersion < fe.V5 && this.readNullBitmap(t, r), t.mode === Je.Sparse ? this.visitSparseUnion(t, {
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return this.metadataVersion < Ee.V5 && this.readNullBitmap(t, i), t.mode === Mn.Sparse ? this.visitSparseUnion(t, {
-                length: n,
-                nullCount: i
-            }) : this.visitDenseUnion(t, {
-                length: n,
-                nullCount: i
-            });
-        }
-        visitDenseUnion(t, {
+            nullCount: r
+        }) : this.visitDenseUnion(t, {
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                typeIds: this.readTypeIds(t),
-                valueOffsets: this.readOffsets(t),
-                children: this.visitMany(t.children)
-            });
-        }
-        visitSparseUnion(t, {
+            nullCount: r
+        });
+    }
+    visitDenseUnion(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                typeIds: this.readTypeIds(t),
-                children: this.visitMany(t.children)
-            });
-        }
-        visitDictionary(t, {
+            nullCount: r,
+            typeIds: this.readTypeIds(t),
+            valueOffsets: this.readOffsets(t),
+            children: this.visitMany(t.children)
+        });
+    }
+    visitSparseUnion(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t.indices),
-                dictionary: this.readDictionary(t)
-            });
-        }
-        visitInterval(t, {
+            nullCount: r,
+            typeIds: this.readTypeIds(t),
+            children: this.visitMany(t.children)
+        });
+    }
+    visitDictionary(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitDuration(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t.indices),
+            dictionary: this.readDictionary(t)
+        });
+    }
+    visitInterval(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                data: this.readData(t)
-            });
-        }
-        visitFixedSizeList(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitDuration(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                child: this.visit(t.children[0])
-            });
-        }
-        visitMap(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            data: this.readData(t)
+        });
+    }
+    visitFixedSizeList(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            nullCount: i
-        } = this.nextFieldNode()) {
-            return Rt({
-                type: t,
-                length: n,
-                nullCount: i,
-                nullBitmap: this.readNullBitmap(t, i),
-                valueOffsets: this.readOffsets(t),
-                child: this.visit(t.children[0])
-            });
-        }
-        nextFieldNode() {
-            return this.nodes[++this.nodesIndex];
-        }
-        nextBufferRange() {
-            return this.buffers[++this.buffersIndex];
-        }
-        readNullBitmap(t, n, i = this.nextBufferRange()) {
-            return n > 0 && this.readData(t, i) || new Uint8Array(0);
-        }
-        readOffsets(t, n) {
-            return this.readData(t, n);
-        }
-        readTypeIds(t, n) {
-            return this.readData(t, n);
-        }
-        readData(t, {
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            child: this.visit(t.children[0])
+        });
+    }
+    visitMap(t, {
+        length: n,
+        nullCount: r
+    } = this.nextFieldNode()) {
+        return St({
+            type: t,
             length: n,
-            offset: i
-        } = this.nextBufferRange()) {
-            return this.bytes.subarray(i, i + n);
-        }
-        readDictionary(t) {
-            return this.dictionaries.get(t.id);
-        }
-    },
-    b7 = class extends xM {
-        constructor(t, n, i, r, s) {
-            super(new Uint8Array(0), n, i, r, s), this.sources = t;
-        }
-        readNullBitmap(t, n, {
-            offset: i
-        } = this.nextBufferRange()) {
-            return n <= 0 ? new Uint8Array(0) : _g(this.sources[i]);
-        }
-        readOffsets(t, {
-            offset: n
-        } = this.nextBufferRange()) {
-            return re(Uint8Array, re(t.OffsetArrayType, this.sources[n]));
-        }
-        readTypeIds(t, {
-            offset: n
-        } = this.nextBufferRange()) {
-            return re(Uint8Array, re(t.ArrayType, this.sources[n]));
-        }
-        readData(t, {
-            offset: n
-        } = this.nextBufferRange()) {
-            const {
-                sources: i
-            } = this;
-            return gt.isTimestamp(t) || (gt.isInt(t) || gt.isTime(t)) && t.bitWidth === 64 || gt.isDuration(t) || gt.isDate(t) && t.unit === Ii.MILLISECOND ? re(Uint8Array, cu.convertArray(i[n])) : gt.isDecimal(t) ? re(Uint8Array, g7.convertArray(i[n])) : gt.isBinary(t) || gt.isLargeBinary(t) || gt.isFixedSizeBinary(t) ? w7(i[n]) : gt.isBool(t) ? _g(i[n]) : gt.isUtf8(t) || gt.isLargeUtf8(t) ? fb(i[n].join("")) : re(Uint8Array, re(t.ArrayType, i[n].map((r) => +r)));
-        }
-    };
+            nullCount: r,
+            nullBitmap: this.readNullBitmap(t, r),
+            valueOffsets: this.readOffsets(t),
+            child: this.visit(t.children[0])
+        });
+    }
+    nextFieldNode() {
+        return this.nodes[++this.nodesIndex];
+    }
+    nextBufferRange() {
+        return this.buffers[++this.buffersIndex];
+    }
+    readNullBitmap(t, n, r = this.nextBufferRange()) {
+        return n > 0 && this.readData(t, r) || new Uint8Array(0);
+    }
+    readOffsets(t, n) {
+        return this.readData(t, n);
+    }
+    readTypeIds(t, n) {
+        return this.readData(t, n);
+    }
+    readData(t, {
+        length: n,
+        offset: r
+    } = this.nextBufferRange()) {
+        return this.bytes.subarray(r, r + n);
+    }
+    readDictionary(t) {
+        return this.dictionaries.get(t.id);
+    }
+}
+class w9 extends ux {
+    constructor(t, n, r, i, s) {
+        super(new Uint8Array(0), n, r, i, s), this.sources = t;
+    }
+    readNullBitmap(t, n, {
+        offset: r
+    } = this.nextBufferRange()) {
+        return n <= 0 ? new Uint8Array(0) : l0(this.sources[r]);
+    }
+    readOffsets(t, {
+        offset: n
+    } = this.nextBufferRange()) {
+        return Yt(Uint8Array, Yt(t.OffsetArrayType, this.sources[n]));
+    }
+    readTypeIds(t, {
+        offset: n
+    } = this.nextBufferRange()) {
+        return Yt(Uint8Array, Yt(t.ArrayType, this.sources[n]));
+    }
+    readData(t, {
+        offset: n
+    } = this.nextBufferRange()) {
+        const {
+            sources: r
+        } = this;
+        return Q.isTimestamp(t) || (Q.isInt(t) || Q.isTime(t)) && t.bitWidth === 64 || Q.isDuration(t) || Q.isDate(t) && t.unit === Pn.MILLISECOND ? Yt(Uint8Array, Ye.convertArray(r[n])) : Q.isDecimal(t) ? Yt(Uint8Array, er.convertArray(r[n])) : Q.isBinary(t) || Q.isLargeBinary(t) || Q.isFixedSizeBinary(t) ? v9(r[n]) : Q.isBool(t) ? l0(r[n]) : Q.isUtf8(t) || Q.isLargeUtf8(t) ? jy(r[n].join("")) : Yt(Uint8Array, Yt(t.ArrayType, r[n].map((i) => +i)));
+    }
+}
 
-function w7(e) {
+function v9(e) {
     const t = e.join(""),
         n = new Uint8Array(t.length / 2);
-    for (let i = 0; i < t.length; i += 2)
-        n[i >> 1] = Number.parseInt(t.slice(i, i + 2), 16);
+    for (let r = 0; r < t.length; r += 2)
+        n[r >> 1] = Number.parseInt(t.slice(r, r + 2), 16);
     return n;
 }
-let ut = class extends Ut {
+class ot extends At {
     compareSchemas(t, n) {
         return t === n || n instanceof t.constructor && this.compareManyFields(t.fields, n.fields);
     }
     compareManyFields(t, n) {
-        return t === n || Array.isArray(t) && Array.isArray(n) && t.length === n.length && t.every((i, r) => this.compareFields(i, n[r]));
+        return t === n || Array.isArray(t) && Array.isArray(n) && t.length === n.length && t.every((r, i) => this.compareFields(r, n[i]));
     }
     compareFields(t, n) {
         return t === n || n instanceof t.constructor && t.name === n.name && t.nullable === n.nullable && this.visit(t.type, n.type);
     }
-};
+}
 
-function wn(e, t) {
+function je(e, t) {
     return t instanceof e.constructor;
 }
 
-function sa(e, t) {
-    return e === t || wn(e, t);
+function Bs(e, t) {
+    return e === t || je(e, t);
 }
 
-function cs(e, t) {
-    return e === t || wn(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned;
+function oi(e, t) {
+    return e === t || je(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned;
 }
 
-function Uy(e, t) {
-    return e === t || wn(e, t) && e.precision === t.precision;
+function Rh(e, t) {
+    return e === t || je(e, t) && e.precision === t.precision;
 }
 
-function v7(e, t) {
-    return e === t || wn(e, t) && e.byteWidth === t.byteWidth;
+function _9(e, t) {
+    return e === t || je(e, t) && e.byteWidth === t.byteWidth;
 }
 
-function Mb(e, t) {
-    return e === t || wn(e, t) && e.unit === t.unit;
+function sm(e, t) {
+    return e === t || je(e, t) && e.unit === t.unit;
 }
 
-function cf(e, t) {
-    return e === t || wn(e, t) && e.unit === t.unit && e.timezone === t.timezone;
+function Qc(e, t) {
+    return e === t || je(e, t) && e.unit === t.unit && e.timezone === t.timezone;
 }
 
-function lf(e, t) {
-    return e === t || wn(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth;
+function tu(e, t) {
+    return e === t || je(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth;
 }
 
-function _7(e, t) {
-    return e === t || wn(e, t) && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
+function x9(e, t) {
+    return e === t || je(e, t) && e.children.length === t.children.length && Ri.compareManyFields(e.children, t.children);
 }
 
-function x7(e, t) {
-    return e === t || wn(e, t) && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
+function S9(e, t) {
+    return e === t || je(e, t) && e.children.length === t.children.length && Ri.compareManyFields(e.children, t.children);
 }
 
-function $b(e, t) {
-    return e === t || wn(e, t) && e.mode === t.mode && e.typeIds.every((n, i) => n === t.typeIds[i]) && Vs.compareManyFields(e.children, t.children);
+function om(e, t) {
+    return e === t || je(e, t) && e.mode === t.mode && e.typeIds.every((n, r) => n === t.typeIds[r]) && Ri.compareManyFields(e.children, t.children);
 }
 
-function S7(e, t) {
-    return e === t || wn(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && Vs.visit(e.indices, t.indices) && Vs.visit(e.dictionary, t.dictionary);
+function M9(e, t) {
+    return e === t || je(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && Ri.visit(e.indices, t.indices) && Ri.visit(e.dictionary, t.dictionary);
 }
 
-function Tb(e, t) {
-    return e === t || wn(e, t) && e.unit === t.unit;
+function am(e, t) {
+    return e === t || je(e, t) && e.unit === t.unit;
 }
 
-function uf(e, t) {
-    return e === t || wn(e, t) && e.unit === t.unit;
+function eu(e, t) {
+    return e === t || je(e, t) && e.unit === t.unit;
 }
 
-function I7(e, t) {
-    return e === t || wn(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
+function A9(e, t) {
+    return e === t || je(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && Ri.compareManyFields(e.children, t.children);
 }
 
-function A7(e, t) {
-    return e === t || wn(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && Vs.compareManyFields(e.children, t.children);
+function $9(e, t) {
+    return e === t || je(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && Ri.compareManyFields(e.children, t.children);
 }
-ut.prototype.visitNull = sa;
-ut.prototype.visitBool = sa;
-ut.prototype.visitInt = cs;
-ut.prototype.visitInt8 = cs;
-ut.prototype.visitInt16 = cs;
-ut.prototype.visitInt32 = cs;
-ut.prototype.visitInt64 = cs;
-ut.prototype.visitUint8 = cs;
-ut.prototype.visitUint16 = cs;
-ut.prototype.visitUint32 = cs;
-ut.prototype.visitUint64 = cs;
-ut.prototype.visitFloat = Uy;
-ut.prototype.visitFloat16 = Uy;
-ut.prototype.visitFloat32 = Uy;
-ut.prototype.visitFloat64 = Uy;
-ut.prototype.visitUtf8 = sa;
-ut.prototype.visitLargeUtf8 = sa;
-ut.prototype.visitBinary = sa;
-ut.prototype.visitLargeBinary = sa;
-ut.prototype.visitFixedSizeBinary = v7;
-ut.prototype.visitDate = Mb;
-ut.prototype.visitDateDay = Mb;
-ut.prototype.visitDateMillisecond = Mb;
-ut.prototype.visitTimestamp = cf;
-ut.prototype.visitTimestampSecond = cf;
-ut.prototype.visitTimestampMillisecond = cf;
-ut.prototype.visitTimestampMicrosecond = cf;
-ut.prototype.visitTimestampNanosecond = cf;
-ut.prototype.visitTime = lf;
-ut.prototype.visitTimeSecond = lf;
-ut.prototype.visitTimeMillisecond = lf;
-ut.prototype.visitTimeMicrosecond = lf;
-ut.prototype.visitTimeNanosecond = lf;
-ut.prototype.visitDecimal = sa;
-ut.prototype.visitList = _7;
-ut.prototype.visitStruct = x7;
-ut.prototype.visitUnion = $b;
-ut.prototype.visitDenseUnion = $b;
-ut.prototype.visitSparseUnion = $b;
-ut.prototype.visitDictionary = S7;
-ut.prototype.visitInterval = Tb;
-ut.prototype.visitIntervalDayTime = Tb;
-ut.prototype.visitIntervalYearMonth = Tb;
-ut.prototype.visitDuration = uf;
-ut.prototype.visitDurationSecond = uf;
-ut.prototype.visitDurationMillisecond = uf;
-ut.prototype.visitDurationMicrosecond = uf;
-ut.prototype.visitDurationNanosecond = uf;
-ut.prototype.visitFixedSizeList = I7;
-ut.prototype.visitMap = A7;
-const Vs = new ut();
+ot.prototype.visitNull = Bs;
+ot.prototype.visitBool = Bs;
+ot.prototype.visitInt = oi;
+ot.prototype.visitInt8 = oi;
+ot.prototype.visitInt16 = oi;
+ot.prototype.visitInt32 = oi;
+ot.prototype.visitInt64 = oi;
+ot.prototype.visitUint8 = oi;
+ot.prototype.visitUint16 = oi;
+ot.prototype.visitUint32 = oi;
+ot.prototype.visitUint64 = oi;
+ot.prototype.visitFloat = Rh;
+ot.prototype.visitFloat16 = Rh;
+ot.prototype.visitFloat32 = Rh;
+ot.prototype.visitFloat64 = Rh;
+ot.prototype.visitUtf8 = Bs;
+ot.prototype.visitLargeUtf8 = Bs;
+ot.prototype.visitBinary = Bs;
+ot.prototype.visitLargeBinary = Bs;
+ot.prototype.visitFixedSizeBinary = _9;
+ot.prototype.visitDate = sm;
+ot.prototype.visitDateDay = sm;
+ot.prototype.visitDateMillisecond = sm;
+ot.prototype.visitTimestamp = Qc;
+ot.prototype.visitTimestampSecond = Qc;
+ot.prototype.visitTimestampMillisecond = Qc;
+ot.prototype.visitTimestampMicrosecond = Qc;
+ot.prototype.visitTimestampNanosecond = Qc;
+ot.prototype.visitTime = tu;
+ot.prototype.visitTimeSecond = tu;
+ot.prototype.visitTimeMillisecond = tu;
+ot.prototype.visitTimeMicrosecond = tu;
+ot.prototype.visitTimeNanosecond = tu;
+ot.prototype.visitDecimal = Bs;
+ot.prototype.visitList = x9;
+ot.prototype.visitStruct = S9;
+ot.prototype.visitUnion = om;
+ot.prototype.visitDenseUnion = om;
+ot.prototype.visitSparseUnion = om;
+ot.prototype.visitDictionary = M9;
+ot.prototype.visitInterval = am;
+ot.prototype.visitIntervalDayTime = am;
+ot.prototype.visitIntervalYearMonth = am;
+ot.prototype.visitDuration = eu;
+ot.prototype.visitDurationSecond = eu;
+ot.prototype.visitDurationMillisecond = eu;
+ot.prototype.visitDurationMicrosecond = eu;
+ot.prototype.visitDurationNanosecond = eu;
+ot.prototype.visitFixedSizeList = A9;
+ot.prototype.visitMap = $9;
+const Ri = new ot();
 
-function M7(e, t) {
-    return Vs.compareSchemas(e, t);
+function I9(e, t) {
+    return Ri.compareSchemas(e, t);
 }
 
-function rm(e, t) {
-    return $7(e, t.map((n) => n.data.concat()));
+function Qd(e, t) {
+    return T9(e, t.map((n) => n.data.concat()));
 }
 
-function $7(e, t) {
+function T9(e, t) {
     const n = [...e.fields],
-        i = [],
-        r = {
+        r = [],
+        i = {
             numBatches: t.reduce((f, h) => Math.max(f, h.length), 0)
         };
     let s = 0,
         o = 0,
         a = -1;
     const c = t.length;
-    let l, u = [];
-    for (; r.numBatches-- > 0;) {
+    let u, l = [];
+    for (; i.numBatches-- > 0;) {
         for (o = Number.POSITIVE_INFINITY, a = -1; ++a < c;)
-            u[a] = l = t[a].shift(), o = Math.min(o, l ? l.length : o);
-        Number.isFinite(o) && (u = T7(n, o, u, t, r), o > 0 && (i[s++] = Rt({
-            type: new fn(n),
+            l[a] = u = t[a].shift(), o = Math.min(o, u ? u.length : o);
+        Number.isFinite(o) && (l = E9(n, o, l, t, i), o > 0 && (r[s++] = St({
+            type: new Be(n),
             length: o,
             nullCount: 0,
-            children: u.slice()
+            children: l.slice()
         })));
     }
     return [
         e = e.assign(n),
-        i.map((f) => new gi(e, f))
+        r.map((f) => new Ln(e, f))
     ];
 }
 
-function T7(e, t, n, i, r) {
+function E9(e, t, n, r, i) {
     var s;
     const o = (t + 63 & -64) >> 3;
-    for (let a = -1, c = i.length; ++a < c;) {
-        const l = n[a],
-            u = l == null ? void 0 : l.length;
-        if (u >= t)
-            u === t ? n[a] = l : (n[a] = l.slice(0, t), r.numBatches = Math.max(r.numBatches, i[a].unshift(l.slice(t, u - t))));
+    for (let a = -1, c = r.length; ++a < c;) {
+        const u = n[a],
+            l = u == null ? void 0 : u.length;
+        if (l >= t)
+            l === t ? n[a] = u : (n[a] = u.slice(0, t), i.numBatches = Math.max(i.numBatches, r[a].unshift(u.slice(t, l - t))));
         else {
             const f = e[a];
             e[a] = f.clone({
                 nullable: !0
-            }), n[a] = (s = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : Rt({
+            }), n[a] = (s = u == null ? void 0 : u._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : St({
                 type: f.type,
                 length: t,
                 nullCount: t,
                 nullBitmap: new Uint8Array(o)
             });
         }
     }
     return n;
 }
-var SM;
-let $u = class $o {
+var lx;
+let xc = class as {
     constructor(...t) {
-        var n, i;
+        var n, r;
         if (t.length === 0)
-            return this.batches = [], this.schema = new _e([]), this._offsets = [0], this;
-        let r, s;
-        t[0] instanceof _e && (r = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
+            return this.batches = [], this.schema = new Pt([]), this._offsets = [0], this;
+        let i, s;
+        t[0] instanceof Pt && (i = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
         const o = (c) => {
                 if (c) {
-                    if (c instanceof gi)
+                    if (c instanceof Ln)
                         return [c];
-                    if (c instanceof $o)
+                    if (c instanceof as)
                         return c.batches;
-                    if (c instanceof de) {
-                        if (c.type instanceof fn)
-                            return [new gi(new _e(c.type.children), c)];
+                    if (c instanceof jt) {
+                        if (c.type instanceof Be)
+                            return [new Ln(new Pt(c.type.children), c)];
                     } else {
                         if (Array.isArray(c))
-                            return c.flatMap((l) => o(l));
+                            return c.flatMap((u) => o(u));
                         if (typeof c[Symbol.iterator] == "function")
-                            return [...c].flatMap((l) => o(l));
+                            return [...c].flatMap((u) => o(u));
                         if (typeof c == "object") {
-                            const l = Object.keys(c),
-                                u = l.map((d) => new Ne([c[d]])),
-                                f = r ?? new _e(l.map((d, p) => new Te(String(d), u[p].type, u[p].nullable))),
-                                [, h] = rm(f, u);
-                            return h.length === 0 ? [new gi(c)] : h;
+                            const u = Object.keys(c),
+                                l = u.map((d) => new ce([c[d]])),
+                                f = i ?? new Pt(u.map((d, p) => new Kt(String(d), l[p].type, l[p].nullable))),
+                                [, h] = Qd(f, l);
+                            return h.length === 0 ? [new Ln(c)] : h;
                         }
                     }
                 }
                 return [];
             },
             a = t.flatMap((c) => o(c));
-        if (r = (i = r ?? ((n = a[0]) === null || n === void 0 ? void 0 : n.schema)) !== null && i !== void 0 ? i : new _e([]), !(r instanceof _e))
+        if (i = (r = i ?? ((n = a[0]) === null || n === void 0 ? void 0 : n.schema)) !== null && r !== void 0 ? r : new Pt([]), !(i instanceof Pt))
             throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
         for (const c of a) {
-            if (!(c instanceof gi))
+            if (!(c instanceof Ln))
                 throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
-            if (!M7(r, c.schema))
+            if (!I9(i, c.schema))
                 throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
         }
-        this.schema = r, this.batches = a, this._offsets = s ?? lM(this.data);
+        this.schema = i, this.batches = a, this._offsets = s ?? Q_(this.data);
     }
     /**
      * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
      */
     get data() {
         return this.batches.map(({
             data: t
@@ -6891,15 +6899,15 @@
     get numRows() {
         return this.data.reduce((t, n) => t + n.length, 0);
     }
     /**
      * The number of null rows in this Table.
      */
     get nullCount() {
-        return this._nullCount === -1 && (this._nullCount = cM(this.data)), this._nullCount;
+        return this._nullCount === -1 && (this._nullCount = K_(this.data)), this._nullCount;
     }
     /**
      * Check whether an element is null.
      *
      * @param index The index at which to read the validity bitmap.
      */
     // @ts-ignore
@@ -6933,15 +6941,15 @@
     indexOf(t, n) {
         return -1;
     }
     /**
      * Iterator for rows in this Table.
      */
     [Symbol.iterator]() {
-        return this.batches.length > 0 ? Sb.visit(new Ne(this.data)) : new Array(0)[Symbol.iterator]();
+        return this.batches.length > 0 ? nm.visit(new ce(this.data)) : new Array(0)[Symbol.iterator]();
     }
     /**
      * Return a JavaScript Array of the Table rows.
      *
      * @returns An Array of Table rows.
      */
     toArray() {
@@ -6961,32 +6969,32 @@
     /**
      * Combines two or more Tables of the same schema.
      *
      * @param others Additional Tables to add to the end of this Tables.
      */
     concat(...t) {
         const n = this.schema,
-            i = this.data.concat(t.flatMap(({
-                data: r
-            }) => r));
-        return new $o(n, i.map((r) => new gi(n, r)));
+            r = this.data.concat(t.flatMap(({
+                data: i
+            }) => i));
+        return new as(n, r.map((i) => new Ln(n, i)));
     }
     /**
      * Return a zero-copy sub-section of this Table.
      *
      * @param begin The beginning of the specified portion of the Table.
      * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
      */
     slice(t, n) {
-        const i = this.schema;
-        [t, n] = oM({
+        const r = this.schema;
+        [t, n] = J_({
             length: this.numRows
         }, t, n);
-        const r = uM(this.data, this._offsets, t, n);
-        return new $o(i, r.map((s) => new gi(i, s)));
+        const i = tx(this.data, this._offsets, t, n);
+        return new as(r, i.map((s) => new Ln(r, s)));
     }
     /**
      * Returns a child Vector by name, or null if this Vector has no child with the given name.
      *
      * @param name The name of the child to retrieve.
      */
     getChild(t) {
@@ -6995,145 +7003,145 @@
     /**
      * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
      *
      * @param index The index of the child to retrieve.
      */
     getChildAt(t) {
         if (t > -1 && t < this.schema.fields.length) {
-            const n = this.data.map((i) => i.children[t]);
+            const n = this.data.map((r) => r.children[t]);
             if (n.length === 0) {
                 const {
-                    type: i
-                } = this.schema.fields[t], r = Rt({
-                    type: i,
+                    type: r
+                } = this.schema.fields[t], i = St({
+                    type: r,
                     length: 0,
                     nullCount: 0
                 });
-                n.push(r._changeLengthAndBackfillNullBitmap(this.numRows));
+                n.push(i._changeLengthAndBackfillNullBitmap(this.numRows));
             }
-            return new Ne(n);
+            return new ce(n);
         }
         return null;
     }
     /**
      * Sets a child Vector by name.
      *
      * @param name The name of the child to overwrite.
      * @returns A new Table with the supplied child for the specified name.
      */
     setChild(t, n) {
-        var i;
-        return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
+        var r;
+        return this.setChildAt((r = this.schema.fields) === null || r === void 0 ? void 0 : r.findIndex((i) => i.name === t), n);
     }
     setChildAt(t, n) {
-        let i = this.schema,
-            r = [...this.batches];
+        let r = this.schema,
+            i = [...this.batches];
         if (t > -1 && t < this.numCols) {
-            n || (n = new Ne([Rt({
-                type: new zs(),
+            n || (n = new ce([St({
+                type: new Li(),
                 length: this.numRows
             })]));
-            const s = i.fields.slice(),
+            const s = r.fields.slice(),
                 o = s[t].clone({
                     type: n.type
                 }),
-                a = this.schema.fields.map((c, l) => this.getChildAt(l));
-            [s[t], a[t]] = [o, n], [i, r] = rm(i, a);
+                a = this.schema.fields.map((c, u) => this.getChildAt(u));
+            [s[t], a[t]] = [o, n], [r, i] = Qd(r, a);
         }
-        return new $o(i, r);
+        return new as(r, i);
     }
     /**
      * Construct a new Table containing only specified columns.
      *
      * @param columnNames Names of columns to keep.
      * @returns A new Table of columns matching the specified names.
      */
     select(t) {
-        const n = this.schema.fields.reduce((i, r, s) => i.set(r.name, s), /* @__PURE__ */ new Map());
-        return this.selectAt(t.map((i) => n.get(i)).filter((i) => i > -1));
+        const n = this.schema.fields.reduce((r, i, s) => r.set(i.name, s), /* @__PURE__ */ new Map());
+        return this.selectAt(t.map((r) => n.get(r)).filter((r) => r > -1));
     }
     /**
      * Construct a new Table containing only columns at the specified indices.
      *
      * @param columnIndices Indices of columns to keep.
      * @returns A new Table of columns at the specified indices.
      */
     selectAt(t) {
         const n = this.schema.selectAt(t),
-            i = this.batches.map((r) => r.selectAt(t));
-        return new $o(n, i);
+            r = this.batches.map((i) => i.selectAt(t));
+        return new as(n, r);
     }
     assign(t) {
         const n = this.schema.fields,
-            [i, r] = t.schema.fields.reduce((a, c, l) => {
-                const [u, f] = a, h = n.findIndex((d) => d.name === c.name);
-                return ~h ? f[h] = l : u.push(l), a;
+            [r, i] = t.schema.fields.reduce((a, c, u) => {
+                const [l, f] = a, h = n.findIndex((d) => d.name === c.name);
+                return ~h ? f[h] = u : l.push(u), a;
             }, [
                 [],
                 []
             ]),
             s = this.schema.assign(t.schema),
             o = [
-                ...n.map((a, c) => [c, r[c]]).map(([a, c]) => c === void 0 ? this.getChildAt(a) : t.getChildAt(c)),
-                ...i.map((a) => t.getChildAt(a))
+                ...n.map((a, c) => [c, i[c]]).map(([a, c]) => c === void 0 ? this.getChildAt(a) : t.getChildAt(c)),
+                ...r.map((a) => t.getChildAt(a))
             ].filter(Boolean);
-        return new $o(...rm(s, o));
+        return new as(...Qd(s, o));
     }
 };
-SM = Symbol.toStringTag;
-$u[SM] = ((e) => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = Ld(xb), e.get = Ld($n.getVisitFn(F.Struct)), e.set = fM(ci.getVisitFn(F.Struct)), e.indexOf = hM(Rd.getVisitFn(F.Struct)), "Table"))($u.prototype);
-var IM;
-let gi = class ql {
+lx = Symbol.toStringTag;
+xc[lx] = ((e) => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = lf(em), e.get = lf(Ze.getVisitFn(L.Struct)), e.set = ex(An.getVisitFn(L.Struct)), e.indexOf = nx(ff.getVisitFn(L.Struct)), "Table"))(xc.prototype);
+var fx;
+let Ln = class Ja {
     constructor(...t) {
         switch (t.length) {
             case 2: {
-                if ([this.schema] = t, !(this.schema instanceof _e))
+                if ([this.schema] = t, !(this.schema instanceof Pt))
                     throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
                 if ([,
-                        this.data = Rt({
+                        this.data = St({
                             nullCount: 0,
-                            type: new fn(this.schema.fields),
-                            children: this.schema.fields.map((n) => Rt({
+                            type: new Be(this.schema.fields),
+                            children: this.schema.fields.map((n) => St({
                                 type: n.type,
                                 nullCount: 0
                             }))
                         })
-                    ] = t, !(this.data instanceof de))
+                    ] = t, !(this.data instanceof jt))
                     throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
-                [this.schema, this.data] = X_(this.schema, this.data.children);
+                [this.schema, this.data] = cb(this.schema, this.data.children);
                 break;
             }
             case 1: {
                 const [n] = t, {
-                    fields: i,
-                    children: r,
+                    fields: r,
+                    children: i,
                     length: s
-                } = Object.keys(n).reduce((c, l, u) => (c.children[u] = n[l], c.length = Math.max(c.length, n[l].length), c.fields[u] = Te.new({
-                    name: l,
-                    type: n[l].type,
+                } = Object.keys(n).reduce((c, u, l) => (c.children[l] = n[u], c.length = Math.max(c.length, n[u].length), c.fields[l] = Kt.new({
+                    name: u,
+                    type: n[u].type,
                     nullable: !0
                 }), c), {
                     length: 0,
                     fields: new Array(),
                     children: new Array()
-                }), o = new _e(i), a = Rt({
-                    type: new fn(i),
+                }), o = new Pt(r), a = St({
+                    type: new Be(r),
                     length: s,
-                    children: r,
+                    children: i,
                     nullCount: 0
                 });
-                [this.schema, this.data] = X_(o, a.children, s);
+                [this.schema, this.data] = cb(o, a.children, s);
                 break;
             }
             default:
                 throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
         }
     }
     get dictionaries() {
-        return this._dictionaries || (this._dictionaries = AM(this.schema.fields, this.data.children));
+        return this._dictionaries || (this._dictionaries = hx(this.schema.fields, this.data.children));
     }
     /**
      * The number of columns in this RecordBatch.
      */
     get numCols() {
         return this.schema.fields.length;
     }
@@ -7157,1735 +7165,1742 @@
         return this.data.getValid(t);
     }
     /**
      * Get a row by position.
      * @param index The index of the element to read.
      */
     get(t) {
-        return $n.visit(this.data, t);
+        return Ze.visit(this.data, t);
     }
     /**
      * Set a row by position.
      * @param index The index of the element to write.
      * @param value The value to set.
      */
     set(t, n) {
-        return ci.visit(this.data, t, n);
+        return An.visit(this.data, t, n);
     }
     /**
      * Retrieve the index of the first occurrence of a row in an RecordBatch.
      * @param element The row to locate in the RecordBatch.
      * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
      */
     indexOf(t, n) {
-        return Rd.visit(this.data, t, n);
+        return ff.visit(this.data, t, n);
     }
     /**
      * Iterator for rows in this RecordBatch.
      */
     [Symbol.iterator]() {
-        return Sb.visit(new Ne([this.data]));
+        return nm.visit(new ce([this.data]));
     }
     /**
      * Return a JavaScript Array of the RecordBatch rows.
      * @returns An Array of RecordBatch rows.
      */
     toArray() {
         return [...this];
     }
     /**
      * Combines two or more RecordBatch of the same schema.
      * @param others Additional RecordBatch to add to the end of this RecordBatch.
      */
     concat(...t) {
-        return new $u(this.schema, [this, ...t]);
+        return new xc(this.schema, [this, ...t]);
     }
     /**
      * Return a zero-copy sub-section of this RecordBatch.
      * @param start The beginning of the specified portion of the RecordBatch.
      * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
      */
     slice(t, n) {
-        const [i] = new Ne([this.data]).slice(t, n).data;
-        return new ql(this.schema, i);
+        const [r] = new ce([this.data]).slice(t, n).data;
+        return new Ja(this.schema, r);
     }
     /**
      * Returns a child Vector by name, or null if this Vector has no child with the given name.
      * @param name The name of the child to retrieve.
      */
     getChild(t) {
         var n;
-        return this.getChildAt((n = this.schema.fields) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
+        return this.getChildAt((n = this.schema.fields) === null || n === void 0 ? void 0 : n.findIndex((r) => r.name === t));
     }
     /**
      * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
      * @param index The index of the child to retrieve.
      */
     getChildAt(t) {
-        return t > -1 && t < this.schema.fields.length ? new Ne([this.data.children[t]]) : null;
+        return t > -1 && t < this.schema.fields.length ? new ce([this.data.children[t]]) : null;
     }
     /**
      * Sets a child Vector by name.
      * @param name The name of the child to overwrite.
      * @returns A new RecordBatch with the new child for the specified name.
      */
     setChild(t, n) {
-        var i;
-        return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
+        var r;
+        return this.setChildAt((r = this.schema.fields) === null || r === void 0 ? void 0 : r.findIndex((i) => i.name === t), n);
     }
     setChildAt(t, n) {
-        let i = this.schema,
-            r = this.data;
+        let r = this.schema,
+            i = this.data;
         if (t > -1 && t < this.numCols) {
-            n || (n = new Ne([Rt({
-                type: new zs(),
+            n || (n = new ce([St({
+                type: new Li(),
                 length: this.numRows
             })]));
-            const s = i.fields.slice(),
-                o = r.children.slice(),
+            const s = r.fields.slice(),
+                o = i.children.slice(),
                 a = s[t].clone({
                     type: n.type
                 });
-            [s[t], o[t]] = [a, n.data[0]], i = new _e(s, new Map(this.schema.metadata)), r = Rt({
-                type: new fn(s),
+            [s[t], o[t]] = [a, n.data[0]], r = new Pt(s, new Map(this.schema.metadata)), i = St({
+                type: new Be(s),
                 children: o
             });
         }
-        return new ql(i, r);
+        return new Ja(r, i);
     }
     /**
      * Construct a new RecordBatch containing only specified columns.
      *
      * @param columnNames Names of columns to keep.
      * @returns A new RecordBatch of columns matching the specified names.
      */
     select(t) {
         const n = this.schema.select(t),
-            i = new fn(n.fields),
-            r = [];
+            r = new Be(n.fields),
+            i = [];
         for (const s of t) {
             const o = this.schema.fields.findIndex((a) => a.name === s);
-            ~o && (r[o] = this.data.children[o]);
+            ~o && (i[o] = this.data.children[o]);
         }
-        return new ql(n, Rt({
-            type: i,
+        return new Ja(n, St({
+            type: r,
             length: this.numRows,
-            children: r
+            children: i
         }));
     }
     /**
      * Construct a new RecordBatch containing only columns at the specified indices.
      *
      * @param columnIndices Indices of columns to keep.
      * @returns A new RecordBatch of columns matching at the specified indices.
      */
     selectAt(t) {
         const n = this.schema.selectAt(t),
-            i = t.map((s) => this.data.children[s]).filter(Boolean),
-            r = Rt({
-                type: new fn(n.fields),
+            r = t.map((s) => this.data.children[s]).filter(Boolean),
+            i = St({
+                type: new Be(n.fields),
                 length: this.numRows,
-                children: i
+                children: r
             });
-        return new ql(n, r);
+        return new Ja(n, i);
     }
 };
-IM = Symbol.toStringTag;
-gi[IM] = ((e) => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))(gi.prototype);
+fx = Symbol.toStringTag;
+Ln[fx] = ((e) => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))(Ln.prototype);
 
-function X_(e, t, n = t.reduce((i, r) => Math.max(i, r.length), 0)) {
-    var i;
-    const r = [...e.fields],
+function cb(e, t, n = t.reduce((r, i) => Math.max(r, i.length), 0)) {
+    var r;
+    const i = [...e.fields],
         s = [...t],
         o = (n + 63 & -64) >> 3;
     for (const [a, c] of e.fields.entries()) {
-        const l = t[a];
-        (!l || l.length !== n) && (r[a] = c.clone({
+        const u = t[a];
+        (!u || u.length !== n) && (i[a] = c.clone({
             nullable: !0
-        }), s[a] = (i = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(n)) !== null && i !== void 0 ? i : Rt({
+        }), s[a] = (r = u == null ? void 0 : u._changeLengthAndBackfillNullBitmap(n)) !== null && r !== void 0 ? r : St({
             type: c.type,
             length: n,
             nullCount: n,
             nullBitmap: new Uint8Array(o)
         }));
     }
     return [
-        e.assign(r),
-        Rt({
-            type: new fn(r),
+        e.assign(i),
+        St({
+            type: new Be(i),
             length: n,
             children: s
         })
     ];
 }
 
-function AM(e, t, n = /* @__PURE__ */ new Map()) {
-    var i, r;
-    if (((i = e == null ? void 0 : e.length) !== null && i !== void 0 ? i : 0) > 0 && (e == null ? void 0 : e.length) === (t == null ? void 0 : t.length))
+function hx(e, t, n = /* @__PURE__ */ new Map()) {
+    var r, i;
+    if (((r = e == null ? void 0 : e.length) !== null && r !== void 0 ? r : 0) > 0 && (e == null ? void 0 : e.length) === (t == null ? void 0 : t.length))
         for (let s = -1, o = e.length; ++s < o;) {
             const {
                 type: a
             } = e[s], c = t[s];
-            for (const l of [c, ...((r = c == null ? void 0 : c.dictionary) === null || r === void 0 ? void 0 : r.data) || []])
-                AM(a.children, l == null ? void 0 : l.children, n);
-            if (gt.isDictionary(a)) {
+            for (const u of [c, ...((i = c == null ? void 0 : c.dictionary) === null || i === void 0 ? void 0 : i.data) || []])
+                hx(a.children, u == null ? void 0 : u.children, n);
+            if (Q.isDictionary(a)) {
                 const {
-                    id: l
+                    id: u
                 } = a;
-                if (!n.has(l))
-                    c != null && c.dictionary && n.set(l, c.dictionary);
-                else if (n.get(l) !== c.dictionary)
+                if (!n.has(u))
+                    c != null && c.dictionary && n.set(u, c.dictionary);
+                else if (n.get(u) !== c.dictionary)
                     throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
             }
         }
     return n;
 }
-let MM = class extends gi {
-        constructor(t) {
-            const n = t.fields.map((r) => Rt({
-                    type: r.type
-                })),
-                i = Rt({
-                    type: new fn(t.fields),
-                    nullCount: 0,
-                    children: n
-                });
-            super(t, i);
-        }
-    },
-    bs = class ji {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsMessage(t, n) {
-            return (n || new ji()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsMessage(t, n) {
-            return t.setPosition(t.position() + nt), (n || new ji()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        version() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : Ee.V1;
-        }
-        headerType() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? this.bb.readUint8(this.bb_pos + t) : Qt.NONE;
-        }
-        header(t) {
-            const n = this.bb.__offset(this.bb_pos, 8);
-            return n ? this.bb.__union(t, this.bb_pos + n) : null;
-        }
-        bodyLength() {
-            const t = this.bb.__offset(this.bb_pos, 10);
-            return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
-        }
-        customMetadata(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 12);
-            return i ? (n || new ni()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-        }
-        customMetadataLength() {
-            const t = this.bb.__offset(this.bb_pos, 12);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        static startMessage(t) {
-            t.startObject(5);
-        }
-        static addVersion(t, n) {
-            t.addFieldInt16(0, n, Ee.V1);
-        }
-        static addHeaderType(t, n) {
-            t.addFieldInt8(1, n, Qt.NONE);
-        }
-        static addHeader(t, n) {
-            t.addFieldOffset(2, n, 0);
-        }
-        static addBodyLength(t, n) {
-            t.addFieldInt64(3, n, BigInt("0"));
-        }
-        static addCustomMetadata(t, n) {
-            t.addFieldOffset(4, n, 0);
-        }
-        static createCustomMetadataVector(t, n) {
-            t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
-            return t.endVector();
-        }
-        static startCustomMetadataVector(t, n) {
-            t.startVector(4, n, 4);
-        }
-        static endMessage(t) {
-            return t.endObject();
-        }
-        static finishMessageBuffer(t, n) {
-            t.finish(n);
-        }
-        static finishSizePrefixedMessageBuffer(t, n) {
-            t.finish(n, void 0, !0);
-        }
-        static createMessage(t, n, i, r, s, o) {
-            return ji.startMessage(t), ji.addVersion(t, n), ji.addHeaderType(t, i), ji.addHeader(t, r), ji.addBodyLength(t, s), ji.addCustomMetadata(t, o), ji.endMessage(t);
-        }
-    },
-    D7 = class extends Ut {
-        visit(t, n) {
-            return t == null || n == null ? void 0 : super.visit(t, n);
-        }
-        visitNull(t, n) {
-            return R_.startNull(n), R_.endNull(n);
-        }
-        visitInt(t, n) {
-            return Ja.startInt(n), Ja.addBitWidth(n, t.bitWidth), Ja.addIsSigned(n, t.isSigned), Ja.endInt(n);
-        }
-        visitFloat(t, n) {
-            return Vh.startFloatingPoint(n), Vh.addPrecision(n, t.precision), Vh.endFloatingPoint(n);
-        }
-        visitBinary(t, n) {
-            return B_.startBinary(n), B_.endBinary(n);
-        }
-        visitLargeBinary(t, n) {
-            return F_.startLargeBinary(n), F_.endLargeBinary(n);
-        }
-        visitBool(t, n) {
-            return O_.startBool(n), O_.endBool(n);
-        }
-        visitUtf8(t, n) {
-            return k_.startUtf8(n), k_.endUtf8(n);
-        }
-        visitLargeUtf8(t, n) {
-            return E_.startLargeUtf8(n), E_.endLargeUtf8(n);
-        }
-        visitDecimal(t, n) {
-            return Oa.startDecimal(n), Oa.addScale(n, t.scale), Oa.addPrecision(n, t.precision), Oa.addBitWidth(n, t.bitWidth), Oa.endDecimal(n);
-        }
-        visitDate(t, n) {
-            return kh.startDate(n), kh.addUnit(n, t.unit), kh.endDate(n);
-        }
-        visitTime(t, n) {
-            return Pl.startTime(n), Pl.addUnit(n, t.unit), Pl.addBitWidth(n, t.bitWidth), Pl.endTime(n);
-        }
-        visitTimestamp(t, n) {
-            const i = t.timezone && n.createString(t.timezone) || void 0;
-            return Vl.startTimestamp(n), Vl.addUnit(n, t.unit), i !== void 0 && Vl.addTimezone(n, i), Vl.endTimestamp(n);
-        }
-        visitInterval(t, n) {
-            return jh.startInterval(n), jh.addUnit(n, t.unit), jh.endInterval(n);
-        }
-        visitDuration(t, n) {
-            return Uh.startDuration(n), Uh.addUnit(n, t.unit), Uh.endDuration(n);
-        }
-        visitList(t, n) {
-            return L_.startList(n), L_.endList(n);
-        }
-        visitStruct(t, n) {
-            return C_.startStruct_(n), C_.endStruct_(n);
-        }
-        visitUnion(t, n) {
-            So.startTypeIdsVector(n, t.typeIds.length);
-            const i = So.createTypeIdsVector(n, t.typeIds);
-            return So.startUnion(n), So.addMode(n, t.mode), So.addTypeIds(n, i), So.endUnion(n);
-        }
-        visitDictionary(t, n) {
-            const i = this.visit(t.indices, n);
-            return Na.startDictionaryEncoding(n), Na.addId(n, BigInt(t.id)), Na.addIsOrdered(n, t.isOrdered), i !== void 0 && Na.addIndexType(n, i), Na.endDictionaryEncoding(n);
-        }
-        visitFixedSizeBinary(t, n) {
-            return zh.startFixedSizeBinary(n), zh.addByteWidth(n, t.byteWidth), zh.endFixedSizeBinary(n);
-        }
-        visitFixedSizeList(t, n) {
-            return Ph.startFixedSizeList(n), Ph.addListSize(n, t.listSize), Ph.endFixedSizeList(n);
-        }
-        visitMap(t, n) {
-            return qh.startMap(n), qh.addKeysSorted(n, t.keysSorted), qh.endMap(n);
-        }
-    };
-const sm = new D7();
+class dx extends Ln {
+    constructor(t) {
+        const n = t.fields.map((i) => St({
+                type: i.type
+            })),
+            r = St({
+                type: new Be(t.fields),
+                nullCount: 0,
+                children: n
+            });
+        super(t, r);
+    }
+}
+let pi = class Qn {
+    constructor() {
+        this.bb = null, this.bb_pos = 0;
+    }
+    __init(t, n) {
+        return this.bb_pos = t, this.bb = n, this;
+    }
+    static getRootAsMessage(t, n) {
+        return (n || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    static getSizePrefixedRootAsMessage(t, n) {
+        return t.setPosition(t.position() + qt), (n || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
+    }
+    version() {
+        const t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : fe.V1;
+    }
+    headerType() {
+        const t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.readUint8(this.bb_pos + t) : Ct.NONE;
+    }
+    header(t) {
+        const n = this.bb.__offset(this.bb_pos, 8);
+        return n ? this.bb.__union(t, this.bb_pos + n) : null;
+    }
+    bodyLength() {
+        const t = this.bb.__offset(this.bb_pos, 10);
+        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
+    }
+    customMetadata(t, n) {
+        const r = this.bb.__offset(this.bb_pos, 12);
+        return r ? (n || new he()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
+    }
+    customMetadataLength() {
+        const t = this.bb.__offset(this.bb_pos, 12);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
+    }
+    static startMessage(t) {
+        t.startObject(5);
+    }
+    static addVersion(t, n) {
+        t.addFieldInt16(0, n, fe.V1);
+    }
+    static addHeaderType(t, n) {
+        t.addFieldInt8(1, n, Ct.NONE);
+    }
+    static addHeader(t, n) {
+        t.addFieldOffset(2, n, 0);
+    }
+    static addBodyLength(t, n) {
+        t.addFieldInt64(3, n, BigInt("0"));
+    }
+    static addCustomMetadata(t, n) {
+        t.addFieldOffset(4, n, 0);
+    }
+    static createCustomMetadataVector(t, n) {
+        t.startVector(4, n.length, 4);
+        for (let r = n.length - 1; r >= 0; r--)
+            t.addOffset(n[r]);
+        return t.endVector();
+    }
+    static startCustomMetadataVector(t, n) {
+        t.startVector(4, n, 4);
+    }
+    static endMessage(t) {
+        return t.endObject();
+    }
+    static finishMessageBuffer(t, n) {
+        t.finish(n);
+    }
+    static finishSizePrefixedMessageBuffer(t, n) {
+        t.finish(n, void 0, !0);
+    }
+    static createMessage(t, n, r, i, s, o) {
+        return Qn.startMessage(t), Qn.addVersion(t, n), Qn.addHeaderType(t, r), Qn.addHeader(t, i), Qn.addBodyLength(t, s), Qn.addCustomMetadata(t, o), Qn.endMessage(t);
+    }
+};
+class N9 extends At {
+    visit(t, n) {
+        return t == null || n == null ? void 0 : super.visit(t, n);
+    }
+    visitNull(t, n) {
+        return K1.startNull(n), K1.endNull(n);
+    }
+    visitInt(t, n) {
+        return rn.startInt(n), rn.addBitWidth(n, t.bitWidth), rn.addIsSigned(n, t.isSigned), rn.endInt(n);
+    }
+    visitFloat(t, n) {
+        return sr.startFloatingPoint(n), sr.addPrecision(n, t.precision), sr.endFloatingPoint(n);
+    }
+    visitBinary(t, n) {
+        return X1.startBinary(n), X1.endBinary(n);
+    }
+    visitLargeBinary(t, n) {
+        return H1.startLargeBinary(n), H1.endLargeBinary(n);
+    }
+    visitBool(t, n) {
+        return G1.startBool(n), G1.endBool(n);
+    }
+    visitUtf8(t, n) {
+        return Q1.startUtf8(n), Q1.endUtf8(n);
+    }
+    visitLargeUtf8(t, n) {
+        return J1.startLargeUtf8(n), J1.endLargeUtf8(n);
+    }
+    visitDecimal(t, n) {
+        return oo.startDecimal(n), oo.addScale(n, t.scale), oo.addPrecision(n, t.precision), oo.addBitWidth(n, t.bitWidth), oo.endDecimal(n);
+    }
+    visitDate(t, n) {
+        return _l.startDate(n), _l.addUnit(n, t.unit), _l.endDate(n);
+    }
+    visitTime(t, n) {
+        return bn.startTime(n), bn.addUnit(n, t.unit), bn.addBitWidth(n, t.bitWidth), bn.endTime(n);
+    }
+    visitTimestamp(t, n) {
+        const r = t.timezone && n.createString(t.timezone) || void 0;
+        return wn.startTimestamp(n), wn.addUnit(n, t.unit), r !== void 0 && wn.addTimezone(n, r), wn.endTimestamp(n);
+    }
+    visitInterval(t, n) {
+        return or.startInterval(n), or.addUnit(n, t.unit), or.endInterval(n);
+    }
+    visitDuration(t, n) {
+        return xl.startDuration(n), xl.addUnit(n, t.unit), xl.endDuration(n);
+    }
+    visitList(t, n) {
+        return Z1.startList(n), Z1.endList(n);
+    }
+    visitStruct(t, n) {
+        return fs.startStruct_(n), fs.endStruct_(n);
+    }
+    visitUnion(t, n) {
+        Xe.startTypeIdsVector(n, t.typeIds.length);
+        const r = Xe.createTypeIdsVector(n, t.typeIds);
+        return Xe.startUnion(n), Xe.addMode(n, t.mode), Xe.addTypeIds(n, r), Xe.endUnion(n);
+    }
+    visitDictionary(t, n) {
+        const r = this.visit(t.indices, n);
+        return jr.startDictionaryEncoding(n), jr.addId(n, BigInt(t.id)), jr.addIsOrdered(n, t.isOrdered), r !== void 0 && jr.addIndexType(n, r), jr.endDictionaryEncoding(n);
+    }
+    visitFixedSizeBinary(t, n) {
+        return Sl.startFixedSizeBinary(n), Sl.addByteWidth(n, t.byteWidth), Sl.endFixedSizeBinary(n);
+    }
+    visitFixedSizeList(t, n) {
+        return Ml.startFixedSizeList(n), Ml.addListSize(n, t.listSize), Ml.endFixedSizeList(n);
+    }
+    visitMap(t, n) {
+        return Al.startMap(n), Al.addKeysSorted(n, t.keysSorted), Al.endMap(n);
+    }
+}
+const tp = new N9();
 
-function N7(e, t = /* @__PURE__ */ new Map()) {
-    return new _e(O7(e, t), Gh(e.metadata), t);
+function D9(e, t = /* @__PURE__ */ new Map()) {
+    return new Pt(L9(e, t), Il(e.metadata), t);
 }
 
-function $M(e) {
-    return new Ai(e.count, TM(e.columns), DM(e.columns));
+function px(e) {
+    return new Un(e.count, yx(e.columns), mx(e.columns));
 }
 
-function B7(e) {
-    return new is($M(e.data), e.id, e.isDelta);
+function O9(e) {
+    return new ni(px(e.data), e.id, e.isDelta);
 }
 
-function O7(e, t) {
-    return (e.fields || []).filter(Boolean).map((n) => Te.fromJSON(n, t));
+function L9(e, t) {
+    return (e.fields || []).filter(Boolean).map((n) => Kt.fromJSON(n, t));
 }
 
-function H_(e, t) {
-    return (e.children || []).filter(Boolean).map((n) => Te.fromJSON(n, t));
+function ub(e, t) {
+    return (e.children || []).filter(Boolean).map((n) => Kt.fromJSON(n, t));
 }
 
-function TM(e) {
+function yx(e) {
     return (e || []).reduce((t, n) => [
         ...t,
-        new Qc(n.count, F7(n.VALIDITY)),
-        ...TM(n.children)
+        new fa(n.count, k9(n.VALIDITY)),
+        ...yx(n.children)
     ], []);
 }
 
-function DM(e, t = []) {
-    for (let n = -1, i = (e || []).length; ++n < i;) {
-        const r = e[n];
-        r.VALIDITY && t.push(new Yr(t.length, r.VALIDITY.length)), r.TYPE_ID && t.push(new Yr(t.length, r.TYPE_ID.length)), r.OFFSET && t.push(new Yr(t.length, r.OFFSET.length)), r.DATA && t.push(new Yr(t.length, r.DATA.length)), t = DM(r.children, t);
+function mx(e, t = []) {
+    for (let n = -1, r = (e || []).length; ++n < r;) {
+        const i = e[n];
+        i.VALIDITY && t.push(new Yr(t.length, i.VALIDITY.length)), i.TYPE_ID && t.push(new Yr(t.length, i.TYPE_ID.length)), i.OFFSET && t.push(new Yr(t.length, i.OFFSET.length)), i.DATA && t.push(new Yr(t.length, i.DATA.length)), t = mx(i.children, t);
     }
     return t;
 }
 
-function F7(e) {
+function k9(e) {
     return (e || []).reduce((t, n) => t + +(n === 0), 0);
 }
 
-function E7(e, t) {
-    let n, i, r, s, o, a;
-    return !t || !(s = e.dictionary) ? (o = K_(e, H_(e, t)), r = new Te(e.name, o, e.nullable, Gh(e.metadata))) : t.has(n = s.id) ? (i = (i = s.indexType) ? J_(i) : new Iu(), a = new Ic(t.get(n), i, n, s.isOrdered), r = new Te(e.name, a, e.nullable, Gh(e.metadata))) : (i = (i = s.indexType) ? J_(i) : new Iu(), t.set(n, o = K_(e, H_(e, t))), a = new Ic(o, i, n, s.isOrdered), r = new Te(e.name, a, e.nullable, Gh(e.metadata))), r || null;
+function R9(e, t) {
+    let n, r, i, s, o, a;
+    return !t || !(s = e.dictionary) ? (o = fb(e, ub(e, t)), i = new Kt(e.name, o, e.nullable, Il(e.metadata))) : t.has(n = s.id) ? (r = (r = s.indexType) ? lb(r) : new wc(), a = new Co(t.get(n), r, n, s.isOrdered), i = new Kt(e.name, a, e.nullable, Il(e.metadata))) : (r = (r = s.indexType) ? lb(r) : new wc(), t.set(n, o = fb(e, ub(e, t))), a = new Co(o, r, n, s.isOrdered), i = new Kt(e.name, a, e.nullable, Il(e.metadata))), i || null;
 }
 
-function Gh(e = []) {
+function Il(e = []) {
     return new Map(e.map(({
         key: t,
         value: n
     }) => [t, n]));
 }
 
-function J_(e) {
-    return new Ps(e.isSigned, e.bitWidth);
+function lb(e) {
+    return new ki(e.isSigned, e.bitWidth);
 }
 
-function K_(e, t) {
+function fb(e, t) {
     const n = e.type.name;
     switch (n) {
         case "NONE":
-            return new zs();
+            return new Li();
         case "null":
-            return new zs();
+            return new Li();
         case "binary":
-            return new vd();
+            return new Gl();
         case "largebinary":
-            return new _d();
+            return new Hl();
         case "utf8":
-            return new xd();
+            return new Jl();
         case "largeutf8":
-            return new Sd();
+            return new Zl();
         case "bool":
-            return new Id();
+            return new Kl();
         case "list":
-            return new Nd((t || [])[0]);
+            return new sf((t || [])[0]);
         case "struct":
-            return new fn(t || []);
+            return new Be(t || []);
         case "struct_":
-            return new fn(t || []);
+            return new Be(t || []);
     }
     switch (n) {
         case "int": {
-            const i = e.type;
-            return new Ps(i.isSigned, i.bitWidth);
+            const r = e.type;
+            return new ki(r.isSigned, r.bitWidth);
         }
         case "floatingpoint": {
-            const i = e.type;
-            return new Au(nn[i.precision]);
+            const r = e.type;
+            return new vc(De[r.precision]);
         }
         case "decimal": {
-            const i = e.type;
-            return new Ad(i.scale, i.precision, i.bitWidth);
+            const r = e.type;
+            return new Ql(r.scale, r.precision, r.bitWidth);
         }
         case "date": {
-            const i = e.type;
-            return new Md(Ii[i.unit]);
+            const r = e.type;
+            return new tf(Pn[r.unit]);
         }
         case "time": {
-            const i = e.type;
-            return new Mu(mt[i.unit], i.bitWidth);
+            const r = e.type;
+            return new _c(ct[r.unit], r.bitWidth);
         }
         case "timestamp": {
-            const i = e.type;
-            return new $d(mt[i.unit], i.timezone);
+            const r = e.type;
+            return new ef(ct[r.unit], r.timezone);
         }
         case "interval": {
-            const i = e.type;
-            return new Td(lr[i.unit]);
+            const r = e.type;
+            return new nf(br[r.unit]);
         }
         case "duration": {
-            const i = e.type;
-            return new Dd(mt[i.unit]);
+            const r = e.type;
+            return new rf(ct[r.unit]);
         }
         case "union": {
-            const i = e.type,
-                [r, ...s] = (i.mode + "").toLowerCase(),
-                o = r.toUpperCase() + s.join("");
-            return new Bd(Mn[o], i.typeIds || [], t || []);
+            const r = e.type,
+                [i, ...s] = (r.mode + "").toLowerCase(),
+                o = i.toUpperCase() + s.join("");
+            return new of(Je[o], r.typeIds || [], t || []);
         }
         case "fixedsizebinary": {
-            const i = e.type;
-            return new Od(i.byteWidth);
+            const r = e.type;
+            return new af(r.byteWidth);
         }
         case "fixedsizelist": {
-            const i = e.type;
-            return new Fd(i.listSize, (t || [])[0]);
+            const r = e.type;
+            return new cf(r.listSize, (t || [])[0]);
         }
         case "map": {
-            const i = e.type;
-            return new Ed((t || [])[0], i.keysSorted);
+            const r = e.type;
+            return new uf((t || [])[0], r.keysSorted);
         }
     }
     throw new Error(`Unrecognized type: "${n}"`);
 }
-var L7 = Cy,
-    R7 = ur;
-let lu = class za {
-        /** @nocollapse */
-        static fromJSON(t, n) {
-            const i = new za(0, Ee.V5, n);
-            return i._createHeader = C7(t, n), i;
-        }
-        /** @nocollapse */
-        static decode(t) {
-            t = new R7(Yt(t));
-            const n = bs.getRootAsMessage(t),
-                i = n.bodyLength(),
-                r = n.version(),
-                s = n.headerType(),
-                o = new za(i, r, s);
-            return o._createHeader = k7(n, s), o;
-        }
-        /** @nocollapse */
-        static encode(t) {
-            const n = new L7();
-            let i = -1;
-            return t.isSchema() ? i = _e.encode(n, t.header()) : t.isRecordBatch() ? i = Ai.encode(n, t.header()) : t.isDictionaryBatch() && (i = is.encode(n, t.header())), bs.startMessage(n), bs.addVersion(n, Ee.V5), bs.addHeader(n, i), bs.addHeaderType(n, t.headerType), bs.addBodyLength(n, BigInt(t.bodyLength)), bs.finishMessageBuffer(n, bs.endMessage(n)), n.asUint8Array();
-        }
-        /** @nocollapse */
-        static from(t, n = 0) {
-            if (t instanceof _e)
-                return new za(0, Ee.V5, Qt.Schema, t);
-            if (t instanceof Ai)
-                return new za(n, Ee.V5, Qt.RecordBatch, t);
-            if (t instanceof is)
-                return new za(n, Ee.V5, Qt.DictionaryBatch, t);
-            throw new Error(`Unrecognized Message header: ${t}`);
-        }
-        get type() {
-            return this.headerType;
-        }
-        get version() {
-            return this._version;
-        }
-        get headerType() {
-            return this._headerType;
-        }
-        get bodyLength() {
-            return this._bodyLength;
-        }
-        header() {
-            return this._createHeader();
-        }
-        isSchema() {
-            return this.headerType === Qt.Schema;
-        }
-        isRecordBatch() {
-            return this.headerType === Qt.RecordBatch;
-        }
-        isDictionaryBatch() {
-            return this.headerType === Qt.DictionaryBatch;
-        }
-        constructor(t, n, i, r) {
-            this._version = n, this._headerType = i, this.body = new Uint8Array(0), r && (this._createHeader = () => r), this._bodyLength = pn(t);
-        }
-    },
-    Ai = class {
-        get nodes() {
-            return this._nodes;
-        }
-        get length() {
-            return this._length;
-        }
-        get buffers() {
-            return this._buffers;
-        }
-        constructor(t, n, i) {
-            this._nodes = n, this._buffers = i, this._length = pn(t);
-        }
-    },
-    is = class {
-        get id() {
-            return this._id;
-        }
-        get data() {
-            return this._data;
-        }
-        get isDelta() {
-            return this._isDelta;
-        }
-        get length() {
-            return this.data.length;
-        }
-        get nodes() {
-            return this.data.nodes;
-        }
-        get buffers() {
-            return this.data.buffers;
-        }
-        constructor(t, n, i = !1) {
-            this._data = t, this._isDelta = i, this._id = pn(n);
-        }
-    },
-    Yr = class {
-        constructor(t, n) {
-            this.offset = pn(t), this.length = pn(n);
-        }
-    },
-    Qc = class {
-        constructor(t, n) {
-            this.length = pn(t), this.nullCount = pn(n);
-        }
-    };
+var F9 = Nv,
+    B9 = Fo;
+class kn {
+    /** @nocollapse */
+    static fromJSON(t, n) {
+        const r = new kn(0, fe.V5, n);
+        return r._createHeader = C9(t, n), r;
+    }
+    /** @nocollapse */
+    static decode(t) {
+        t = new B9(Dt(t));
+        const n = pi.getRootAsMessage(t),
+            r = n.bodyLength(),
+            i = n.version(),
+            s = n.headerType(),
+            o = new kn(r, i, s);
+        return o._createHeader = P9(n, s), o;
+    }
+    /** @nocollapse */
+    static encode(t) {
+        const n = new F9();
+        let r = -1;
+        return t.isSchema() ? r = Pt.encode(n, t.header()) : t.isRecordBatch() ? r = Un.encode(n, t.header()) : t.isDictionaryBatch() && (r = ni.encode(n, t.header())), pi.startMessage(n), pi.addVersion(n, fe.V5), pi.addHeader(n, r), pi.addHeaderType(n, t.headerType), pi.addBodyLength(n, BigInt(t.bodyLength)), pi.finishMessageBuffer(n, pi.endMessage(n)), n.asUint8Array();
+    }
+    /** @nocollapse */
+    static from(t, n = 0) {
+        if (t instanceof Pt)
+            return new kn(0, fe.V5, Ct.Schema, t);
+        if (t instanceof Un)
+            return new kn(n, fe.V5, Ct.RecordBatch, t);
+        if (t instanceof ni)
+            return new kn(n, fe.V5, Ct.DictionaryBatch, t);
+        throw new Error(`Unrecognized Message header: ${t}`);
+    }
+    get type() {
+        return this.headerType;
+    }
+    get version() {
+        return this._version;
+    }
+    get headerType() {
+        return this._headerType;
+    }
+    get bodyLength() {
+        return this._bodyLength;
+    }
+    header() {
+        return this._createHeader();
+    }
+    isSchema() {
+        return this.headerType === Ct.Schema;
+    }
+    isRecordBatch() {
+        return this.headerType === Ct.RecordBatch;
+    }
+    isDictionaryBatch() {
+        return this.headerType === Ct.DictionaryBatch;
+    }
+    constructor(t, n, r, i) {
+        this._version = n, this._headerType = r, this.body = new Uint8Array(0), i && (this._createHeader = () => i), this._bodyLength = Pe(t);
+    }
+}
+class Un {
+    get nodes() {
+        return this._nodes;
+    }
+    get length() {
+        return this._length;
+    }
+    get buffers() {
+        return this._buffers;
+    }
+    constructor(t, n, r) {
+        this._nodes = n, this._buffers = r, this._length = Pe(t);
+    }
+}
+class ni {
+    get id() {
+        return this._id;
+    }
+    get data() {
+        return this._data;
+    }
+    get isDelta() {
+        return this._isDelta;
+    }
+    get length() {
+        return this.data.length;
+    }
+    get nodes() {
+        return this.data.nodes;
+    }
+    get buffers() {
+        return this.data.buffers;
+    }
+    constructor(t, n, r = !1) {
+        this._data = t, this._isDelta = r, this._id = Pe(n);
+    }
+}
+class Yr {
+    constructor(t, n) {
+        this.offset = Pe(t), this.length = Pe(n);
+    }
+}
+class fa {
+    constructor(t, n) {
+        this.length = Pe(t), this.nullCount = Pe(n);
+    }
+}
 
-function C7(e, t) {
+function C9(e, t) {
     return () => {
         switch (t) {
-            case Qt.Schema:
-                return _e.fromJSON(e);
-            case Qt.RecordBatch:
-                return Ai.fromJSON(e);
-            case Qt.DictionaryBatch:
-                return is.fromJSON(e);
+            case Ct.Schema:
+                return Pt.fromJSON(e);
+            case Ct.RecordBatch:
+                return Un.fromJSON(e);
+            case Ct.DictionaryBatch:
+                return ni.fromJSON(e);
         }
-        throw new Error(`Unrecognized Message type: { name: ${Qt[t]}, type: ${t} }`);
+        throw new Error(`Unrecognized Message type: { name: ${Ct[t]}, type: ${t} }`);
     };
 }
 
-function k7(e, t) {
+function P9(e, t) {
     return () => {
         switch (t) {
-            case Qt.Schema:
-                return _e.decode(e.header(new Yi()), /* @__PURE__ */ new Map(), e.version());
-            case Qt.RecordBatch:
-                return Ai.decode(e.header(new Lr()), e.version());
-            case Qt.DictionaryBatch:
-                return is.decode(e.header(new Da()), e.version());
-        }
-        throw new Error(`Unrecognized Message type: { name: ${Qt[t]}, type: ${t} }`);
-    };
-}
-Te.encode = H7;
-Te.decode = G7;
-Te.fromJSON = E7;
-_e.encode = X7;
-_e.decode = U7;
-_e.fromJSON = N7;
-Ai.encode = J7;
-Ai.decode = z7;
-Ai.fromJSON = $M;
-is.encode = K7;
-is.decode = P7;
-is.fromJSON = B7;
-Qc.encode = Z7;
-Qc.decode = j7;
-Yr.encode = Q7;
-Yr.decode = V7;
-
-function U7(e, t = /* @__PURE__ */ new Map(), n = Ee.V5) {
-    const i = W7(e, t);
-    return new _e(i, Xh(e), t, n);
+            case Ct.Schema:
+                return Pt.decode(e.header(new tr()), /* @__PURE__ */ new Map(), e.version());
+            case Ct.RecordBatch:
+                return Un.decode(e.header(new Cr()), e.version());
+            case Ct.DictionaryBatch:
+                return ni.decode(e.header(new io()), e.version());
+        }
+        throw new Error(`Unrecognized Message type: { name: ${Ct[t]}, type: ${t} }`);
+    };
+}
+Kt.encode = J9;
+Kt.decode = G9;
+Kt.fromJSON = R9;
+Pt.encode = H9;
+Pt.decode = U9;
+Pt.fromJSON = D9;
+Un.encode = Z9;
+Un.decode = z9;
+Un.fromJSON = px;
+ni.encode = K9;
+ni.decode = q9;
+ni.fromJSON = O9;
+fa.encode = Q9;
+fa.decode = V9;
+Yr.encode = tO;
+Yr.decode = j9;
+
+function U9(e, t = /* @__PURE__ */ new Map(), n = fe.V5) {
+    const r = X9(e, t);
+    return new Pt(r, Tl(e), t, n);
 }
 
-function z7(e, t = Ee.V5) {
+function z9(e, t = fe.V5) {
     if (e.compression() !== null)
         throw new Error("Record batch compression not implemented");
-    return new Ai(e.length(), q7(e), Y7(e, t));
+    return new Un(e.length(), Y9(e), W9(e, t));
 }
 
-function P7(e, t = Ee.V5) {
-    return new is(Ai.decode(e.data(), t), e.id(), e.isDelta());
+function q9(e, t = fe.V5) {
+    return new ni(Un.decode(e.data(), t), e.id(), e.isDelta());
 }
 
-function V7(e) {
+function j9(e) {
     return new Yr(e.offset(), e.length());
 }
 
-function j7(e) {
-    return new Qc(e.length(), e.nullCount());
+function V9(e) {
+    return new fa(e.length(), e.nullCount());
 }
 
-function q7(e) {
+function Y9(e) {
     const t = [];
-    for (let n, i = -1, r = -1, s = e.nodesLength(); ++i < s;)
-        (n = e.nodes(i)) && (t[++r] = Qc.decode(n));
+    for (let n, r = -1, i = -1, s = e.nodesLength(); ++r < s;)
+        (n = e.nodes(r)) && (t[++i] = fa.decode(n));
     return t;
 }
 
-function Y7(e, t) {
+function W9(e, t) {
     const n = [];
-    for (let i, r = -1, s = -1, o = e.buffersLength(); ++r < o;)
-        (i = e.buffers(r)) && (t < Ee.V4 && (i.bb_pos += 8 * (r + 1)), n[++s] = Yr.decode(i));
+    for (let r, i = -1, s = -1, o = e.buffersLength(); ++i < o;)
+        (r = e.buffers(i)) && (t < fe.V4 && (r.bb_pos += 8 * (i + 1)), n[++s] = Yr.decode(r));
     return n;
 }
 
-function W7(e, t) {
+function X9(e, t) {
     const n = [];
-    for (let i, r = -1, s = -1, o = e.fieldsLength(); ++r < o;)
-        (i = e.fields(r)) && (n[++s] = Te.decode(i, t));
+    for (let r, i = -1, s = -1, o = e.fieldsLength(); ++i < o;)
+        (r = e.fields(i)) && (n[++s] = Kt.decode(r, t));
     return n;
 }
 
-function Z_(e, t) {
+function hb(e, t) {
     const n = [];
-    for (let i, r = -1, s = -1, o = e.childrenLength(); ++r < o;)
-        (i = e.children(r)) && (n[++s] = Te.decode(i, t));
+    for (let r, i = -1, s = -1, o = e.childrenLength(); ++i < o;)
+        (r = e.children(i)) && (n[++s] = Kt.decode(r, t));
     return n;
 }
 
-function G7(e, t) {
-    let n, i, r, s, o, a;
-    return !t || !(a = e.dictionary()) ? (r = t2(e, Z_(e, t)), i = new Te(e.name(), r, e.nullable(), Xh(e))) : t.has(n = pn(a.id())) ? (s = (s = a.indexType()) ? Q_(s) : new Iu(), o = new Ic(t.get(n), s, n, a.isOrdered()), i = new Te(e.name(), o, e.nullable(), Xh(e))) : (s = (s = a.indexType()) ? Q_(s) : new Iu(), t.set(n, r = t2(e, Z_(e, t))), o = new Ic(r, s, n, a.isOrdered()), i = new Te(e.name(), o, e.nullable(), Xh(e))), i || null;
+function G9(e, t) {
+    let n, r, i, s, o, a;
+    return !t || !(a = e.dictionary()) ? (i = pb(e, hb(e, t)), r = new Kt(e.name(), i, e.nullable(), Tl(e))) : t.has(n = Pe(a.id())) ? (s = (s = a.indexType()) ? db(s) : new wc(), o = new Co(t.get(n), s, n, a.isOrdered()), r = new Kt(e.name(), o, e.nullable(), Tl(e))) : (s = (s = a.indexType()) ? db(s) : new wc(), t.set(n, i = pb(e, hb(e, t))), o = new Co(i, s, n, a.isOrdered()), r = new Kt(e.name(), o, e.nullable(), Tl(e))), r || null;
 }
 
-function Xh(e) {
+function Tl(e) {
     const t = /* @__PURE__ */ new Map();
     if (e)
-        for (let n, i, r = -1, s = Math.trunc(e.customMetadataLength()); ++r < s;)
-            (n = e.customMetadata(r)) && (i = n.key()) != null && t.set(i, n.value());
+        for (let n, r, i = -1, s = Math.trunc(e.customMetadataLength()); ++i < s;)
+            (n = e.customMetadata(i)) && (r = n.key()) != null && t.set(r, n.value());
     return t;
 }
 
-function Q_(e) {
-    return new Ps(e.isSigned(), e.bitWidth());
+function db(e) {
+    return new ki(e.isSigned(), e.bitWidth());
 }
 
-function t2(e, t) {
+function pb(e, t) {
     const n = e.typeType();
     switch (n) {
-        case he.NONE:
-            return new zs();
-        case he.Null:
-            return new zs();
-        case he.Binary:
-            return new vd();
-        case he.LargeBinary:
-            return new _d();
-        case he.Utf8:
-            return new xd();
-        case he.LargeUtf8:
-            return new Sd();
-        case he.Bool:
-            return new Id();
-        case he.List:
-            return new Nd((t || [])[0]);
-        case he.Struct_:
-            return new fn(t || []);
+        case Jt.NONE:
+            return new Li();
+        case Jt.Null:
+            return new Li();
+        case Jt.Binary:
+            return new Gl();
+        case Jt.LargeBinary:
+            return new Hl();
+        case Jt.Utf8:
+            return new Jl();
+        case Jt.LargeUtf8:
+            return new Zl();
+        case Jt.Bool:
+            return new Kl();
+        case Jt.List:
+            return new sf((t || [])[0]);
+        case Jt.Struct_:
+            return new Be(t || []);
     }
     switch (n) {
-        case he.Int: {
-            const i = e.type(new Ja());
-            return new Ps(i.isSigned(), i.bitWidth());
+        case Jt.Int: {
+            const r = e.type(new rn());
+            return new ki(r.isSigned(), r.bitWidth());
         }
-        case he.FloatingPoint: {
-            const i = e.type(new Vh());
-            return new Au(i.precision());
+        case Jt.FloatingPoint: {
+            const r = e.type(new sr());
+            return new vc(r.precision());
         }
-        case he.Decimal: {
-            const i = e.type(new Oa());
-            return new Ad(i.scale(), i.precision(), i.bitWidth());
+        case Jt.Decimal: {
+            const r = e.type(new oo());
+            return new Ql(r.scale(), r.precision(), r.bitWidth());
         }
-        case he.Date: {
-            const i = e.type(new kh());
-            return new Md(i.unit());
+        case Jt.Date: {
+            const r = e.type(new _l());
+            return new tf(r.unit());
         }
-        case he.Time: {
-            const i = e.type(new Pl());
-            return new Mu(i.unit(), i.bitWidth());
+        case Jt.Time: {
+            const r = e.type(new bn());
+            return new _c(r.unit(), r.bitWidth());
         }
-        case he.Timestamp: {
-            const i = e.type(new Vl());
-            return new $d(i.unit(), i.timezone());
+        case Jt.Timestamp: {
+            const r = e.type(new wn());
+            return new ef(r.unit(), r.timezone());
         }
-        case he.Interval: {
-            const i = e.type(new jh());
-            return new Td(i.unit());
+        case Jt.Interval: {
+            const r = e.type(new or());
+            return new nf(r.unit());
         }
-        case he.Duration: {
-            const i = e.type(new Uh());
-            return new Dd(i.unit());
+        case Jt.Duration: {
+            const r = e.type(new xl());
+            return new rf(r.unit());
         }
-        case he.Union: {
-            const i = e.type(new So());
-            return new Bd(i.mode(), i.typeIdsArray() || [], t || []);
+        case Jt.Union: {
+            const r = e.type(new Xe());
+            return new of(r.mode(), r.typeIdsArray() || [], t || []);
         }
-        case he.FixedSizeBinary: {
-            const i = e.type(new zh());
-            return new Od(i.byteWidth());
+        case Jt.FixedSizeBinary: {
+            const r = e.type(new Sl());
+            return new af(r.byteWidth());
         }
-        case he.FixedSizeList: {
-            const i = e.type(new Ph());
-            return new Fd(i.listSize(), (t || [])[0]);
+        case Jt.FixedSizeList: {
+            const r = e.type(new Ml());
+            return new cf(r.listSize(), (t || [])[0]);
         }
-        case he.Map: {
-            const i = e.type(new qh());
-            return new Ed((t || [])[0], i.keysSorted());
+        case Jt.Map: {
+            const r = e.type(new Al());
+            return new uf((t || [])[0], r.keysSorted());
         }
     }
-    throw new Error(`Unrecognized type: "${he[n]}" (${n})`);
+    throw new Error(`Unrecognized type: "${Jt[n]}" (${n})`);
 }
 
-function X7(e, t) {
-    const n = t.fields.map((s) => Te.encode(e, s));
-    Yi.startFieldsVector(e, n.length);
-    const i = Yi.createFieldsVector(e, n),
-        r = t.metadata && t.metadata.size > 0 ? Yi.createCustomMetadataVector(e, [...t.metadata].map(([s, o]) => {
+function H9(e, t) {
+    const n = t.fields.map((s) => Kt.encode(e, s));
+    tr.startFieldsVector(e, n.length);
+    const r = tr.createFieldsVector(e, n),
+        i = t.metadata && t.metadata.size > 0 ? tr.createCustomMetadataVector(e, [...t.metadata].map(([s, o]) => {
             const a = e.createString(`${s}`),
                 c = e.createString(`${o}`);
-            return ni.startKeyValue(e), ni.addKey(e, a), ni.addValue(e, c), ni.endKeyValue(e);
+            return he.startKeyValue(e), he.addKey(e, a), he.addValue(e, c), he.endKeyValue(e);
         })) : -1;
-    return Yi.startSchema(e), Yi.addFields(e, i), Yi.addEndianness(e, t9 ? Sc.Little : Sc.Big), r !== -1 && Yi.addCustomMetadata(e, r), Yi.endSchema(e);
+    return tr.startSchema(e), tr.addFields(e, r), tr.addEndianness(e, eO ? Bo.Little : Bo.Big), i !== -1 && tr.addCustomMetadata(e, i), tr.endSchema(e);
 }
 
-function H7(e, t) {
+function J9(e, t) {
     let n = -1,
-        i = -1,
-        r = -1;
+        r = -1,
+        i = -1;
     const s = t.type;
     let o = t.typeId;
-    gt.isDictionary(s) ? (o = s.dictionary.typeId, r = sm.visit(s, e), i = sm.visit(s.dictionary, e)) : i = sm.visit(s, e);
-    const a = (s.children || []).map((u) => Te.encode(e, u)),
-        c = Gn.createChildrenVector(e, a),
-        l = t.metadata && t.metadata.size > 0 ? Gn.createCustomMetadataVector(e, [...t.metadata].map(([u, f]) => {
-            const h = e.createString(`${u}`),
+    Q.isDictionary(s) ? (o = s.dictionary.typeId, i = tp.visit(s, e), r = tp.visit(s.dictionary, e)) : r = tp.visit(s, e);
+    const a = (s.children || []).map((l) => Kt.encode(e, l)),
+        c = yn.createChildrenVector(e, a),
+        u = t.metadata && t.metadata.size > 0 ? yn.createCustomMetadataVector(e, [...t.metadata].map(([l, f]) => {
+            const h = e.createString(`${l}`),
                 d = e.createString(`${f}`);
-            return ni.startKeyValue(e), ni.addKey(e, h), ni.addValue(e, d), ni.endKeyValue(e);
+            return he.startKeyValue(e), he.addKey(e, h), he.addValue(e, d), he.endKeyValue(e);
         })) : -1;
-    return t.name && (n = e.createString(t.name)), Gn.startField(e), Gn.addType(e, i), Gn.addTypeType(e, o), Gn.addChildren(e, c), Gn.addNullable(e, !!t.nullable), n !== -1 && Gn.addName(e, n), r !== -1 && Gn.addDictionary(e, r), l !== -1 && Gn.addCustomMetadata(e, l), Gn.endField(e);
+    return t.name && (n = e.createString(t.name)), yn.startField(e), yn.addType(e, r), yn.addTypeType(e, o), yn.addChildren(e, c), yn.addNullable(e, !!t.nullable), n !== -1 && yn.addName(e, n), i !== -1 && yn.addDictionary(e, i), u !== -1 && yn.addCustomMetadata(e, u), yn.endField(e);
 }
 
-function J7(e, t) {
+function Z9(e, t) {
     const n = t.nodes || [],
-        i = t.buffers || [];
-    Lr.startNodesVector(e, n.length);
+        r = t.buffers || [];
+    Cr.startNodesVector(e, n.length);
     for (const o of n.slice().reverse())
-        Qc.encode(e, o);
-    const r = e.endVector();
-    Lr.startBuffersVector(e, i.length);
-    for (const o of i.slice().reverse())
+        fa.encode(e, o);
+    const i = e.endVector();
+    Cr.startBuffersVector(e, r.length);
+    for (const o of r.slice().reverse())
         Yr.encode(e, o);
     const s = e.endVector();
-    return Lr.startRecordBatch(e), Lr.addLength(e, BigInt(t.length)), Lr.addNodes(e, r), Lr.addBuffers(e, s), Lr.endRecordBatch(e);
+    return Cr.startRecordBatch(e), Cr.addLength(e, BigInt(t.length)), Cr.addNodes(e, i), Cr.addBuffers(e, s), Cr.endRecordBatch(e);
 }
 
-function K7(e, t) {
-    const n = Ai.encode(e, t.data);
-    return Da.startDictionaryBatch(e), Da.addId(e, BigInt(t.id)), Da.addIsDelta(e, t.isDelta), Da.addData(e, n), Da.endDictionaryBatch(e);
+function K9(e, t) {
+    const n = Un.encode(e, t.data);
+    return io.startDictionaryBatch(e), io.addId(e, BigInt(t.id)), io.addIsDelta(e, t.isDelta), io.addData(e, n), io.endDictionaryBatch(e);
 }
 
-function Z7(e, t) {
-    return VI.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount));
+function Q9(e, t) {
+    return Lv.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount));
 }
 
-function Q7(e, t) {
-    return PI.createBuffer(e, BigInt(t.offset), BigInt(t.length));
+function tO(e, t) {
+    return Ov.createBuffer(e, BigInt(t.offset), BigInt(t.length));
 }
-const t9 = (() => {
+const eO = (() => {
         const e = new ArrayBuffer(2);
         return new DataView(e).setInt16(
             0,
             256,
             !0
             /* littleEndian */
         ), new Int16Array(e)[0] === 256;
     })(),
-    Db = (e) => `Expected ${Qt[e]} Message in stream, but was null or length 0.`,
-    Nb = (e) => `Header pointer of flatbuffer-encoded ${Qt[e]} Message is null or length 0.`,
-    NM = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`,
-    BM = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`;
-let OM = class {
-        constructor(t) {
-                this.source = t instanceof kd ? t : new kd(t);
-            }
-            [Symbol.iterator]() {
-                return this;
-            }
-        next() {
-            let t;
-            return (t = this.readMetadataLength()).done || t.value === -1 && (t = this.readMetadataLength()).done || (t = this.readMetadata(t.value)).done ? xe : t;
+    cm = (e) => `Expected ${Ct[e]} Message in stream, but was null or length 0.`,
+    um = (e) => `Header pointer of flatbuffer-encoded ${Ct[e]} Message is null or length 0.`,
+    gx = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`,
+    bx = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`;
+class wx {
+    constructor(t) {
+            this.source = t instanceof df ? t : new df(t);
         }
-        throw (t) {
-            return this.source.throw(t);
+        [Symbol.iterator]() {
+            return this;
+        }
+    next() {
+        let t;
+        return (t = this.readMetadataLength()).done || t.value === -1 && (t = this.readMetadataLength()).done || (t = this.readMetadata(t.value)).done ? ne : t;
+    }
+    throw (t) {
+        return this.source.throw(t);
+    }
+    return (t) {
+        return this.source.return(t);
+    }
+    readMessage(t) {
+        let n;
+        if ((n = this.next()).done)
+            return null;
+        if (t != null && n.value.headerType !== t)
+            throw new Error(cm(t));
+        return n.value;
+    }
+    readMessageBody(t) {
+        if (t <= 0)
+            return new Uint8Array(0);
+        const n = Dt(this.source.read(t));
+        if (n.byteLength < t)
+            throw new Error(bx(t, n.byteLength));
+        return (
+            /* 1. */
+            n.byteOffset % 8 === 0 && /* 2. */
+            n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
+        );
+    }
+    readSchema(t = !1) {
+        const n = Ct.Schema,
+            r = this.readMessage(n),
+            i = r == null ? void 0 : r.header();
+        if (t && !i)
+            throw new Error(um(n));
+        return i;
+    }
+    readMetadataLength() {
+        const t = this.source.read(Fh),
+            n = t && new Fo(t),
+            r = (n == null ? void 0 : n.readInt32(0)) || 0;
+        return {
+            done: r === 0,
+            value: r
+        };
+    }
+    readMetadata(t) {
+        const n = this.source.read(t);
+        if (!n)
+            return ne;
+        if (n.byteLength < t)
+            throw new Error(gx(t, n.byteLength));
+        return {
+            done: !1,
+            value: kn.decode(n)
+        };
+    }
+}
+class nO {
+    constructor(t, n) {
+            this.source = t instanceof Uo ? t : Mv(t) ? new pf(t, n) : new Uo(t);
         }
-        return (t) {
-            return this.source.return(t);
+        [Symbol.asyncIterator]() {
+            return this;
         }
-        readMessage(t) {
+    next() {
+        return bt(this, void 0, void 0, function*() {
+            let t;
+            return (t = yield this.readMetadataLength()).done || t.value === -1 && (t = yield this.readMetadataLength()).done || (t = yield this.readMetadata(t.value)).done ? ne : t;
+        });
+    }
+    throw (t) {
+        return bt(this, void 0, void 0, function*() {
+            return yield this.source.throw(t);
+        });
+    }
+    return (t) {
+        return bt(this, void 0, void 0, function*() {
+            return yield this.source.return(t);
+        });
+    }
+    readMessage(t) {
+        return bt(this, void 0, void 0, function*() {
             let n;
-            if ((n = this.next()).done)
+            if ((n = yield this.next()).done)
                 return null;
             if (t != null && n.value.headerType !== t)
-                throw new Error(Db(t));
+                throw new Error(cm(t));
             return n.value;
-        }
-        readMessageBody(t) {
+        });
+    }
+    readMessageBody(t) {
+        return bt(this, void 0, void 0, function*() {
             if (t <= 0)
                 return new Uint8Array(0);
-            const n = Yt(this.source.read(t));
+            const n = Dt(yield this.source.read(t));
             if (n.byteLength < t)
-                throw new Error(BM(t, n.byteLength));
+                throw new Error(bx(t, n.byteLength));
             return (
                 /* 1. */
                 n.byteOffset % 8 === 0 && /* 2. */
                 n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
             );
-        }
-        readSchema(t = !1) {
-            const n = Qt.Schema,
-                i = this.readMessage(n),
-                r = i == null ? void 0 : i.header();
-            if (t && !r)
-                throw new Error(Nb(n));
-            return r;
-        }
-        readMetadataLength() {
-            const t = this.source.read(zy),
-                n = t && new ur(t),
-                i = (n == null ? void 0 : n.readInt32(0)) || 0;
+        });
+    }
+    readSchema(t = !1) {
+        return bt(this, void 0, void 0, function*() {
+            const n = Ct.Schema,
+                r = yield this.readMessage(n), i = r == null ? void 0 : r.header();
+            if (t && !i)
+                throw new Error(um(n));
+            return i;
+        });
+    }
+    readMetadataLength() {
+        return bt(this, void 0, void 0, function*() {
+            const t = yield this.source.read(Fh), n = t && new Fo(t), r = (n == null ? void 0 : n.readInt32(0)) || 0;
             return {
-                done: i === 0,
-                value: i
+                done: r === 0,
+                value: r
             };
-        }
-        readMetadata(t) {
-            const n = this.source.read(t);
+        });
+    }
+    readMetadata(t) {
+        return bt(this, void 0, void 0, function*() {
+            const n = yield this.source.read(t);
             if (!n)
-                return xe;
+                return ne;
             if (n.byteLength < t)
-                throw new Error(NM(t, n.byteLength));
+                throw new Error(gx(t, n.byteLength));
             return {
                 done: !1,
-                value: lu.decode(n)
+                value: kn.decode(n)
+            };
+        });
+    }
+}
+class rO extends wx {
+    constructor(t) {
+        super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof ob ? t : new ob(t);
+    }
+    next() {
+        const {
+            _json: t
+        } = this;
+        if (!this._schema)
+            return this._schema = !0, {
+                done: !1,
+                value: kn.fromJSON(t.schema, Ct.Schema)
+            };
+        if (this._dictionaryIndex < t.dictionaries.length) {
+            const n = t.dictionaries[this._dictionaryIndex++];
+            return this._body = n.data.columns, {
+                done: !1,
+                value: kn.fromJSON(n, Ct.DictionaryBatch)
             };
         }
-    },
-    e9 = class {
-        constructor(t, n) {
-                this.source = t instanceof Ud ? t : EI(t) ? new zd(t, n) : new Ud(t);
-            }
-            [Symbol.asyncIterator]() {
-                return this;
-            }
-        next() {
-            return W(this, void 0, void 0, function*() {
-                let t;
-                return (t = yield this.readMetadataLength()).done || t.value === -1 && (t = yield this.readMetadataLength()).done || (t = yield this.readMetadata(t.value)).done ? xe : t;
-            });
-        }
-        throw (t) {
-            return W(this, void 0, void 0, function*() {
-                return yield this.source.throw(t);
-            });
-        }
-        return (t) {
-            return W(this, void 0, void 0, function*() {
-                return yield this.source.return(t);
-            });
-        }
-        readMessage(t) {
-            return W(this, void 0, void 0, function*() {
-                let n;
-                if ((n = yield this.next()).done)
-                    return null;
-                if (t != null && n.value.headerType !== t)
-                    throw new Error(Db(t));
-                return n.value;
-            });
-        }
-        readMessageBody(t) {
-            return W(this, void 0, void 0, function*() {
-                if (t <= 0)
-                    return new Uint8Array(0);
-                const n = Yt(yield this.source.read(t));
-                if (n.byteLength < t)
-                    throw new Error(BM(t, n.byteLength));
-                return (
-                    /* 1. */
-                    n.byteOffset % 8 === 0 && /* 2. */
-                    n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
-                );
-            });
-        }
-        readSchema(t = !1) {
-            return W(this, void 0, void 0, function*() {
-                const n = Qt.Schema,
-                    i = yield this.readMessage(n), r = i == null ? void 0 : i.header();
-                if (t && !r)
-                    throw new Error(Nb(n));
-                return r;
-            });
-        }
-        readMetadataLength() {
-            return W(this, void 0, void 0, function*() {
-                const t = yield this.source.read(zy), n = t && new ur(t), i = (n == null ? void 0 : n.readInt32(0)) || 0;
-                return {
-                    done: i === 0,
-                    value: i
-                };
-            });
-        }
-        readMetadata(t) {
-            return W(this, void 0, void 0, function*() {
-                const n = yield this.source.read(t);
-                if (!n)
-                    return xe;
-                if (n.byteLength < t)
-                    throw new Error(NM(t, n.byteLength));
-                return {
-                    done: !1,
-                    value: lu.decode(n)
-                };
-            });
-        }
-    },
-    n9 = class extends OM {
-        constructor(t) {
-            super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof W_ ? t : new W_(t);
-        }
-        next() {
-            const {
-                _json: t
-            } = this;
-            if (!this._schema)
-                return this._schema = !0, {
-                    done: !1,
-                    value: lu.fromJSON(t.schema, Qt.Schema)
-                };
-            if (this._dictionaryIndex < t.dictionaries.length) {
-                const n = t.dictionaries[this._dictionaryIndex++];
-                return this._body = n.data.columns, {
-                    done: !1,
-                    value: lu.fromJSON(n, Qt.DictionaryBatch)
-                };
-            }
-            if (this._batchIndex < t.batches.length) {
-                const n = t.batches[this._batchIndex++];
-                return this._body = n.columns, {
-                    done: !1,
-                    value: lu.fromJSON(n, Qt.RecordBatch)
-                };
-            }
-            return this._body = [], xe;
+        if (this._batchIndex < t.batches.length) {
+            const n = t.batches[this._batchIndex++];
+            return this._body = n.columns, {
+                done: !1,
+                value: kn.fromJSON(n, Ct.RecordBatch)
+            };
         }
-        readMessageBody(t) {
-            return n(this._body);
+        return this._body = [], ne;
+    }
+    readMessageBody(t) {
+        return n(this._body);
 
-            function n(i) {
-                return (i || []).reduce((r, s) => [
-                    ...r,
-                    ...s.VALIDITY && [s.VALIDITY] || [],
-                    ...s.TYPE_ID && [s.TYPE_ID] || [],
-                    ...s.OFFSET && [s.OFFSET] || [],
-                    ...s.DATA && [s.DATA] || [],
-                    ...n(s.children)
-                ], []);
-            }
-        }
-        readMessage(t) {
-            let n;
-            if ((n = this.next()).done)
-                return null;
-            if (t != null && n.value.headerType !== t)
-                throw new Error(Db(t));
-            return n.value;
-        }
-        readSchema() {
-            const t = Qt.Schema,
-                n = this.readMessage(t),
-                i = n == null ? void 0 : n.header();
-            if (!n || !i)
-                throw new Error(Nb(t));
-            return i;
+        function n(r) {
+            return (r || []).reduce((i, s) => [
+                ...i,
+                ...s.VALIDITY && [s.VALIDITY] || [],
+                ...s.TYPE_ID && [s.TYPE_ID] || [],
+                ...s.OFFSET && [s.OFFSET] || [],
+                ...s.DATA && [s.DATA] || [],
+                ...n(s.children)
+            ], []);
         }
-    };
-const zy = 4,
-    Tg = "ARROW1",
-    Pd = new Uint8Array(Tg.length);
-for (let e = 0; e < Tg.length; e += 1)
-    Pd[e] = Tg.codePointAt(e);
-
-function Bb(e, t = 0) {
-    for (let n = -1, i = Pd.length; ++n < i;)
-        if (Pd[n] !== e[t + n])
+    }
+    readMessage(t) {
+        let n;
+        if ((n = this.next()).done)
+            return null;
+        if (t != null && n.value.headerType !== t)
+            throw new Error(cm(t));
+        return n.value;
+    }
+    readSchema() {
+        const t = Ct.Schema,
+            n = this.readMessage(t),
+            r = n == null ? void 0 : n.header();
+        if (!n || !r)
+            throw new Error(um(t));
+        return r;
+    }
+}
+const Fh = 4,
+    p0 = "ARROW1",
+    yf = new Uint8Array(p0.length);
+for (let e = 0; e < p0.length; e += 1)
+    yf[e] = p0.codePointAt(e);
+
+function lm(e, t = 0) {
+    for (let n = -1, r = yf.length; ++n < r;)
+        if (yf[n] !== e[t + n])
             return !1;
     return !0;
 }
-const ff = Pd.length,
-    FM = ff + zy,
-    i9 = ff * 2 + zy;
-let hf = class Hh extends wM {
-        constructor(t) {
-            super(), this._impl = t;
-        }
-        get closed() {
-            return this._impl.closed;
-        }
-        get schema() {
-            return this._impl.schema;
-        }
-        get autoDestroy() {
-            return this._impl.autoDestroy;
-        }
-        get dictionaries() {
-            return this._impl.dictionaries;
-        }
-        get numDictionaries() {
-            return this._impl.numDictionaries;
-        }
-        get numRecordBatches() {
-            return this._impl.numRecordBatches;
-        }
-        get footer() {
-            return this._impl.isFile() ? this._impl.footer : null;
-        }
-        isSync() {
-            return this._impl.isSync();
-        }
-        isAsync() {
-            return this._impl.isAsync();
-        }
-        isFile() {
-            return this._impl.isFile();
-        }
-        isStream() {
-            return this._impl.isStream();
-        }
-        next() {
-            return this._impl.next();
-        }
-        throw (t) {
-            return this._impl.throw(t);
-        }
-        return (t) {
-            return this._impl.return(t);
+const nu = yf.length,
+    vx = nu + Fh,
+    iO = nu * 2 + Fh;
+class Zr extends ax {
+    constructor(t) {
+        super(), this._impl = t;
+    }
+    get closed() {
+        return this._impl.closed;
+    }
+    get schema() {
+        return this._impl.schema;
+    }
+    get autoDestroy() {
+        return this._impl.autoDestroy;
+    }
+    get dictionaries() {
+        return this._impl.dictionaries;
+    }
+    get numDictionaries() {
+        return this._impl.numDictionaries;
+    }
+    get numRecordBatches() {
+        return this._impl.numRecordBatches;
+    }
+    get footer() {
+        return this._impl.isFile() ? this._impl.footer : null;
+    }
+    isSync() {
+        return this._impl.isSync();
+    }
+    isAsync() {
+        return this._impl.isAsync();
+    }
+    isFile() {
+        return this._impl.isFile();
+    }
+    isStream() {
+        return this._impl.isStream();
+    }
+    next() {
+        return this._impl.next();
+    }
+    throw (t) {
+        return this._impl.throw(t);
+    }
+    return (t) {
+        return this._impl.return(t);
+    }
+    cancel() {
+        return this._impl.cancel();
+    }
+    reset(t) {
+        return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this;
+    }
+    open(t) {
+        const n = this._impl.open(t);
+        return yc(n) ? n.then(() => this) : this;
+    }
+    readRecordBatch(t) {
+            return this._impl.isFile() ? this._impl.readRecordBatch(t) : null;
         }
-        cancel() {
-            return this._impl.cancel();
+        [Symbol.iterator]() {
+            return this._impl[Symbol.iterator]();
         }
-        reset(t) {
-            return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this;
+        [Symbol.asyncIterator]() {
+            return this._impl[Symbol.asyncIterator]();
         }
-        open(t) {
-            const n = this._impl.open(t);
-            return vu(n) ? n.then(() => this) : this;
+    toDOMStream() {
+        return mn.toDOMStream(this.isSync() ? {
+            [Symbol.iterator]: () => this
+        } : {
+            [Symbol.asyncIterator]: () => this
+        });
+    }
+    toNodeStream() {
+        return mn.toNodeStream(this.isSync() ? {
+            [Symbol.iterator]: () => this
+        } : {
+            [Symbol.asyncIterator]: () => this
+        }, {
+            objectMode: !0
+        });
+    }
+    /** @nocollapse */
+    // @ts-ignore
+    static throughNode(t) {
+        throw new Error('"throughNode" not available in this environment');
+    }
+    /** @nocollapse */
+    static throughDOM(t, n) {
+        throw new Error('"throughDOM" not available in this environment');
+    }
+    /** @nocollapse */
+    static from(t) {
+        return t instanceof Zr ? t : s0(t) ? cO(t) : Mv(t) ? fO(t) : yc(t) ? bt(this, void 0, void 0, function*() {
+            return yield Zr.from(yield t);
+        }) : Av(t) || Yy(t) || Iv(t) || Vy(t) ? lO(new Uo(t)) : uO(new df(t));
+    }
+    /** @nocollapse */
+    static readAll(t) {
+        return t instanceof Zr ? t.isSync() ? yb(t) : mb(t) : s0(t) || ArrayBuffer.isView(t) || Lh(t) || Sv(t) ? yb(t) : mb(t);
+    }
+}
+class mf extends Zr {
+    constructor(t) {
+        super(t), this._impl = t;
+    }
+    readAll() {
+            return [...this];
         }
-        readRecordBatch(t) {
-                return this._impl.isFile() ? this._impl.readRecordBatch(t) : null;
-            }
-            [Symbol.iterator]() {
-                return this._impl[Symbol.iterator]();
-            }
-            [Symbol.asyncIterator]() {
-                return this._impl[Symbol.asyncIterator]();
-            }
-        toDOMStream() {
-            return Hn.toDOMStream(this.isSync() ? {
-                [Symbol.iterator]: () => this
-            } : {
-                [Symbol.asyncIterator]: () => this
-            });
+        [Symbol.iterator]() {
+            return this._impl[Symbol.iterator]();
         }
-        toNodeStream() {
-            return Hn.toNodeStream(this.isSync() ? {
-                [Symbol.iterator]: () => this
-            } : {
-                [Symbol.asyncIterator]: () => this
-            }, {
-                objectMode: !0
+        [Symbol.asyncIterator]() {
+            return lr(this, arguments, function*() {
+                yield _t(yield* vl(xo(this[Symbol.iterator]())));
             });
         }
-        /** @nocollapse */
-        // @ts-ignore
-        static throughNode(t) {
-            throw new Error('"throughNode" not available in this environment');
-        }
-        /** @nocollapse */
-        static throughDOM(t, n) {
-            throw new Error('"throughDOM" not available in this environment');
-        }
-        /** @nocollapse */
-        static from(t) {
-            return t instanceof Hh ? t : pg(t) ? a9(t) : EI(t) ? u9(t) : vu(t) ? W(this, void 0, void 0, function*() {
-                return yield Hh.from(yield t);
-            }) : LI(t) || db(t) || CI(t) || hb(t) ? l9(new Ud(t)) : c9(new kd(t));
-        }
-        /** @nocollapse */
-        static readAll(t) {
-            return t instanceof Hh ? t.isSync() ? e2(t) : n2(t) : pg(t) || ArrayBuffer.isView(t) || Ry(t) || FI(t) ? e2(t) : n2(t);
-        }
-    },
-    Vd = class extends hf {
-        constructor(t) {
-            super(t), this._impl = t;
-        }
-        readAll() {
-                return [...this];
-            }
-            [Symbol.iterator]() {
-                return this._impl[Symbol.iterator]();
-            }
-            [Symbol.asyncIterator]() {
-                return Re(this, arguments, function*() {
-                    yield H(yield* ks(ai(this[Symbol.iterator]())));
-                });
-            }
-    },
-    jd = class extends hf {
-        constructor(t) {
-            super(t), this._impl = t;
-        }
-        readAll() {
-                var t, n, i, r;
-                return W(this, void 0, void 0, function*() {
-                    const s = new Array();
+}
+class gf extends Zr {
+    constructor(t) {
+        super(t), this._impl = t;
+    }
+    readAll() {
+            var t, n, r, i;
+            return bt(this, void 0, void 0, function*() {
+                const s = new Array();
+                try {
+                    for (var o = !0, a = xo(this), c; c = yield a.next(), t = c.done, !t; o = !0) {
+                        i = c.value, o = !1;
+                        const u = i;
+                        s.push(u);
+                    }
+                } catch (u) {
+                    n = {
+                        error: u
+                    };
+                } finally {
                     try {
-                        for (var o = !0, a = ai(this), c; c = yield a.next(), t = c.done, !t; o = !0) {
-                            r = c.value, o = !1;
-                            const l = r;
-                            s.push(l);
-                        }
-                    } catch (l) {
-                        n = {
-                            error: l
-                        };
+                        !o && !t && (r = a.return) && (yield r.call(a));
                     } finally {
-                        try {
-                            !o && !t && (i = a.return) && (yield i.call(a));
-                        } finally {
-                            if (n)
-                                throw n.error;
-                        }
+                        if (n)
+                            throw n.error;
                     }
-                    return s;
-                });
-            }
-            [Symbol.iterator]() {
-                throw new Error("AsyncRecordBatchStreamReader is not Iterable");
-            }
-            [Symbol.asyncIterator]() {
-                return this._impl[Symbol.asyncIterator]();
-            }
-    },
-    EM = class extends Vd {
-        constructor(t) {
-            super(t), this._impl = t;
-        }
-    },
-    r9 = class extends jd {
-        constructor(t) {
-            super(t), this._impl = t;
-        }
-    },
-    LM = class {
-        get numDictionaries() {
-            return this._dictionaryIndex;
-        }
-        get numRecordBatches() {
-            return this._recordBatchIndex;
-        }
-        constructor(t = /* @__PURE__ */ new Map()) {
-            this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t;
-        }
-        isSync() {
-            return !1;
-        }
-        isAsync() {
-            return !1;
-        }
-        isFile() {
-            return !1;
-        }
-        isStream() {
-            return !1;
+                }
+                return s;
+            });
         }
-        reset(t) {
-            return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = /* @__PURE__ */ new Map(), this;
+        [Symbol.iterator]() {
+            throw new Error("AsyncRecordBatchStreamReader is not Iterable");
         }
-        _loadRecordBatch(t, n) {
-            const i = this._loadVectors(t, n, this.schema.fields),
-                r = Rt({
-                    type: new fn(this.schema.fields),
-                    length: t.length,
-                    children: i
-                });
-            return new gi(this.schema, r);
+        [Symbol.asyncIterator]() {
+            return this._impl[Symbol.asyncIterator]();
         }
-        _loadDictionaryBatch(t, n) {
-            const {
-                id: i,
-                isDelta: r
-            } = t, {
-                dictionaries: s,
-                schema: o
-            } = this, a = s.get(i);
-            if (r || !a) {
-                const c = o.dictionaries.get(i),
-                    l = this._loadVectors(t.data, n, [c]);
-                return (a && r ? a.concat(new Ne(l)) : new Ne(l)).memoize();
-            }
-            return a.memoize();
-        }
-        _loadVectors(t, n, i) {
-            return new xM(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
-        }
-    },
-    qd = class extends LM {
-        constructor(t, n) {
-            super(n), this._reader = pg(t) ? new n9(this._handle = t) : new OM(this._handle = t);
+}
+class _x extends mf {
+    constructor(t) {
+        super(t), this._impl = t;
+    }
+}
+class sO extends gf {
+    constructor(t) {
+        super(t), this._impl = t;
+    }
+}
+class xx {
+    get numDictionaries() {
+        return this._dictionaryIndex;
+    }
+    get numRecordBatches() {
+        return this._recordBatchIndex;
+    }
+    constructor(t = /* @__PURE__ */ new Map()) {
+        this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t;
+    }
+    isSync() {
+        return !1;
+    }
+    isAsync() {
+        return !1;
+    }
+    isFile() {
+        return !1;
+    }
+    isStream() {
+        return !1;
+    }
+    reset(t) {
+        return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = /* @__PURE__ */ new Map(), this;
+    }
+    _loadRecordBatch(t, n) {
+        const r = this._loadVectors(t, n, this.schema.fields),
+            i = St({
+                type: new Be(this.schema.fields),
+                length: t.length,
+                children: r
+            });
+        return new Ln(this.schema, i);
+    }
+    _loadDictionaryBatch(t, n) {
+        const {
+            id: r,
+            isDelta: i
+        } = t, {
+            dictionaries: s,
+            schema: o
+        } = this, a = s.get(r);
+        if (i || !a) {
+            const c = o.dictionaries.get(r),
+                u = this._loadVectors(t.data, n, [c]);
+            return (a && i ? a.concat(new ce(u)) : new ce(u)).memoize();
         }
-        isSync() {
+        return a.memoize();
+    }
+    _loadVectors(t, n, r) {
+        return new ux(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(r);
+    }
+}
+class bf extends xx {
+    constructor(t, n) {
+        super(n), this._reader = s0(t) ? new rO(this._handle = t) : new wx(this._handle = t);
+    }
+    isSync() {
+        return !0;
+    }
+    isStream() {
             return !0;
         }
-        isStream() {
-                return !0;
-            }
-            [Symbol.iterator]() {
-                return this;
-            }
-        cancel() {
-            !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
+        [Symbol.iterator]() {
+            return this;
         }
-        open(t) {
-            return this.closed || (this.autoDestroy = CM(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this;
+    cancel() {
+        !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
+    }
+    open(t) {
+        return this.closed || (this.autoDestroy = Mx(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this;
+    }
+    throw (t) {
+        return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : ne;
+    }
+    return (t) {
+        return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : ne;
+    }
+    next() {
+        if (this.closed)
+            return ne;
+        let t;
+        const {
+            _reader: n
+        } = this;
+        for (; t = this._readNextMessageAndValidate();)
+            if (t.isSchema())
+                this.reset(t.header());
+            else if (t.isRecordBatch()) {
+            this._recordBatchIndex++;
+            const r = t.header(),
+                i = n.readMessageBody(t.bodyLength);
+            return {
+                done: !1,
+                value: this._loadRecordBatch(r, i)
+            };
+        } else if (t.isDictionaryBatch()) {
+            this._dictionaryIndex++;
+            const r = t.header(),
+                i = n.readMessageBody(t.bodyLength),
+                s = this._loadDictionaryBatch(r, i);
+            this.dictionaries.set(r.id, s);
         }
-        throw (t) {
-            return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : xe;
+        return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, {
+            done: !1,
+            value: new dx(this.schema)
+        }) : this.return();
+    }
+    _readNextMessageAndValidate(t) {
+        return this._reader.readMessage(t);
+    }
+}
+class wf extends xx {
+    constructor(t, n) {
+        super(n), this._reader = new nO(this._handle = t);
+    }
+    isAsync() {
+        return !0;
+    }
+    isStream() {
+            return !0;
         }
-        return (t) {
-            return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : xe;
+        [Symbol.asyncIterator]() {
+            return this;
         }
-        next() {
+    cancel() {
+        return bt(this, void 0, void 0, function*() {
+            !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
+        });
+    }
+    open(t) {
+        return bt(this, void 0, void 0, function*() {
+            return this.closed || (this.autoDestroy = Mx(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this;
+        });
+    }
+    throw (t) {
+        return bt(this, void 0, void 0, function*() {
+            return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t): ne;
+        });
+    }
+    return (t) {
+        return bt(this, void 0, void 0, function*() {
+            return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t): ne;
+        });
+    }
+    next() {
+        return bt(this, void 0, void 0, function*() {
             if (this.closed)
-                return xe;
+                return ne;
             let t;
             const {
                 _reader: n
             } = this;
-            for (; t = this._readNextMessageAndValidate();)
+            for (; t = yield this._readNextMessageAndValidate();)
                 if (t.isSchema())
-                    this.reset(t.header());
+                    yield this.reset(t.header());
                 else if (t.isRecordBatch()) {
                 this._recordBatchIndex++;
-                const i = t.header(),
-                    r = n.readMessageBody(t.bodyLength);
+                const r = t.header(),
+                    i = yield n.readMessageBody(t.bodyLength);
                 return {
                     done: !1,
-                    value: this._loadRecordBatch(i, r)
+                    value: this._loadRecordBatch(r, i)
                 };
             } else if (t.isDictionaryBatch()) {
                 this._dictionaryIndex++;
-                const i = t.header(),
-                    r = n.readMessageBody(t.bodyLength),
-                    s = this._loadDictionaryBatch(i, r);
-                this.dictionaries.set(i.id, s);
+                const r = t.header(),
+                    i = yield n.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(r, i);
+                this.dictionaries.set(r.id, s);
             }
             return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, {
                 done: !1,
-                value: new MM(this.schema)
-            }) : this.return();
-        }
-        _readNextMessageAndValidate(t) {
-            return this._reader.readMessage(t);
-        }
-    },
-    Yd = class extends LM {
-        constructor(t, n) {
-            super(n), this._reader = new e9(this._handle = t);
-        }
-        isAsync() {
-            return !0;
+                value: new dx(this.schema)
+            }) : yield this.return();
+        });
+    }
+    _readNextMessageAndValidate(t) {
+        return bt(this, void 0, void 0, function*() {
+            return yield this._reader.readMessage(t);
+        });
+    }
+}
+class Sx extends bf {
+    get footer() {
+        return this._footer;
+    }
+    get numDictionaries() {
+        return this._footer ? this._footer.numDictionaries : 0;
+    }
+    get numRecordBatches() {
+        return this._footer ? this._footer.numRecordBatches : 0;
+    }
+    constructor(t, n) {
+        super(t instanceof ab ? t : new ab(t), n);
+    }
+    isSync() {
+        return !0;
+    }
+    isFile() {
+        return !0;
+    }
+    open(t) {
+        if (!this.closed && !this._footer) {
+            this.schema = (this._footer = this._readFooter()).schema;
+            for (const n of this._footer.dictionaryBatches())
+                n && this._readDictionaryBatch(this._dictionaryIndex++);
         }
-        isStream() {
-                return !0;
-            }
-            [Symbol.asyncIterator]() {
-                return this;
+        return super.open(t);
+    }
+    readRecordBatch(t) {
+        var n;
+        if (this.closed)
+            return null;
+        this._footer || this.open();
+        const r = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
+        if (r && this._handle.seek(r.offset)) {
+            const i = this._reader.readMessage(Ct.RecordBatch);
+            if (i != null && i.isRecordBatch()) {
+                const s = i.header(),
+                    o = this._reader.readMessageBody(i.bodyLength);
+                return this._loadRecordBatch(s, o);
             }
-        cancel() {
-            return W(this, void 0, void 0, function*() {
-                !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
-            });
-        }
-        open(t) {
-            return W(this, void 0, void 0, function*() {
-                return this.closed || (this.autoDestroy = CM(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this;
-            });
-        }
-        throw (t) {
-            return W(this, void 0, void 0, function*() {
-                return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t): xe;
-            });
-        }
-        return (t) {
-            return W(this, void 0, void 0, function*() {
-                return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t): xe;
-            });
-        }
-        next() {
-            return W(this, void 0, void 0, function*() {
-                if (this.closed)
-                    return xe;
-                let t;
-                const {
-                    _reader: n
-                } = this;
-                for (; t = yield this._readNextMessageAndValidate();)
-                    if (t.isSchema())
-                        yield this.reset(t.header());
-                    else if (t.isRecordBatch()) {
-                    this._recordBatchIndex++;
-                    const i = t.header(),
-                        r = yield n.readMessageBody(t.bodyLength);
-                    return {
-                        done: !1,
-                        value: this._loadRecordBatch(i, r)
-                    };
-                } else if (t.isDictionaryBatch()) {
-                    this._dictionaryIndex++;
-                    const i = t.header(),
-                        r = yield n.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(i, r);
-                    this.dictionaries.set(i.id, s);
-                }
-                return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, {
-                    done: !1,
-                    value: new MM(this.schema)
-                }) : yield this.return();
-            });
-        }
-        _readNextMessageAndValidate(t) {
-            return W(this, void 0, void 0, function*() {
-                return yield this._reader.readMessage(t);
-            });
-        }
-    },
-    RM = class extends qd {
-        get footer() {
-            return this._footer;
-        }
-        get numDictionaries() {
-            return this._footer ? this._footer.numDictionaries : 0;
         }
-        get numRecordBatches() {
-            return this._footer ? this._footer.numRecordBatches : 0;
-        }
-        constructor(t, n) {
-            super(t instanceof G_ ? t : new G_(t), n);
-        }
-        isSync() {
-            return !0;
+        return null;
+    }
+    _readDictionaryBatch(t) {
+        var n;
+        const r = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
+        if (r && this._handle.seek(r.offset)) {
+            const i = this._reader.readMessage(Ct.DictionaryBatch);
+            if (i != null && i.isDictionaryBatch()) {
+                const s = i.header(),
+                    o = this._reader.readMessageBody(i.bodyLength),
+                    a = this._loadDictionaryBatch(s, o);
+                this.dictionaries.set(s.id, a);
+            }
         }
-        isFile() {
-            return !0;
+    }
+    _readFooter() {
+        const {
+            _handle: t
+        } = this, n = t.size - vx, r = t.readInt32(n), i = t.readAt(n - r, r);
+        return rm.decode(i);
+    }
+    _readNextMessageAndValidate(t) {
+        var n;
+        if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
+            const r = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(this._recordBatchIndex);
+            if (r && this._handle.seek(r.offset))
+                return this._reader.readMessage(t);
         }
-        open(t) {
+        return null;
+    }
+}
+class oO extends wf {
+    get footer() {
+        return this._footer;
+    }
+    get numDictionaries() {
+        return this._footer ? this._footer.numDictionaries : 0;
+    }
+    get numRecordBatches() {
+        return this._footer ? this._footer.numRecordBatches : 0;
+    }
+    constructor(t, ...n) {
+        const r = typeof n[0] != "number" ? n.shift() : void 0,
+            i = n[0] instanceof Map ? n.shift() : void 0;
+        super(t instanceof pf ? t : new pf(t, r), i);
+    }
+    isFile() {
+        return !0;
+    }
+    isAsync() {
+        return !0;
+    }
+    open(t) {
+        const n = Object.create(null, {
+            open: {
+                get: () => super.open
+            }
+        });
+        return bt(this, void 0, void 0, function*() {
             if (!this.closed && !this._footer) {
-                this.schema = (this._footer = this._readFooter()).schema;
-                for (const n of this._footer.dictionaryBatches())
-                    n && this._readDictionaryBatch(this._dictionaryIndex++);
+                this.schema = (this._footer = yield this._readFooter()).schema;
+                for (const r of this._footer.dictionaryBatches())
+                    r && (yield this._readDictionaryBatch(this._dictionaryIndex++));
             }
-            return super.open(t);
-        }
-        readRecordBatch(t) {
-            var n;
+            return yield n.open.call(this, t);
+        });
+    }
+    readRecordBatch(t) {
+        var n;
+        return bt(this, void 0, void 0, function*() {
             if (this.closed)
                 return null;
-            this._footer || this.open();
-            const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
-            if (i && this._handle.seek(i.offset)) {
-                const r = this._reader.readMessage(Qt.RecordBatch);
-                if (r != null && r.isRecordBatch()) {
-                    const s = r.header(),
-                        o = this._reader.readMessageBody(r.bodyLength);
+            this._footer || (yield this.open());
+            const r = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
+            if (r && (yield this._handle.seek(r.offset))) {
+                const i = yield this._reader.readMessage(Ct.RecordBatch);
+                if (i != null && i.isRecordBatch()) {
+                    const s = i.header(),
+                        o = yield this._reader.readMessageBody(i.bodyLength);
                     return this._loadRecordBatch(s, o);
                 }
             }
             return null;
-        }
-        _readDictionaryBatch(t) {
-            var n;
-            const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
-            if (i && this._handle.seek(i.offset)) {
-                const r = this._reader.readMessage(Qt.DictionaryBatch);
-                if (r != null && r.isDictionaryBatch()) {
-                    const s = r.header(),
-                        o = this._reader.readMessageBody(r.bodyLength),
-                        a = this._loadDictionaryBatch(s, o);
+        });
+    }
+    _readDictionaryBatch(t) {
+        var n;
+        return bt(this, void 0, void 0, function*() {
+            const r = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
+            if (r && (yield this._handle.seek(r.offset))) {
+                const i = yield this._reader.readMessage(Ct.DictionaryBatch);
+                if (i != null && i.isDictionaryBatch()) {
+                    const s = i.header(),
+                        o = yield this._reader.readMessageBody(i.bodyLength), a = this._loadDictionaryBatch(s, o);
                     this.dictionaries.set(s.id, a);
                 }
             }
-        }
-        _readFooter() {
+        });
+    }
+    _readFooter() {
+        return bt(this, void 0, void 0, function*() {
             const {
                 _handle: t
-            } = this, n = t.size - FM, i = t.readInt32(n), r = t.readAt(n - i, i);
-            return Ib.decode(r);
-        }
-        _readNextMessageAndValidate(t) {
-            var n;
-            if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
-                const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(this._recordBatchIndex);
-                if (i && this._handle.seek(i.offset))
-                    return this._reader.readMessage(t);
+            } = this;
+            t._pending && (yield t._pending);
+            const n = t.size - vx,
+                r = yield t.readInt32(n), i = yield t.readAt(n - r, r);
+            return rm.decode(i);
+        });
+    }
+    _readNextMessageAndValidate(t) {
+        return bt(this, void 0, void 0, function*() {
+            if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
+                const n = this._footer.getRecordBatch(this._recordBatchIndex);
+                if (n && (yield this._handle.seek(n.offset)))
+                    return yield this._reader.readMessage(t);
             }
             return null;
-        }
-    },
-    s9 = class extends Yd {
-        get footer() {
-            return this._footer;
-        }
-        get numDictionaries() {
-            return this._footer ? this._footer.numDictionaries : 0;
-        }
-        get numRecordBatches() {
-            return this._footer ? this._footer.numRecordBatches : 0;
-        }
-        constructor(t, ...n) {
-            const i = typeof n[0] != "number" ? n.shift() : void 0,
-                r = n[0] instanceof Map ? n.shift() : void 0;
-            super(t instanceof zd ? t : new zd(t, i), r);
-        }
-        isFile() {
-            return !0;
-        }
-        isAsync() {
-            return !0;
-        }
-        open(t) {
-            const n = Object.create(null, {
-                open: {
-                    get: () => super.open
-                }
-            });
-            return W(this, void 0, void 0, function*() {
-                if (!this.closed && !this._footer) {
-                    this.schema = (this._footer = yield this._readFooter()).schema;
-                    for (const i of this._footer.dictionaryBatches())
-                        i && (yield this._readDictionaryBatch(this._dictionaryIndex++));
-                }
-                return yield n.open.call(this, t);
-            });
-        }
-        readRecordBatch(t) {
-            var n;
-            return W(this, void 0, void 0, function*() {
-                if (this.closed)
-                    return null;
-                this._footer || (yield this.open());
-                const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
-                if (i && (yield this._handle.seek(i.offset))) {
-                    const r = yield this._reader.readMessage(Qt.RecordBatch);
-                    if (r != null && r.isRecordBatch()) {
-                        const s = r.header(),
-                            o = yield this._reader.readMessageBody(r.bodyLength);
-                        return this._loadRecordBatch(s, o);
-                    }
-                }
-                return null;
-            });
-        }
-        _readDictionaryBatch(t) {
-            var n;
-            return W(this, void 0, void 0, function*() {
-                const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
-                if (i && (yield this._handle.seek(i.offset))) {
-                    const r = yield this._reader.readMessage(Qt.DictionaryBatch);
-                    if (r != null && r.isDictionaryBatch()) {
-                        const s = r.header(),
-                            o = yield this._reader.readMessageBody(r.bodyLength), a = this._loadDictionaryBatch(s, o);
-                        this.dictionaries.set(s.id, a);
-                    }
-                }
-            });
-        }
-        _readFooter() {
-            return W(this, void 0, void 0, function*() {
-                const {
-                    _handle: t
-                } = this;
-                t._pending && (yield t._pending);
-                const n = t.size - FM,
-                    i = yield t.readInt32(n), r = yield t.readAt(n - i, i);
-                return Ib.decode(r);
-            });
-        }
-        _readNextMessageAndValidate(t) {
-            return W(this, void 0, void 0, function*() {
-                if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
-                    const n = this._footer.getRecordBatch(this._recordBatchIndex);
-                    if (n && (yield this._handle.seek(n.offset)))
-                        return yield this._reader.readMessage(t);
-                }
-                return null;
-            });
-        }
-    },
-    o9 = class extends qd {
-        constructor(t, n) {
-            super(t, n);
-        }
-        _loadVectors(t, n, i) {
-            return new b7(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
-        }
-    };
+        });
+    }
+}
+class aO extends bf {
+    constructor(t, n) {
+        super(t, n);
+    }
+    _loadVectors(t, n, r) {
+        return new w9(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(r);
+    }
+}
 
-function CM(e, t) {
+function Mx(e, t) {
     return t && typeof t.autoDestroy == "boolean" ? t.autoDestroy : e.autoDestroy;
 }
 
-function* e2(e) {
-    const t = hf.from(e);
+function* yb(e) {
+    const t = Zr.from(e);
     try {
         if (!t.open({
                 autoDestroy: !1
             }).closed)
             do
                 yield t;
             while (!t.reset().open().closed);
     } finally {
         t.cancel();
     }
 }
 
-function n2(e) {
-    return Re(this, arguments, function*() {
-        const n = yield H(hf.from(e));
+function mb(e) {
+    return lr(this, arguments, function*() {
+        const n = yield _t(Zr.from(e));
         try {
-            if (!(yield H(n.open({
+            if (!(yield _t(n.open({
                     autoDestroy: !1
                 }))).closed)
                 do
-                    yield yield H(n);
-                while (!(yield H(n.reset().open())).closed);
+                    yield yield _t(n);
+                while (!(yield _t(n.reset().open())).closed);
         } finally {
-            yield H(n.cancel());
+            yield _t(n.cancel());
         }
     });
 }
 
-function a9(e) {
-    return new Vd(new o9(e));
+function cO(e) {
+    return new mf(new aO(e));
 }
 
-function c9(e) {
-    const t = e.peek(ff + 7 & -8);
-    return t && t.byteLength >= 4 ? Bb(t) ? new EM(new RM(e.read())) : new Vd(new qd(e)) : new Vd(new qd(function*() {}()));
+function uO(e) {
+    const t = e.peek(nu + 7 & -8);
+    return t && t.byteLength >= 4 ? lm(t) ? new _x(new Sx(e.read())) : new mf(new bf(e)) : new mf(new bf(function*() {}()));
 }
 
-function l9(e) {
-    return W(this, void 0, void 0, function*() {
-        const t = yield e.peek(ff + 7 & -8);
-        return t && t.byteLength >= 4 ? Bb(t) ? new EM(new RM(yield e.read())) : new jd(new Yd(e)) : new jd(new Yd(function() {
-            return Re(this, arguments, function*() {});
+function lO(e) {
+    return bt(this, void 0, void 0, function*() {
+        const t = yield e.peek(nu + 7 & -8);
+        return t && t.byteLength >= 4 ? lm(t) ? new _x(new Sx(yield e.read())) : new gf(new wf(e)) : new gf(new wf(function() {
+            return lr(this, arguments, function*() {});
         }()));
     });
 }
 
-function u9(e) {
-    return W(this, void 0, void 0, function*() {
+function fO(e) {
+    return bt(this, void 0, void 0, function*() {
         const {
             size: t
-        } = yield e.stat(), n = new zd(e, t);
-        return t >= i9 && Bb(yield n.readAt(0, ff + 7 & -8)) ? new r9(new s9(n)) : new jd(new Yd(n));
+        } = yield e.stat(), n = new pf(e, t);
+        return t >= iO && lm(yield n.readAt(0, nu + 7 & -8)) ? new sO(new oO(n)) : new gf(new wf(n));
     });
 }
 
-function kM(e) {
-    const t = hf.from(e);
-    return vu(t) ? t.then((n) => kM(n)) : t.isAsync() ? t.readAll().then((n) => new $u(n)) : new $u(t.readAll());
+function fm(e) {
+    const t = Zr.from(e);
+    return yc(t) ? t.then((n) => fm(n)) : t.isAsync() ? t.readAll().then((n) => new xc(n)) : new xc(t.readAll());
 }
 
-function f9(e = "ws://localhost:3000/") {
+function hO(e = "ws://localhost:3000/") {
     const t = [];
     let n = !1,
-        i = null,
-        r;
+        r = null,
+        i;
     const s = {
         open() {
             n = !0, c();
         },
         close() {
-            for (n = !1, i = null, r = null; t.length;)
+            for (n = !1, r = null, i = null; t.length;)
                 t.shift().reject("Socket closed");
         },
-        error(l) {
-            if (i) {
+        error(u) {
+            if (r) {
                 const {
-                    reject: u
-                } = i;
-                i = null, c(), u(l);
+                    reject: l
+                } = r;
+                r = null, c(), l(u);
             } else
-                console.error("WebSocket error: ", l);
+                console.error("WebSocket error: ", u);
         },
         message({
-            data: l
+            data: u
         }) {
-            if (i) {
+            if (r) {
                 const {
-                    query: u,
+                    query: l,
                     resolve: f,
                     reject: h
-                } = i;
-                if (i = null, c(), typeof l == "string") {
-                    const d = JSON.parse(l);
+                } = r;
+                if (r = null, c(), typeof u == "string") {
+                    const d = JSON.parse(u);
                     d.error ? h(d.error) : f(d);
-                } else if (u.type === "exec")
+                } else if (l.type === "exec")
                     f();
-                else if (u.type === "arrow")
-                    f(kM(l.arrayBuffer()));
+                else if (l.type === "arrow")
+                    f(fm(u.arrayBuffer()));
                 else
-                    throw new Error(`Unexpected socket data: ${l}`);
+                    throw new Error(`Unexpected socket data: ${u}`);
             } else
-                console.log("WebSocket message: ", l);
+                console.log("WebSocket message: ", u);
         }
     };
 
     function o() {
-        r = new WebSocket(e);
-        for (const l in s)
-            r.addEventListener(l, s[l]);
+        i = new WebSocket(e);
+        for (const u in s)
+            i.addEventListener(u, s[u]);
     }
 
-    function a(l, u, f) {
-        r == null && o(), t.push({
-            query: l,
-            resolve: u,
+    function a(u, l, f) {
+        i == null && o(), t.push({
+            query: u,
+            resolve: l,
             reject: f
-        }), n && !i && c();
+        }), n && !r && c();
     }
 
     function c() {
-        t.length && (i = t.shift(), r.send(JSON.stringify(i.query)));
+        t.length && (r = t.shift(), i.send(JSON.stringify(r.query)));
     }
     return {
         get connected() {
             return n;
         },
-        query(l) {
+        /**
+         * Query the DuckDB server.
+         * @param {object} query
+         * @param {'exec' | 'arrow' | 'json'} [query.type] The query type: 'exec', 'arrow', or 'json'.
+         * @param {string} query.sql A SQL query string.
+         * @returns the query result
+         */
+        query(u) {
             return new Promise(
-                (u, f) => a(l, u, f)
+                (l, f) => a(u, l, f)
             );
         }
     };
 }
-class js {
+class Fi {
     /**
      * Create a new Ref instance.
      * @param {string|Ref|null} table The table name.
-     * @param {string|null} column The column name.
+     * @param {string|null} [column] The column name.
      */
     constructor(t, n) {
         t && (this.table = String(t)), n && (this.column = n);
     }
     /**
      * Get the list of referenced columns. Either a single element array
      * if column is non-null, otherwise an empty array.
@@ -8899,87 +8914,87 @@
      */
     toString() {
         const {
             table: t,
             column: n
         } = this;
         if (n) {
-            const i = n.startsWith("*") ? n : `"${n}"`;
-            return `${t ? `${i2(t)}.` : ""}${i}`;
+            const r = n.startsWith("*") ? n : `"${n}"`;
+            return `${t ? `${gb(t)}.` : ""}${r}`;
         } else
-            return t ? i2(t) : "NULL";
+            return t ? gb(t) : "NULL";
     }
 }
 
-function i2(e) {
+function gb(e) {
     return e.split(".").map((n) => `"${n}"`).join(".");
 }
 
-function h9(e, t) {
-    return e instanceof js && e.column === t;
+function dO(e, t) {
+    return e instanceof Fi && e.column === t;
 }
 
-function oe(e) {
-    return typeof e == "string" ? Py(e) : e;
+function Ut(e) {
+    return typeof e == "string" ? Bh(e) : e;
 }
 
-function Jh(e) {
-    return typeof e == "string" ? d9(e) : e;
+function El(e) {
+    return typeof e == "string" ? pO(e) : e;
 }
 
-function d9(e) {
-    return new js(e);
+function pO(e) {
+    return new Fi(e);
 }
 
-function Py(e, t) {
-    return arguments.length === 1 && (t = e, e = null), new js(e, t);
+function Bh(e, t = null) {
+    return arguments.length === 1 && (t = e, e = null), new Fi(e, t);
 }
 
-function df(e) {
+function ru(e) {
     switch (typeof e) {
         case "boolean":
             return e ? "TRUE" : "FALSE";
         case "string":
-            return `'${e}'`;
+            return `'${e.replace("'", "''")}'`;
         case "number":
             return Number.isFinite(e) ? String(e) : "NULL";
         default:
             if (e == null)
                 return "NULL";
             if (e instanceof Date) {
                 const t = +e;
                 if (Number.isNaN(t))
                     return "NULL";
                 const n = e.getUTCFullYear(),
-                    i = e.getUTCMonth(),
-                    r = e.getUTCDate();
-                return t === Date.UTC(n, i, r) ? `MAKE_DATE(${n}, ${i + 1}, ${r})` : `EPOCH_MS(${t})`;
+                    r = e.getUTCMonth(),
+                    i = e.getUTCDate();
+                return t === Date.UTC(n, r, i) ? `MAKE_DATE(${n}, ${r + 1}, ${i})` : `EPOCH_MS(${t})`;
             } else
                 return e instanceof RegExp ? `'${e.source}'` : String(e);
     }
 }
-const Mc = (e) => typeof(e == null ? void 0 : e.addEventListener) == "function";
+const qo = (e) => typeof(e == null ? void 0 : e.addEventListener) == "function";
 
-function UM(e) {
-    return e instanceof Vy;
+function Ax(e) {
+    return e instanceof Ch;
 }
-class Vy {
+class Ch {
     /**
      * Create a new SQL expression instance.
-     * @param {(string|SQLExpression|Ref)[]} parts The parts of the expression.
+     * @param {(string | ParamLike | SQLExpression | import('./ref.js').Ref)[]} parts The parts of the expression.
      * @param {string[]} [columns=[]] The column dependencies
      * @param {object} [props] Additional properties for this expression.
      */
-    constructor(t, n, i) {
-        this._expr = Array.isArray(t) ? t : [t], this._deps = n || [], this.annotate(i);
-        const r = this._expr.filter((s) => Mc(s));
-        r.length > 0 ? (this._params = Array.from(new Set(r)), this._params.forEach((s) => {
+    constructor(t, n, r) {
+        this._expr = Array.isArray(t) ? t : [t], this._deps = n || [], this.annotate(r);
+        const i = this._expr.filter((s) => qo(s));
+        i.length > 0 ? (this._params = Array.from(new Set(i)), this._params.forEach((s) => {
             s.addEventListener("value", () => {
                 var o;
-                return p9(this, (o = this.map) == null ? void 0 : o.get("value"));
+                return yO(this, (o = this.map) == null ? void 0 : o.get("value"));
             });
         })) : this.addEventListener = void 0;
     }
     /**
      * A reference to this expression.
      * Provides compatibility with param-like objects.
      */
@@ -8992,843 +9007,1016 @@
      */
     get columns() {
         const {
             _params: t,
             _deps: n
         } = this;
         if (t) {
-            const i = new Set(t.flatMap((r) => {
+            const r = new Set(t.flatMap((i) => {
                 var o;
-                const s = (o = r.value) == null ? void 0 : o.columns;
+                const s = (o = i.value) == null ? void 0 : o.columns;
                 return Array.isArray(s) ? s : [];
             }));
-            if (i.size) {
-                const r = new Set(n);
-                return i.forEach((s) => r.add(s)), Array.from(r);
+            if (r.size) {
+                const i = new Set(n);
+                return r.forEach((s) => i.add(s)), Array.from(i);
             }
         }
         return n;
     }
     /**
      * The first column dependency in this expression, or undefined if none.
      * @returns {string} The first column dependency.
      */
     get column() {
         return this._deps.length ? this._deps[0] : this.columns[0];
     }
     /**
      * Annotate this expression instance with additional properties.
      * @param {object[]} [props] One or more objects with properties to add.
-     * @returns {this} This SQL expression.
+     * @returns This SQL expression.
      */
     annotate(...t) {
         return Object.assign(this, ...t);
     }
     /**
      * Generate a SQL code string corresponding to this expression.
      * @returns {string} A SQL code string.
      */
     toString() {
-        return this._expr.map((t) => Mc(t) && !UM(t) ? df(t.value) : t).join("");
+        return this._expr.map((t) => qo(t) && !Ax(t) ? ru(t.value) : t).join("");
     }
     /**
      * Add an event listener callback for the provided event type.
      * @param {string} type The event type to listen for (for example, "value").
      * @param {(a: SQLExpression) => Promise?} callback The callback function to
      *  invoke upon updates. A callback may optionally return a Promise that
      *  upstream listeners may await before proceeding.
      */
     addEventListener(t, n) {
-        const i = this.map || (this.map = /* @__PURE__ */ new Map());
-        (i.get(t) || (i.set(t, /* @__PURE__ */ new Set()), i.get(t))).add(n);
+        const r = this.map || (this.map = /* @__PURE__ */ new Map());
+        (r.get(t) || (r.set(t, /* @__PURE__ */ new Set()), r.get(t))).add(n);
     }
 }
 
-function p9(e, t) {
+function yO(e, t) {
     if (t != null && t.size)
         return Promise.allSettled(Array.from(t, (n) => n(e)));
 }
 
-function zM(e, t) {
+function $x(e, t) {
     const n = [e[0]],
-        i = /* @__PURE__ */ new Set(),
-        r = t.length;
-    for (let s = 0, o = 0; s < r;) {
+        r = /* @__PURE__ */ new Set(),
+        i = t.length;
+    for (let s = 0, o = 0; s < i;) {
         const a = t[s];
-        Mc(a) ? n[++o] = a : (Array.isArray(a == null ? void 0 : a.columns) && a.columns.forEach((l) => i.add(l)), n[o] += typeof a == "string" ? a : df(a));
+        qo(a) ? n[++o] = a : (Array.isArray(a == null ? void 0 : a.columns) && a.columns.forEach((u) => r.add(u)), n[o] += typeof a == "string" ? a : ru(a));
         const c = e[++s];
-        Mc(n[o]) ? n[++o] = c : n[o] += c;
+        qo(n[o]) ? n[++o] = c : n[o] += c;
     }
     return {
         spans: n,
-        cols: Array.from(i)
+        cols: Array.from(r)
     };
 }
 
-function q(e, ...t) {
+function j(e, ...t) {
     const {
         spans: n,
-        cols: i
-    } = zM(e, t);
-    return new Vy(n, i);
+        cols: r
+    } = $x(e, t);
+    return new Ch(n, r);
 }
 
-function y9(e) {
-    const t = oe(e);
-    return q`${t} DESC NULLS LAST`.annotate({
+function mO(e) {
+    const t = Ut(e);
+    return j`${t} DESC NULLS LAST`.annotate({
         label: t == null ? void 0 : t.label,
         desc: !0
     });
 }
-const tl = (e) => ({
+const Ph = (e) => ({
     value: e,
-    toString: () => df(e)
+    toString: () => ru(e)
 });
 
-function pf(e) {
+function iu(e) {
     var t;
     e(this.op, this), (t = this.children) == null || t.forEach((n) => n.visit(e));
 }
 
-function PM(e, t) {
-    const n = t.filter((r) => r != null).map(oe),
-        i = n.map((r, s) => s ? ` ${e} ` : "");
-    return n.length === 1 ? i.push("") : n.length > 1 && (i[0] = "(", i.push(")")), q(i, ...n).annotate({
+function Ix(e, t) {
+    const n = t.filter((i) => i != null).map(Ut),
+        r = n.map((i, s) => s ? ` ${e} ` : "");
+    return n.length === 1 ? r.push("") : n.length > 1 && (r[0] = "(", r.push(")")), j(r, ...n).annotate({
         op: e,
         children: n,
-        visit: pf
+        visit: iu
     });
 }
-const qs = (...e) => PM("AND", e.flat()),
-    Ob = (...e) => PM("OR", e.flat()),
-    m9 = (e) => (t) => q`(${e} ${oe(t)})`.annotate({
+const Bi = (...e) => Ix("AND", e.flat()),
+    hm = (...e) => Ix("OR", e.flat()),
+    gO = (e) => (t) => j`(${e} ${Ut(t)})`.annotate({
         op: e,
         a: t,
-        visit: pf
+        visit: iu
     }),
-    g9 = m9("NOT"),
-    VM = (e) => (t) => q`(${oe(t)} ${e})`.annotate({
+    bO = gO("NOT"),
+    Tx = (e) => (t) => j`(${Ut(t)} ${e})`.annotate({
         op: e,
         a: t,
-        visit: pf
+        visit: iu
     }),
-    Fb = VM("IS NULL"),
-    Tu = VM("IS NOT NULL"),
-    ro = (e) => (t, n) => q`(${oe(t)} ${e} ${oe(n)})`.annotate({
+    dm = Tx("IS NULL"),
+    Sc = Tx("IS NOT NULL"),
+    Gi = (e) => (t, n) => j`(${Ut(t)} ${e} ${Ut(n)})`.annotate({
         op: e,
         a: t,
         b: n,
-        visit: pf
+        visit: iu
     }),
-    jy = ro("="),
-    Eb = ro("<>"),
-    Du = ro("<"),
-    jM = ro(">"),
-    Nu = ro("<="),
-    b9 = ro(">="),
-    w9 = ro("IS DISTINCT FROM"),
-    qM = ro("IS NOT DISTINCT FROM");
-
-function YM(e, t, n, i) {
-    t = oe(t);
-    const r = e.startsWith("NOT ") ? "NOT " : "";
-    return (n ? i ? q`${r}(${n[0]} <= ${t} AND ${t} < ${n[1]})` : q`(${t} ${e} ${n[0]} AND ${n[1]})` : q``).annotate({
+    wO = Gi("="),
+    pm = Gi("<>"),
+    Mc = Gi("<"),
+    Ex = Gi(">"),
+    Ac = Gi("<="),
+    vO = Gi(">="),
+    _O = Gi("IS DISTINCT FROM"),
+    ym = Gi("IS NOT DISTINCT FROM");
+
+function Nx(e, t, n, r) {
+    t = Ut(t);
+    const i = e.startsWith("NOT ") ? "NOT " : "";
+    return (n ? r ? j`${i}(${n[0]} <= ${t} AND ${t} < ${n[1]})` : j`(${t} ${e} ${n[0]} AND ${n[1]})` : j``).annotate({
         op: e,
-        visit: pf,
+        visit: iu,
         field: t,
         range: n
     });
 }
-const Tn = (e, t, n) => YM("BETWEEN", e, t, n),
-    v9 = (e, t, n) => YM("NOT BETWEEN", e, t, n);
+const $n = (e, t, n) => Nx("BETWEEN", e, t, n),
+    xO = (e, t, n) => Nx("NOT BETWEEN", e, t, n);
 
-function Wd(e, t) {
+function vf(e, t) {
     return Array.from({
         length: e
     }, () => t);
 }
 
-function ls(e, t) {
+function ai(e, t) {
     return (...n) => {
-        const i = n.map(oe),
-            r = t ? `::${t}` : "";
-        return (i.length ? q([`${e}(`, ...Wd(i.length - 1, ", "), `)${r}`], ...i) : q`${e}()${r}`).annotate({
+        const r = n.map(Ut),
+            i = t ? `::${t}` : "";
+        return (r.length ? j([`${e}(`, ...vf(r.length - 1, ", "), `)${i}`], ...r) : j`${e}()${i}`).annotate({
             func: e,
-            args: i
+            args: r
         });
     };
 }
-const _9 = ls("REGEXP_MATCHES"),
-    x9 = ls("CONTAINS"),
-    S9 = ls("PREFIX"),
-    I9 = ls("SUFFIX");
-class Ds extends Vy {
-    constructor(t, n, i, r, s = "", o = "", a = "") {
+const SO = ai("REGEXP_MATCHES"),
+    MO = ai("CONTAINS"),
+    AO = ai("PREFIX"),
+    $O = ai("SUFFIX");
+class Si extends Ch {
+    /**
+     * Create a new WindowFunction instance.
+     * @param {string} op The window operation indicator.
+     * @param {*} func The window function expression.
+     * @param {*} [type] The SQL data type to cast to.
+     * @param {string} [name] The window definition name.
+     * @param {*} [group] Grouping (partition by) expressions.
+     * @param {*} [order] Sorting (order by) expressions.
+     * @param {*} [frame] The window frame definition.
+     */
+    constructor(t, n, r, i, s = "", o = "", a = "") {
         let c;
-        if (r && !(s || o || a))
-            c = r ? q`${n} OVER "${r}"` : q`${n} OVER ()`;
+        if (i && !(s || o || a))
+            c = i ? j`${n} OVER "${i}"` : j`${n} OVER ()`;
         else {
             const h = s && o ? " " : "",
                 d = (s || o) && a ? " " : "";
-            c = q`${n} OVER (${r ? `"${r}" ` : ""}${s}${h}${o}${d}${a})`;
+            c = j`${n} OVER (${i ? `"${i}" ` : ""}${s}${h}${o}${d}${a})`;
         }
-        i && (c = q`(${c})::${i}`);
+        r && (c = j`(${c})::${r}`);
         const {
-            _expr: u,
+            _expr: l,
             _deps: f
         } = c;
-        super(u, f, {
-            window: t,
-            func: n,
-            type: i,
-            name: r,
-            group: s,
-            order: o,
-            frame: a
-        });
+        super(l, f), this.window = t, this.func = n, this.type = r, this.name = i, this.group = s, this.order = o, this.frame = a;
     }
     get basis() {
         return this.column;
     }
     get label() {
         const {
             func: t
         } = this;
         return t.label ?? t.toString();
     }
+    /**
+     * Return an updated window function over a named window definition.
+     * @param {string} name The window definition name.
+     * @returns {WindowFunction} A new window function.
+     */
     over(t) {
         const {
             window: n,
-            func: i,
-            type: r,
+            func: r,
+            type: i,
             group: s,
             order: o,
             frame: a
         } = this;
-        return new Ds(n, i, r, t, s, o, a);
+        return new Si(n, r, i, t, s, o, a);
     }
+    /**
+     * Return an updated window function with the given partitioning.
+     * @param {*} expr The grouping (partition by) criteria for the window function.
+     * @returns {WindowFunction} A new window function.
+     */
     partitionby(...t) {
-        const n = t.flat().filter((u) => u).map(oe),
-            i = q(
-                ["PARTITION BY ", Wd(n.length - 1, ", "), ""],
+        const n = t.flat().filter((l) => l).map(Ut),
+            r = j(
+                ["PARTITION BY ", vf(n.length - 1, ", "), ""],
                 ...n
             ),
             {
-                window: r,
+                window: i,
                 func: s,
                 type: o,
                 name: a,
                 order: c,
-                frame: l
+                frame: u
             } = this;
-        return new Ds(r, s, o, a, i, c, l);
+        return new Si(i, s, o, a, r, c, u);
     }
+    /**
+     * Return an updated window function with the given ordering.
+     * @param {*} expr The sorting (order by) criteria for the window function.
+     * @returns {WindowFunction} A new window function.
+     */
     orderby(...t) {
-        const n = t.flat().filter((u) => u).map(oe),
-            i = q(
-                ["ORDER BY ", Wd(n.length - 1, ", "), ""],
+        const n = t.flat().filter((l) => l).map(Ut),
+            r = j(
+                ["ORDER BY ", vf(n.length - 1, ", "), ""],
                 ...n
             ),
             {
-                window: r,
+                window: i,
                 func: s,
                 type: o,
                 name: a,
                 group: c,
-                frame: l
+                frame: u
             } = this;
-        return new Ds(r, s, o, a, c, i, l);
+        return new Si(i, s, o, a, c, r, u);
     }
+    /**
+     * Return an updated window function with the given rows frame.
+     * @param {(number|null)[] | import('./expression.js').ParamLike} expr The row-based window frame.
+     * @returns {WindowFunction} A new window function.
+     */
     rows(t) {
-        const n = r2("ROWS", t),
+        const n = bb("ROWS", t),
             {
-                window: i,
-                func: r,
+                window: r,
+                func: i,
                 type: s,
                 name: o,
                 group: a,
                 order: c
             } = this;
-        return new Ds(i, r, s, o, a, c, n);
+        return new Si(r, i, s, o, a, c, n);
     }
+    /**
+     * Return an updated window function with the given range frame.
+     * @param {(number|null)[] | import('./expression.js').ParamLike} expr The range-based window frame.
+     * @returns {WindowFunction} A new window function.
+     */
     range(t) {
-        const n = r2("RANGE", t),
+        const n = bb("RANGE", t),
             {
-                window: i,
-                func: r,
+                window: r,
+                func: i,
                 type: s,
                 name: o,
                 group: a,
                 order: c
             } = this;
-        return new Ds(i, r, s, o, a, c, n);
+        return new Si(r, i, s, o, a, c, n);
     }
 }
 
-function r2(e, t) {
-    if (Mc(t)) {
-        const n = q`${t}`;
-        return n.toString = () => `${e} ${s2(t.value)}`, n;
+function bb(e, t) {
+    if (qo(t)) {
+        const n = j`${t}`;
+        return n.toString = () => `${e} ${wb(t.value)}`, n;
     }
-    return `${e} ${s2(t)}`;
+    return `${e} ${wb(t)}`;
 }
 
-function s2(e) {
-    const [t, n] = e, i = t === 0 ? "CURRENT ROW" : Number.isFinite(t) ? `${Math.abs(t)} PRECEDING` : "UNBOUNDED PRECEDING", r = n === 0 ? "CURRENT ROW" : Number.isFinite(n) ? `${Math.abs(n)} FOLLOWING` : "UNBOUNDED FOLLOWING";
-    return `BETWEEN ${i} AND ${r}`;
+function wb(e) {
+    const [t, n] = e, r = t === 0 ? "CURRENT ROW" : Number.isFinite(t) ? `${Math.abs(t)} PRECEDING` : "UNBOUNDED PRECEDING", i = n === 0 ? "CURRENT ROW" : Number.isFinite(n) ? `${Math.abs(n)} FOLLOWING` : "UNBOUNDED FOLLOWING";
+    return `BETWEEN ${r} AND ${i}`;
 }
 
-function Li(e, t) {
+function Gn(e, t) {
     return (...n) => {
-        const i = ls(e)(...n);
-        return new Ds(e, i, t);
+        const r = ai(e)(...n);
+        return new Si(e, r, t);
     };
 }
-const A9 = Li("ROW_NUMBER", "INTEGER"),
-    M9 = Li("RANK", "INTEGER"),
-    $9 = Li("DENSE_RANK", "INTEGER"),
-    T9 = Li("PERCENT_RANK"),
-    D9 = Li("CUME_DIST"),
-    N9 = Li("NTILE"),
-    B9 = Li("LAG"),
-    O9 = Li("LEAD"),
-    F9 = Li("FIRST_VALUE"),
-    E9 = Li("LAST_VALUE"),
-    L9 = Li("NTH_VALUE");
+const IO = Gn("ROW_NUMBER", "INTEGER"),
+    TO = Gn("RANK", "INTEGER"),
+    EO = Gn("DENSE_RANK", "INTEGER"),
+    NO = Gn("PERCENT_RANK"),
+    DO = Gn("CUME_DIST"),
+    OO = Gn("NTILE"),
+    LO = Gn("LAG"),
+    kO = Gn("LEAD"),
+    RO = Gn("FIRST_VALUE"),
+    FO = Gn("LAST_VALUE"),
+    BO = Gn("NTH_VALUE");
 
-function R9(e, ...t) {
-    return q(e, ...t).annotate({
+function Tt(e, ...t) {
+    return j(e, ...t).annotate({
         aggregate: !0
     });
 }
-class uu extends Vy {
-    constructor(t, n, i, r, s) {
-        n = (n || []).map(oe);
+class ac extends Ch {
+    /**
+     * Create a new AggregateFunction instance.
+     * @param {*} op The aggregate operation.
+     * @param {*} [args] The aggregate function arguments.
+     * @param {*} [type] The SQL data type to cast to.
+     * @param {boolean} [isDistinct] Flag indicating if this is a distinct value aggregate.
+     * @param {*} [filter] Filtering expression to apply prior to aggregation.
+     */
+    constructor(t, n, r, i, s) {
+        n = (n || []).map(Ut);
         const {
             strings: o,
             exprs: a
-        } = C9(t, n, i, r, s), {
+        } = CO(t, n, r, i, s), {
             spans: c,
-            cols: l
-        } = zM(o, a);
-        super(c, l, {
-            aggregate: t,
-            args: n,
-            type: i,
-            isDistinct: r,
-            filter: s
-        });
+            cols: u
+        } = $x(o, a);
+        super(c, u), this.aggregate = t, this.args = n, this.type = r, this.isDistinct = i, this.filter = s;
     }
     get basis() {
         return this.column;
     }
     get label() {
         const {
             aggregate: t,
             args: n,
-            isDistinct: i
-        } = this, r = i ? "DISTINCT" + (n.length ? " " : "") : "", s = n.length ? `(${r}${n.map(k9).join(", ")})` : "";
+            isDistinct: r
+        } = this, i = r ? "DISTINCT" + (n.length ? " " : "") : "", s = n.length ? `(${i}${n.map(PO).join(", ")})` : "";
         return `${t.toLowerCase()}${s}`;
     }
+    /**
+     * Return a new derived aggregate function over distinct values.
+     * @returns {AggregateFunction} A new aggregate function.
+     */
     distinct() {
         const {
             aggregate: t,
             args: n,
-            type: i,
-            filter: r
+            type: r,
+            filter: i
         } = this;
-        return new uu(t, n, i, !0, r);
+        return new ac(t, n, r, !0, i);
     }
+    /**
+     * Return a new derived aggregate function that filters values.
+     * @param {*} filter The filter expresion.
+     * @returns {AggregateFunction} A new aggregate function.
+     */
     where(t) {
         const {
             aggregate: n,
-            args: i,
-            type: r,
+            args: r,
+            type: i,
             isDistinct: s
         } = this;
-        return new uu(n, i, r, s, t);
+        return new ac(n, r, i, s, t);
     }
+    /**
+     * Return a new window function over this aggregate.
+     * @returns {WindowFunction} A new aggregate function.
+     */
     window() {
         const {
             aggregate: t,
             args: n,
-            type: i,
-            isDistinct: r
-        } = this, s = new uu(t, n, null, r);
-        return new Ds(t, s, i);
+            type: r,
+            isDistinct: i
+        } = this, s = new ac(t, n, null, i);
+        return new Si(t, s, r);
     }
+    /**
+     * Return a window function over this aggregate with the given partitioning.
+     * @param {*} expr The grouping (partition by) criteria for the window function.
+     * @returns {WindowFunction} A new window function.
+     */
     partitionby(...t) {
         return this.window().partitionby(...t);
     }
+    /**
+     * Return a window function over this aggregate with the given ordering.
+     * @param {*} expr The sorting (order by) criteria for the window function.
+     * @returns {WindowFunction} A new window function.
+     */
     orderby(...t) {
         return this.window().orderby(...t);
     }
-    rows(t, n) {
-        return this.window().rows(t, n);
+    /**
+     * Return a window function over this aggregate with the given row frame.
+     * @param {(number|null)[] | import('./expression.js').ParamLike} frame The row-based window frame.
+     * @returns {WindowFunction} A new window function.
+     */
+    rows(t) {
+        return this.window().rows(t);
     }
-    range(t, n) {
-        return this.window().range(t, n);
+    /**
+     * Return a window function over this aggregate with the given range frame.
+     * @param {(number|null)[] | import('./expression.js').ParamLike} frame The range-based window frame.
+     * @returns {WindowFunction} A new window function.
+     */
+    range(t) {
+        return this.window().range(t);
     }
 }
 
-function C9(e, t, n, i, r) {
+function CO(e, t, n, r, i) {
     const s = `)${n ? `::${n}` : ""}`;
-    let o = [`${e}(${i ? "DISTINCT " : ""}`],
+    let o = [`${e}(${r ? "DISTINCT " : ""}`],
         a = [];
     return t.length ? (o = o.concat([
-        ...Wd(t.length - 1, ", "),
-        `${s}${r ? " FILTER (WHERE " : ""}`,
-        ...r ? [")"] : []
-    ]), a = [...t, ...r ? [r] : []]) : o[0] += "*" + s, {
+        ...vf(t.length - 1, ", "),
+        `${s}${i ? " FILTER (WHERE " : ""}`,
+        ...i ? [")"] : []
+    ]), a = [...t, ...i ? [i] : []]) : o[0] += "*" + s, {
         exprs: a,
         strings: o
     };
 }
 
-function k9(e) {
-    const t = df(e);
+function PO(e) {
+    const t = ru(e);
     return t && t.startsWith('"') && t.endsWith('"') ? t.slice(1, -1) : t;
 }
 
-function Kt(e, t) {
-    return (...n) => new uu(e, n, t);
+function Rt(e, t) {
+    return (...n) => new ac(e, n, t);
 }
-const ko = Kt("COUNT", "INTEGER"),
-    U9 = Kt("AVG"),
-    z9 = Kt("MAD"),
-    $c = Kt("MAX"),
-    Tc = Kt("MIN"),
-    oa = Kt("SUM", "DOUBLE"),
-    P9 = Kt("PRODUCT"),
-    V9 = Kt("MEDIAN"),
-    j9 = Kt("QUANTILE"),
-    q9 = Kt("MODE"),
-    Y9 = Kt("VARIANCE"),
-    W9 = Kt("STDDEV"),
-    G9 = Kt("SKEWNESS"),
-    X9 = Kt("KURTOSIS"),
-    H9 = Kt("ENTROPY"),
-    J9 = Kt("VAR_POP"),
-    K9 = Kt("STDDEV_POP"),
-    Z9 = Kt("CORR"),
-    Q9 = Kt("COVAR_POP"),
-    tU = Kt("REGR_INTERCEPT"),
-    eU = Kt("REGR_SLOPE"),
-    nU = Kt("REGR_COUNT"),
-    iU = Kt("REGR_SYY"),
-    rU = Kt("REGR_SXX"),
-    sU = Kt("REGR_AVGX"),
-    oU = Kt("FIRST"),
-    aU = Kt("LAST"),
-    Dg = Kt("ARG_MIN"),
-    Ng = Kt("ARG_MAX"),
-    cU = Kt("STRING_AGG"),
-    lU = Kt("ARRAY_AGG");
-
-function Lb(e, t) {
-    const n = oe(e),
-        i = q`CAST(${n} AS ${t})`;
-    return Object.defineProperty(i, "label", {
+const Di = Rt("COUNT", "INTEGER"),
+    Dx = Rt("AVG"),
+    UO = Rt("MAD"),
+    jo = Rt("MAX"),
+    Vo = Rt("MIN"),
+    Cs = Rt("SUM", "DOUBLE"),
+    zO = Rt("PRODUCT"),
+    qO = Rt("MEDIAN"),
+    jO = Rt("QUANTILE"),
+    VO = Rt("MODE"),
+    YO = Rt("VARIANCE"),
+    Ox = Rt("STDDEV"),
+    WO = Rt("SKEWNESS"),
+    XO = Rt("KURTOSIS"),
+    GO = Rt("ENTROPY"),
+    HO = Rt("VAR_POP"),
+    JO = Rt("STDDEV_POP"),
+    ZO = Rt("CORR"),
+    KO = Rt("COVAR_SAMP"),
+    QO = Rt("COVAR_POP"),
+    tL = Rt("REGR_INTERCEPT"),
+    eL = Rt("REGR_SLOPE"),
+    nL = Rt("REGR_COUNT"),
+    rL = Rt("REGR_SYY"),
+    iL = Rt("REGR_SXX"),
+    sL = Rt("REGR_AVGX"),
+    oL = Rt("FIRST"),
+    aL = Rt("LAST"),
+    y0 = Rt("ARG_MIN"),
+    m0 = Rt("ARG_MAX"),
+    cL = Rt("STRING_AGG"),
+    uL = Rt("ARRAY_AGG");
+
+function mm(e, t) {
+    const n = Ut(e),
+        r = j`CAST(${n} AS ${t})`;
+    return Object.defineProperty(r, "label", {
         enumerable: !0,
         get() {
             return e.label;
         }
-    }), Object.defineProperty(i, "aggregate", {
+    }), Object.defineProperty(r, "aggregate", {
         enumerable: !0,
         get() {
             return e.aggregate || !1;
         }
-    }), i;
+    }), r;
 }
-const Bg = (e) => Lb(e, "DOUBLE"),
-    uU = (e) => Lb(e, "INTEGER"),
-    fU = (e) => q`epoch_ms(${oe(e)})`,
-    hU = (e) => {
-        const t = oe(e);
-        return q`MAKE_DATE(2012, MONTH(${t}), 1)`.annotate({
+const g0 = (e) => mm(e, "DOUBLE"),
+    lL = (e) => mm(e, "INTEGER"),
+    fL = (e) => j`epoch_ms(${Ut(e)})`,
+    hL = (e) => {
+        const t = Ut(e);
+        return j`MAKE_DATE(2012, MONTH(${t}), 1)`.annotate({
             label: "month"
         });
     },
-    dU = (e) => {
-        const t = oe(e);
-        return q`MAKE_DATE(2012, MONTH(${t}), DAY(${t}))`.annotate({
+    dL = (e) => {
+        const t = Ut(e);
+        return j`MAKE_DATE(2012, MONTH(${t}), DAY(${t}))`.annotate({
             label: "date"
         });
     },
-    pU = (e) => {
-        const t = oe(e);
-        return q`MAKE_DATE(2012, 1, DAY(${t}))`.annotate({
+    pL = (e) => {
+        const t = Ut(e);
+        return j`MAKE_DATE(2012, 1, DAY(${t}))`.annotate({
             label: "date"
         });
     },
-    WM = ls("ST_AsGeoJSON"),
-    yU = ls("ST_X"),
-    mU = ls("ST_Y"),
-    Rb = ls("ST_CENTROID"),
-    gU = (e) => yU(Rb(e)),
-    bU = (e) => mU(Rb(e));
-class Lt {
+    Lx = ai("ST_AsGeoJSON"),
+    yL = ai("ST_X"),
+    mL = ai("ST_Y"),
+    gm = ai("ST_CENTROID"),
+    gL = (e) => yL(gm(e)),
+    bL = (e) => mL(gm(e));
+class xt {
     static select(...t) {
-        return new Lt().select(...t);
+        return new xt().select(...t);
     }
     static from(...t) {
-        return new Lt().from(...t);
+        return new xt().from(...t);
     }
     static with(...t) {
-        return new Lt().with(...t);
+        return new xt().with(...t);
     }
     static union(...t) {
-        return new Bo("UNION", t.flat());
+        return new hs("UNION", t.flat());
     }
     static unionAll(...t) {
-        return new Bo("UNION ALL", t.flat());
+        return new hs("UNION ALL", t.flat());
     }
     static intersect(...t) {
-        return new Bo("INTERSECT", t.flat());
+        return new hs("INTERSECT", t.flat());
     }
     static except(...t) {
-        return new Bo("EXCEPT", t.flat());
+        return new hs("EXCEPT", t.flat());
     }
     static describe(t) {
         const n = t.clone(),
             {
-                clone: i,
-                toString: r
+                clone: r,
+                toString: i
             } = n;
         return Object.assign(n, {
             describe: !0,
-            clone: () => Lt.describe(i.call(n)),
-            toString: () => `DESCRIBE ${r.call(n)}`
+            clone: () => xt.describe(r.call(n)),
+            toString: () => `DESCRIBE ${i.call(n)}`
         });
     }
     constructor() {
         this.query = {
             with: [],
             select: [],
             from: [],
             where: [],
             groupby: [],
             having: [],
             window: [],
             qualify: [],
             orderby: []
-        };
+        }, this.cteFor = null;
     }
     clone() {
-        const t = new Lt();
+        const t = new xt();
         return t.query = {
             ...this.query
         }, t;
     }
+    /**
+     * Retrieve current WITH common table expressions (CTEs).
+     * @returns {any[]}
+     */
+    /**
+     * Add WITH common table expressions (CTEs).
+     * @param  {...any} expr Expressions to add.
+     * @returns {this}
+     */
     with(...t) {
         const {
             query: n
         } = this;
         if (t.length === 0)
             return n.with;
         {
-            const i = [],
-                r = (s, o) => {
+            const r = [],
+                i = (s, o) => {
                     const a = o.clone();
-                    a.cteFor = this, i.push({
+                    a.cteFor = this, r.push({
                         as: s,
                         query: a
                     });
                 };
             return t.flat().forEach((s) => {
                 if (s != null)
                     if (s.as && s.query)
-                        r(s.as, s.query);
+                        i(s.as, s.query);
                     else
                         for (const o in s)
-                            r(o, s[o]);
-            }), n.with = n.with.concat(i), this;
+                            i(o, s[o]);
+            }), n.with = n.with.concat(r), this;
         }
     }
+    /**
+     * Retrieve current SELECT expressions.
+     * @returns {any[]}
+     */
+    /**
+     * Add SELECT expressions.
+     * @param {...any} expr Expressions to add.
+     * @returns {this}
+     */
     select(...t) {
         const {
             query: n
         } = this;
         if (t.length === 0)
             return n.select;
         {
-            const i = [];
-            for (const r of t.flat())
-                if (r != null)
-                    if (typeof r == "string")
-                        i.push({
-                            as: r,
-                            expr: oe(r)
+            const r = [];
+            for (const s of t.flat())
+                if (s != null)
+                    if (typeof s == "string")
+                        r.push({
+                            as: s,
+                            expr: Ut(s)
                         });
-                    else if (r instanceof js)
-                i.push({
-                    as: r.column,
-                    expr: r
+                    else if (s instanceof Fi)
+                r.push({
+                    as: s.column,
+                    expr: s
                 });
-            else if (Array.isArray(r))
-                i.push({
-                    as: r[0],
-                    expr: r[1]
+            else if (Array.isArray(s))
+                r.push({
+                    as: s[0],
+                    expr: s[1]
                 });
             else
-                for (const s in r)
-                    i.push({
-                        as: rh(s),
-                        expr: oe(r[s])
+                for (const o in s)
+                    r.push({
+                        as: qu(o),
+                        expr: Ut(s[o])
                     });
-            return n.select = n.select.concat(i), this;
+            const i = new Set(r.map((s) => s.as));
+            return n.select = n.select.filter((s) => !i.has(s.as)).concat(r.filter((s) => s.expr)), this;
         }
     }
     $select(...t) {
         return this.query.select = [], this.select(...t);
     }
     distinct(t = !0) {
         return this.query.distinct = !!t, this;
     }
+    /**
+     * Retrieve current from expressions.
+     * @returns {any[]}
+     */
+    /**
+     * Provide table from expressions.
+     * @param  {...any} expr
+     * @returns {this}
+     */
     from(...t) {
         const {
             query: n
         } = this;
         if (t.length === 0)
             return n.from;
         {
-            const i = [];
-            return t.flat().forEach((r) => {
-                if (r != null)
-                    if (typeof r == "string")
-                        i.push({
-                            as: r,
-                            from: Jh(r)
+            const r = [];
+            return t.flat().forEach((i) => {
+                if (i != null)
+                    if (typeof i == "string")
+                        r.push({
+                            as: i,
+                            from: El(i)
                         });
-                    else if (r instanceof js)
-                    i.push({
-                        as: r.table,
-                        from: r
+                    else if (i instanceof Fi)
+                    r.push({
+                        as: i.table,
+                        from: i
                     });
-                else if (Kh(r) || UM(r))
-                    i.push({
-                        from: r
+                else if (Nl(i) || Ax(i))
+                    r.push({
+                        from: i
                     });
-                else if (Array.isArray(r))
-                    i.push({
-                        as: rh(r[0]),
-                        from: Jh(r[1])
+                else if (Array.isArray(i))
+                    r.push({
+                        as: qu(i[0]),
+                        from: El(i[1])
                     });
                 else
-                    for (const s in r)
-                        i.push({
-                            as: rh(s),
-                            from: Jh(r[s])
+                    for (const s in i)
+                        r.push({
+                            as: qu(s),
+                            from: El(i[s])
                         });
-            }), n.from = n.from.concat(i), this;
+            }), n.from = n.from.concat(r), this;
         }
     }
     $from(...t) {
         return this.query.from = [], this.from(...t);
     }
+    /**
+     * Retrieve current SAMPLE settings.
+     * @returns {any[]}
+     */
+    /**
+     * Set SAMPLE settings.
+     * @param {number|object} value The percentage or number of rows to sample.
+     * @param {string} [method] The sampling method to use.
+     * @returns {this}
+     */
     sample(t, n) {
         const {
-            query: i
+            query: r
         } = this;
         if (arguments.length === 0)
-            return i.sample;
+            return r.sample;
         {
-            let r = t;
-            return typeof t == "number" && (r = t > 0 && t < 1 ? {
+            let i = t;
+            return typeof t == "number" && (i = t > 0 && t < 1 ? {
                 perc: 100 * t,
                 method: n
             } : {
                 rows: Math.round(t),
                 method: n
-            }), i.sample = r, this;
+            }), r.sample = i, this;
         }
     }
+    /**
+     * Retrieve current WHERE expressions.
+     * @returns {any[]}
+     */
+    /**
+     * Add WHERE expressions.
+     * @param  {...any} expr Expressions to add.
+     * @returns {this}
+     */
     where(...t) {
         const {
             query: n
         } = this;
         return t.length === 0 ? n.where : (n.where = n.where.concat(
-            t.flat().filter((i) => i)
+            t.flat().filter((r) => r)
         ), this);
     }
     $where(...t) {
         return this.query.where = [], this.where(...t);
     }
+    /**
+     * Retrieve current GROUP BY expressions.
+     * @returns {any[]}
+     */
+    /**
+     * Add GROUP BY expressions.
+     * @param  {...any} expr Expressions to add.
+     * @returns {this}
+     */
     groupby(...t) {
         const {
             query: n
         } = this;
         return t.length === 0 ? n.groupby : (n.groupby = n.groupby.concat(
-            t.flat().filter((i) => i).map(oe)
+            t.flat().filter((r) => r).map(Ut)
         ), this);
     }
     $groupby(...t) {
         return this.query.groupby = [], this.groupby(...t);
     }
+    /**
+     * Retrieve current HAVING expressions.
+     * @returns {any[]}
+     */
+    /**
+     * Add HAVING expressions.
+     * @param  {...any} expr Expressions to add.
+     * @returns {this}
+     */
     having(...t) {
         const {
             query: n
         } = this;
         return t.length === 0 ? n.having : (n.having = n.having.concat(
-            t.flat().filter((i) => i)
+            t.flat().filter((r) => r)
         ), this);
     }
+    /**
+     * Retrieve current WINDOW definitions.
+     * @returns {any[]}
+     */
+    /**
+     * Add WINDOW definitions.
+     * @param  {...any} expr Expressions to add.
+     * @returns {this}
+     */
     window(...t) {
         const {
             query: n
         } = this;
         if (t.length === 0)
             return n.window;
         {
-            const i = [];
-            return t.flat().forEach((r) => {
-                if (r != null)
-                    for (const s in r)
-                        i.push({
-                            as: rh(s),
-                            expr: r[s]
+            const r = [];
+            return t.flat().forEach((i) => {
+                if (i != null)
+                    for (const s in i)
+                        r.push({
+                            as: qu(s),
+                            expr: i[s]
                         });
-            }), n.window = n.window.concat(i), this;
+            }), n.window = n.window.concat(r), this;
         }
     }
+    /**
+     * Retrieve current QUALIFY expressions.
+     * @returns {any[]}
+     */
+    /**
+     * Add QUALIFY expressions.
+     * @param  {...any} expr Expressions to add.
+     * @returns {this}
+     */
     qualify(...t) {
         const {
             query: n
         } = this;
         return t.length === 0 ? n.qualify : (n.qualify = n.qualify.concat(
-            t.flat().filter((i) => i)
+            t.flat().filter((r) => r)
         ), this);
     }
+    /**
+     * Retrieve current ORDER BY expressions.
+     * @returns {any[]}
+     */
+    /**
+     * Add ORDER BY expressions.
+     * @param  {...any} expr Expressions to add.
+     * @returns {this}
+     */
     orderby(...t) {
         const {
             query: n
         } = this;
         return t.length === 0 ? n.orderby : (n.orderby = n.orderby.concat(
-            t.flat().filter((i) => i).map(oe)
+            t.flat().filter((r) => r).map(Ut)
         ), this);
     }
+    /**
+     * Retrieve current LIMIT value.
+     * @returns {number|null}
+     */
+    /**
+     * Set the query result LIMIT.
+     * @param {number} value The limit value.
+     * @returns {this}
+     */
     limit(t) {
         const {
             query: n
         } = this;
         return arguments.length === 0 ? n.limit : (n.limit = Number.isFinite(t) ? t : void 0, this);
     }
+    /**
+     * Retrieve current OFFSET value.
+     * @returns {number|null}
+     */
+    /**
+     * Set the query result OFFSET.
+     * @param {number} value The offset value.
+     * @returns {this}
+     */
     offset(t) {
         const {
             query: n
         } = this;
         return arguments.length === 0 ? n.offset : (n.offset = Number.isFinite(t) ? t : void 0, this);
     }
     get subqueries() {
         const {
             query: t,
             cteFor: n
-        } = this, i = ((n == null ? void 0 : n.query) || t).with, r = i == null ? void 0 : i.reduce((o, {
+        } = this, r = ((n == null ? void 0 : n.query) || t).with, i = r == null ? void 0 : r.reduce((o, {
             as: a,
             query: c
         }) => (o[a] = c, o), {}), s = [];
         return t.from.forEach(({
             from: o
         }) => {
-            if (Kh(o))
+            if (Nl(o))
                 s.push(o);
-            else if (r[o.table]) {
-                const a = r[o.table];
+            else if (i[o.table]) {
+                const a = i[o.table];
                 s.push(a);
             }
         }), s;
     }
     toString() {
         const {
             with: t,
             select: n,
-            distinct: i,
-            from: r,
+            distinct: r,
+            from: i,
             sample: s,
             where: o,
             groupby: a,
             having: c,
-            window: l,
-            qualify: u,
+            window: u,
+            qualify: l,
             orderby: f,
             limit: h,
             offset: d
         } = this.query, p = [];
         if (t.length) {
-            const g = t.map(({
-                as: y,
+            const m = t.map(({
+                as: g,
                 query: b
-            }) => `"${y}" AS (${b})`);
-            p.push(`WITH ${g.join(", ")}`);
+            }) => `"${g}" AS (${b})`);
+            p.push(`WITH ${m.join(", ")}`);
         }
-        const m = n.map(
+        const y = n.map(
             ({
-                as: g,
-                expr: y
-            }) => h9(y, g) && !y.table ? `${y}` : `${y} AS "${g}"`
+                as: m,
+                expr: g
+            }) => dO(g, m) && !g.table ? `${g}` : `${g} AS "${m}"`
         );
-        if (p.push(`SELECT${i ? " DISTINCT" : ""} ${m.join(", ")}`), r.length) {
-            const g = r.map(({
-                as: y,
+        if (p.push(`SELECT${r ? " DISTINCT" : ""} ${y.join(", ")}`), i.length) {
+            const m = i.map(({
+                as: g,
                 from: b
             }) => {
-                const w = Kh(b) ? `(${b})` : `${b}`;
-                return !y || y === b.table ? w : `${w} AS "${y}"`;
+                const w = Nl(b) ? `(${b})` : `${b}`;
+                return !g || g === b.table ? w : `${w} AS "${g}"`;
             });
-            p.push(`FROM ${g.join(", ")}`);
+            p.push(`FROM ${m.join(", ")}`);
         }
         if (o.length) {
-            const g = o.map(String).filter((y) => y).join(" AND ");
-            g && p.push(`WHERE ${g}`);
+            const m = o.map(String).filter((g) => g).join(" AND ");
+            m && p.push(`WHERE ${m}`);
         }
         if (s) {
             const {
-                rows: g,
-                perc: y,
+                rows: m,
+                perc: g,
                 method: b,
                 seed: w
-            } = s, v = g ? `${g} ROWS` : `${y} PERCENT`, x = b ? ` (${b}${w != null ? `, ${w}` : ""})` : "";
+            } = s, v = m ? `${m} ROWS` : `${g} PERCENT`, x = b ? ` (${b}${w != null ? `, ${w}` : ""})` : "";
             p.push(`USING SAMPLE ${v}${x}`);
         }
         if (a.length && p.push(`GROUP BY ${a.join(", ")}`), c.length) {
-            const g = c.map(String).filter((y) => y).join(" AND ");
-            g && p.push(`HAVING ${g}`);
+            const m = c.map(String).filter((g) => g).join(" AND ");
+            m && p.push(`HAVING ${m}`);
         }
-        if (l.length) {
-            const g = l.map(({
-                as: y,
+        if (u.length) {
+            const m = u.map(({
+                as: g,
                 expr: b
-            }) => `"${y}" AS (${b})`);
-            p.push(`WINDOW ${g.join(", ")}`);
+            }) => `"${g}" AS (${b})`);
+            p.push(`WINDOW ${m.join(", ")}`);
         }
-        if (u.length) {
-            const g = u.map(String).filter((y) => y).join(" AND ");
-            g && p.push(`QUALIFY ${g}`);
+        if (l.length) {
+            const m = l.map(String).filter((g) => g).join(" AND ");
+            m && p.push(`QUALIFY ${m}`);
         }
         return f.length && p.push(`ORDER BY ${f.join(", ")}`), Number.isFinite(h) && p.push(`LIMIT ${h}`), Number.isFinite(d) && p.push(`OFFSET ${d}`), p.join(" ");
     }
 }
-class Bo {
+class hs {
     constructor(t, n) {
-        this.op = t, this.queries = n.map((i) => i.clone()), this.query = {
+        this.op = t, this.queries = n.map((r) => r.clone()), this.query = {
             orderby: []
-        };
+        }, this.cteFor = null;
     }
     clone() {
-        const t = new Bo(this.op, this.queries);
+        const t = new hs(this.op, this.queries);
         return t.query = {
             ...this.query
         }, t;
     }
     orderby(...t) {
         const {
             query: n
         } = this;
         return t.length === 0 ? n.orderby : (n.orderby = n.orderby.concat(
-            t.flat().filter((i) => i).map(oe)
+            t.flat().filter((r) => r).map(Ut)
         ), this);
     }
     limit(t) {
         const {
             query: n
         } = this;
         return arguments.length === 0 ? n.limit : (n.limit = Number.isFinite(t) ? t : void 0, this);
@@ -9840,777 +10028,1539 @@
         return arguments.length === 0 ? n.offset : (n.offset = Number.isFinite(t) ? t : void 0, this);
     }
     get subqueries() {
         const {
             queries: t,
             cteFor: n
         } = this;
-        return n && t.forEach((i) => i.cteFor = n), t;
+        return n && t.forEach((r) => r.cteFor = n), t;
     }
     toString() {
         const {
             op: t,
             queries: n,
             query: {
-                orderby: i,
-                limit: r,
+                orderby: r,
+                limit: i,
                 offset: s
             }
         } = this, o = [n.join(` ${t} `)];
-        return i.length && o.push(`ORDER BY ${i.join(", ")}`), Number.isFinite(r) && o.push(`LIMIT ${r}`), Number.isFinite(s) && o.push(`OFFSET ${s}`), o.join(" ");
+        return r.length && o.push(`ORDER BY ${r.join(", ")}`), Number.isFinite(i) && o.push(`LIMIT ${i}`), Number.isFinite(s) && o.push(`OFFSET ${s}`), o.join(" ");
     }
 }
 
-function Kh(e) {
-    return e instanceof Lt || e instanceof Bo;
+function Nl(e) {
+    return e instanceof xt || e instanceof hs;
 }
 
-function wU(e) {
-    return Kh(e) && e.describe;
+function wL(e) {
+    return Nl(e) && e.describe;
 }
 
-function rh(e) {
-    return vU(e) ? e.slice(1, -1) : e;
+function qu(e) {
+    return vL(e) ? e.slice(1, -1) : e;
 }
 
-function vU(e) {
+function vL(e) {
     return e[0] === '"' && e[e.length - 1] === '"';
 }
-const Zh = (e) => e;
+const Dl = (e) => e;
 
-function _U() {
+function vb() {
     return {
-        apply: Zh,
-        invert: Zh,
-        sqlApply: oe,
-        sqlInvert: Zh
+        apply: Dl,
+        invert: Dl,
+        sqlApply: Ut,
+        sqlInvert: Dl
     };
 }
 
-function xU({
-    base: e
+function _L({
+    base: e = null
 } = {}) {
     if (e == null || e === Math.E)
         return {
             apply: Math.log,
             invert: Math.exp,
-            sqlApply: (t) => q`LN(${oe(t)})`,
-            sqlInvert: (t) => q`EXP(${t})`
+            sqlApply: (t) => j`LN(${Ut(t)})`,
+            sqlInvert: (t) => j`EXP(${t})`
         };
     if (e === 10)
         return {
             apply: Math.log10,
             invert: (t) => Math.pow(10, t),
-            sqlApply: (t) => q`LOG(${oe(t)})`,
-            sqlInvert: (t) => q`POW(10, ${t})`
+            sqlApply: (t) => j`LOG(${Ut(t)})`,
+            sqlInvert: (t) => j`POW(10, ${t})`
         };
     {
         const t = +e;
         return {
             apply: (n) => Math.log(n) / Math.log(t),
             invert: (n) => Math.pow(t, n),
-            sqlApply: (n) => q`LN(${oe(n)}) / LN(${t})`,
-            sqlInvert: (n) => q`POW(${t}, ${n})`
+            sqlApply: (n) => j`LN(${Ut(n)}) / LN(${t})`,
+            sqlInvert: (n) => j`POW(${t}, ${n})`
         };
     }
 }
 
-function SU({
+function xL({
     constant: e = 1
 } = {}) {
     const t = +e;
     return {
         apply: (n) => Math.sign(n) * Math.log1p(Math.abs(n)),
         invert: (n) => Math.sign(n) * Math.exp(Math.abs(n) - t),
-        sqlApply: (n) => (n = oe(n), q`SIGN(${n}) * LN(${t} + ABS(${n}))`),
-        sqlInvert: (n) => q`SIGN(${n}) * (EXP(ABS(${n})) - ${t})`
+        sqlApply: (n) => (n = Ut(n), j`SIGN(${n}) * LN(${t} + ABS(${n}))`),
+        sqlInvert: (n) => j`SIGN(${n}) * (EXP(ABS(${n})) - ${t})`
     };
 }
 
-function IU() {
+function SL() {
     return {
         apply: (e) => Math.sign(e) * Math.sqrt(Math.abs(e)),
         invert: (e) => Math.sign(e) * e * e,
-        sqlApply: (e) => (e = oe(e), q`SIGN(${e}) * SQRT(ABS(${e}))`),
-        sqlInvert: (e) => q`SIGN(${e}) * (${e}) ** 2`
+        sqlApply: (e) => (e = Ut(e), j`SIGN(${e}) * SQRT(ABS(${e}))`),
+        sqlInvert: (e) => j`SIGN(${e}) * (${e}) ** 2`
     };
 }
 
-function AU({
+function ML({
     exponent: e = 1
 } = {}) {
     const t = +e;
     return {
         apply: (n) => Math.sign(n) * Math.pow(Math.abs(n), t),
         invert: (n) => Math.sign(n) * Math.pow(Math.abs(n), 1 / t),
-        sqlApply: (n) => (n = oe(n), q`SIGN(${n}) * POW(ABS(${n}), ${t})`),
-        sqlInvert: (n) => q`SIGN(${n}) * POW(ABS(${n}), 1/${t})`
+        sqlApply: (n) => (n = Ut(n), j`SIGN(${n}) * POW(ABS(${n}), ${t})`),
+        sqlInvert: (n) => j`SIGN(${n}) * POW(ABS(${n}), 1/${t})`
     };
 }
 
-function o2() {
+function _b() {
     return {
         apply: (e) => +e,
         invert: (e) => new Date(e),
-        sqlApply: (e) => e instanceof Date ? +e : fU(oe(e)),
-        sqlInvert: Zh
+        sqlApply: (e) => e instanceof Date ? +e : fL(Ut(e)),
+        sqlInvert: Dl
     };
 }
-const MU = {
-    linear: _U,
-    log: xU,
-    symlog: SU,
-    sqrt: IU,
-    pow: AU,
-    time: o2,
-    utc: o2
+const AL = {
+    identity: vb,
+    linear: vb,
+    log: _L,
+    symlog: xL,
+    sqrt: SL,
+    pow: ML,
+    time: _b,
+    utc: _b
 };
 
-function GM(e) {
-    const t = MU[e.type];
+function kx(e) {
+    const t = AL[e.type];
     return t ? {
         ...e,
         ...t(e)
     } : null;
 }
 
-function yf(e, t, {
+function su(e, t, {
     replace: n = !1,
-    temp: i = !0,
-    view: r = !1
+    temp: r = !0,
+    view: i = !1
 } = {}) {
-    return "CREATE" + (n ? " OR REPLACE " : " ") + (i ? "TEMP " : "") + (r ? "VIEW" : "TABLE") + (n ? " " : " IF NOT EXISTS ") + e + " AS " + t;
+    return "CREATE" + (n ? " OR REPLACE " : " ") + (r ? "TEMP " : "") + (i ? "VIEW" : "TABLE") + (n ? " " : " IF NOT EXISTS ") + e + " AS " + t;
 }
 
-function XM(e) {
+function Rx(e) {
     return `INSTALL ${e}; LOAD ${e}`;
 }
 
-function $U(e, {
+function $L(e, {
     columns: t = Object.keys((e == null ? void 0 : e[0]) || {})
 } = {}) {
     let n = [];
-    if (Array.isArray(t) ? (n = t, t = n.reduce((r, s) => (r[s] = s, r), {})) : t && (n = Object.keys(t)), !n.length)
+    if (Array.isArray(t) ? (n = t, t = n.reduce((i, s) => (i[s] = s, i), {})) : t && (n = Object.keys(t)), !n.length)
         throw new Error("Can not create table from empty column set.");
-    const i = [];
-    for (const r of e) {
-        const s = n.map((o) => `${df(r[o])} AS "${t[o]}"`);
-        i.push(`(SELECT ${s.join(", ")})`);
+    const r = [];
+    for (const i of e) {
+        const s = n.map((o) => `${ru(i[o])} AS "${t[o]}"`);
+        r.push(`(SELECT ${s.join(", ")})`);
     }
-    return i.join(" UNION ALL ");
+    return r.join(" UNION ALL ");
 }
 
-function qy(e, t, n, i = {}, r = {}) {
+function Uh(e, t, n, r = {}, i = {}) {
     const {
         select: s = ["*"],
         where: o,
         view: a,
         temp: c,
-        replace: l,
-        ...u
-    } = i, f = FU({
-        ...r,
-        ...u
+        replace: u,
+        ...l
+    } = r, f = OL({
+        ...i,
+        ...l
     }), h = `${e}('${n}'${f ? ", " + f : ""})`, d = o ? ` WHERE ${o}` : "", p = `SELECT ${s.join(", ")} FROM ${h}${d}`;
-    return yf(t, p, {
+    return su(t, p, {
         view: a,
         temp: c,
-        replace: l
+        replace: u
     });
 }
 
-function TU(e, t, n) {
-    return qy("read_csv", e, t, n, {
+function IL(e, t, n) {
+    return Uh("read_csv", e, t, n, {
         auto_detect: !0,
         sample_size: -1
     });
 }
 
-function DU(e, t, n) {
-    return qy("read_json", e, t, n, {
+function TL(e, t, n) {
+    return Uh("read_json", e, t, n, {
         auto_detect: !0,
         json_format: "auto"
     });
 }
 
-function NU(e, t, n) {
-    return qy("read_parquet", e, t, n);
+function EL(e, t, n) {
+    return Uh("read_parquet", e, t, n);
 }
 
-function BU(e, t, n = {}) {
+function NL(e, t, n = {}) {
     const {
-        options: i,
-        ...r
+        options: r,
+        ...i
     } = n;
-    if (i) {
-        const s = Array.isArray(i) ? i.join(", ") : typeof i == "string" ? i : Object.entries(i).map(([o, a]) => `${o}=${a}`).join(", ");
-        r.open_options = s.toUpperCase();
+    if (r) {
+        const s = Array.isArray(r) ? r.join(", ") : typeof r == "string" ? r : Object.entries(r).map(([o, a]) => `${o}=${a}`).join(", ");
+        Object.assign(i, {
+            open_options: s.toUpperCase()
+        });
     }
-    return qy("st_read", e, t, r);
+    return Uh("st_read", e, t, i);
 }
 
-function OU(e, t, n = {}) {
+function DL(e, t, n = {}) {
     const {
-        select: i = ["*"],
-        ...r
-    } = n, s = $U(t), o = i.length === 1 && i[0] === "*" ? s : `SELECT ${i} FROM ${s}`;
-    return yf(e, o, r);
+        select: r = ["*"],
+        ...i
+    } = n, s = $L(t), o = r.length === 1 && r[0] === "*" ? s : `SELECT ${r} FROM ${s}`;
+    return su(e, o, i);
 }
 
-function FU(e) {
-    return Object.entries(e).map(([t, n]) => `${t}=${Og(n)}`).join(", ");
+function OL(e) {
+    return Object.entries(e).map(([t, n]) => `${t}=${b0(n)}`).join(", ");
 }
 
-function Og(e) {
+function b0(e) {
     switch (typeof e) {
         case "boolean":
             return String(e);
         case "string":
             return `'${e}'`;
         case "undefined":
         case "object":
-            return e == null ? "NULL" : Array.isArray(e) ? "[" + e.map((t) => Og(t)).join(", ") + "]" : "{" + Object.entries(e).map(([t, n]) => `'${t}': ${Og(n)}`).join(", ") + "}";
+            return e == null ? "NULL" : Array.isArray(e) ? "[" + e.map((t) => b0(t)).join(", ") + "]" : "{" + Object.entries(e).map(([t, n]) => `'${t}': ${b0(n)}`).join(", ") + "}";
         default:
             return e;
     }
 }
 
-function EU(e) {
+function LL(e) {
     let t = 2166136261;
-    for (let n = 0, i = e.length; n < i; ++n) {
-        const r = e.charCodeAt(n),
-            s = r & 65280;
-        s && (t = a2(t ^ s >> 8)), t = a2(t ^ r & 255);
+    for (let n = 0, r = e.length; n < r; ++n) {
+        const i = e.charCodeAt(n),
+            s = i & 65280;
+        s && (t = xb(t ^ s >> 8)), t = xb(t ^ i & 255);
     }
-    return LU(t);
+    return kL(t);
 }
 
-function a2(e) {
+function xb(e) {
     return e + (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
 }
 
-function LU(e) {
+function kL(e) {
     return e += e << 13, e ^= e >>> 7, e += e << 3, e ^= e >>> 17, e += e << 5, e & 4294967295;
 }
-class RU {
+const Sb = {
+    from: NaN
+};
+
+function Mb(e) {
+    var a;
+    if (!e.filterIndexable)
+        return Sb;
+    const t = e.query(),
+        n = w0(t);
+    if (typeof n != "string" || !t.groupby)
+        return Sb;
+    const r = new Set(t.groupby().map((c) => c.column)),
+        i = [],
+        s = [],
+        o = {};
+    for (const c of t.select()) {
+        const {
+            as: u,
+            expr: {
+                aggregate: l,
+                args: f
+            }
+        } = c, h = (a = l == null ? void 0 : l.toUpperCase) == null ? void 0 : a.call(l);
+        switch (h) {
+            case "COUNT":
+            case "SUM":
+                i.push({
+                    [u]: Tt`SUM("${u}")::DOUBLE`
+                });
+                break;
+            case "AVG":
+                i.push({
+                    [u]: FL(o, u, f[0])
+                });
+                break;
+            case "ARG_MAX":
+                i.push({
+                    [u]: BL(o, u, f)
+                });
+                break;
+            case "ARG_MIN":
+                i.push({
+                    [u]: CL(o, u, f)
+                });
+                break;
+            case "VARIANCE":
+            case "VAR_SAMP":
+                o[u] = null, i.push({
+                    [u]: ju(o, f[0], n)
+                });
+                break;
+            case "VAR_POP":
+                o[u] = null, i.push({
+                    [u]: ju(o, f[0], n, !1)
+                });
+                break;
+            case "STDDEV":
+            case "STDDEV_SAMP":
+                o[u] = null, i.push({
+                    [u]: Tt`SQRT(${ju(o, f[0], n)})`
+                });
+                break;
+            case "STDDEV_POP":
+                o[u] = null, i.push({
+                    [u]: Tt`SQRT(${ju(o, f[0], n, !1)})`
+                });
+                break;
+            case "COVAR_SAMP":
+                o[u] = null, i.push({
+                    [u]: Ol(o, f, n)
+                });
+                break;
+            case "COVAR_POP":
+                o[u] = null, i.push({
+                    [u]: Ol(o, f, n, !1)
+                });
+                break;
+            case "CORR":
+                o[u] = null, i.push({
+                    [u]: Ab(o, f, n)
+                });
+                break;
+            case "REGR_COUNT":
+                o[u] = null, i.push({
+                    [u]: Tt`${ha(o, f)}::DOUBLE`
+                });
+                break;
+            case "REGR_AVGX":
+                o[u] = null, i.push({
+                    [u]: Cx(o, f)
+                });
+                break;
+            case "REGR_AVGY":
+                o[u] = null, i.push({
+                    [u]: Px(o, f)
+                });
+                break;
+            case "REGR_SYY":
+                o[u] = null, i.push({
+                    [u]: _0(o, 0, f, n)
+                });
+                break;
+            case "REGR_SXX":
+                o[u] = null, i.push({
+                    [u]: _0(o, 1, f, n)
+                });
+                break;
+            case "REGR_SXY":
+                o[u] = null, i.push({
+                    [u]: Ol(o, f, n, null)
+                });
+                break;
+            case "REGR_SLOPE":
+                o[u] = null, i.push({
+                    [u]: Ux(o, f, n)
+                });
+                break;
+            case "REGR_INTERCEPT":
+                o[u] = null, i.push({
+                    [u]: PL(o, f, n)
+                });
+                break;
+            case "REGR_R2":
+                o[u] = null, i.push({
+                    [u]: Tt`(${Ab(o, f, n)}) ** 2`
+                });
+                break;
+            case "MAX":
+            case "MIN":
+            case "BIT_AND":
+            case "BIT_OR":
+            case "BIT_XOR":
+            case "BOOL_AND":
+            case "BOOL_OR":
+            case "PRODUCT":
+                i.push({
+                    [u]: Tt`${h}("${u}")`
+                });
+                break;
+            default:
+                if (r.has(u))
+                    s.push(u);
+                else
+                    return null;
+        }
+    }
+    return {
+        from: n,
+        dims: s,
+        aggr: i,
+        aux: o
+    };
+}
+
+function zn(e, ...t) {
+    const n = t.length ? "_" + t.map(RL).join("_") : "";
+    return `__${e}${n}__`;
+}
+
+function RL(e) {
+    return `${e}`.replaceAll('"', "").replaceAll(" ", "_");
+}
+
+function w0(e) {
+    const t = e.subqueries;
+    if (e.select) {
+        const r = e.from();
+        if (!r.length)
+            return;
+        if (t.length === 0)
+            return r[0].from.table;
+    }
+    const n = w0(t[0]);
+    for (let r = 1; r < t.length; ++r) {
+        const i = w0(t[r]);
+        if (i !== void 0 && i !== n)
+            return NaN;
+    }
+    return n;
+}
+
+function Fx(e, t) {
+    const n = zn("count", t);
+    return e[n] = Tt`COUNT(${t})`, Tt`SUM(${n})`.annotate({
+        name: n
+    });
+}
+
+function FL(e, t, n) {
+    const r = Fx(e, n);
+    return Tt`(SUM("${t}" * ${r.name}) / ${r})`;
+}
+
+function $c(e, t) {
+    return j`(SELECT AVG(${e}) FROM "${t}")`;
+}
+
+function BL(e, t, [, n]) {
+    const r = zn("max", n);
+    return e[r] = Tt`MAX(${n})`, Tt`ARG_MAX("${t}", ${r})`;
+}
+
+function CL(e, t, [, n]) {
+    const r = zn("min", n);
+    return e[r] = Tt`MIN(${n})`, Tt`ARG_MIN("${t}", ${r})`;
+}
+
+function ju(e, t, n, r = !0) {
+    const i = Fx(e, t),
+        s = zn("rssq", t),
+        o = zn("rsum", t),
+        a = j`${t} - ${$c(t, n)}`;
+    return e[s] = Tt`SUM((${a}) ** 2)`, e[o] = Tt`SUM(${a})`, Tt`(SUM(${s}) - (SUM(${o}) ** 2 / ${i})) / (${i}${r ? " - 1" : ""})`;
+}
+
+function Ol(e, t, n, r = !0) {
+    const i = ha(e, t),
+        s = Bx(e, t, n),
+        o = Ic(e, 1, t, n),
+        a = Ic(e, 0, t, n),
+        c = r === null ? "" : r ? ` / (${i} - 1)` : ` / ${i}`;
+    return Tt`(${s} - ${o} * ${a} / ${i})${c}`;
+}
+
+function Ab(e, t, n) {
+    const r = ha(e, t),
+        i = Bx(e, t, n),
+        s = v0(e, 1, t, n),
+        o = v0(e, 0, t, n),
+        a = Ic(e, 1, t, n),
+        c = Ic(e, 0, t, n),
+        u = Tt`(${s} - (${a} ** 2) / ${r})`,
+        l = Tt`(${o} - (${c} ** 2) / ${r})`;
+    return Tt`(${i} - ${a} * ${c} / ${r}) / SQRT(${u} * ${l})`;
+}
+
+function ha(e, [t, n]) {
+    const r = zn("count", t, n);
+    return e[r] = Tt`REGR_COUNT(${t}, ${n})`, Tt`SUM(${r})`.annotate({
+        name: r
+    });
+}
+
+function Ic(e, t, n, r) {
+    const i = n[t],
+        s = n[1 - t],
+        o = zn("rs", i);
+    return e[o] = Tt`SUM(${i} - ${$c(i, r)}) FILTER (${s} IS NOT NULL)`, Tt`SUM(${o})`;
+}
+
+function v0(e, t, n, r) {
+    const i = n[t],
+        s = n[1 - t],
+        o = zn("rss", i);
+    return e[o] = Tt`SUM((${i} - ${$c(i, r)}) ** 2) FILTER (${s} IS NOT NULL)`, Tt`SUM(${o})`;
+}
+
+function Bx(e, t, n) {
+    const [r, i] = t, s = zn("sxy", r, i);
+    return e[s] = Tt`SUM((${i} - ${$c(i, n)}) * (${r} - ${$c(r, n)}))`, Tt`SUM(${s})`;
+}
+
+function Cx(e, t) {
+    const [n, r] = t, i = ha(e, t), s = zn("avg", r, n);
+    return e[s] = Tt`REGR_AVGX(${n}, ${r})`, Tt`(SUM(${s} * ${i.name}) / ${i})`;
+}
+
+function Px(e, t) {
+    const [n, r] = t, i = ha(e, t), s = zn("avg", n, r);
+    return e[s] = Tt`REGR_AVGY(${n}, ${r})`, Tt`(SUM(${s} * ${i.name}) / ${i})`;
+}
+
+function _0(e, t, n, r) {
+    const i = ha(e, n),
+        s = Ic(e, t, n, r),
+        o = v0(e, t, n, r);
+    return Tt`(${o} - (${s} ** 2 / ${i}))`;
+}
+
+function Ux(e, t, n) {
+    const r = Ol(e, t, n, null),
+        i = _0(e, 1, t, n);
+    return Tt`(${r}) / ${i}`;
+}
+
+function PL(e, t, n) {
+    const r = Cx(e, t),
+        i = Px(e, t),
+        s = Ux(e, t, n);
+    return Tt`${i} - (${s}) * ${r}`;
+}
+class UL {
     /**
      *
      * @param {import('./Coordinator.js').Coordinator} mc a Mosaic coordinator
      * @param {*} options Options hash to configure the data cube indexes and pass selections to the coordinator.
      */
     constructor(t, {
         selection: n,
-        temp: i = !0
+        temp: r = !0
     }) {
-        this.mc = t, this.selection = n, this.temp = i, this.reset();
+        this.mc = t, this.selection = n, this.temp = r, this.reset();
     }
     reset() {
-        this.enabled = !1, this.clients = null, this.indices = null, this.activeView = null;
+        this.enabled = !1, this.clients = null, this.indices = null, this.active = null;
     }
     clear() {
-        this.indices && (this.mc.cancel(Array.from(this.indices.values(), (t) => t.result)), this.indices = null);
+        this.indices && (this.mc.cancel(Array.from(this.indices.values(), (t) => t == null ? void 0 : t.result)), this.indices = null);
     }
     index(t, n) {
-        var l, u;
+        var l, f;
         if (this.clients !== t) {
-            const f = Array.from(t, l2),
-                h = (l = f[0]) == null ? void 0 : l.from;
-            this.enabled = f.every((d) => d && d.from === h), this.clients = t, this.activeView = null, this.clear();
+            const h = Array.from(t, Mb).filter((p) => p),
+                d = (l = h[0]) == null ? void 0 : l.from;
+            this.enabled = h.length && h.every((p) => p.from === d), this.clients = t, this.active = null, this.clear();
         }
         if (!this.enabled)
             return !1;
         n = n || this.selection.active;
         const {
-            source: i
+            source: r
         } = n;
-        if (i && i === ((u = this.activeView) == null ? void 0 : u.source))
+        if (r && r === ((f = this.active) == null ? void 0 : f.source))
             return !0;
-        if (this.clear(), !i)
+        if (this.clear(), !r)
             return !1;
-        const r = this.activeView = CU(n);
-        if (!r)
+        const i = this.active = zL(n);
+        if (!i)
             return !1;
-        this.mc.logger().warn("DATA CUBE INDEX CONSTRUCTION");
-        const s = this.selection.remove(i),
-            o = this.indices = /* @__PURE__ */ new Map(),
+        const s = this.mc.logger();
+        s.warn("DATA CUBE INDEX CONSTRUCTION");
+        const o = this.selection.remove(r),
+            a = this.indices = /* @__PURE__ */ new Map(),
             {
-                mc: a,
-                temp: c
+                mc: c,
+                temp: u
             } = this;
-        for (const f of t) {
-            if (s.skip(f, n))
+        for (const h of t) {
+            if (o.skip(h, n)) {
+                a.set(h, null);
+                continue;
+            }
+            const d = Mb(h);
+            if (!d)
                 continue;
-            const h = l2(f),
-                d = f.query(s.predicate(f)).select({
-                    ...r.columns,
-                    ...h.count
-                }).groupby(Object.keys(r.columns)),
-                [p] = d.subqueries;
-            if (p) {
-                const v = Object.values(r.columns).map((x) => x.columns[0]);
-                UU(p, v);
-            }
-            const m = d.orderby();
-            d.query.orderby = [];
-            const g = d.toString(),
-                b = `cube_index_${(EU(g) >>> 0).toString(16)}`,
-                w = a.exec(yf(b, g, {
-                    temp: c
+            const p = h.query(o.predicate(h)).select({
+                    ...i.columns,
+                    ...d.aux
+                }).groupby(Object.keys(i.columns)),
+                [y] = p.subqueries;
+            if (y) {
+                const x = Object.values(i.columns).flatMap((_) => _.columns);
+                VL(y, x);
+            }
+            const m = p.orderby();
+            p.query.orderby = [];
+            const g = p.toString(),
+                w = `cube_index_${(LL(g) >>> 0).toString(16)}`,
+                v = c.exec(su(w, g, {
+                    temp: u
                 }));
-            o.set(f, {
-                table: b,
-                result: w,
+            v.catch((x) => s.error(x)), a.set(h, {
+                table: w,
+                result: v,
                 order: m,
-                ...h
+                ...d
             });
         }
+        return !0;
     }
     async update() {
         const {
             clients: t,
             selection: n,
-            activeView: i
-        } = this, r = i.predicate(n.active.predicate);
+            active: r
+        } = this, i = r.predicate(n.active.predicate);
         return Promise.all(
-            Array.from(t).map((s) => this.updateClient(s, r))
+            Array.from(t).map((s) => this.updateClient(s, i))
         );
     }
     async updateClient(t, n) {
-        const i = this.indices.get(t);
-        if (!i)
+        const {
+            mc: r,
+            indices: i,
+            selection: s
+        } = this;
+        if (!i.has(t))
+            return n = s.predicate(t), r.updateClient(t, t.query(n));
+        const o = this.indices.get(t);
+        if (!o)
             return;
-        n || (n = this.activeView.predicate(this.selection.active.predicate));
         const {
-            table: r,
-            dims: s,
-            aggr: o,
-            order: a = []
-        } = i, c = Lt.select(s, o).from(r).groupby(s).where(n).orderby(a);
-        return this.mc.updateClient(t, c);
+            table: a,
+            dims: c,
+            aggr: u,
+            order: l = []
+        } = o, f = xt.select(c, u).from(a).groupby(c).where(n).orderby(l);
+        return r.updateClient(t, f);
     }
 }
 
-function CU(e) {
-    var c;
+function zL(e) {
+    var u;
     const {
         source: t,
-        schema: n
+        meta: n
     } = e;
-    let i = (c = e.predicate) == null ? void 0 : c.columns;
-    if (!n || !i)
+    let r = (u = e.predicate) == null ? void 0 : u.columns;
+    if (!n || !r)
         return null;
     const {
-        type: r,
+        type: i,
         scales: s,
-        pixelSize: o = 1
+        bin: o,
+        pixelSize: a = 1
     } = n;
-    let a;
-    if (r === "interval" && s) {
-        const l = s.map((u) => kU(u, o));
-        if (l.some((u) => u == null))
+    let c;
+    if (i === "interval" && s) {
+        const l = s.map((f) => jL(f, a, o));
+        if (l.some((f) => f == null))
             return null;
-        l.length === 1 ? (a = (u) => u ? Tn("active0", u.range.map(l[0])) : [], i = {
+        l.length === 1 ? (c = (f) => f ? $n("active0", f.range.map(l[0])) : [], r = {
             active0: l[0](e.predicate.field)
-        }) : (a = (u) => u ? qs(u.children.map(({
-            range: f
-        }, h) => Tn(`active${h}`, f.map(l[h])))) : [], i = Object.fromEntries(
-            e.predicate.children.map((u, f) => [`active${f}`, l[f](u.field)])
+        }) : (c = (f) => f ? Bi(f.children.map(({
+            range: h
+        }, d) => $n(`active${d}`, h.map(l[d])))) : [], r = Object.fromEntries(
+            e.predicate.children.map((f, h) => [`active${h}`, l[h](f.field)])
         ));
-    } else if (r === "point")
-        a = (l) => l, i = Object.fromEntries(i.map((l) => [l.toString(), l]));
+    } else if (i === "point")
+        c = (l) => l, r = Object.fromEntries(r.map((l) => [`${l}`, Ut(l)]));
     else
         return null;
     return {
         source: t,
-        columns: i,
-        predicate: a
+        columns: r,
+        predicate: c
     };
 }
+const qL = {
+    ceil: "CEIL",
+    round: "ROUND"
+};
 
-function kU(e, t) {
+function jL(e, t, n) {
     const {
-        apply: n,
-        sqlApply: i
-    } = GM(e);
-    if (n) {
-        const {
-            domain: r,
-            range: s
-        } = e, o = n(Math.min(...r)), a = n(Math.max(...r)), c = Math.abs(s[1] - s[0]) / (a - o) / t, l = t === 1 ? "" : `${t}::INTEGER * `;
-        return (u) => q`${l}FLOOR(${c}::DOUBLE * (${i(u)} - ${o}::DOUBLE))::INTEGER`;
-    }
+        type: r,
+        domain: i,
+        range: s,
+        apply: o,
+        sqlApply: a
+    } = kx(e);
+    if (!o)
+        return;
+    const c = qL[`${n}`.toLowerCase()] || "FLOOR",
+        u = o(Math.min(...i)),
+        l = o(Math.max(...i)),
+        f = r === "identity" ? 1 : Math.abs(s[1] - s[0]) / (l - u),
+        h = f / t === 1 ? "" : `${f / t}::DOUBLE * `,
+        d = u === 0 ? "" : ` - ${u}::DOUBLE`;
+    return (p) => j`${c}(${h}(${a(p)}${d}))::INTEGER`;
 }
-const c2 = {
-    from: NaN
-};
 
-function l2(e) {
-    var a;
-    if (!e.filterIndexable)
-        return c2;
-    const t = e.query(),
-        n = Fg(t);
-    if (!n || !t.groupby)
-        return c2;
-    const i = new Set(t.groupby().map((c) => c.column)),
-        r = [],
-        s = [];
-    let o;
-    for (const {
-            as: c,
-            expr: {
-                aggregate: l
-            }
-        }
-        of t.select())
-        switch ((a = l == null ? void 0 : l.toUpperCase) == null ? void 0 : a.call(l)) {
-            case "COUNT":
-            case "SUM":
-                r.push({
-                    [c]: q`SUM("${c}")::DOUBLE`
-                });
-                break;
-            case "AVG":
-                o = "_count_", r.push({
-                    [c]: q`(SUM("${c}" * ${o}) / SUM(${o}))::DOUBLE`
-                });
-                break;
-            case "MAX":
-                r.push({
-                    [c]: q`MAX("${c}")`
-                });
-                break;
-            case "MIN":
-                r.push({
-                    [c]: q`MIN("${c}")`
+function VL(e, t) {
+    const n = /* @__PURE__ */ new Set(),
+        r = (i) => {
+            n.has(i) || (n.add(i), i.select && i.from().length && i.select(t), i.subqueries.forEach(r));
+        };
+    r(e);
+}
+class YL {
+    /**
+     * Create a new asynchronous dispatcher instance.
+     */
+    constructor() {
+        this._callbacks = /* @__PURE__ */ new Map();
+    }
+    /**
+     * Add an event listener callback for the provided event type.
+     * @param {string} type The event type.
+     * @param {(value: *) => void | Promise} callback The event handler
+     *  callback function to add. If the callback has already been
+     *  added for the event type, this method has no effect.
+     */
+    addEventListener(t, n) {
+        this._callbacks.has(t) || this._callbacks.set(t, {
+            callbacks: /* @__PURE__ */ new Set(),
+            pending: null,
+            queue: new WL()
+        }), this._callbacks.get(t).callbacks.add(n);
+    }
+    /**
+     * Remove an event listener callback for the provided event type.
+     * @param {string} type The event type.
+     * @param {(value: *) => void | Promise} callback The event handler
+     *  callback function to remove.
+     */
+    removeEventListener(t, n) {
+        const r = this._callbacks.get(t);
+        r && r.callbacks.delete(n);
+    }
+    /**
+     * Lifecycle method that returns the event value to emit.
+     * This default implementation simply returns the input value as-is.
+     * Subclasses may override this method to implement custom transformations
+     * prior to emitting an event value to all listeners.
+     * @param {string} type The event type.
+     * @param {*} value The event value.
+     * @returns The (possibly transformed) event value to emit.
+     */
+    willEmit(t, n) {
+        return n;
+    }
+    /**
+     * Lifecycle method that returns a filter function for updating the
+     * queue of unemitted event values prior to enqueueing a new value.
+     * This default implementation simply returns null, indicating that
+     * any other unemitted event values should be dropped (that is, all
+     * queued events are filtered)
+     * @param {string} type The event type.
+     * @param {*} value The new event value that will be enqueued.
+     * @returns {(value: *) => boolean|null} A dispatch queue filter
+     *  function, or null if all unemitted event values should be filtered.
+     */
+    emitQueueFilter(t, n) {
+        return null;
+    }
+    /**
+     * Cancel all unemitted event values for the given event type.
+     * @param {string} type The event type.
+     */
+    cancel(t) {
+        const n = this._callbacks.get(t);
+        n == null || n.queue.clear();
+    }
+    /**
+     * Emit an event value to listeners for the given event type.
+     * If a previous emit has not yet resolved, the event value
+     * will be queued to be emitted later.
+     * The actual event value given to listeners will be the result
+     * of passing the input value through the emitValue() method.
+     * @param {string} type The event type.
+     * @param {*} value The event value.
+     */
+    emit(t, n) {
+        const r = this._callbacks.get(t) || {};
+        if (r.pending)
+            r.queue.enqueue(n, this.emitQueueFilter(t, n));
+        else {
+            const i = this.willEmit(t, n),
+                {
+                    callbacks: s,
+                    queue: o
+                } = r;
+            if (s != null && s.size) {
+                const a = Array.from(s, (c) => c(i));
+                r.pending = Promise.allSettled(a).then(() => {
+                    r.pending = null, o.isEmpty() || this.emit(t, o.dequeue());
                 });
-                break;
-            default:
-                if (i.has(c))
-                    s.push(c);
-                else
-                    return null;
+            }
         }
-    return {
-        aggr: r,
-        dims: s,
-        count: o ? {
-            [o]: q`COUNT(*)`
-        } : {},
-        from: n
-    };
+    }
+}
+class WL {
+    /**
+     * Create a new dispatch queue instance.
+     */
+    constructor() {
+        this.clear();
+    }
+    /**
+     * Clear the queue state of all event values.
+     */
+    clear() {
+        this.next = null;
+    }
+    /**
+     * Indicate if the queue is empty.
+     * @returns {boolean} True if queue is empty, false otherwise.
+     */
+    isEmpty() {
+        return !this.next;
+    }
+    /**
+     * Add a new value to the queue, and optionally filter the
+     * current queue content in response.
+     * @param {*} value The value to add.
+     * @param {(value: *) => boolean} [filter] An optional filter
+     *  function to apply to existing queue content. If unspecified
+     *  or falsy, all previously queued values are removed. Otherwise,
+     *  the provided function is applied to all queue entries. The
+     *  entry is retained if the filter function returns a truthy value,
+     *  otherwise the entry is removed.
+     */
+    enqueue(t, n) {
+        const r = {
+            value: t
+        };
+        if (n && this.next) {
+            let i = this;
+            for (; i.next;)
+                n(i.next.value) ? i = i.next : i.next = i.next.next;
+            i.next = r;
+        } else
+            this.next = r;
+    }
+    /**
+     * Remove and return the next queued event value.
+     * @returns {*} The next event value in the queue.
+     */
+    dequeue() {
+        const {
+            next: t
+        } = this;
+        return this.next = t == null ? void 0 : t.next, t == null ? void 0 : t.value;
+    }
 }
 
-function Fg(e) {
-    const t = e.subqueries;
-    if (e.select) {
-        const i = e.from();
-        if (!i.length)
-            return;
-        if (t.length === 0)
-            return i[0].from.table;
+function zx(e, t) {
+    return e === t ? !1 : e instanceof Date && t instanceof Date ? +e != +t : Array.isArray(e) && Array.isArray(t) ? XL(e, t) : !0;
+}
+
+function XL(e, t) {
+    if (e.length !== t.length)
+        return !0;
+    for (let n = 0; n < e.length; ++n)
+        if (e[n] !== t[n])
+            return !0;
+    return !1;
+}
+
+function Oi(e) {
+    return e instanceof bs;
+}
+class bs extends YL {
+    /**
+     * Create a new Param instance.
+     * @param {*} value The initial value of the Param.
+     */
+    constructor(t) {
+        super(), this._value = t;
     }
-    const n = Fg(t[0]);
-    for (let i = 1; i < t.length; ++i) {
-        const r = Fg(t[i]);
-        if (r !== void 0 && r !== n)
-            return NaN;
+    /**
+     * Create a new Param instance with the given initial value.
+     * @param {*} value The initial value of the Param.
+     * @returns {Param} The new Param instance.
+     */
+    static value(t) {
+        return new bs(t);
+    }
+    /**
+     * Create a new Param instance over an array of initial values,
+     * which may contain nested Params.
+     * @param {*} values The initial values of the Param.
+     * @returns {Param} The new Param instance.
+     */
+    static array(t) {
+        if (t.some((n) => Oi(n))) {
+            const n = new bs(),
+                r = () => {
+                    n.update(t.map((i) => Oi(i) ? i.value : i));
+                };
+            return r(), t.forEach((i) => Oi(i) ? i.addEventListener("value", r) : 0), n;
+        }
+        return new bs(t);
+    }
+    /**
+     * The current value of the Param.
+     */
+    get value() {
+        return this._value;
+    }
+    /**
+     * Update the Param value
+     * @param {*} value The new value of the Param.
+     * @param {object} [options] The update options.
+     * @param {boolean} [options.force] A boolean flag indicating if the Param
+     *  should emit a 'value' event even if the internal value is unchanged.
+     * @returns {this} This Param instance.
+     */
+    update(t, {
+        force: n
+    } = {}) {
+        return zx(this._value, t) || n ? this.emit("value", t) : this.cancel("value"), this;
+    }
+    /**
+     * Upon value-typed updates, sets the current value to the input value
+     * immediately prior to the event value being emitted to listeners.
+     * @param {string} type The event type.
+     * @param {*} value The input event value.
+     * @returns {*} The input event value.
+     */
+    willEmit(t, n) {
+        return t === "value" && (this._value = n), n;
     }
-    return n;
 }
 
-function UU(e, t) {
-    const n = /* @__PURE__ */ new Set(),
-        i = (r) => {
-            n.has(r) || (n.add(r), r.select && r.from().length && r.select(t), r.subqueries.forEach(i));
-        };
-    i(e);
+function dr(e) {
+    return e instanceof _f;
 }
-class zU {
+let _f = class ho extends bs {
     /**
-     * @param {import('./Coordinator.js').Coordinator} coordinator The Mosaic coordinator.
-     * @param {*} selection The shared filter selection.
-     * @param {*} index Boolean flag or options hash for data cube indexer.
-     *  Falsy values disable indexing.
+     * Create a new Selection instance with an
+     * intersect (conjunction) resolution strategy.
+     * @param {object} [options] The selection options.
+     * @param {boolean} [options.cross=false] Boolean flag indicating
+     *  cross-filtered resolution. If true, selection clauses will not
+     *  be applied to the clients they are associated with.
+     * @returns {Selection} The new Selection instance.
      */
-    constructor(t, n, i = !0) {
-        this.mc = t, this.selection = n, this.clients = /* @__PURE__ */ new Set(), this.indexer = i ? new RU(this.mc, {
-            ...i,
-            selection: n
-        }) : null;
+    static intersect({
+        cross: t = !1
+    } = {}) {
+        return new ho(new Na({
+            cross: t
+        }));
+    }
+    /**
+     * Create a new Selection instance with a
+     * union (disjunction) resolution strategy.
+     * @param {object} [options] The selection options.
+     * @param {boolean} [options.cross=false] Boolean flag indicating
+     *  cross-filtered resolution. If true, selection clauses will not
+     *  be applied to the clients they are associated with.
+     * @returns {Selection} The new Selection instance.
+     */
+    static union({
+        cross: t = !1
+    } = {}) {
+        return new ho(new Na({
+            cross: t,
+            union: !0
+        }));
+    }
+    /**
+     * Create a new Selection instance with a singular resolution strategy
+     * that keeps only the most recent selection clause.
+     * @param {object} [options] The selection options.
+     * @param {boolean} [options.cross=false] Boolean flag indicating
+     *  cross-filtered resolution. If true, selection clauses will not
+     *  be applied to the clients they are associated with.
+     * @returns {Selection} The new Selection instance.
+     */
+    static single({
+        cross: t = !1
+    } = {}) {
+        return new ho(new Na({
+            cross: t,
+            single: !0
+        }));
+    }
+    /**
+     * Create a new Selection instance with a
+     * cross-filtered intersect resolution strategy.
+     * @returns {Selection} The new Selection instance.
+     */
+    static crossfilter() {
+        return new ho(new Na({
+            cross: !0
+        }));
+    }
+    /**
+     * Create a new Selection instance.
+     * @param {SelectionResolver} resolver The selection resolution
+     *  strategy to apply.
+     */
+    constructor(t = new Na()) {
+        super([]), this._resolved = this._value, this._resolver = t;
+    }
+    /**
+     * Create a cloned copy of this Selection instance.
+     * @returns {Selection} A clone of this selection.
+     */
+    clone() {
+        const t = new ho(this._resolver);
+        return t._value = t._resolved = this._value, t;
+    }
+    /**
+     * Create a clone of this Selection with clauses corresponding
+     * to the provided source removed.
+     * @param {*} source The clause source to remove.
+     * @returns {Selection} A cloned and updated Selection.
+     */
+    remove(t) {
+        const n = this.clone();
+        return n._value = n._resolved = n._resolver.resolve(this._resolved, {
+            source: t
+        }), n._value.active = {
+            source: t
+        }, n;
+    }
+    /**
+     * The selection clause resolver.
+     */
+    get resolver() {
+        return this._resolver;
+    }
+    /**
+     * Indicate if this selection has a single resolution strategy.
+     */
+    get single() {
+        return this._resolver.single;
+    }
+    /**
+     * The current array of selection clauses.
+     */
+    get clauses() {
+        return super.value;
+    }
+    /**
+     * The current active (most recently updated) selection clause.
+     */
+    get active() {
+        return this.clauses.active;
+    }
+    /**
+     * The value corresponding to the current active selection clause.
+     * This method ensures compatibility where a normal Param is expected.
+     */
+    get value() {
+        var t;
+        return (t = this.active) == null ? void 0 : t.value;
+    }
+    /**
+     * The value corresponding to a given source. Returns undefined if
+     * this selection does not include a clause from this source.
+     * @param {*} source The clause source to look up the value for.
+     */
+    valueFor(t) {
+        var n;
+        return (n = this.clauses.find((r) => r.source === t)) == null ? void 0 : n.value;
+    }
+    /**
+     * Emit an activate event with the given selection clause.
+     * @param {*} clause The clause repesenting the potential activation.
+     */
+    activate(t) {
+        this.emit("activate", t);
+    }
+    /**
+     * Update the selection with a new selection clause.
+     * @param {*} clause The selection clause to add.
+     * @returns {this} This Selection instance.
+     */
+    update(t) {
+        return this._resolved = this._resolver.resolve(this._resolved, t, !0), this._resolved.active = t, super.update(this._resolved);
+    }
+    /**
+     * Upon value-typed updates, sets the current clause list to the
+     * input value and returns the active clause value.
+     * @param {string} type The event type.
+     * @param {*} value The input event value.
+     * @returns {*} For value-typed events, returns the active clause
+     *  values. Otherwise returns the input event value as-is.
+     */
+    willEmit(t, n) {
+        return t === "value" ? (this._value = n, this.value) : n;
+    }
+    /**
+     * Upon value-typed updates, returns a dispatch queue filter function.
+     * The return value depends on the selection resolution strategy.
+     * @param {string} type The event type.
+     * @param {*} value The new event value that will be enqueued.
+     * @returns {(value: *) => boolean|null} For value-typed events,
+     *  returns a dispatch queue filter function. Otherwise returns null.
+     */
+    emitQueueFilter(t, n) {
+        return t === "value" ? this._resolver.queueFilter(n) : null;
+    }
+    /**
+     * Indicates if a selection clause should not be applied to a given client.
+     * The return value depends on the selection resolution strategy.
+     * @param {*} client The selection clause.
+     * @param {*} clause The client to test.
+     * @returns True if the client should be skipped, false otherwise.
+     */
+    skip(t, n) {
+        return this._resolver.skip(t, n);
+    }
+    /**
+     * Return a selection query predicate for the given client.
+     * @param {*} client The client whose data may be filtered.
+     * @param {boolean} [noSkip=false] Disable skipping of active
+     *  cross-filtered sources. If set true, the source of the active
+     *  clause in a cross-filtered selection will not be skipped.
+     * @returns {*} The query predicate for filtering client data,
+     *  based on the current state of this selection.
+     */
+    predicate(t, n = !1) {
         const {
-            value: r,
+            clauses: r
+        } = this, i = n ? null : r.active;
+        return this._resolver.predicate(r, i, t);
+    }
+};
+class Na {
+    /**
+     * Create a new selection resolved instance.
+     * @param {object} [options] The resolution strategy options.
+     * @param {boolean} [options.union=false] Boolean flag to indicate a union strategy.
+     *  If false, an intersection strategy is used.
+     * @param {boolean} [options.cross=false] Boolean flag to indicate cross-filtering.
+     * @param {boolean} [options.single=false] Boolean flag to indicate single clauses only.
+     */
+    constructor({
+        union: t,
+        cross: n,
+        single: r
+    } = {}) {
+        this.union = !!t, this.cross = !!n, this.single = !!r;
+    }
+    /**
+     * Resolve a list of selection clauses according to the resolution strategy.
+     * @param {*[]} clauseList An array of selection clauses.
+     * @param {*} clause A new selection clause to add.
+     * @returns {*[]} An updated array of selection clauses.
+     */
+    resolve(t, n, r = !1) {
+        const {
+            source: i,
+            predicate: s
+        } = n, o = t.filter((c) => i !== c.source), a = this.single ? [] : o;
+        return this.single && r && o.forEach((c) => {
+            var u, l;
+            return (l = (u = c.source) == null ? void 0 : u.reset) == null ? void 0 : l.call(u);
+        }), s && a.push(n), a;
+    }
+    /**
+     * Indicates if a selection clause should not be applied to a given client.
+     * The return value depends on the resolution strategy.
+     * @param {*} client The selection clause.
+     * @param {*} clause The client to test.
+     * @returns True if the client should be skipped, false otherwise.
+     */
+    skip(t, n) {
+        var r;
+        return this.cross && ((r = n == null ? void 0 : n.clients) == null ? void 0 : r.has(t));
+    }
+    /**
+     * Return a selection query predicate for the given client.
+     * @param {*[]} clauseList An array of selection clauses.
+     * @param {*} active The current active selection clause.
+     * @param {*} client The client whose data may be filtered.
+     * @returns {*} The query predicate for filtering client data,
+     *  based on the current state of this selection.
+     */
+    predicate(t, n, r) {
+        const {
+            union: i
+        } = this;
+        if (this.skip(r, n))
+            return;
+        const s = t.filter((o) => !this.skip(r, o)).map((o) => o.predicate);
+        return i && s.length > 1 ? hm(s) : s;
+    }
+    /**
+     * Returns a filter function for queued selection updates.
+     * @param {*} value The new event value that will be enqueued.
+     * @returns {(value: *) => boolean|null} A dispatch queue filter
+     *  function, or null if all unemitted event values should be filtered.
+     */
+    queueFilter(t) {
+        var n;
+        if (this.cross) {
+            const r = (n = t.active) == null ? void 0 : n.source;
+            return (i) => {
+                var s;
+                return ((s = i.active) == null ? void 0 : s.source) !== r;
+            };
+        }
+        return null;
+    }
+}
+class GL {
+    /**
+     * @param {Coordinator} coordinator The Mosaic coordinator.
+     * @param {Selection} selection The shared filter selection.
+     * @param {object|boolean} index Boolean flag or options hash for
+     *  a data cube indexer. Falsy values disable indexing.
+     */
+    constructor(t, n, r = !0) {
+        this.mc = t, this.selection = n, this.clients = /* @__PURE__ */ new Set(), this.indexer = null, this.index(r);
+        const {
+            value: i,
             activate: s
         } = this.handlers = {
             value: () => this.update(),
             activate: (o) => {
                 var a;
-                return (a = this.indexer) == null ? void 0 : a.index(this.clients, o);
+                (a = this.indexer) == null || a.index(this.clients, o);
             }
         };
-        n.addEventListener("value", r), n.addEventListener("activate", s);
+        n.addEventListener("value", i), n.addEventListener("activate", s);
     }
     finalize() {
         const {
             value: t,
             activate: n
         } = this.handlers;
         this.selection.removeEventListener("value", t), this.selection.removeEventListener("activate", n);
     }
+    index(t) {
+        const {
+            selection: n
+        } = this, {
+            resolver: r
+        } = n;
+        this.indexer = t && (r.single || !r.union) ? new UL(this.mc, {
+            ...t,
+            selection: n
+        }) : null;
+    }
     reset() {
         var t;
         (t = this.indexer) == null || t.reset();
     }
     add(t) {
         return (this.clients = new Set(this.clients)).add(t), this;
     }
     remove(t) {
         return this.clients.has(t) && (this.clients = new Set(this.clients)).delete(t), this;
     }
+    /**
+     * Internal method to process a selection update.
+     * The return value is passed as a selection callback value.
+     * @returns {Promise} A Promise that resolves when the update completes.
+     */
     update() {
         const {
             mc: t,
             indexer: n,
-            clients: i,
-            selection: r
+            clients: r,
+            selection: i
         } = this;
-        return n != null && n.index(i) ? n.update() : PU(t, i, r);
+        return (n == null ? void 0 : n.index(r)) ? n.update() : HL(t, r, i);
     }
 }
 
-function PU(e, t, n) {
-    return Promise.all(Array.from(t).map((i) => {
-        const r = n.predicate(i);
-        if (r != null)
-            return e.updateClient(i, i.query(r));
+function HL(e, t, n) {
+    return Promise.all(Array.from(t).map((r) => {
+        const i = n.predicate(r);
+        if (i != null)
+            return e.updateClient(r, r.query(i));
     }));
 }
 
-function HM() {
+function qx() {
     let e, t;
-    const n = new Promise((i, r) => {
-        e = i, t = r;
+    const n = new Promise((r, i) => {
+        e = r, t = i;
+    });
+    return Object.assign(n, {
+        fulfill: (r) => (e(r), n),
+        reject: (r) => (t(r), n)
     });
-    return n.fulfill = (i) => (e(i), n), n.reject = (i) => (t(i), n), n;
 }
 
-function VU(e) {
+function JL(e) {
     return (typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : setTimeout)(e);
 }
 
-function jU(e, t, n) {
-    let i = [],
-        r = 0;
+function ZL(e, t, n) {
+    let r = [],
+        i = 0;
 
     function s() {
-        const o = qU(i, t);
-        i = [], r = 0;
+        const o = KL(r, t);
+        r = [], i = 0;
         for (const a of o)
-            WU(a, e, n), HU(a, t);
+            tk(a, e, n), rk(a, t);
     }
     return {
         add(o, a) {
-            o.request.type === "arrow" ? (r = r || VU(() => s()), i.push({
+            o.request.type === "arrow" ? (i = i || JL(() => s()), r.push({
                 entry: o,
                 priority: a,
-                index: i.length
+                index: r.length
             })) : e(o, a);
         }
     };
 }
 
-function qU(e, t) {
+function KL(e, t) {
     const n = [],
-        i = /* @__PURE__ */ new Map();
-    for (const r of e) {
+        r = /* @__PURE__ */ new Map();
+    for (const i of e) {
         const {
             entry: {
                 request: s
             }
-        } = r, o = YU(s.query, t);
-        if (!i.has(o)) {
+        } = i, o = QL(s.query, t);
+        if (!r.has(o)) {
             const a = [];
-            n.push(a), i.set(o, a);
+            n.push(a), r.set(o, a);
         }
-        i.get(o).push(r);
+        r.get(o).push(i);
     }
     return n;
 }
 
-function YU(e, t) {
+function QL(e, t) {
     const n = `${e}`;
-    if (e instanceof Lt && !t.get(n)) {
-        if (e.orderby().length || e.where().length || e.qualify().length || e.having().length)
+    if (e instanceof xt && !t.get(n)) {
+        if (
+            // @ts-ignore
+            e.orderby().length || e.where().length || // @ts-ignore
+            e.qualify().length || e.having().length
+        )
             return n;
-        const i = e.clone().$select("*"),
-            r = e.groupby();
-        if (r.length) {
+        const r = e.clone().$select("*"),
+            i = e.groupby();
+        if (i.length) {
             const s = {};
             e.select().forEach(({
                 as: o,
                 expr: a
-            }) => s[o] = a), i.$groupby(r.map((o) => o instanceof js && s[o.column] || o));
+            }) => s[o] = a), r.$groupby(i.map((o) => o instanceof Fi && s[o.column] || o));
         }
-        return `${i}`;
+        return `${r}`;
     } else
         return n;
 }
 
-function WU(e, t, n) {
-    if (GU(e))
+function tk(e, t, n) {
+    if (ek(e))
         t({
             request: {
                 type: "arrow",
                 cache: !1,
                 record: !1,
-                query: e.query = XU(e, n)
+                query: e.query = nk(e, n)
             },
-            result: e.result = HM()
+            result: e.result = qx()
         });
     else
         for (const {
-                entry: i,
-                priority: r
+                entry: r,
+                priority: i
             }
             of e)
-            t(i, r);
+            t(r, i);
 }
 
-function GU(e) {
+function ek(e) {
     if (e.length > 1) {
         const t = `${e[0].entry.request.query}`;
         for (let n = 1; n < e.length; ++n)
             if (t !== `${e[n].entry.request.query}`)
                 return !0;
     }
     return !1;
 }
 
-function XU(e, t) {
+function nk(e, t) {
     const n = e.maps = [],
-        i = /* @__PURE__ */ new Map();
+        r = /* @__PURE__ */ new Map();
     for (const o of e) {
         const {
             query: a
         } = o.entry.request, c = [];
         n.push(c);
         for (const {
-                as: l,
-                expr: u
+                as: u,
+                expr: l
             }
             of a.select()) {
-            const f = `${u}`;
-            i.has(f) || i.set(f, [`col${i.size}`, u]);
-            const [h] = i.get(f);
-            c.push([h, l]);
+            const f = `${l}`;
+            r.has(f) || r.set(f, [`col${r.size}`, l]);
+            const [h] = r.get(f);
+            c.push([h, u]);
         }
         t(`${a}`);
     }
-    const r = e[0].entry.request.query.clone(),
-        s = r.groupby();
+    const i = e[0].entry.request.query.clone(),
+        s = i.groupby();
     if (s.length) {
         const o = {};
-        e.maps[0].forEach(([a, c]) => o[c] = a), r.$groupby(s.map((a) => a instanceof js && o[a.column] || a));
+        e.maps[0].forEach(([a, c]) => o[c] = a), i.$groupby(s.map((a) => a instanceof Fi && o[a.column] || a));
     }
-    return r.$select(Array.from(i.values()));
+    return i.$select(Array.from(r.values()));
 }
-async function HU(e, t) {
+async function rk(e, t) {
     const {
         maps: n,
-        query: i,
-        result: r
+        query: r,
+        result: i
     } = e;
     if (!n)
         return;
     let s;
     try {
-        s = await r;
+        s = await i;
     } catch (a) {
         for (const {
                 entry: c
             }
             of e)
             c.result.reject(a);
         return;
     }
-    const o = wU(i);
+    const o = wL(r);
     e.forEach(({
         entry: a
     }, c) => {
         const {
-            request: l,
-            result: u
-        } = a, f = n[c], h = o && f ? KU(s, f) : f ? JU(s, f) : s;
-        l.cache && t.set(String(l.query), h), u.fulfill(h);
+            request: u,
+            result: l
+        } = a, f = n[c], h = o && f ? sk(s, f) : f ? ik(s, f) : s;
+        u.cache && t.set(String(u.query), h), l.fulfill(h);
     });
 }
 
-function JU(e, t) {
+function ik(e, t) {
     const n = {};
-    for (const [i, r] of t)
-        n[r] = e.getChild(i);
+    for (const [r, i] of t)
+        n[i] = e.getChild(r);
     return new e.constructor(n);
 }
 
-function KU(e, t) {
+function sk(e, t) {
     const n = new Map(t),
-        i = [];
-    for (const r of e)
-        n.has(r.column_name) && i.push({
-            ...r,
-            column_name: n.get(r.column_name)
+        r = [];
+    for (const i of e)
+        n.has(i.column_name) && r.push({
+            ...i,
+            column_name: n.get(i.column_name)
         });
-    return i;
+    return r;
 }
-const ZU = typeof requestIdleCallback < "u" ? requestIdleCallback : setTimeout,
-    QU = () => ({
+const ok = typeof requestIdleCallback < "u" ? requestIdleCallback : setTimeout,
+    ak = () => ({
         get: () => {},
         set: (e, t) => t,
         clear: () => {}
     });
 
-function tz({
+function ck({
     max: e = 1e3,
     // max entries
     ttl: t = 3 * 60 * 60 * 1e3
     // time-to-live, default 3 hours
 } = {}) {
     let n = /* @__PURE__ */ new Map();
 
-    function i() {
-        const r = performance.now() - t;
+    function r() {
+        const i = performance.now() - t;
         let s = null,
             o = 1 / 0;
         for (const [a, c] of n) {
             const {
-                last: l
+                last: u
             } = c;
-            l < o && (s = a, o = l), r > l && n.delete(a);
+            u < o && (s = a, o = u), i > u && n.delete(a);
         }
         s && n.delete(s);
     }
     return {
-        get(r) {
-            const s = n.get(r);
+        get(i) {
+            const s = n.get(i);
             if (s)
                 return s.last = performance.now(), s.value;
         },
-        set(r, s) {
-            return n.set(r, {
+        set(i, s) {
+            return n.set(i, {
                 last: performance.now(),
                 value: s
-            }), n.size > e && ZU(i), s;
+            }), n.size > e && ok(r), s;
         },
         clear() {
             n = /* @__PURE__ */ new Map();
         }
     };
 }
 
-function ez(e) {
+function uk(e) {
     const t = Array.from({
             length: e
         },
         () => ({
             head: null,
             tail: null
         })
@@ -10626,169 +11576,170 @@
         /**
          * Insert an item into the queue with a given priority rank.
          * @param {*} item The item to add.
          * @param {number} rank The integer priority rank.
          *  Priority ranks are integers starting at zero.
          *  Lower ranks indicate higher priority.
          */
-        insert(n, i) {
-            const r = t[i];
-            if (!r)
-                throw new Error(`Invalid queue priority rank: ${i}`);
+        insert(n, r) {
+            const i = t[r];
+            if (!i)
+                throw new Error(`Invalid queue priority rank: ${r}`);
             const s = {
                 item: n,
                 next: null
             };
-            r.head === null ? r.head = r.tail = s : r.tail = r.tail.next = s;
+            i.head === null ? i.head = i.tail = s : i.tail = i.tail.next = s;
         },
         /**
          * Remove a set of items from the queue, regardless of priority rank.
          * If a provided item is not in the queue it will be ignored.
          * @param {(item: *) => boolean} test A predicate function to test
          * 	if an item should be removed (true to drop, false to keep).
          */
         remove(n) {
-            for (const i of t) {
+            for (const r of t) {
                 let {
-                    head: r,
+                    head: i,
                     tail: s
-                } = i;
-                for (let o = null, a = r; a; o = a, a = a.next)
-                    n(a.item) && (a === r ? r = a.next : o.next = a.next, a === s && (s = o || r));
-                i.head = r, i.tail = s;
+                } = r;
+                for (let o = null, a = i; a; o = a, a = a.next)
+                    n(a.item) && (a === i ? i = a.next : o.next = a.next, a === s && (s = o || i));
+                r.head = i, r.tail = s;
             }
         },
         /**
          * Remove and return the next highest priority item.
          * @returns {*} The next item in the queue,
          *  or undefined if this queue is empty.
          */
         next() {
             for (const n of t) {
                 const {
-                    head: i
+                    head: r
                 } = n;
-                if (i !== null)
-                    return n.head = i.next, n.tail === i && (n.tail = null), i.item;
+                if (r !== null)
+                    return n.head = r.next, n.tail === r && (n.tail = null), r.item;
             }
         }
     };
 }
-const Ms = {
+const _i = {
     High: 0,
     Normal: 1,
     Low: 2
 };
-
-function nz() {
-    const e = ez(3);
-    let t, n, i, r = [],
-        s = null,
-        o;
-
-    function a() {
-        if (s || e.isEmpty())
+class lk {
+    constructor() {
+        this.queue = uk(3), this.db = null, this.clientCache = null, this._logger = null, this._logQueries = !1, this.recorders = [], this.pending = null, this._consolidate = null;
+    }
+    next() {
+        if (this.pending || this.queue.isEmpty())
             return;
         const {
-            request: f,
-            result: h
-        } = e.next();
-        s = u(f, h), s.finally(() => {
-            s = null, a();
+            request: t,
+            result: n
+        } = this.queue.next();
+        this.pending = this.submit(t, n), this.pending.finally(() => {
+            this.pending = null, this.next();
         });
     }
-
-    function c(f, h = Ms.Normal) {
-        e.insert(f, h), a();
+    enqueue(t, n = _i.Normal) {
+        this.queue.insert(t, n), this.next();
     }
-
-    function l(f) {
-        r.length && f && r.forEach((h) => h.add(f));
+    recordQuery(t) {
+        this.recorders.length && t && this.recorders.forEach((n) => n.add(t));
     }
-    async function u(f, h) {
+    async submit(t, n) {
         try {
             const {
-                query: d,
-                type: p,
-                cache: m = !1,
-                record: g = !0,
-                options: y
-            } = f, b = d ? `${d}` : null;
-            if (g && l(b), m) {
-                const x = n.get(b);
-                if (x) {
-                    i.debug("Cache"), h.fulfill(x);
+                query: r,
+                type: i,
+                cache: s = !1,
+                record: o = !0,
+                options: a
+            } = t, c = r ? `${r}` : null;
+            if (o && this.recordQuery(c), s) {
+                const f = this.clientCache.get(c);
+                if (f) {
+                    this._logger.debug("Cache"), n.fulfill(f);
                     return;
                 }
             }
-            const w = performance.now(),
-                v = await t.query({
-                    type: p,
-                    sql: b,
-                    ...y
-                });
-            m && n.set(b, v), i.debug(`Request: ${(performance.now() - w).toFixed(1)}`), h.fulfill(v);
-        } catch (d) {
-            h.reject(d);
+            const u = performance.now();
+            this._logQueries && this._logger.debug("Query", {
+                type: i,
+                sql: c,
+                ...a
+            });
+            const l = await this.db.query({
+                type: i,
+                sql: c,
+                ...a
+            });
+            s && this.clientCache.set(c, l), this._logger.debug(`Request: ${(performance.now() - u).toFixed(1)}`), n.fulfill(l);
+        } catch (r) {
+            n.reject(r);
         }
     }
-    return {
-        cache(f) {
-            return f !== void 0 ? n = f === !0 ? tz() : f || QU() : n;
-        },
-        logger(f) {
-            return f ? i = f : i;
-        },
-        connector(f) {
-            return f ? t = f : t;
-        },
-        consolidate(f) {
-            f && !o ? o = jU(c, n, l) : !f && o && (o = null);
-        },
-        request(f, h = Ms.Normal) {
-            const d = HM(),
-                p = {
-                    request: f,
-                    result: d
-                };
-            return o ? o.add(p, h) : c(p, h), d;
-        },
-        cancel(f) {
-            const h = new Set(f);
-            e.remove(({
-                result: d
-            }) => h.has(d));
-        },
-        clear() {
-            e.remove(({
-                result: f
-            }) => (f.reject("Cleared"), !0));
-        },
-        record() {
-            let f = [];
-            const h = {
-                add(d) {
-                    f.push(d);
-                },
-                reset() {
-                    f = [];
-                },
-                snapshot() {
-                    return f.slice();
-                },
-                stop() {
-                    return r = r.filter((d) => d !== h), f;
-                }
+    cache(t) {
+        return t !== void 0 ? this.clientCache = t === !0 ? ck() : t || ak() : this.clientCache;
+    }
+    logger(t) {
+        return t ? this._logger = t : this._logger;
+    }
+    logQueries(t) {
+        return t !== void 0 ? this._logQueries = !!t : this._logQueries;
+    }
+    connector(t) {
+        return t ? this.db = t : this.db;
+    }
+    consolidate(t) {
+        t && !this._consolidate ? this._consolidate = ZL(this.enqueue.bind(this), this.clientCache, this.recordQuery.bind(this)) : !t && this._consolidate && (this._consolidate = null);
+    }
+    request(t, n = _i.Normal) {
+        const r = qx(),
+            i = {
+                request: t,
+                result: r
             };
-            return r.push(h), h;
-        }
-    };
+        return this._consolidate ? this._consolidate.add(i, n) : this.enqueue(i, n), r;
+    }
+    cancel(t) {
+        const n = new Set(t);
+        this.queue.remove(({
+            result: r
+        }) => n.has(r));
+    }
+    clear() {
+        this.queue.remove(({
+            result: t
+        }) => (t.reject("Cleared"), !0));
+    }
+    record() {
+        let t = [];
+        const n = {
+            add(r) {
+                t.push(r);
+            },
+            reset() {
+                t = [];
+            },
+            snapshot() {
+                return t.slice();
+            },
+            stop() {
+                return this.recorders = this.recorders.filter((r) => r !== n), t;
+            }
+        };
+        return this.recorders.push(n), n;
+    }
 }
 
-function JM(e) {
+function jx(e) {
     switch (e) {
         case "BIGINT":
         case "HUGEINT":
         case "INTEGER":
         case "SMALLINT":
         case "TINYINT":
         case "UBIGINT":
@@ -10806,14 +11757,15 @@
         case "TIME":
         case "TIMESTAMP_NS":
             return "date";
         case "BOOLEAN":
             return "boolean";
         case "VARCHAR":
         case "UUID":
+        case "JSON":
             return "string";
         case "ARRAY":
         case "LIST":
             return "array";
         case "BLOB":
         case "STRUCT":
         case "MAP":
@@ -10825,2552 +11777,2163 @@
             if (e.startsWith("STRUCT") || e.startsWith("MAP"))
                 return "object";
             if (e.endsWith("]"))
                 return "array";
             throw new Error(`Unsupported type: ${e}`);
     }
 }
-const Cb = 2,
-    iz = 3,
-    kb = 7,
-    KM = 10;
 
-function Ub(e) {
+function fk(e) {
     return typeof(e == null ? void 0 : e.getChild) == "function";
 }
 
-function rz(e) {
-    switch (e.typeId) {
-        case Cb:
-        case iz:
-        case kb:
-            return Float64Array;
-        default:
-            return Array;
-    }
-}
-
-function ZM(e) {
-    const {
-        typeId: t
-    } = e;
-    if (t === KM)
-        return (n) => n == null ? n : new Date(n);
-    if (t === Cb && e.bitWidth >= 64)
-        return (n) => n == null ? n : Number(n);
-    if (t === kb) {
-        const n = 1 / Math.pow(10, e.scale);
-        return (i) => i == null ? i : QM(i, n);
+function hk(e) {
+    if (Q.isTimestamp(e))
+        return (t) => t == null ? t : new Date(t);
+    if (Q.isInt(e) && e.bitWidth >= 64)
+        return (t) => t == null ? t : Number(t);
+    if (Q.isDecimal(e)) {
+        const t = 1 / Math.pow(10, e.scale);
+        return (n) => n == null ? n : Vx(n, t);
     }
-    return (n) => n;
+    return (t) => t;
 }
 
-function Gd(e) {
+function dk(e) {
     const {
         type: t
-    } = e, {
-        typeId: n
-    } = t;
-    if (n === KM) {
-        const i = e.length,
-            r = new Array(i);
-        for (let s = 0; s < i; ++s) {
-            const o = e.get(s);
-            r[s] = o == null ? null : new Date(o);
+    } = e;
+    if (Q.isTimestamp(t)) {
+        const n = e.length,
+            r = new Array(n);
+        for (let i = 0; i < n; ++i) {
+            const s = e.get(i);
+            r[i] = s == null ? null : new Date(s);
         }
         return r;
     }
-    if (n === Cb && t.bitWidth >= 64) {
-        const i = e.length,
-            r = new Float64Array(i);
-        for (let s = 0; s < i; ++s) {
-            const o = e.get(s);
-            r[s] = o == null ? NaN : Number(o);
+    if (Q.isInt(t) && t.bitWidth >= 64) {
+        const n = e.length,
+            r = e.nullCount ? new Array(n) : new Float64Array(n);
+        for (let i = 0; i < n; ++i) {
+            const s = e.get(i);
+            r[i] = s == null ? null : Number(s);
         }
         return r;
     }
-    if (n === kb) {
-        const i = 1 / Math.pow(10, t.scale),
+    if (Q.isDecimal(t)) {
+        const n = 1 / Math.pow(10, t.scale),
             r = e.length,
-            s = new Float64Array(r);
-        for (let o = 0; o < r; ++o) {
-            const a = e.get(o);
-            s[o] = a == null ? NaN : QM(a, i);
+            i = e.nullCount ? new Array(r) : new Float64Array(r);
+        for (let s = 0; s < r; ++s) {
+            const o = e.get(s);
+            i[s] = o == null ? null : Vx(o, n);
         }
-        return s;
+        return i;
     }
-    return e.toArray();
+    return e.nullCount ? Array.from(e) : e.toArray();
 }
-const u2 = Array.from({
+const $b = Array.from({
         length: 8
     },
     (e, t) => Math.pow(2, t * 32)
 );
 
-function QM(e, t) {
+function Vx(e, t) {
     const n = e.length;
-    let i = 0;
+    let r = 0;
     if (e.signed && (e[n - 1] | 0) < 0) {
-        for (let r = 0; r < n; ++r)
-            i += ~e[r] * u2[r];
-        i = -(i + 1);
+        for (let i = 0; i < n; ++i)
+            r += ~e[i] * $b[i];
+        r = -(r + 1);
     } else
-        for (let r = 0; r < n; ++r)
-            i += e[r] * u2[r];
-    return i * t;
-}
-const sz = "count",
-    oz = "nulls",
-    az = "max",
-    cz = "min",
-    lz = "distinct",
-    uz = {
-        [sz]: ko,
-        [lz]: (e) => ko(e).distinct(),
-        [az]: $c,
-        [cz]: Tc,
-        [oz]: (e) => ko().where(Fb(e))
+        for (let i = 0; i < n; ++i)
+            r += e[i] * $b[i];
+    return r * t;
+}
+const pk = "count",
+    yk = "nulls",
+    mk = "max",
+    gk = "min",
+    bk = "distinct",
+    wk = {
+        [pk]: Di,
+        [bk]: (e) => Di(e).distinct(),
+        [mk]: jo,
+        [gk]: Vo,
+        [yk]: (e) => Di().where(dm(e))
     };
 
-function fz(e, t, n) {
-    return Lt.from(e).select(Array.from(n, (i) => [i, uz[i](t)]));
+function vk(e, t, n) {
+    return xt.from(e).select(Array.from(n, (r) => [r, wk[r](t)]));
 }
-async function hz(e, t) {
-    return t.length === 1 && `${t[0].column}` == "*" ? pz(e, t[0].table) : (await Promise.all(t.map((n) => dz(e, n)))).filter((n) => n);
+async function _k(e, t) {
+    return t.length === 1 && `${t[0].column}` == "*" ? Sk(e, t[0].table) : (await Promise.all(t.map((n) => xk(e, n)))).filter((n) => n);
 }
-async function dz(e, {
+async function xk(e, {
     table: t,
     column: n,
-    stats: i
+    stats: r
 }) {
-    const r = Lt.from({
+    const i = xt.from({
             source: t
         }).select({
             column: n
-        }).groupby(n.aggregate ? q`ALL` : []),
-        [s] = Array.from(await e.query(Lt.describe(r))),
+        }).groupby(n.aggregate ? j`ALL` : []),
+        [s] = Array.from(await e.query(xt.describe(i))),
         o = {
             table: t,
             column: `${n}`,
             sqlType: s.column_type,
-            type: JM(s.column_type),
+            type: jx(s.column_type),
             nullable: s.null === "YES"
         };
-    if (!(i != null && i.length || i != null && i.size))
+    if (!(r != null && r.length || r != null && r.size))
         return o;
     const a = await e.query(
-        fz(t, n, i), {
+        vk(t, n, r), {
             persist: !0
         }
     );
     for (let c = 0; c < a.numCols; ++c) {
         const {
-            name: l
-        } = a.schema.fields[c], u = a.getChildAt(c), f = ZM(u.type);
-        o[l] = f(u.get(0));
+            name: u
+        } = a.schema.fields[c], l = a.getChildAt(c), f = hk(l.type);
+        o[u] = f(l.get(0));
     }
     return o;
 }
-async function pz(e, t) {
-    const n = await e.query(`DESCRIBE ${Jh(t)}`);
-    return Array.from(n).map((i) => ({
+async function Sk(e, t) {
+    const n = await e.query(`DESCRIBE ${El(t)}`);
+    return Array.from(n).map((r) => ({
         table: t,
-        column: i.column_name,
-        sqlType: i.column_type,
-        type: JM(i.column_type),
-        nullable: i.null === "YES"
+        column: r.column_name,
+        sqlType: r.column_type,
+        type: jx(r.column_type),
+        nullable: r.null === "YES"
     }));
 }
 
-function yz() {
+function Mk() {
     return {
         debug() {},
         info() {},
         log() {},
         warn() {},
         error() {}
     };
 }
-let sh;
+let Vu;
 
 function Wr(e) {
-    return e ? sh = e : sh == null && (sh = new mz()), sh;
+    return e ? Vu = e : Vu == null && (Vu = new Ak()), Vu;
 }
-class mz {
-    constructor(t = f9(), n = {}) {
+class Ak {
+    constructor(t = hO(), n = {}) {
         const {
-            logger: i = console,
-            manager: r = nz()
+            logger: r = console,
+            manager: i = new lk()
         } = n;
-        this.manager = r, this.logger(i), this.configure(n), this.databaseConnector(t), this.clear();
+        this.manager = i, this.logger(r), this.configure(n), this.databaseConnector(t), this.clear();
     }
     logger(t) {
-        return arguments.length && (this._logger = t || yz(), this.manager.logger(this._logger)), this._logger;
+        return arguments.length && (this._logger = t || Mk(), this.manager.logger(this._logger)), this._logger;
     }
+    /**
+     * Set configuration options for this coordinator.
+     * @param {object} [options] Configration options.
+     * @param {boolean} [options.cache=true] Boolean flag to enable/disable query caching.
+     * @param {boolean} [options.consolidate=true] Boolean flag to enable/disable query consolidation.
+     * @param {boolean|object} [options.indexes=true] Boolean flag to enable/disable
+     *  automatic data cube indexes or an index options object.
+     */
     configure({
         cache: t = !0,
         consolidate: n = !0,
-        indexes: i = !0
-    }) {
-        this.manager.cache(t), this.manager.consolidate(n), this.indexes = i;
+        indexes: r = !0
+    } = {}) {
+        this.manager.cache(t), this.manager.consolidate(n), this.indexes = r;
     }
     clear({
         clients: t = !0,
         cache: n = !0
     } = {}) {
-        var i, r;
-        this.manager.clear(), t && ((i = this.clients) == null || i.forEach((s) => this.disconnect(s)), (r = this.filterGroups) == null || r.forEach((s) => s.finalize()), this.clients = /* @__PURE__ */ new Set(), this.filterGroups = /* @__PURE__ */ new Map()), n && this.manager.cache().clear();
+        var r, i;
+        this.manager.clear(), t && ((r = this.clients) == null || r.forEach((s) => this.disconnect(s)), (i = this.filterGroups) == null || i.forEach((s) => s.finalize()), this.clients = /* @__PURE__ */ new Set(), this.filterGroups = /* @__PURE__ */ new Map()), n && this.manager.cache().clear();
     }
     databaseConnector(t) {
         return this.manager.connector(t);
     }
     // -- Query Management ----
     cancel(t) {
         this.manager.cancel(t);
     }
     exec(t, {
-        priority: n = Ms.Normal
+        priority: n = _i.Normal
     } = {}) {
         return t = Array.isArray(t) ? t.join(`;
 `) : t, this.manager.request({
             type: "exec",
             query: t
         }, n);
     }
     query(t, {
         type: n = "arrow",
-        cache: i = !0,
-        priority: r = Ms.Normal,
+        cache: r = !0,
+        priority: i = _i.Normal,
         ...s
     } = {}) {
         return this.manager.request({
             type: n,
             query: t,
-            cache: i,
+            cache: r,
             options: s
-        }, r);
+        }, i);
     }
     prefetch(t, n = {}) {
         return this.query(t, {
             ...n,
             cache: !0,
-            priority: Ms.Low
+            priority: _i.Low
         });
     }
-    createBundle(t, n, i = Ms.Low) {
-        const r = {
+    createBundle(t, n, r = _i.Low) {
+        const i = {
             name: t,
             queries: n
         };
         return this.manager.request({
             type: "create-bundle",
-            options: r
-        }, i);
+            options: i
+        }, r);
     }
-    loadBundle(t, n = Ms.High) {
-        const i = {
+    loadBundle(t, n = _i.High) {
+        const r = {
             name: t
         };
         return this.manager.request({
             type: "load-bundle",
-            options: i
+            options: r
         }, n);
     }
     // -- Client Management ----
-    updateClient(t, n, i = Ms.Normal) {
+    updateClient(t, n, r = _i.Normal) {
         return t.queryPending(), this.query(n, {
-            priority: i
+            priority: r
         }).then(
-            (r) => t.queryResult(r).update(),
-            (r) => {
-                t.queryError(r), this._logger.error(r);
+            (i) => t.queryResult(i).update(),
+            (i) => {
+                t.queryError(i), this._logger.error(i);
             }
         );
     }
     requestQuery(t, n) {
-        var i;
-        return (i = this.filterGroups.get(t.filterBy)) == null || i.reset(), n ? this.updateClient(t, n) : t.update();
+        var r;
+        return (r = this.filterGroups.get(t.filterBy)) == null || r.reset(), n ? this.updateClient(t, n) : t.update();
     }
     /**
      * Connect a client to the coordinator.
-     *
      * @param {import('./MosaicClient.js').MosaicClient} client the client to disconnect
      */
     async connect(t) {
         const {
             clients: n,
-            filterGroups: i,
-            indexes: r
+            filterGroups: r,
+            indexes: i
         } = this;
         if (n.has(t))
             throw new Error("Client already connected.");
         n.add(t), t.coordinator = this;
         const s = t.fields();
-        s != null && s.length && t.fieldInfo(await hz(this, s));
+        s != null && s.length && t.fieldInfo(await _k(this, s));
         const o = t.filterBy;
         if (o)
-            if (i.has(o))
-                i.get(o).add(t);
+            if (r.has(o))
+                r.get(o).add(t);
             else {
-                const a = new zU(this, o, r);
-                i.set(o, a.add(t));
+                const a = new GL(this, o, i);
+                r.set(o, a.add(t));
             }
         t.requestQuery();
     }
     /**
      * Disconnect a client from the coordinator.
      *
      * @param {import('./MosaicClient.js').MosaicClient} client the client to disconnect
      */
     disconnect(t) {
-        var r;
+        var i;
         const {
             clients: n,
-            filterGroups: i
+            filterGroups: r
         } = this;
-        n.has(t) && (n.delete(t), (r = i.get(t.filterBy)) == null || r.remove(t), t.coordinator = null);
-    }
-}
-class gz {
-    /**
-     * Create a new asynchronous dispatcher instance.
-     */
-    constructor() {
-        this._callbacks = /* @__PURE__ */ new Map();
-    }
-    /**
-     * Add an event listener callback for the provided event type.
-     * @param {string} type The event type.
-     * @param {(value: *) => Promise?} callback The event handler
-     *  callback function to add. If the callback has already been
-     *  added for the event type, this method has no effect.
-     */
-    addEventListener(t, n) {
-        this._callbacks.has(t) || this._callbacks.set(t, {
-            callbacks: /* @__PURE__ */ new Set(),
-            pending: null,
-            queue: new bz()
-        }), this._callbacks.get(t).callbacks.add(n);
-    }
-    /**
-     * Remove an event listener callback for the provided event type.
-     * @param {string} type The event type.
-     * @param {(value: *) => Promise?} callback The event handler
-     *  callback function to remove.
-     */
-    removeEventListener(t, n) {
-        const i = this._callbacks.get(t);
-        i && i.callbacks.delete(n);
-    }
-    /**
-     * Lifecycle method that returns the event value to emit.
-     * This default implementation simply returns the input value as-is.
-     * Subclasses may override this method to implement custom transformations
-     * prior to emitting an event value to all listeners.
-     * @param {string} type The event type.
-     * @param {*} value The event value.
-     * @returns The (possibly transformed) event value to emit.
-     */
-    willEmit(t, n) {
-        return n;
-    }
-    /**
-     * Lifecycle method that returns a filter function for updating the
-     * queue of unemitted event values prior to enqueueing a new value.
-     * This default implementation simply returns null, indicating that
-     * any other unemitted event values should be dropped (that is, all
-     * queued events are filtered)
-     * @param {*} value The new event value that will be enqueued.
-     * @returns {(value: *) => boolean|null} A dispatch queue filter
-     *  function, or null if all unemitted event values should be filtered.
-     */
-    emitQueueFilter() {
-        return null;
-    }
-    /**
-     * Cancel all unemitted event values for the given event type.
-     * @param {string} type The event type.
-     */
-    cancel(t) {
-        const n = this._callbacks.get(t);
-        n == null || n.queue.clear();
-    }
-    /**
-     * Emit an event value to listeners for the given event type.
-     * If a previous emit has not yet resolved, the event value
-     * will be queued to be emitted later.
-     * The actual event value given to listeners will be the result
-     * of passing the input value through the emitValue() method.
-     * @param {string} type The event type.
-     * @param {*} value The event value.
-     */
-    emit(t, n) {
-        const i = this._callbacks.get(t) || {};
-        if (i.pending)
-            i.queue.enqueue(n, this.emitQueueFilter(t, n));
-        else {
-            const r = this.willEmit(t, n),
-                {
-                    callbacks: s,
-                    queue: o
-                } = i;
-            if (s != null && s.size) {
-                const a = Promise.allSettled(Array.from(s, (c) => c(r))).then(() => {
-                    i.pending = null, o.isEmpty() || this.emit(t, o.dequeue());
-                });
-                i.pending = a;
-            }
-        }
-    }
-}
-class bz {
-    /**
-     * Create a new dispatch queue instance.
-     */
-    constructor() {
-        this.clear();
-    }
-    /**
-     * Clear the queue state of all event values.
-     */
-    clear() {
-        this.next = null;
-    }
-    /**
-     * Indicate if the queue is empty.
-     * @returns {boolean} True if queue is empty, false otherwise.
-     */
-    isEmpty() {
-        return !this.next;
-    }
-    /**
-     * Add a new value to the queue, and optionally filter the
-     * current queue content in response.
-     * @param {*} value The value to add.
-     * @param {(value: *) => boolean} [filter] An optional filter
-     *  function to apply to existing queue content. If unspecified
-     *  or falsy, all previously queued values are removed. Otherwise,
-     *  the provided function is applied to all queue entries. The
-     *  entry is retained if the filter function returns a truthy value,
-     *  otherwise the entry is removed.
-     */
-    enqueue(t, n) {
-        const i = {
-            value: t
-        };
-        if (n && this.next) {
-            let r = this;
-            for (; r.next;)
-                n(r.next.value) ? r = r.next : r.next = r.next.next;
-            r.next = i;
-        } else
-            this.next = i;
-    }
-    /**
-     * Remove and return the next queued event value.
-     * @returns {*} The next event value in the queue.
-     */
-    dequeue() {
-        const {
-            next: t
-        } = this;
-        return this.next = t == null ? void 0 : t.next, t == null ? void 0 : t.value;
+        n.has(t) && (n.delete(t), (i = r.get(t.filterBy)) == null || i.remove(t), t.coordinator = null);
     }
 }
 
-function t3(e, t) {
-    return e === t ? !1 : e instanceof Date && t instanceof Date ? +e != +t : Array.isArray(e) && Array.isArray(t) ? wz(e, t) : !0;
+function Yx(e, t, {
+    source: n,
+    clients: r = void 0
+}) {
+    const i = t !== void 0 ? ym(e, Ph(t)) : null;
+    return {
+        meta: {
+            type: "point"
+        },
+        source: n,
+        clients: r,
+        value: t,
+        predicate: i
+    };
 }
 
-function wz(e, t) {
-    if (e.length !== t.length)
-        return !0;
-    for (let n = 0; n < e.length; ++n)
-        if (e[n] !== t[n])
-            return !0;
-    return !1;
+function Wx(e, t, {
+    source: n,
+    clients: r = void 0
+}) {
+    let i = null;
+    if (t) {
+        const s = t.map((o) => {
+            const a = o.map((c, u) => ym(e[u], Ph(c)));
+            return a.length > 1 ? Bi(a) : a[0];
+        });
+        i = s.length > 1 ? hm(s) : s[0];
+    }
+    return {
+        meta: {
+            type: "point"
+        },
+        source: n,
+        clients: r,
+        value: t,
+        predicate: i
+    };
 }
 
-function Us(e) {
-    return e instanceof Uo;
-}
-class Uo extends gz {
-    /**
-     * Create a new Param instance.
-     * @param {*} value The initial value of the Param.
-     */
-    constructor(t) {
-        super(), this._value = t;
-    }
-    /**
-     * Create a new Param instance with the given initial value.
-     * @param {*} value The initial value of the Param.
-     * @returns {Param} The new Param instance.
-     */
-    static value(t) {
-        return new Uo(t);
-    }
-    /**
-     * Create a new Param instance over an array of initial values,
-     * which may contain nested Params.
-     * @param {*} values The initial values of the Param.
-     * @returns {Param} The new Param instance.
-     */
-    static array(t) {
-        if (t.some((n) => Us(n))) {
-            const n = new Uo(),
-                i = () => n.update(t.map((r) => Us(r) ? r.value : r));
-            return i(), t.forEach((r) => Us(r) ? r.addEventListener("value", i) : 0), n;
-        }
-        return new Uo(t);
-    }
-    /**
-     * The current value of the Param.
-     */
-    get value() {
-        return this._value;
-    }
-    /**
-     * Update the Param value
-     * @param {*} value The new value of the Param.
-     * @param {object} [options] The update options.
-     * @param {boolean} [options.force] A boolean flag indicating if the Param
-     *  should emit a 'value' event even if the internal value is unchanged.
-     * @returns {this} This Param instance.
-     */
-    update(t, {
-        force: n
-    } = {}) {
-        return t3(this._value, t) || n ? this.emit("value", t) : this.cancel("value"), this;
-    }
-    /**
-     * Upon value-typed updates, sets the current value to the input value
-     * immediately prior to the event value being emitted to listeners.
-     * @param {string} type The event type.
-     * @param {*} value The input event value.
-     * @returns {*} The input event value.
-     */
-    willEmit(t, n) {
-        return t === "value" && (this._value = n), n;
-    }
+function bm(e, t, {
+    source: n,
+    clients: r,
+    bin: i,
+    scale: s,
+    pixelSize: o = 1
+}) {
+    const a = t != null ? $n(e, t) : null;
+    return {
+        meta: {
+            type: "interval",
+            scales: [s],
+            bin: i,
+            pixelSize: o
+        },
+        source: n,
+        clients: r,
+        value: t,
+        predicate: a
+    };
 }
 
-function Xo(e) {
-    return e instanceof Xd;
+function $k(e, t, {
+    source: n,
+    clients: r,
+    bin: i,
+    scales: s = [],
+    pixelSize: o = 1
+}) {
+    const a = t != null ? Bi(e.map((u, l) => $n(u, t[l]))) : null;
+    return {
+        meta: {
+            type: "interval",
+            scales: s,
+            bin: i,
+            pixelSize: o
+        },
+        source: n,
+        clients: r,
+        value: t,
+        predicate: a
+    };
 }
-let Xd = class Pa extends Uo {
-    /**
-     * Create a new Selection instance with an
-     * intersect (conjunction) resolution strategy.
-     * @param {object} [options] The selection options.
-     * @param {boolean} [options.cross=false] Boolean flag indicating
-     *  cross-filtered resolution. If true, selection clauses will not
-     *  be applied to the clients they are associated with.
-     * @returns {Selection} The new Selection instance.
-     */
-    static intersect({
-        cross: t = !1
-    } = {}) {
-        return new Pa(new wl({
-            cross: t
-        }));
-    }
-    /**
-     * Create a new Selection instance with a
-     * union (disjunction) resolution strategy.
-     * @param {object} [options] The selection options.
-     * @param {boolean} [options.cross=false] Boolean flag indicating
-     *  cross-filtered resolution. If true, selection clauses will not
-     *  be applied to the clients they are associated with.
-     * @returns {Selection} The new Selection instance.
-     */
-    static union({
-        cross: t = !1
-    } = {}) {
-        return new Pa(new wl({
-            cross: t,
-            union: !0
-        }));
-    }
-    /**
-     * Create a new Selection instance with a singular resolution strategy
-     * that keeps only the most recent selection clause.
-     * @param {object} [options] The selection options.
-     * @param {boolean} [options.cross=false] Boolean flag indicating
-     *  cross-filtered resolution. If true, selection clauses will not
-     *  be applied to the clients they are associated with.
-     * @returns {Selection} The new Selection instance.
-     */
-    static single({
-        cross: t = !1
-    } = {}) {
-        return new Pa(new wl({
-            cross: t,
-            single: !0
-        }));
-    }
-    /**
-     * Create a new Selection instance with a
-     * cross-filtered intersect resolution strategy.
-     * @returns {Selection} The new Selection instance.
-     */
-    static crossfilter() {
-        return new Pa(new wl({
-            cross: !0
-        }));
-    }
-    /**
-     * Create a new Selection instance.
-     * @param {SelectionResolver} resolver The selection resolution
-     *  strategy to apply.
-     */
-    constructor(t = new wl()) {
-        super([]), this._resolved = this._value, this._resolver = t;
-    }
-    /**
-     * Create a cloned copy of this Selection instance.
-     * @returns {this} A clone of this selection.
-     */
-    clone() {
-        const t = new Pa(this._resolver);
-        return t._value = t._resolved = this._value, t;
-    }
-    /**
-     * Create a clone of this Selection with clauses corresponding
-     * to the provided source removed.
-     * @param {*} source The clause source to remove.
-     * @returns {this} A cloned and updated Selection.
-     */
-    remove(t) {
-        const n = this.clone();
-        return n._value = n._resolved = n._resolver.resolve(this._resolved, {
-            source: t
-        }), n._value.active = {
-            source: t
-        }, n;
-    }
-    /**
-     * The current active (most recently updated) selection clause.
-     */
-    get active() {
-        return this.clauses.active;
-    }
-    /**
-     * The value corresponding to the current active selection clause.
-     * This method ensures compatibility where a normal Param is expected.
-     */
-    get value() {
-        var t;
-        return (t = this.active) == null ? void 0 : t.value;
-    }
-    /**
-     * The current array of selection clauses.
-     */
-    get clauses() {
-        return super.value;
-    }
-    /**
-     * Indicate if this selection has a single resolution strategy.
-     */
-    get single() {
-        return this._resolver.single;
-    }
-    /**
-     * Emit an activate event with the given selection clause.
-     * @param {*} clause The clause repesenting the potential activation.
-     */
-    activate(t) {
-        this.emit("activate", t);
-    }
-    /**
-     * Update the selection with a new selection clause.
-     * @param {*} clause The selection clause to add.
-     * @returns {this} This Selection instance.
-     */
-    update(t) {
-        return this._resolved = this._resolver.resolve(this._resolved, t, !0), this._resolved.active = t, super.update(this._resolved);
-    }
-    /**
-     * Upon value-typed updates, sets the current clause list to the
-     * input value and returns the active clause value.
-     * @param {string} type The event type.
-     * @param {*} value The input event value.
-     * @returns {*} For value-typed events, returns the active clause
-     *  values. Otherwise returns the input event value as-is.
-     */
-    willEmit(t, n) {
-        return t === "value" ? (this._value = n, this.value) : n;
-    }
-    /**
-     * Upon value-typed updates, returns a dispatch queue filter function.
-     * The return value depends on the selection resolution strategy.
-     * @param {string} type The event type.
-     * @param {*} value The input event value.
-     * @returns {*} For value-typed events, returns a dispatch queue filter
-     *  function. Otherwise returns null.
-     */
-    emitQueueFilter(t, n) {
-        return t === "value" ? this._resolver.queueFilter(n) : null;
-    }
-    /**
-     * Indicates if a selection clause should not be applied to a given client.
-     * The return value depends on the selection resolution strategy.
-     * @param {*} client The selection clause.
-     * @param {*} clause The client to test.
-     * @returns True if the client should be skipped, false otherwise.
-     */
-    skip(t, n) {
-        return this._resolver.skip(t, n);
-    }
-    /**
-     * Return a selection query predicate for the given client.
-     * @param {*} client The client whose data may be filtered.
-     * @param {boolean} [noSkip=false] Disable skipping of active
-     *  cross-filtered sources. If set true, the source of the active
-     *  clause in a cross-filtered selection will not be skipped.
-     * @returns {*} The query predicate for filtering client data,
-     *  based on the current state of this selection.
-     */
-    predicate(t, n = !1) {
-        const {
-            clauses: i
-        } = this, r = n ? null : i.active;
-        return this._resolver.predicate(i, r, t);
-    }
+const Ik = {
+    contains: MO,
+    prefix: AO,
+    suffix: $O,
+    regexp: SO
 };
-class wl {
-    /**
-     * Create a new selection resolved instance.
-     * @param {object} [options] The resolution strategy options.
-     * @param {boolean} [options.union=false] Boolean flag to indicate a union strategy.
-     *  If false, an intersection strategy is used.
-     * @param {boolean} [options.cross=false] Boolean flag to indicate cross-filtering.
-     * @param {boolean} [options.single=false] Boolean flag to indicate single clauses only.
-     */
-    constructor({
-        union: t,
-        cross: n,
-        single: i
-    } = {}) {
-        this.union = !!t, this.cross = !!n, this.single = !!i;
-    }
-    /**
-     * Resolve a list of selection clauses according to the resolution strategy.
-     * @param {*[]} clauseList An array of selection clauses.
-     * @param {*} clause A new selection clause to add.
-     * @returns {*[]} An updated array of selection clauses.
-     */
-    resolve(t, n, i = !1) {
-        const {
-            source: r,
-            predicate: s
-        } = n, o = t.filter((c) => r !== c.source), a = this.single ? [] : o;
-        return this.single && i && o.forEach((c) => {
-            var l, u;
-            return (u = (l = c.source) == null ? void 0 : l.reset) == null ? void 0 : u.call(l);
-        }), s && a.push(n), a;
-    }
-    /**
-     * Indicates if a selection clause should not be applied to a given client.
-     * The return value depends on the resolution strategy.
-     * @param {*} client The selection clause.
-     * @param {*} clause The client to test.
-     * @returns True if the client should be skipped, false otherwise.
-     */
-    skip(t, n) {
-        var i;
-        return this.cross && ((i = n == null ? void 0 : n.clients) == null ? void 0 : i.has(t));
-    }
-    /**
-     * Return a selection query predicate for the given client.
-     * @param {*[]} clauseList An array of selection clauses.
-     * @param {*} active The current active selection clause.
-     * @param {*} client The client whose data may be filtered.
-     * @returns {*} The query predicate for filtering client data,
-     *  based on the current state of this selection.
-     */
-    predicate(t, n, i) {
-        const {
-            union: r
-        } = this;
-        if (this.skip(i, n))
-            return;
-        const s = t.filter((o) => !this.skip(i, o)).map((o) => o.predicate);
-        return r && s.length > 1 ? Ob(s) : s;
-    }
-    /**
-     * Returns a filter function for queued selection updates.
-     * @param {*} value The new event value that will be enqueued.
-     * @returns {(value: *) => boolean|null} A dispatch queue filter
-     *  function, or null if all unemitted event values should be filtered.
-     */
-    queueFilter(t) {
-        var n;
-        if (this.cross) {
-            const i = (n = t.active) == null ? void 0 : n.source;
-            return (r) => {
-                var s;
-                return ((s = r.active) == null ? void 0 : s.source) !== i;
-            };
-        }
-    }
+
+function Tk(e, t, {
+    source: n,
+    clients: r = void 0,
+    method: i = "contains"
+}) {
+    let s = Ik[i];
+    const o = t ? s(e, Ph(t)) : null;
+    return {
+        meta: {
+            type: "match",
+            method: i
+        },
+        source: n,
+        clients: r,
+        value: t,
+        predicate: o
+    };
 }
 
-function vz() {
+function Ek() {
     const e = /* @__PURE__ */ new Set();
-    let t, n = new Promise((i) => t = i);
+    let t, n = new Promise((r) => t = r);
     return {
         /**
          * Mark an item as pending.
          * @param {*} item An item to synchronize on.
          */
-        pending(i) {
-            e.add(i);
+        pending(r) {
+            e.add(r);
         },
         /**
          * Mark a pending item as ready, indicating it is
          * ready for a synchronized update.
          * @param {*} item An item to synchronize on.
          * @returns {boolean} True if the synchronizer is ready to
          *  resolve, false otherwise.
          */
-        ready(i) {
-            return e.delete(i), e.size === 0;
+        ready(r) {
+            return e.delete(r), e.size === 0;
         },
         /**
          * Resolve the current synchronization cycle, causing the synchronize
          * promise to resolve and thereby trigger downstream updates.
          */
         resolve() {
-            n = new Promise((i) => {
-                t(), t = i;
+            n = new Promise((r) => {
+                t(), t = r;
             });
         },
         /**
          * The promise for the current synchronization cycle.
          * @return {Promise} The synchronization promise.
          */
         get promise() {
             return n;
         }
     };
 }
-const mf = Symbol("Fixed"),
-    Mi = Symbol("Transient"),
-    e3 = Symbol("Transform");
+const ou = Symbol("Fixed"),
+    qn = Symbol("Transient"),
+    Xx = Symbol("Transform");
 
-function me(e, t) {
+function zt(e, t) {
     return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
 }
 
-function Ho(e, t) {
+function Is(e, t) {
     return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
 }
 
-function Yy(e) {
-    let t, n, i;
-    e.length !== 2 ? (t = me, n = (a, c) => me(e(a), c), i = (a, c) => e(a) - c) : (t = e === me || e === Ho ? e : _z, n = e, i = e);
+function zh(e) {
+    let t, n, r;
+    e.length !== 2 ? (t = zt, n = (a, c) => zt(e(a), c), r = (a, c) => e(a) - c) : (t = e === zt || e === Is ? e : Nk, n = e, r = e);
 
-    function r(a, c, l = 0, u = a.length) {
-        if (l < u) {
+    function i(a, c, u = 0, l = a.length) {
+        if (u < l) {
             if (t(c, c) !== 0)
-                return u;
+                return l;
             do {
-                const f = l + u >>> 1;
-                n(a[f], c) < 0 ? l = f + 1 : u = f;
-            } while (l < u);
+                const f = u + l >>> 1;
+                n(a[f], c) < 0 ? u = f + 1 : l = f;
+            } while (u < l);
         }
-        return l;
+        return u;
     }
 
-    function s(a, c, l = 0, u = a.length) {
-        if (l < u) {
+    function s(a, c, u = 0, l = a.length) {
+        if (u < l) {
             if (t(c, c) !== 0)
-                return u;
+                return l;
             do {
-                const f = l + u >>> 1;
-                n(a[f], c) <= 0 ? l = f + 1 : u = f;
-            } while (l < u);
+                const f = u + l >>> 1;
+                n(a[f], c) <= 0 ? u = f + 1 : l = f;
+            } while (u < l);
         }
-        return l;
+        return u;
     }
 
-    function o(a, c, l = 0, u = a.length) {
-        const f = r(a, c, l, u - 1);
-        return f > l && i(a[f - 1], c) > -i(a[f], c) ? f - 1 : f;
+    function o(a, c, u = 0, l = a.length) {
+        const f = i(a, c, u, l - 1);
+        return f > u && r(a[f - 1], c) > -r(a[f], c) ? f - 1 : f;
     }
     return {
-        left: r,
+        left: i,
         center: o,
         right: s
     };
 }
 
-function _z() {
+function Nk() {
     return 0;
 }
 
-function n3(e) {
+function Gx(e) {
     return e === null ? NaN : +e;
 }
 
-function* xz(e, t) {
+function* Dk(e, t) {
     if (t === void 0)
         for (let n of e)
             n != null && (n = +n) >= n && (yield n);
     else {
         let n = -1;
-        for (let i of e)
-            (i = t(i, ++n, e)) != null && (i = +i) >= i && (yield i);
+        for (let r of e)
+            (r = t(r, ++n, e)) != null && (r = +r) >= r && (yield r);
     }
 }
-const Sz = Yy(me),
-    Wy = Sz.right;
-Yy(n3).center;
-const i3 = r3(s3),
-    Iz = r3(Az);
+const Ok = zh(zt),
+    qh = Ok.right;
+zh(Gx).center;
+const Hx = Jx(Zx),
+    Lk = Jx(kk);
 
-function r3(e) {
-    return function(t, n, i = n) {
+function Jx(e) {
+    return function(t, n, r = n) {
         if (!((n = +n) >= 0))
             throw new RangeError("invalid rx");
-        if (!((i = +i) >= 0))
+        if (!((r = +r) >= 0))
             throw new RangeError("invalid ry");
         let {
-            data: r,
+            data: i,
             width: s,
             height: o
         } = t;
         if (!((s = Math.floor(s)) >= 0))
             throw new RangeError("invalid width");
-        if (!((o = Math.floor(o !== void 0 ? o : r.length / s)) >= 0))
+        if (!((o = Math.floor(o !== void 0 ? o : i.length / s)) >= 0))
             throw new RangeError("invalid height");
-        if (!s || !o || !n && !i)
+        if (!s || !o || !n && !r)
             return t;
         const a = n && e(n),
-            c = i && e(i),
-            l = r.slice();
-        return a && c ? (ga(a, l, r, s, o), ga(a, r, l, s, o), ga(a, l, r, s, o), ba(c, r, l, s, o), ba(c, l, r, s, o), ba(c, r, l, s, o)) : a ? (ga(a, r, l, s, o), ga(a, l, r, s, o), ga(a, r, l, s, o)) : c && (ba(c, r, l, s, o), ba(c, l, r, s, o), ba(c, r, l, s, o)), t;
+            c = r && e(r),
+            u = i.slice();
+        return a && c ? (Xs(a, u, i, s, o), Xs(a, i, u, s, o), Xs(a, u, i, s, o), Gs(c, i, u, s, o), Gs(c, u, i, s, o), Gs(c, i, u, s, o)) : a ? (Xs(a, i, u, s, o), Xs(a, u, i, s, o), Xs(a, i, u, s, o)) : c && (Gs(c, i, u, s, o), Gs(c, u, i, s, o), Gs(c, i, u, s, o)), t;
     };
 }
 
-function ga(e, t, n, i, r) {
-    for (let s = 0, o = i * r; s < o;)
-        e(t, n, s, s += i, 1);
+function Xs(e, t, n, r, i) {
+    for (let s = 0, o = r * i; s < o;)
+        e(t, n, s, s += r, 1);
 }
 
-function ba(e, t, n, i, r) {
-    for (let s = 0, o = i * r; s < i; ++s)
-        e(t, n, s, s + o, i);
+function Gs(e, t, n, r, i) {
+    for (let s = 0, o = r * i; s < r; ++s)
+        e(t, n, s, s + o, r);
 }
 
-function Az(e) {
-    const t = s3(e);
-    return (n, i, r, s, o) => {
-        r <<= 2, s <<= 2, o <<= 2, t(n, i, r + 0, s + 0, o), t(n, i, r + 1, s + 1, o), t(n, i, r + 2, s + 2, o), t(n, i, r + 3, s + 3, o);
+function kk(e) {
+    const t = Zx(e);
+    return (n, r, i, s, o) => {
+        i <<= 2, s <<= 2, o <<= 2, t(n, r, i + 0, s + 0, o), t(n, r, i + 1, s + 1, o), t(n, r, i + 2, s + 2, o), t(n, r, i + 3, s + 3, o);
     };
 }
 
-function s3(e) {
+function Zx(e) {
     const t = Math.floor(e);
     if (t === e)
-        return Mz(e);
+        return Rk(e);
     const n = e - t,
-        i = 2 * e + 1;
-    return (r, s, o, a, c) => {
+        r = 2 * e + 1;
+    return (i, s, o, a, c) => {
         if (!((a -= c) >= o))
             return;
-        let l = t * s[o];
-        const u = c * t,
-            f = u + c;
-        for (let h = o, d = o + u; h < d; h += c)
-            l += s[Math.min(a, h)];
+        let u = t * s[o];
+        const l = c * t,
+            f = l + c;
+        for (let h = o, d = o + l; h < d; h += c)
+            u += s[Math.min(a, h)];
         for (let h = o, d = a; h <= d; h += c)
-            l += s[Math.min(a, h + u)], r[h] = (l + n * (s[Math.max(o, h - f)] + s[Math.min(a, h + f)])) / i, l -= s[Math.max(o, h - u)];
+            u += s[Math.min(a, h + l)], i[h] = (u + n * (s[Math.max(o, h - f)] + s[Math.min(a, h + f)])) / r, u -= s[Math.max(o, h - l)];
     };
 }
 
-function Mz(e) {
+function Rk(e) {
     const t = 2 * e + 1;
-    return (n, i, r, s, o) => {
-        if (!((s -= o) >= r))
+    return (n, r, i, s, o) => {
+        if (!((s -= o) >= i))
             return;
-        let a = e * i[r];
+        let a = e * r[i];
         const c = o * e;
-        for (let l = r, u = r + c; l < u; l += o)
-            a += i[Math.min(s, l)];
-        for (let l = r, u = s; l <= u; l += o)
-            a += i[Math.min(s, l + c)], n[l] = a / t, a -= i[Math.max(r, l - c)];
+        for (let u = i, l = i + c; u < l; u += o)
+            a += r[Math.min(s, u)];
+        for (let u = i, l = s; u <= l; u += o)
+            a += r[Math.min(s, u + c)], n[u] = a / t, a -= r[Math.max(i, u - c)];
     };
 }
 
-function Gy(e, t) {
+function jh(e, t) {
     let n = 0;
     if (t === void 0)
-        for (let i of e)
-            i != null && (i = +i) >= i && ++n;
-    else {
-        let i = -1;
         for (let r of e)
-            (r = t(r, ++i, e)) != null && (r = +r) >= r && ++n;
+            r != null && (r = +r) >= r && ++n;
+    else {
+        let r = -1;
+        for (let i of e)
+            (i = t(i, ++r, e)) != null && (i = +i) >= i && ++n;
     }
     return n;
 }
 
-function $z(e) {
+function Fk(e) {
     return e.length | 0;
 }
 
-function Tz(e) {
+function Bk(e) {
     return !(e > 0);
 }
 
-function Dz(e) {
+function Ck(e) {
     return typeof e != "object" || "length" in e ? e : Array.from(e);
 }
 
-function Nz(e) {
+function Pk(e) {
     return (t) => e(...t);
 }
 
-function Bz(...e) {
-    const t = typeof e[e.length - 1] == "function" && Nz(e.pop());
-    e = e.map(Dz);
-    const n = e.map($z),
-        i = e.length - 1,
-        r = new Array(i + 1).fill(0),
+function Uk(...e) {
+    const t = typeof e[e.length - 1] == "function" && Pk(e.pop());
+    e = e.map(Ck);
+    const n = e.map(Fk),
+        r = e.length - 1,
+        i = new Array(r + 1).fill(0),
         s = [];
-    if (i < 0 || n.some(Tz))
+    if (r < 0 || n.some(Bk))
         return s;
     for (;;) {
-        s.push(r.map((a, c) => e[c][a]));
-        let o = i;
-        for (; ++r[o] === n[o];) {
+        s.push(i.map((a, c) => e[c][a]));
+        let o = r;
+        for (; ++i[o] === n[o];) {
             if (o === 0)
                 return t ? s.map(t) : s;
-            r[o--] = 0;
+            i[o--] = 0;
         }
     }
 }
 
-function Oz(e, t) {
+function zk(e, t) {
     var n = 0,
-        i = 0;
-    return Float64Array.from(e, t === void 0 ? (r) => n += +r || 0 : (r) => n += +t(r, i++, e) || 0);
+        r = 0;
+    return Float64Array.from(e, t === void 0 ? (i) => n += +i || 0 : (i) => n += +t(i, r++, e) || 0);
 }
 
-function zb(e, t) {
+function wm(e, t) {
     let n = 0,
-        i, r = 0,
+        r, i = 0,
         s = 0;
     if (t === void 0)
         for (let o of e)
-            o != null && (o = +o) >= o && (i = o - r, r += i / ++n, s += i * (o - r));
+            o != null && (o = +o) >= o && (r = o - i, i += r / ++n, s += r * (o - i));
     else {
         let o = -1;
         for (let a of e)
-            (a = t(a, ++o, e)) != null && (a = +a) >= a && (i = a - r, r += i / ++n, s += i * (a - r));
+            (a = t(a, ++o, e)) != null && (a = +a) >= a && (r = a - i, i += r / ++n, s += r * (a - i));
     }
     if (n > 1)
         return s / (n - 1);
 }
 
-function gf(e, t) {
-    const n = zb(e, t);
+function au(e, t) {
+    const n = wm(e, t);
     return n && Math.sqrt(n);
 }
 
-function ke(e, t) {
-    let n, i;
+function de(e, t) {
+    let n, r;
     if (t === void 0)
-        for (const r of e)
-            r != null && (n === void 0 ? r >= r && (n = i = r) : (n > r && (n = r), i < r && (i = r)));
+        for (const i of e)
+            i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)));
     else {
-        let r = -1;
+        let i = -1;
         for (let s of e)
-            (s = t(s, ++r, e)) != null && (n === void 0 ? s >= s && (n = i = s) : (n > s && (n = s), i < s && (i = s)));
+            (s = t(s, ++i, e)) != null && (n === void 0 ? s >= s && (n = r = s) : (n > s && (n = s), r < s && (r = s)));
     }
-    return [n, i];
+    return [n, r];
 }
-class sr {
+class pr {
     constructor() {
         this._partials = new Float64Array(32), this._n = 0;
     }
     add(t) {
         const n = this._partials;
-        let i = 0;
-        for (let r = 0; r < this._n && r < 32; r++) {
-            const s = n[r],
+        let r = 0;
+        for (let i = 0; i < this._n && i < 32; i++) {
+            const s = n[i],
                 o = t + s,
                 a = Math.abs(t) < Math.abs(s) ? t - (o - s) : s - (o - t);
-            a && (n[i++] = a), t = o;
+            a && (n[r++] = a), t = o;
         }
-        return n[i] = t, this._n = i + 1, this;
+        return n[r] = t, this._n = r + 1, this;
     }
     valueOf() {
         const t = this._partials;
         let n = this._n,
-            i, r, s, o = 0;
+            r, i, s, o = 0;
         if (n > 0) {
-            for (o = t[--n]; n > 0 && (i = o, r = t[--n], o = i + r, s = r - (o - i), !s);)
+            for (o = t[--n]; n > 0 && (r = o, i = t[--n], o = r + i, s = i - (o - r), !s);)
             ;
-            n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (r = s * 2, i = o + r, r == i - o && (o = i));
+            n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (i = s * 2, r = o + i, i == r - o && (o = r));
         }
         return o;
     }
 }
-class Jo extends Map {
-    constructor(t, n = c3) {
+class Ts extends Map {
+    constructor(t, n = tS) {
         if (super(), Object.defineProperties(this, {
                 _intern: {
                     value: /* @__PURE__ */ new Map()
                 },
                 _key: {
                     value: n
                 }
             }), t != null)
-            for (const [i, r] of t)
-                this.set(i, r);
+            for (const [r, i] of t)
+                this.set(r, i);
     }
     get(t) {
-        return super.get(Eg(this, t));
+        return super.get(x0(this, t));
     }
     has(t) {
-        return super.has(Eg(this, t));
+        return super.has(x0(this, t));
     }
     set(t, n) {
-        return super.set(o3(this, t), n);
+        return super.set(Kx(this, t), n);
     }
     delete(t) {
-        return super.delete(a3(this, t));
+        return super.delete(Qx(this, t));
     }
 }
-class el extends Set {
-    constructor(t, n = c3) {
+class da extends Set {
+    constructor(t, n = tS) {
         if (super(), Object.defineProperties(this, {
                 _intern: {
                     value: /* @__PURE__ */ new Map()
                 },
                 _key: {
                     value: n
                 }
             }), t != null)
-            for (const i of t)
-                this.add(i);
+            for (const r of t)
+                this.add(r);
     }
     has(t) {
-        return super.has(Eg(this, t));
+        return super.has(x0(this, t));
     }
     add(t) {
-        return super.add(o3(this, t));
+        return super.add(Kx(this, t));
     }
     delete(t) {
-        return super.delete(a3(this, t));
+        return super.delete(Qx(this, t));
     }
 }
 
-function Eg({
+function x0({
     _intern: e,
     _key: t
 }, n) {
-    const i = t(n);
-    return e.has(i) ? e.get(i) : n;
+    const r = t(n);
+    return e.has(r) ? e.get(r) : n;
 }
 
-function o3({
+function Kx({
     _intern: e,
     _key: t
 }, n) {
-    const i = t(n);
-    return e.has(i) ? e.get(i) : (e.set(i, n), n);
+    const r = t(n);
+    return e.has(r) ? e.get(r) : (e.set(r, n), n);
 }
 
-function a3({
+function Qx({
     _intern: e,
     _key: t
 }, n) {
-    const i = t(n);
-    return e.has(i) && (n = e.get(i), e.delete(i)), n;
+    const r = t(n);
+    return e.has(r) && (n = e.get(r), e.delete(r)), n;
 }
 
-function c3(e) {
+function tS(e) {
     return e !== null && typeof e == "object" ? e.valueOf() : e;
 }
 
-function Lg(e) {
+function S0(e) {
     return e;
 }
 
-function us(e, ...t) {
-    return Pb(e, Lg, Lg, t);
+function ci(e, ...t) {
+    return vm(e, S0, S0, t);
 }
 
-function uc(e, t, ...n) {
-    return Pb(e, Lg, t, n);
+function Io(e, t, ...n) {
+    return vm(e, S0, t, n);
 }
 
-function Fz(e, t, ...n) {
-    return Pb(e, Array.from, t, n);
+function qk(e, t, ...n) {
+    return vm(e, Array.from, t, n);
 }
 
-function Pb(e, t, n, i) {
-    return function r(s, o) {
-        if (o >= i.length)
+function vm(e, t, n, r) {
+    return function i(s, o) {
+        if (o >= r.length)
             return n(s);
-        const a = new Jo(),
-            c = i[o++];
-        let l = -1;
-        for (const u of s) {
-            const f = c(u, ++l, s),
+        const a = new Ts(),
+            c = r[o++];
+        let u = -1;
+        for (const l of s) {
+            const f = c(l, ++u, s),
                 h = a.get(f);
-            h ? h.push(u) : a.set(f, [u]);
+            h ? h.push(l) : a.set(f, [l]);
         }
-        for (const [u, f] of a)
-            a.set(u, r(f, o));
+        for (const [l, f] of a)
+            a.set(l, i(f, o));
         return t(a);
     }(e, 0);
 }
 
-function Ez(e, t) {
+function jk(e, t) {
     return Array.from(t, (n) => e[n]);
 }
 
-function Hd(e, ...t) {
+function xf(e, ...t) {
     if (typeof e[Symbol.iterator] != "function")
         throw new TypeError("values is not iterable");
     e = Array.from(e);
     let [n] = t;
     if (n && n.length !== 2 || t.length > 1) {
-        const i = Uint32Array.from(e, (r, s) => s);
-        return t.length > 1 ? (t = t.map((r) => e.map(r)), i.sort((r, s) => {
+        const r = Uint32Array.from(e, (i, s) => s);
+        return t.length > 1 ? (t = t.map((i) => e.map(i)), r.sort((i, s) => {
             for (const o of t) {
-                const a = Bu(o[r], o[s]);
+                const a = Tc(o[i], o[s]);
                 if (a)
                     return a;
             }
-        })) : (n = e.map(n), i.sort((r, s) => Bu(n[r], n[s]))), Ez(e, i);
+        })) : (n = e.map(n), r.sort((i, s) => Tc(n[i], n[s]))), jk(e, r);
     }
-    return e.sort(Vb(n));
+    return e.sort(_m(n));
 }
 
-function Vb(e = me) {
-    if (e === me)
-        return Bu;
+function _m(e = zt) {
+    if (e === zt)
+        return Tc;
     if (typeof e != "function")
         throw new TypeError("compare is not a function");
     return (t, n) => {
-        const i = e(t, n);
-        return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0);
+        const r = e(t, n);
+        return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);
     };
 }
 
-function Bu(e, t) {
+function Tc(e, t) {
     return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
 }
 
-function jb(e, t, n) {
-    return (t.length !== 2 ? Hd(uc(e, t, n), ([i, r], [s, o]) => me(r, o) || me(i, s)) : Hd(us(e, n), ([i, r], [s, o]) => t(r, o) || me(i, s))).map(([i]) => i);
+function xm(e, t, n) {
+    return (t.length !== 2 ? xf(Io(e, t, n), ([r, i], [s, o]) => zt(i, o) || zt(r, s)) : xf(ci(e, n), ([r, i], [s, o]) => t(i, o) || zt(r, s))).map(([r]) => r);
 }
-const Lz = Math.sqrt(50),
-    Rz = Math.sqrt(10),
-    Cz = Math.sqrt(2);
-
-function Jd(e, t, n) {
-    const i = (t - e) / Math.max(0, n),
-        r = Math.floor(Math.log10(i)),
-        s = i / Math.pow(10, r),
-        o = s >= Lz ? 10 : s >= Rz ? 5 : s >= Cz ? 2 : 1;
-    let a, c, l;
-    return r < 0 ? (l = Math.pow(10, -r) / o, a = Math.round(e * l), c = Math.round(t * l), a / l < e && ++a, c / l > t && --c, l = -l) : (l = Math.pow(10, r) * o, a = Math.round(e / l), c = Math.round(t / l), a * l < e && ++a, c * l > t && --c), c < a && 0.5 <= n && n < 2 ? Jd(e, t, n * 2) : [a, c, l];
+const Vk = Math.sqrt(50),
+    Yk = Math.sqrt(10),
+    Wk = Math.sqrt(2);
+
+function Sf(e, t, n) {
+    const r = (t - e) / Math.max(0, n),
+        i = Math.floor(Math.log10(r)),
+        s = r / Math.pow(10, i),
+        o = s >= Vk ? 10 : s >= Yk ? 5 : s >= Wk ? 2 : 1;
+    let a, c, u;
+    return i < 0 ? (u = Math.pow(10, -i) / o, a = Math.round(e * u), c = Math.round(t * u), a / u < e && ++a, c / u > t && --c, u = -u) : (u = Math.pow(10, i) * o, a = Math.round(e / u), c = Math.round(t / u), a * u < e && ++a, c * u > t && --c), c < a && 0.5 <= n && n < 2 ? Sf(e, t, n * 2) : [a, c, u];
 }
 
-function Ys(e, t, n) {
+function Ci(e, t, n) {
     if (t = +t, e = +e, n = +n, !(n > 0))
         return [];
     if (e === t)
         return [e];
-    const i = t < e,
-        [r, s, o] = i ? Jd(t, e, n) : Jd(e, t, n);
-    if (!(s >= r))
+    const r = t < e,
+        [i, s, o] = r ? Sf(t, e, n) : Sf(e, t, n);
+    if (!(s >= i))
         return [];
-    const a = s - r + 1,
+    const a = s - i + 1,
         c = new Array(a);
-    if (i)
+    if (r)
         if (o < 0)
-            for (let l = 0; l < a; ++l)
-                c[l] = (s - l) / -o;
+            for (let u = 0; u < a; ++u)
+                c[u] = (s - u) / -o;
         else
-            for (let l = 0; l < a; ++l)
-                c[l] = (s - l) * o;
+            for (let u = 0; u < a; ++u)
+                c[u] = (s - u) * o;
     else if (o < 0)
-        for (let l = 0; l < a; ++l)
-            c[l] = (r + l) / -o;
+        for (let u = 0; u < a; ++u)
+            c[u] = (i + u) / -o;
     else
-        for (let l = 0; l < a; ++l)
-            c[l] = (r + l) * o;
+        for (let u = 0; u < a; ++u)
+            c[u] = (i + u) * o;
     return c;
 }
 
-function Ou(e, t, n) {
-    return t = +t, e = +e, n = +n, Jd(e, t, n)[2];
+function Ec(e, t, n) {
+    return t = +t, e = +e, n = +n, Sf(e, t, n)[2];
 }
 
-function Rg(e, t, n) {
+function M0(e, t, n) {
     t = +t, e = +e, n = +n;
-    const i = t < e,
-        r = i ? Ou(t, e, n) : Ou(e, t, n);
-    return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
+    const r = t < e,
+        i = r ? Ec(t, e, n) : Ec(e, t, n);
+    return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
 }
 
-function l3(e, t, n) {
-    let i;
+function eS(e, t, n) {
+    let r;
     for (;;) {
-        const r = Ou(e, t, n);
-        if (r === i || r === 0 || !isFinite(r))
+        const i = Ec(e, t, n);
+        if (i === r || i === 0 || !isFinite(i))
             return [e, t];
-        r > 0 ? (e = Math.floor(e / r) * r, t = Math.ceil(t / r) * r) : r < 0 && (e = Math.ceil(e * r) / r, t = Math.floor(t * r) / r), i = r;
+        i > 0 ? (e = Math.floor(e / i) * i, t = Math.ceil(t / i) * i) : i < 0 && (e = Math.ceil(e * i) / i, t = Math.floor(t * i) / i), r = i;
     }
 }
 
-function qb(e) {
-    return Math.max(1, Math.ceil(Math.log(Gy(e)) / Math.LN2) + 1);
+function Sm(e) {
+    return Math.max(1, Math.ceil(Math.log(jh(e)) / Math.LN2) + 1);
 }
 
-function De(e, t) {
+function ae(e, t) {
     let n;
     if (t === void 0)
-        for (const i of e)
-            i != null && (n < i || n === void 0 && i >= i) && (n = i);
+        for (const r of e)
+            r != null && (n < r || n === void 0 && r >= r) && (n = r);
     else {
-        let i = -1;
-        for (let r of e)
-            (r = t(r, ++i, e)) != null && (n < r || n === void 0 && r >= r) && (n = r);
+        let r = -1;
+        for (let i of e)
+            (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
     }
     return n;
 }
 
-function kz(e, t) {
-    let n, i = -1,
-        r = -1;
+function Xk(e, t) {
+    let n, r = -1,
+        i = -1;
     if (t === void 0)
         for (const s of e)
-            ++r, s != null && (n < s || n === void 0 && s >= s) && (n = s, i = r);
+            ++i, s != null && (n < s || n === void 0 && s >= s) && (n = s, r = i);
     else
         for (let s of e)
-            (s = t(s, ++r, e)) != null && (n < s || n === void 0 && s >= s) && (n = s, i = r);
-    return i;
+            (s = t(s, ++i, e)) != null && (n < s || n === void 0 && s >= s) && (n = s, r = i);
+    return r;
 }
 
-function Ye(e, t) {
+function ve(e, t) {
     let n;
     if (t === void 0)
-        for (const i of e)
-            i != null && (n > i || n === void 0 && i >= i) && (n = i);
+        for (const r of e)
+            r != null && (n > r || n === void 0 && r >= r) && (n = r);
     else {
-        let i = -1;
-        for (let r of e)
-            (r = t(r, ++i, e)) != null && (n > r || n === void 0 && r >= r) && (n = r);
+        let r = -1;
+        for (let i of e)
+            (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
     }
     return n;
 }
 
-function Uz(e, t) {
-    let n, i = -1,
-        r = -1;
+function Gk(e, t) {
+    let n, r = -1,
+        i = -1;
     if (t === void 0)
         for (const s of e)
-            ++r, s != null && (n > s || n === void 0 && s >= s) && (n = s, i = r);
+            ++i, s != null && (n > s || n === void 0 && s >= s) && (n = s, r = i);
     else
         for (let s of e)
-            (s = t(s, ++r, e)) != null && (n > s || n === void 0 && s >= s) && (n = s, i = r);
-    return i;
+            (s = t(s, ++i, e)) != null && (n > s || n === void 0 && s >= s) && (n = s, r = i);
+    return r;
 }
 
-function u3(e, t, n = 0, i = 1 / 0, r) {
-    if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i))
+function nS(e, t, n = 0, r = 1 / 0, i) {
+    if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r))
         return e;
-    for (r = r === void 0 ? Bu : Vb(r); i > n;) {
-        if (i - n > 600) {
-            const c = i - n + 1,
-                l = t - n + 1,
-                u = Math.log(c),
-                f = 0.5 * Math.exp(2 * u / 3),
-                h = 0.5 * Math.sqrt(u * f * (c - f) / c) * (l - c / 2 < 0 ? -1 : 1),
-                d = Math.max(n, Math.floor(t - l * f / c + h)),
-                p = Math.min(i, Math.floor(t + (c - l) * f / c + h));
-            u3(e, t, d, p, r);
+    for (i = i === void 0 ? Tc : _m(i); r > n;) {
+        if (r - n > 600) {
+            const c = r - n + 1,
+                u = t - n + 1,
+                l = Math.log(c),
+                f = 0.5 * Math.exp(2 * l / 3),
+                h = 0.5 * Math.sqrt(l * f * (c - f) / c) * (u - c / 2 < 0 ? -1 : 1),
+                d = Math.max(n, Math.floor(t - u * f / c + h)),
+                p = Math.min(r, Math.floor(t + (c - u) * f / c + h));
+            nS(e, t, d, p, i);
         }
         const s = e[t];
         let o = n,
-            a = i;
-        for (vl(e, n, t), r(e[i], s) > 0 && vl(e, n, i); o < a;) {
-            for (vl(e, o, a), ++o, --a; r(e[o], s) < 0;)
+            a = r;
+        for (Da(e, n, t), i(e[r], s) > 0 && Da(e, n, r); o < a;) {
+            for (Da(e, o, a), ++o, --a; i(e[o], s) < 0;)
                 ++o;
-            for (; r(e[a], s) > 0;)
+            for (; i(e[a], s) > 0;)
                 --a;
         }
-        r(e[n], s) === 0 ? vl(e, n, a) : (++a, vl(e, a, i)), a <= t && (n = a + 1), t <= a && (i = a - 1);
+        i(e[n], s) === 0 ? Da(e, n, a) : (++a, Da(e, a, r)), a <= t && (n = a + 1), t <= a && (r = a - 1);
     }
     return e;
 }
 
-function vl(e, t, n) {
-    const i = e[t];
-    e[t] = e[n], e[n] = i;
+function Da(e, t, n) {
+    const r = e[t];
+    e[t] = e[n], e[n] = r;
 }
 
-function Yb(e, t = me) {
-    let n, i = !1;
+function Mm(e, t = zt) {
+    let n, r = !1;
     if (t.length === 1) {
-        let r;
+        let i;
         for (const s of e) {
             const o = t(s);
-            (i ? me(o, r) > 0 : me(o, o) === 0) && (n = s, r = o, i = !0);
+            (r ? zt(o, i) > 0 : zt(o, o) === 0) && (n = s, i = o, r = !0);
         }
     } else
-        for (const r of e)
-            (i ? t(r, n) > 0 : t(r, r) === 0) && (n = r, i = !0);
+        for (const i of e)
+            (r ? t(i, n) > 0 : t(i, i) === 0) && (n = i, r = !0);
     return n;
 }
 
-function Ws(e, t, n) {
-    if (e = Float64Array.from(xz(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
-        if (t <= 0 || i < 2)
-            return Ye(e);
+function Pi(e, t, n) {
+    if (e = Float64Array.from(Dk(e, n)), !(!(r = e.length) || isNaN(t = +t))) {
+        if (t <= 0 || r < 2)
+            return ve(e);
         if (t >= 1)
-            return De(e);
-        var i, r = (i - 1) * t,
-            s = Math.floor(r),
-            o = De(u3(e, s).subarray(0, s + 1)),
-            a = Ye(e.subarray(s + 1));
-        return o + (a - o) * (r - s);
+            return ae(e);
+        var r, i = (r - 1) * t,
+            s = Math.floor(i),
+            o = ae(nS(e, s).subarray(0, s + 1)),
+            a = ve(e.subarray(s + 1));
+        return o + (a - o) * (i - s);
     }
 }
 
-function zz(e, t, n = n3) {
-    if (!(!(i = e.length) || isNaN(t = +t))) {
-        if (t <= 0 || i < 2)
+function Hk(e, t, n = Gx) {
+    if (!(!(r = e.length) || isNaN(t = +t))) {
+        if (t <= 0 || r < 2)
             return +n(e[0], 0, e);
         if (t >= 1)
-            return +n(e[i - 1], i - 1, e);
-        var i, r = (i - 1) * t,
-            s = Math.floor(r),
+            return +n(e[r - 1], r - 1, e);
+        var r, i = (r - 1) * t,
+            s = Math.floor(i),
             o = +n(e[s], s, e),
             a = +n(e[s + 1], s + 1, e);
-        return o + (a - o) * (r - s);
+        return o + (a - o) * (i - s);
     }
 }
 
-function Pz(e, t, n) {
-    const i = Gy(e),
-        r = Ws(e, 0.75) - Ws(e, 0.25);
-    return i && r ? Math.ceil((n - t) / (2 * r * Math.pow(i, -1 / 3))) : 1;
+function Jk(e, t, n) {
+    const r = jh(e),
+        i = Pi(e, 0.75) - Pi(e, 0.25);
+    return r && i ? Math.ceil((n - t) / (2 * i * Math.pow(r, -1 / 3))) : 1;
 }
 
-function f3(e, t, n) {
-    const i = Gy(e),
-        r = gf(e);
-    return i && r ? Math.ceil((n - t) * Math.cbrt(i) / (3.49 * r)) : 1;
+function rS(e, t, n) {
+    const r = jh(e),
+        i = au(e);
+    return r && i ? Math.ceil((n - t) * Math.cbrt(r) / (3.49 * i)) : 1;
 }
 
-function Xy(e, t) {
+function Vh(e, t) {
     let n = 0,
-        i = 0;
+        r = 0;
     if (t === void 0)
-        for (let r of e)
-            r != null && (r = +r) >= r && (++n, i += r);
+        for (let i of e)
+            i != null && (i = +i) >= i && (++n, r += i);
     else {
-        let r = -1;
+        let i = -1;
         for (let s of e)
-            (s = t(s, ++r, e)) != null && (s = +s) >= s && (++n, i += s);
+            (s = t(s, ++i, e)) != null && (s = +s) >= s && (++n, r += s);
     }
     if (n)
-        return i / n;
+        return r / n;
 }
 
-function Fu(e, t) {
-    return Ws(e, 0.5, t);
+function Nc(e, t) {
+    return Pi(e, 0.5, t);
 }
 
-function* Vz(e) {
+function* Zk(e) {
     for (const t of e)
         yield* t;
 }
 
-function h3(e) {
-    return Array.from(Vz(e));
+function iS(e) {
+    return Array.from(Zk(e));
 }
 
-function d3(e, t) {
-    const n = new Jo();
+function sS(e, t) {
+    const n = new Ts();
     if (t === void 0)
         for (let s of e)
             s != null && s >= s && n.set(s, (n.get(s) || 0) + 1);
     else {
         let s = -1;
         for (let o of e)
             (o = t(o, ++s, e)) != null && o >= o && n.set(o, (n.get(o) || 0) + 1);
     }
-    let i, r = 0;
+    let r, i = 0;
     for (const [s, o] of n)
-        o > r && (r = o, i = s);
-    return i;
+        o > i && (i = o, r = s);
+    return r;
 }
 
-function jz(e, t = qz) {
+function Kk(e, t = Qk) {
     const n = [];
-    let i, r = !1;
+    let r, i = !1;
     for (const s of e)
-        r && n.push(t(i, s)), i = s, r = !0;
+        i && n.push(t(r, s)), r = s, i = !0;
     return n;
 }
 
-function qz(e, t) {
+function Qk(e, t) {
     return [e, t];
 }
 
-function Cn(e, t, n) {
-    e = +e, t = +t, n = (r = arguments.length) < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +n;
-    for (var i = -1, r = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(r); ++i < r;)
-        s[i] = e + i * n;
+function sn(e, t, n) {
+    e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
+    for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(i); ++r < i;)
+        s[r] = e + r * n;
     return s;
 }
 
-function p3(e, t = me) {
+function oS(e, t = zt) {
     if (typeof e[Symbol.iterator] != "function")
         throw new TypeError("values is not iterable");
     let n = Array.from(e);
-    const i = new Float64Array(n.length);
-    t.length !== 2 && (n = n.map(t), t = me);
-    const r = (a, c) => t(n[a], n[c]);
+    const r = new Float64Array(n.length);
+    t.length !== 2 && (n = n.map(t), t = zt);
+    const i = (a, c) => t(n[a], n[c]);
     let s, o;
-    return e = Uint32Array.from(n, (a, c) => c), e.sort(t === me ? (a, c) => Bu(n[a], n[c]) : Vb(r)), e.forEach((a, c) => {
-        const l = r(a, s === void 0 ? a : s);
-        l >= 0 ? ((s === void 0 || l > 0) && (s = a, o = c), i[a] = o) : i[a] = NaN;
-    }), i;
+    return e = Uint32Array.from(n, (a, c) => c), e.sort(t === zt ? (a, c) => Tc(n[a], n[c]) : _m(i)), e.forEach((a, c) => {
+        const u = i(a, s === void 0 ? a : s);
+        u >= 0 ? ((s === void 0 || u > 0) && (s = a, o = c), r[a] = o) : r[a] = NaN;
+    }), r;
 }
 
-function Yz(e, t = me) {
-    let n, i = !1;
+function tR(e, t = zt) {
+    let n, r = !1;
     if (t.length === 1) {
-        let r;
+        let i;
         for (const s of e) {
             const o = t(s);
-            (i ? me(o, r) < 0 : me(o, o) === 0) && (n = s, r = o, i = !0);
+            (r ? zt(o, i) < 0 : zt(o, o) === 0) && (n = s, i = o, r = !0);
         }
     } else
-        for (const r of e)
-            (i ? t(r, n) < 0 : t(r, r) === 0) && (n = r, i = !0);
+        for (const i of e)
+            (r ? t(i, n) < 0 : t(i, i) === 0) && (n = i, r = !0);
     return n;
 }
 
-function fr(e, t) {
+function wr(e, t) {
     let n = 0;
     if (t === void 0)
-        for (let i of e)
-            (i = +i) && (n += i);
-    else {
-        let i = -1;
         for (let r of e)
-            (r = +t(r, ++i, e)) && (n += r);
+            (r = +r) && (n += r);
+    else {
+        let r = -1;
+        for (let i of e)
+            (i = +t(i, ++r, e)) && (n += i);
     }
     return n;
 }
 
-function Kd(e) {
+function Mf(e) {
     if (typeof e[Symbol.iterator] != "function")
         throw new TypeError("values is not iterable");
     return Array.from(e).reverse();
 }
 
-function Wz(e) {
+function eR(e) {
     return e;
 }
-var om = 1,
-    am = 2,
-    Cg = 3,
-    oh = 4,
-    f2 = 1e-6;
+var ep = 1,
+    np = 2,
+    A0 = 3,
+    Yu = 4,
+    Ib = 1e-6;
 
-function Gz(e) {
+function nR(e) {
     return "translate(" + e + ",0)";
 }
 
-function Xz(e) {
+function rR(e) {
     return "translate(0," + e + ")";
 }
 
-function Hz(e) {
+function iR(e) {
     return (t) => +e(t);
 }
 
-function Jz(e, t) {
+function sR(e, t) {
     return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;
 }
 
-function Kz() {
+function oR() {
     return !this.__axis;
 }
 
-function Zz(e, t) {
+function aR(e, t) {
     var n = [],
-        i = null,
         r = null,
+        i = null,
         s = 6,
         o = 6,
         a = 3,
         c = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5,
-        l = e === om || e === oh ? -1 : 1,
-        u = e === oh || e === am ? "x" : "y",
-        f = e === om || e === Cg ? Gz : Xz;
+        u = e === ep || e === Yu ? -1 : 1,
+        l = e === Yu || e === np ? "x" : "y",
+        f = e === ep || e === A0 ? nR : rR;
 
     function h(d) {
-        var p = i ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()),
-            m = r ?? (t.tickFormat ? t.tickFormat.apply(t, n) : Wz),
-            g = Math.max(s, 0) + a,
-            y = t.range(),
-            b = +y[0] + c,
-            w = +y[y.length - 1] + c,
-            v = (t.bandwidth ? Jz : Hz)(t.copy(), c),
+        var p = r ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()),
+            y = i ?? (t.tickFormat ? t.tickFormat.apply(t, n) : eR),
+            m = Math.max(s, 0) + a,
+            g = t.range(),
+            b = +g[0] + c,
+            w = +g[g.length - 1] + c,
+            v = (t.bandwidth ? sR : iR)(t.copy(), c),
             x = d.selection ? d.selection() : d,
             _ = x.selectAll(".domain").data([null]),
-            I = x.selectAll(".tick").data(p, t).order(),
-            A = I.exit(),
-            M = I.enter().append("g").attr("class", "tick"),
-            N = I.select("line"),
-            $ = I.select("text");
-        _ = _.merge(_.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), I = I.merge(M), N = N.merge(M.append("line").attr("stroke", "currentColor").attr(u + "2", l * s)), $ = $.merge(M.append("text").attr("fill", "currentColor").attr(u, l * g).attr("dy", e === om ? "0em" : e === Cg ? "0.71em" : "0.32em")), d !== x && (_ = _.transition(d), I = I.transition(d), N = N.transition(d), $ = $.transition(d), A = A.transition(d).attr("opacity", f2).attr("transform", function(B) {
-            return isFinite(B = v(B)) ? f(B + c) : this.getAttribute("transform");
-        }), M.attr("opacity", f2).attr("transform", function(B) {
+            M = x.selectAll(".tick").data(p, t).order(),
+            T = M.exit(),
+            $ = M.enter().append("g").attr("class", "tick"),
+            N = M.select("line"),
+            A = M.select("text");
+        _ = _.merge(_.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), M = M.merge($), N = N.merge($.append("line").attr("stroke", "currentColor").attr(l + "2", u * s)), A = A.merge($.append("text").attr("fill", "currentColor").attr(l, u * m).attr("dy", e === ep ? "0em" : e === A0 ? "0.71em" : "0.32em")), d !== x && (_ = _.transition(d), M = M.transition(d), N = N.transition(d), A = A.transition(d), T = T.transition(d).attr("opacity", Ib).attr("transform", function(D) {
+            return isFinite(D = v(D)) ? f(D + c) : this.getAttribute("transform");
+        }), $.attr("opacity", Ib).attr("transform", function(D) {
             var R = this.parentNode.__axis;
-            return f((R && isFinite(R = R(B)) ? R : v(B)) + c);
-        })), A.remove(), _.attr("d", e === oh || e === am ? o ? "M" + l * o + "," + b + "H" + c + "V" + w + "H" + l * o : "M" + c + "," + b + "V" + w : o ? "M" + b + "," + l * o + "V" + c + "H" + w + "V" + l * o : "M" + b + "," + c + "H" + w), I.attr("opacity", 1).attr("transform", function(B) {
-            return f(v(B) + c);
-        }), N.attr(u + "2", l * s), $.attr(u, l * g).text(m), x.filter(Kz).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === am ? "start" : e === oh ? "end" : "middle"), x.each(function() {
+            return f((R && isFinite(R = R(D)) ? R : v(D)) + c);
+        })), T.remove(), _.attr("d", e === Yu || e === np ? o ? "M" + u * o + "," + b + "H" + c + "V" + w + "H" + u * o : "M" + c + "," + b + "V" + w : o ? "M" + b + "," + u * o + "V" + c + "H" + w + "V" + u * o : "M" + b + "," + c + "H" + w), M.attr("opacity", 1).attr("transform", function(D) {
+            return f(v(D) + c);
+        }), N.attr(l + "2", u * s), A.attr(l, u * m).text(y), x.filter(oR).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === np ? "start" : e === Yu ? "end" : "middle"), x.each(function() {
             this.__axis = v;
         });
     }
     return h.scale = function(d) {
         return arguments.length ? (t = d, h) : t;
     }, h.ticks = function() {
         return n = Array.from(arguments), h;
     }, h.tickArguments = function(d) {
         return arguments.length ? (n = d == null ? [] : Array.from(d), h) : n.slice();
     }, h.tickValues = function(d) {
-        return arguments.length ? (i = d == null ? null : Array.from(d), h) : i && i.slice();
+        return arguments.length ? (r = d == null ? null : Array.from(d), h) : r && r.slice();
     }, h.tickFormat = function(d) {
-        return arguments.length ? (r = d, h) : r;
+        return arguments.length ? (i = d, h) : i;
     }, h.tickSize = function(d) {
         return arguments.length ? (s = o = +d, h) : s;
     }, h.tickSizeInner = function(d) {
         return arguments.length ? (s = +d, h) : s;
     }, h.tickSizeOuter = function(d) {
         return arguments.length ? (o = +d, h) : o;
     }, h.tickPadding = function(d) {
         return arguments.length ? (a = +d, h) : a;
     }, h.offset = function(d) {
         return arguments.length ? (c = +d, h) : c;
     }, h;
 }
 
-function Qz(e) {
-    return Zz(Cg, e);
+function cR(e) {
+    return aR(A0, e);
 }
-var tP = {
+var uR = {
     value: () => {}
 };
 
-function Hy() {
-    for (var e = 0, t = arguments.length, n = {}, i; e < t; ++e) {
-        if (!(i = arguments[e] + "") || i in n || /[\s.]/.test(i))
-            throw new Error("illegal type: " + i);
-        n[i] = [];
+function Yh() {
+    for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
+        if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
+            throw new Error("illegal type: " + r);
+        n[r] = [];
     }
-    return new Qh(n);
+    return new Ll(n);
 }
 
-function Qh(e) {
+function Ll(e) {
     this._ = e;
 }
 
-function eP(e, t) {
+function lR(e, t) {
     return e.trim().split(/^|\s+/).map(function(n) {
-        var i = "",
-            r = n.indexOf(".");
-        if (r >= 0 && (i = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n))
+        var r = "",
+            i = n.indexOf(".");
+        if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
             throw new Error("unknown type: " + n);
         return {
             type: n,
-            name: i
+            name: r
         };
     });
 }
-Qh.prototype = Hy.prototype = {
-    constructor: Qh,
+Ll.prototype = Yh.prototype = {
+    constructor: Ll,
     on: function(e, t) {
         var n = this._,
-            i = eP(e + "", n),
-            r, s = -1,
-            o = i.length;
+            r = lR(e + "", n),
+            i, s = -1,
+            o = r.length;
         if (arguments.length < 2) {
             for (; ++s < o;)
-                if ((r = (e = i[s]).type) && (r = nP(n[r], e.name)))
-                    return r;
+                if ((i = (e = r[s]).type) && (i = fR(n[i], e.name)))
+                    return i;
             return;
         }
         if (t != null && typeof t != "function")
             throw new Error("invalid callback: " + t);
         for (; ++s < o;)
-            if (r = (e = i[s]).type)
-                n[r] = h2(n[r], e.name, t);
+            if (i = (e = r[s]).type)
+                n[i] = Tb(n[i], e.name, t);
             else if (t == null)
-            for (r in n)
-                n[r] = h2(n[r], e.name, null);
+            for (i in n)
+                n[i] = Tb(n[i], e.name, null);
         return this;
     },
     copy: function() {
         var e = {},
             t = this._;
         for (var n in t)
             e[n] = t[n].slice();
-        return new Qh(e);
+        return new Ll(e);
     },
     call: function(e, t) {
-        if ((r = arguments.length - 2) > 0)
-            for (var n = new Array(r), i = 0, r, s; i < r; ++i)
-                n[i] = arguments[i + 2];
+        if ((i = arguments.length - 2) > 0)
+            for (var n = new Array(i), r = 0, i, s; r < i; ++r)
+                n[r] = arguments[r + 2];
         if (!this._.hasOwnProperty(e))
             throw new Error("unknown type: " + e);
-        for (s = this._[e], i = 0, r = s.length; i < r; ++i)
-            s[i].value.apply(t, n);
+        for (s = this._[e], r = 0, i = s.length; r < i; ++r)
+            s[r].value.apply(t, n);
     },
     apply: function(e, t, n) {
         if (!this._.hasOwnProperty(e))
             throw new Error("unknown type: " + e);
-        for (var i = this._[e], r = 0, s = i.length; r < s; ++r)
-            i[r].value.apply(t, n);
+        for (var r = this._[e], i = 0, s = r.length; i < s; ++i)
+            r[i].value.apply(t, n);
     }
 };
 
-function nP(e, t) {
-    for (var n = 0, i = e.length, r; n < i; ++n)
-        if ((r = e[n]).name === t)
-            return r.value;
+function fR(e, t) {
+    for (var n = 0, r = e.length, i; n < r; ++n)
+        if ((i = e[n]).name === t)
+            return i.value;
 }
 
-function h2(e, t, n) {
-    for (var i = 0, r = e.length; i < r; ++i)
-        if (e[i].name === t) {
-            e[i] = tP, e = e.slice(0, i).concat(e.slice(i + 1));
+function Tb(e, t, n) {
+    for (var r = 0, i = e.length; r < i; ++r)
+        if (e[r].name === t) {
+            e[r] = uR, e = e.slice(0, r).concat(e.slice(r + 1));
             break;
         }
     return n != null && e.push({
         name: t,
         value: n
     }), e;
 }
-var kg = "http://www.w3.org/1999/xhtml";
-const Ko = {
+var $0 = "http://www.w3.org/1999/xhtml";
+const Es = {
     svg: "http://www.w3.org/2000/svg",
-    xhtml: kg,
+    xhtml: $0,
     xlink: "http://www.w3.org/1999/xlink",
     xml: "http://www.w3.org/XML/1998/namespace",
     xmlns: "http://www.w3.org/2000/xmlns/"
 };
 
-function Jy(e) {
+function Wh(e) {
     var t = e += "",
         n = t.indexOf(":");
-    return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Ko.hasOwnProperty(t) ? {
-        space: Ko[t],
+    return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Es.hasOwnProperty(t) ? {
+        space: Es[t],
         local: e
     } : e;
 }
 
-function iP(e) {
+function hR(e) {
     return function() {
         var t = this.ownerDocument,
             n = this.namespaceURI;
-        return n === kg && t.documentElement.namespaceURI === kg ? t.createElement(e) : t.createElementNS(n, e);
+        return n === $0 && t.documentElement.namespaceURI === $0 ? t.createElement(e) : t.createElementNS(n, e);
     };
 }
 
-function rP(e) {
+function dR(e) {
     return function() {
         return this.ownerDocument.createElementNS(e.space, e.local);
     };
 }
 
-function Ky(e) {
-    var t = Jy(e);
-    return (t.local ? rP : iP)(t);
+function Xh(e) {
+    var t = Wh(e);
+    return (t.local ? dR : hR)(t);
 }
 
-function sP() {}
+function pR() {}
 
-function Wb(e) {
-    return e == null ? sP : function() {
+function Am(e) {
+    return e == null ? pR : function() {
         return this.querySelector(e);
     };
 }
 
-function oP(e) {
-    typeof e != "function" && (e = Wb(e));
-    for (var t = this._groups, n = t.length, i = new Array(n), r = 0; r < n; ++r)
-        for (var s = t[r], o = s.length, a = i[r] = new Array(o), c, l, u = 0; u < o; ++u)
-            (c = s[u]) && (l = e.call(c, c.__data__, u, s)) && ("__data__" in c && (l.__data__ = c.__data__), a[u] = l);
-    return new zn(i, this._parents);
+function yR(e) {
+    typeof e != "function" && (e = Am(e));
+    for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
+        for (var s = t[i], o = s.length, a = r[i] = new Array(o), c, u, l = 0; l < o; ++l)
+            (c = s[l]) && (u = e.call(c, c.__data__, l, s)) && ("__data__" in c && (u.__data__ = c.__data__), a[l] = u);
+    return new cn(r, this._parents);
 }
 
-function aP(e) {
+function mR(e) {
     return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
 }
 
-function cP() {
+function gR() {
     return [];
 }
 
-function y3(e) {
-    return e == null ? cP : function() {
+function aS(e) {
+    return e == null ? gR : function() {
         return this.querySelectorAll(e);
     };
 }
 
-function lP(e) {
+function bR(e) {
     return function() {
-        return aP(e.apply(this, arguments));
+        return mR(e.apply(this, arguments));
     };
 }
 
-function uP(e) {
-    typeof e == "function" ? e = lP(e) : e = y3(e);
-    for (var t = this._groups, n = t.length, i = [], r = [], s = 0; s < n; ++s)
-        for (var o = t[s], a = o.length, c, l = 0; l < a; ++l)
-            (c = o[l]) && (i.push(e.call(c, c.__data__, l, o)), r.push(c));
-    return new zn(i, r);
+function wR(e) {
+    typeof e == "function" ? e = bR(e) : e = aS(e);
+    for (var t = this._groups, n = t.length, r = [], i = [], s = 0; s < n; ++s)
+        for (var o = t[s], a = o.length, c, u = 0; u < a; ++u)
+            (c = o[u]) && (r.push(e.call(c, c.__data__, u, o)), i.push(c));
+    return new cn(r, i);
 }
 
-function m3(e) {
+function cS(e) {
     return function() {
         return this.matches(e);
     };
 }
 
-function g3(e) {
+function uS(e) {
     return function(t) {
         return t.matches(e);
     };
 }
-var fP = Array.prototype.find;
+var vR = Array.prototype.find;
 
-function hP(e) {
+function _R(e) {
     return function() {
-        return fP.call(this.children, e);
+        return vR.call(this.children, e);
     };
 }
 
-function dP() {
+function xR() {
     return this.firstElementChild;
 }
 
-function pP(e) {
-    return this.select(e == null ? dP : hP(typeof e == "function" ? e : g3(e)));
+function SR(e) {
+    return this.select(e == null ? xR : _R(typeof e == "function" ? e : uS(e)));
 }
-var yP = Array.prototype.filter;
+var MR = Array.prototype.filter;
 
-function mP() {
+function AR() {
     return Array.from(this.children);
 }
 
-function gP(e) {
+function $R(e) {
     return function() {
-        return yP.call(this.children, e);
+        return MR.call(this.children, e);
     };
 }
 
-function bP(e) {
-    return this.selectAll(e == null ? mP : gP(typeof e == "function" ? e : g3(e)));
+function IR(e) {
+    return this.selectAll(e == null ? AR : $R(typeof e == "function" ? e : uS(e)));
 }
 
-function wP(e) {
-    typeof e != "function" && (e = m3(e));
-    for (var t = this._groups, n = t.length, i = new Array(n), r = 0; r < n; ++r)
-        for (var s = t[r], o = s.length, a = i[r] = [], c, l = 0; l < o; ++l)
-            (c = s[l]) && e.call(c, c.__data__, l, s) && a.push(c);
-    return new zn(i, this._parents);
+function TR(e) {
+    typeof e != "function" && (e = cS(e));
+    for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
+        for (var s = t[i], o = s.length, a = r[i] = [], c, u = 0; u < o; ++u)
+            (c = s[u]) && e.call(c, c.__data__, u, s) && a.push(c);
+    return new cn(r, this._parents);
 }
 
-function b3(e) {
+function lS(e) {
     return new Array(e.length);
 }
 
-function vP() {
-    return new zn(this._enter || this._groups.map(b3), this._parents);
+function ER() {
+    return new cn(this._enter || this._groups.map(lS), this._parents);
 }
 
-function Zd(e, t) {
+function Af(e, t) {
     this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
 }
-Zd.prototype = {
-    constructor: Zd,
+Af.prototype = {
+    constructor: Af,
     appendChild: function(e) {
         return this._parent.insertBefore(e, this._next);
     },
     insertBefore: function(e, t) {
         return this._parent.insertBefore(e, t);
     },
     querySelector: function(e) {
         return this._parent.querySelector(e);
     },
     querySelectorAll: function(e) {
         return this._parent.querySelectorAll(e);
     }
 };
 
-function _P(e) {
+function NR(e) {
     return function() {
         return e;
     };
 }
 
-function xP(e, t, n, i, r, s) {
-    for (var o = 0, a, c = t.length, l = s.length; o < l; ++o)
-        (a = t[o]) ? (a.__data__ = s[o], i[o] = a) : n[o] = new Zd(e, s[o]);
+function DR(e, t, n, r, i, s) {
+    for (var o = 0, a, c = t.length, u = s.length; o < u; ++o)
+        (a = t[o]) ? (a.__data__ = s[o], r[o] = a) : n[o] = new Af(e, s[o]);
     for (; o < c; ++o)
-        (a = t[o]) && (r[o] = a);
+        (a = t[o]) && (i[o] = a);
 }
 
-function SP(e, t, n, i, r, s, o) {
-    var a, c, l = /* @__PURE__ */ new Map(),
-        u = t.length,
+function OR(e, t, n, r, i, s, o) {
+    var a, c, u = /* @__PURE__ */ new Map(),
+        l = t.length,
         f = s.length,
-        h = new Array(u),
+        h = new Array(l),
         d;
-    for (a = 0; a < u; ++a)
-        (c = t[a]) && (h[a] = d = o.call(c, c.__data__, a, t) + "", l.has(d) ? r[a] = c : l.set(d, c));
+    for (a = 0; a < l; ++a)
+        (c = t[a]) && (h[a] = d = o.call(c, c.__data__, a, t) + "", u.has(d) ? i[a] = c : u.set(d, c));
     for (a = 0; a < f; ++a)
-        d = o.call(e, s[a], a, s) + "", (c = l.get(d)) ? (i[a] = c, c.__data__ = s[a], l.delete(d)) : n[a] = new Zd(e, s[a]);
-    for (a = 0; a < u; ++a)
-        (c = t[a]) && l.get(h[a]) === c && (r[a] = c);
+        d = o.call(e, s[a], a, s) + "", (c = u.get(d)) ? (r[a] = c, c.__data__ = s[a], u.delete(d)) : n[a] = new Af(e, s[a]);
+    for (a = 0; a < l; ++a)
+        (c = t[a]) && u.get(h[a]) === c && (i[a] = c);
 }
 
-function IP(e) {
+function LR(e) {
     return e.__data__;
 }
 
-function AP(e, t) {
+function kR(e, t) {
     if (!arguments.length)
-        return Array.from(this, IP);
-    var n = t ? SP : xP,
-        i = this._parents,
-        r = this._groups;
-    typeof e != "function" && (e = _P(e));
-    for (var s = r.length, o = new Array(s), a = new Array(s), c = new Array(s), l = 0; l < s; ++l) {
-        var u = i[l],
-            f = r[l],
+        return Array.from(this, LR);
+    var n = t ? OR : DR,
+        r = this._parents,
+        i = this._groups;
+    typeof e != "function" && (e = NR(e));
+    for (var s = i.length, o = new Array(s), a = new Array(s), c = new Array(s), u = 0; u < s; ++u) {
+        var l = r[u],
+            f = i[u],
             h = f.length,
-            d = MP(e.call(u, u && u.__data__, l, i)),
+            d = RR(e.call(l, l && l.__data__, u, r)),
             p = d.length,
-            m = a[l] = new Array(p),
-            g = o[l] = new Array(p),
-            y = c[l] = new Array(h);
-        n(u, f, m, g, y, d, t);
+            y = a[u] = new Array(p),
+            m = o[u] = new Array(p),
+            g = c[u] = new Array(h);
+        n(l, f, y, m, g, d, t);
         for (var b = 0, w = 0, v, x; b < p; ++b)
-            if (v = m[b]) {
-                for (b >= w && (w = b + 1); !(x = g[w]) && ++w < p;)
+            if (v = y[b]) {
+                for (b >= w && (w = b + 1); !(x = m[w]) && ++w < p;)
                 ;
                 v._next = x || null;
             }
     }
-    return o = new zn(o, i), o._enter = a, o._exit = c, o;
+    return o = new cn(o, r), o._enter = a, o._exit = c, o;
 }
 
-function MP(e) {
+function RR(e) {
     return typeof e == "object" && "length" in e ? e : Array.from(e);
 }
 
-function $P() {
-    return new zn(this._exit || this._groups.map(b3), this._parents);
+function FR() {
+    return new cn(this._exit || this._groups.map(lS), this._parents);
 }
 
-function TP(e, t, n) {
-    var i = this.enter(),
-        r = this,
+function BR(e, t, n) {
+    var r = this.enter(),
+        i = this,
         s = this.exit();
-    return typeof e == "function" ? (i = e(i), i && (i = i.selection())) : i = i.append(e + ""), t != null && (r = t(r), r && (r = r.selection())), n == null ? s.remove() : n(s), i && r ? i.merge(r).order() : r;
+    return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? s.remove() : n(s), r && i ? r.merge(i).order() : i;
 }
 
-function DP(e) {
-    for (var t = e.selection ? e.selection() : e, n = this._groups, i = t._groups, r = n.length, s = i.length, o = Math.min(r, s), a = new Array(r), c = 0; c < o; ++c)
-        for (var l = n[c], u = i[c], f = l.length, h = a[c] = new Array(f), d, p = 0; p < f; ++p)
-            (d = l[p] || u[p]) && (h[p] = d);
-    for (; c < r; ++c)
+function CR(e) {
+    for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, s = r.length, o = Math.min(i, s), a = new Array(i), c = 0; c < o; ++c)
+        for (var u = n[c], l = r[c], f = u.length, h = a[c] = new Array(f), d, p = 0; p < f; ++p)
+            (d = u[p] || l[p]) && (h[p] = d);
+    for (; c < i; ++c)
         a[c] = n[c];
-    return new zn(a, this._parents);
+    return new cn(a, this._parents);
 }
 
-function NP() {
+function PR() {
     for (var e = this._groups, t = -1, n = e.length; ++t < n;)
-        for (var i = e[t], r = i.length - 1, s = i[r], o; --r >= 0;)
-            (o = i[r]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
+        for (var r = e[t], i = r.length - 1, s = r[i], o; --i >= 0;)
+            (o = r[i]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
     return this;
 }
 
-function BP(e) {
-    e || (e = OP);
+function UR(e) {
+    e || (e = zR);
 
     function t(f, h) {
         return f && h ? e(f.__data__, h.__data__) : !f - !h;
     }
-    for (var n = this._groups, i = n.length, r = new Array(i), s = 0; s < i; ++s) {
-        for (var o = n[s], a = o.length, c = r[s] = new Array(a), l, u = 0; u < a; ++u)
-            (l = o[u]) && (c[u] = l);
+    for (var n = this._groups, r = n.length, i = new Array(r), s = 0; s < r; ++s) {
+        for (var o = n[s], a = o.length, c = i[s] = new Array(a), u, l = 0; l < a; ++l)
+            (u = o[l]) && (c[l] = u);
         c.sort(t);
     }
-    return new zn(r, this._parents).order();
+    return new cn(i, this._parents).order();
 }
 
-function OP(e, t) {
+function zR(e, t) {
     return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
 }
 
-function FP() {
+function qR() {
     var e = arguments[0];
     return arguments[0] = this, e.apply(null, arguments), this;
 }
 
-function EP() {
+function jR() {
     return Array.from(this);
 }
 
-function LP() {
+function VR() {
     for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
-        for (var i = e[t], r = 0, s = i.length; r < s; ++r) {
-            var o = i[r];
+        for (var r = e[t], i = 0, s = r.length; i < s; ++i) {
+            var o = r[i];
             if (o)
                 return o;
         }
     return null;
 }
 
-function RP() {
+function YR() {
     let e = 0;
     for (const t of this)
         ++e;
     return e;
 }
 
-function CP() {
+function WR() {
     return !this.node();
 }
 
-function kP(e) {
-    for (var t = this._groups, n = 0, i = t.length; n < i; ++n)
-        for (var r = t[n], s = 0, o = r.length, a; s < o; ++s)
-            (a = r[s]) && e.call(a, a.__data__, s, r);
+function XR(e) {
+    for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
+        for (var i = t[n], s = 0, o = i.length, a; s < o; ++s)
+            (a = i[s]) && e.call(a, a.__data__, s, i);
     return this;
 }
 
-function UP(e) {
+function GR(e) {
     return function() {
         this.removeAttribute(e);
     };
 }
 
-function zP(e) {
+function HR(e) {
     return function() {
         this.removeAttributeNS(e.space, e.local);
     };
 }
 
-function PP(e, t) {
+function JR(e, t) {
     return function() {
         this.setAttribute(e, t);
     };
 }
 
-function VP(e, t) {
+function ZR(e, t) {
     return function() {
         this.setAttributeNS(e.space, e.local, t);
     };
 }
 
-function jP(e, t) {
+function KR(e, t) {
     return function() {
         var n = t.apply(this, arguments);
         n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
     };
 }
 
-function qP(e, t) {
+function QR(e, t) {
     return function() {
         var n = t.apply(this, arguments);
         n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
     };
 }
 
-function YP(e, t) {
-    var n = Jy(e);
+function tF(e, t) {
+    var n = Wh(e);
     if (arguments.length < 2) {
-        var i = this.node();
-        return n.local ? i.getAttributeNS(n.space, n.local) : i.getAttribute(n);
+        var r = this.node();
+        return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
     }
-    return this.each((t == null ? n.local ? zP : UP : typeof t == "function" ? n.local ? qP : jP : n.local ? VP : PP)(n, t));
+    return this.each((t == null ? n.local ? HR : GR : typeof t == "function" ? n.local ? QR : KR : n.local ? ZR : JR)(n, t));
 }
 
-function w3(e) {
+function fS(e) {
     return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
 }
 
-function WP(e) {
+function eF(e) {
     return function() {
         this.style.removeProperty(e);
     };
 }
 
-function GP(e, t, n) {
+function nF(e, t, n) {
     return function() {
         this.style.setProperty(e, t, n);
     };
 }
 
-function XP(e, t, n) {
+function rF(e, t, n) {
     return function() {
-        var i = t.apply(this, arguments);
-        i == null ? this.style.removeProperty(e) : this.style.setProperty(e, i, n);
+        var r = t.apply(this, arguments);
+        r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
     };
 }
 
-function HP(e, t, n) {
-    return arguments.length > 1 ? this.each((t == null ? WP : typeof t == "function" ? XP : GP)(e, t, n ?? "")) : Dc(this.node(), e);
+function iF(e, t, n) {
+    return arguments.length > 1 ? this.each((t == null ? eF : typeof t == "function" ? rF : nF)(e, t, n ?? "")) : Yo(this.node(), e);
 }
 
-function Dc(e, t) {
-    return e.style.getPropertyValue(t) || w3(e).getComputedStyle(e, null).getPropertyValue(t);
+function Yo(e, t) {
+    return e.style.getPropertyValue(t) || fS(e).getComputedStyle(e, null).getPropertyValue(t);
 }
 
-function JP(e) {
+function sF(e) {
     return function() {
         delete this[e];
     };
 }
 
-function KP(e, t) {
+function oF(e, t) {
     return function() {
         this[e] = t;
     };
 }
 
-function ZP(e, t) {
+function aF(e, t) {
     return function() {
         var n = t.apply(this, arguments);
         n == null ? delete this[e] : this[e] = n;
     };
 }
 
-function QP(e, t) {
-    return arguments.length > 1 ? this.each((t == null ? JP : typeof t == "function" ? ZP : KP)(e, t)) : this.node()[e];
+function cF(e, t) {
+    return arguments.length > 1 ? this.each((t == null ? sF : typeof t == "function" ? aF : oF)(e, t)) : this.node()[e];
 }
 
-function v3(e) {
+function hS(e) {
     return e.trim().split(/^|\s+/);
 }
 
-function Gb(e) {
-    return e.classList || new _3(e);
+function $m(e) {
+    return e.classList || new dS(e);
 }
 
-function _3(e) {
-    this._node = e, this._names = v3(e.getAttribute("class") || "");
+function dS(e) {
+    this._node = e, this._names = hS(e.getAttribute("class") || "");
 }
-_3.prototype = {
+dS.prototype = {
     add: function(e) {
         var t = this._names.indexOf(e);
         t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
     },
     remove: function(e) {
         var t = this._names.indexOf(e);
         t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
     },
     contains: function(e) {
         return this._names.indexOf(e) >= 0;
     }
 };
 
-function x3(e, t) {
-    for (var n = Gb(e), i = -1, r = t.length; ++i < r;)
-        n.add(t[i]);
+function pS(e, t) {
+    for (var n = $m(e), r = -1, i = t.length; ++r < i;)
+        n.add(t[r]);
 }
 
-function S3(e, t) {
-    for (var n = Gb(e), i = -1, r = t.length; ++i < r;)
-        n.remove(t[i]);
+function yS(e, t) {
+    for (var n = $m(e), r = -1, i = t.length; ++r < i;)
+        n.remove(t[r]);
 }
 
-function tV(e) {
+function uF(e) {
     return function() {
-        x3(this, e);
+        pS(this, e);
     };
 }
 
-function eV(e) {
+function lF(e) {
     return function() {
-        S3(this, e);
+        yS(this, e);
     };
 }
 
-function nV(e, t) {
+function fF(e, t) {
     return function() {
-        (t.apply(this, arguments) ? x3 : S3)(this, e);
+        (t.apply(this, arguments) ? pS : yS)(this, e);
     };
 }
 
-function iV(e, t) {
-    var n = v3(e + "");
+function hF(e, t) {
+    var n = hS(e + "");
     if (arguments.length < 2) {
-        for (var i = Gb(this.node()), r = -1, s = n.length; ++r < s;)
-            if (!i.contains(n[r]))
+        for (var r = $m(this.node()), i = -1, s = n.length; ++i < s;)
+            if (!r.contains(n[i]))
                 return !1;
         return !0;
     }
-    return this.each((typeof t == "function" ? nV : t ? tV : eV)(n, t));
+    return this.each((typeof t == "function" ? fF : t ? uF : lF)(n, t));
 }
 
-function rV() {
+function dF() {
     this.textContent = "";
 }
 
-function sV(e) {
+function pF(e) {
     return function() {
         this.textContent = e;
     };
 }
 
-function oV(e) {
+function yF(e) {
     return function() {
         var t = e.apply(this, arguments);
         this.textContent = t ?? "";
     };
 }
 
-function aV(e) {
-    return arguments.length ? this.each(e == null ? rV : (typeof e == "function" ? oV : sV)(e)) : this.node().textContent;
+function mF(e) {
+    return arguments.length ? this.each(e == null ? dF : (typeof e == "function" ? yF : pF)(e)) : this.node().textContent;
 }
 
-function cV() {
+function gF() {
     this.innerHTML = "";
 }
 
-function lV(e) {
+function bF(e) {
     return function() {
         this.innerHTML = e;
     };
 }
 
-function uV(e) {
+function wF(e) {
     return function() {
         var t = e.apply(this, arguments);
         this.innerHTML = t ?? "";
     };
 }
 
-function fV(e) {
-    return arguments.length ? this.each(e == null ? cV : (typeof e == "function" ? uV : lV)(e)) : this.node().innerHTML;
+function vF(e) {
+    return arguments.length ? this.each(e == null ? gF : (typeof e == "function" ? wF : bF)(e)) : this.node().innerHTML;
 }
 
-function hV() {
+function _F() {
     this.nextSibling && this.parentNode.appendChild(this);
 }
 
-function dV() {
-    return this.each(hV);
+function xF() {
+    return this.each(_F);
 }
 
-function pV() {
+function SF() {
     this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
 }
 
-function yV() {
-    return this.each(pV);
+function MF() {
+    return this.each(SF);
 }
 
-function mV(e) {
-    var t = typeof e == "function" ? e : Ky(e);
+function AF(e) {
+    var t = typeof e == "function" ? e : Xh(e);
     return this.select(function() {
         return this.appendChild(t.apply(this, arguments));
     });
 }
 
-function gV() {
+function $F() {
     return null;
 }
 
-function bV(e, t) {
-    var n = typeof e == "function" ? e : Ky(e),
-        i = t == null ? gV : typeof t == "function" ? t : Wb(t);
+function IF(e, t) {
+    var n = typeof e == "function" ? e : Xh(e),
+        r = t == null ? $F : typeof t == "function" ? t : Am(t);
     return this.select(function() {
-        return this.insertBefore(n.apply(this, arguments), i.apply(this, arguments) || null);
+        return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
     });
 }
 
-function wV() {
+function TF() {
     var e = this.parentNode;
     e && e.removeChild(this);
 }
 
-function vV() {
-    return this.each(wV);
+function EF() {
+    return this.each(TF);
 }
 
-function _V() {
+function NF() {
     var e = this.cloneNode(!1),
         t = this.parentNode;
     return t ? t.insertBefore(e, this.nextSibling) : e;
 }
 
-function xV() {
+function DF() {
     var e = this.cloneNode(!0),
         t = this.parentNode;
     return t ? t.insertBefore(e, this.nextSibling) : e;
 }
 
-function SV(e) {
-    return this.select(e ? xV : _V);
+function OF(e) {
+    return this.select(e ? DF : NF);
 }
 
-function IV(e) {
+function LF(e) {
     return arguments.length ? this.property("__data__", e) : this.node().__data__;
 }
 
-function AV(e) {
+function kF(e) {
     return function(t) {
         e.call(this, t, this.__data__);
     };
 }
 
-function MV(e) {
+function RF(e) {
     return e.trim().split(/^|\s+/).map(function(t) {
         var n = "",
-            i = t.indexOf(".");
-        return i >= 0 && (n = t.slice(i + 1), t = t.slice(0, i)), {
+            r = t.indexOf(".");
+        return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), {
             type: t,
             name: n
         };
     });
 }
 
-function $V(e) {
+function FF(e) {
     return function() {
         var t = this.__on;
         if (t) {
-            for (var n = 0, i = -1, r = t.length, s; n < r; ++n)
-                s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++i] = s;
-            ++i ? t.length = i : delete this.__on;
+            for (var n = 0, r = -1, i = t.length, s; n < i; ++n)
+                s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
+            ++r ? t.length = r : delete this.__on;
         }
     };
 }
 
-function TV(e, t, n) {
+function BF(e, t, n) {
     return function() {
-        var i = this.__on,
-            r, s = AV(t);
-        if (i) {
-            for (var o = 0, a = i.length; o < a; ++o)
-                if ((r = i[o]).type === e.type && r.name === e.name) {
-                    this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = n), r.value = t;
+        var r = this.__on,
+            i, s = kF(t);
+        if (r) {
+            for (var o = 0, a = r.length; o < a; ++o)
+                if ((i = r[o]).type === e.type && i.name === e.name) {
+                    this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = n), i.value = t;
                     return;
                 }
         }
-        this.addEventListener(e.type, s, n), r = {
+        this.addEventListener(e.type, s, n), i = {
             type: e.type,
             name: e.name,
             value: t,
             listener: s,
             options: n
-        }, i ? i.push(r) : this.__on = [r];
+        }, r ? r.push(i) : this.__on = [i];
     };
 }
 
-function DV(e, t, n) {
-    var i = MV(e + ""),
-        r, s = i.length,
+function CF(e, t, n) {
+    var r = RF(e + ""),
+        i, s = r.length,
         o;
     if (arguments.length < 2) {
         var a = this.node().__on;
         if (a) {
-            for (var c = 0, l = a.length, u; c < l; ++c)
-                for (r = 0, u = a[c]; r < s; ++r)
-                    if ((o = i[r]).type === u.type && o.name === u.name)
-                        return u.value;
+            for (var c = 0, u = a.length, l; c < u; ++c)
+                for (i = 0, l = a[c]; i < s; ++i)
+                    if ((o = r[i]).type === l.type && o.name === l.name)
+                        return l.value;
         }
         return;
     }
-    for (a = t ? TV : $V, r = 0; r < s; ++r)
-        this.each(a(i[r], t, n));
+    for (a = t ? BF : FF, i = 0; i < s; ++i)
+        this.each(a(r[i], t, n));
     return this;
 }
 
-function I3(e, t, n) {
-    var i = w3(e),
-        r = i.CustomEvent;
-    typeof r == "function" ? r = new r(t, n) : (r = i.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r);
+function mS(e, t, n) {
+    var r = fS(e),
+        i = r.CustomEvent;
+    typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
 }
 
-function NV(e, t) {
+function PF(e, t) {
     return function() {
-        return I3(this, e, t);
+        return mS(this, e, t);
     };
 }
 
-function BV(e, t) {
+function UF(e, t) {
     return function() {
-        return I3(this, e, t.apply(this, arguments));
+        return mS(this, e, t.apply(this, arguments));
     };
 }
 
-function OV(e, t) {
-    return this.each((typeof t == "function" ? BV : NV)(e, t));
+function zF(e, t) {
+    return this.each((typeof t == "function" ? UF : PF)(e, t));
 }
 
-function* FV() {
+function* qF() {
     for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
-        for (var i = e[t], r = 0, s = i.length, o; r < s; ++r)
-            (o = i[r]) && (yield o);
+        for (var r = e[t], i = 0, s = r.length, o; i < s; ++i)
+            (o = r[i]) && (yield o);
 }
-var A3 = [null];
+var gS = [null];
 
-function zn(e, t) {
+function cn(e, t) {
     this._groups = e, this._parents = t;
 }
 
-function bf() {
-    return new zn([
+function cu() {
+    return new cn([
         [document.documentElement]
-    ], A3);
+    ], gS);
 }
 
-function EV() {
+function jF() {
     return this;
 }
-zn.prototype = bf.prototype = {
-    constructor: zn,
-    select: oP,
-    selectAll: uP,
-    selectChild: pP,
-    selectChildren: bP,
-    filter: wP,
-    data: AP,
-    enter: vP,
-    exit: $P,
-    join: TP,
-    merge: DP,
-    selection: EV,
-    order: NP,
-    sort: BP,
-    call: FP,
-    nodes: EP,
-    node: LP,
-    size: RP,
-    empty: CP,
-    each: kP,
-    attr: YP,
-    style: HP,
-    property: QP,
-    classed: iV,
-    text: aV,
-    html: fV,
-    raise: dV,
-    lower: yV,
-    append: mV,
-    insert: bV,
-    remove: vV,
-    clone: SV,
-    datum: IV,
-    on: DV,
-    dispatch: OV,
-    [Symbol.iterator]: FV
+cn.prototype = cu.prototype = {
+    constructor: cn,
+    select: yR,
+    selectAll: wR,
+    selectChild: SR,
+    selectChildren: IR,
+    filter: TR,
+    data: kR,
+    enter: ER,
+    exit: FR,
+    join: BR,
+    merge: CR,
+    selection: jF,
+    order: PR,
+    sort: UR,
+    call: qR,
+    nodes: jR,
+    node: VR,
+    size: YR,
+    empty: WR,
+    each: XR,
+    attr: tF,
+    style: iF,
+    property: cF,
+    classed: hF,
+    text: mF,
+    html: vF,
+    raise: xF,
+    lower: MF,
+    append: AF,
+    insert: IF,
+    remove: EF,
+    clone: OF,
+    datum: LF,
+    on: CF,
+    dispatch: zF,
+    [Symbol.iterator]: qF
 };
 
-function ce(e) {
-    return typeof e == "string" ? new zn([
+function Wt(e) {
+    return typeof e == "string" ? new cn([
         [document.querySelector(e)]
-    ], [document.documentElement]) : new zn([
+    ], [document.documentElement]) : new cn([
         [e]
-    ], A3);
+    ], gS);
 }
 
-function LV(e) {
+function VF(e) {
     let t;
     for (; t = e.sourceEvent;)
         e = t;
     return e;
 }
 
-function yi(e, t) {
-    if (e = LV(e), t === void 0 && (t = e.currentTarget), t) {
+function On(e, t) {
+    if (e = VF(e), t === void 0 && (t = e.currentTarget), t) {
         var n = t.ownerSVGElement || t;
         if (n.createSVGPoint) {
-            var i = n.createSVGPoint();
-            return i.x = e.clientX, i.y = e.clientY, i = i.matrixTransform(t.getScreenCTM().inverse()), [i.x, i.y];
+            var r = n.createSVGPoint();
+            return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
         }
         if (t.getBoundingClientRect) {
-            var r = t.getBoundingClientRect();
-            return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop];
+            var i = t.getBoundingClientRect();
+            return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
         }
     }
     return [e.pageX, e.pageY];
 }
-const Ug = {
+const I0 = {
     capture: !0,
     passive: !1
 };
 
-function zg(e) {
+function T0(e) {
     e.preventDefault(), e.stopImmediatePropagation();
 }
 
-function M3(e) {
+function bS(e) {
     var t = e.document.documentElement,
-        n = ce(e).on("dragstart.drag", zg, Ug);
-    "onselectstart" in t ? n.on("selectstart.drag", zg, Ug) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
+        n = Wt(e).on("dragstart.drag", T0, I0);
+    "onselectstart" in t ? n.on("selectstart.drag", T0, I0) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
 }
 
-function $3(e, t) {
+function wS(e, t) {
     var n = e.document.documentElement,
-        i = ce(e).on("dragstart.drag", null);
-    t && (i.on("click.drag", zg, Ug), setTimeout(function() {
-        i.on("click.drag", null);
-    }, 0)), "onselectstart" in n ? i.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
+        r = Wt(e).on("dragstart.drag", null);
+    t && (r.on("click.drag", T0, I0), setTimeout(function() {
+        r.on("click.drag", null);
+    }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
 }
 
-function nl(e, t, n) {
+function pa(e, t, n) {
     e.prototype = t.prototype = n, n.constructor = e;
 }
 
-function wf(e, t) {
+function uu(e, t) {
     var n = Object.create(e.prototype);
-    for (var i in t)
-        n[i] = t[i];
+    for (var r in t)
+        n[r] = t[r];
     return n;
 }
 
-function so() {}
-var Zo = 0.7,
-    Nc = 1 / Zo,
-    fc = "\\s*([+-]?\\d+)\\s*",
-    Eu = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
-    or = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
-    RV = /^#([0-9a-f]{3,8})$/,
-    CV = new RegExp(`^rgb\\(${fc},${fc},${fc}\\)$`),
-    kV = new RegExp(`^rgb\\(${or},${or},${or}\\)$`),
-    UV = new RegExp(`^rgba\\(${fc},${fc},${fc},${Eu}\\)$`),
-    zV = new RegExp(`^rgba\\(${or},${or},${or},${Eu}\\)$`),
-    PV = new RegExp(`^hsl\\(${Eu},${or},${or}\\)$`),
-    VV = new RegExp(`^hsla\\(${Eu},${or},${or},${Eu}\\)$`),
-    d2 = {
+function Hi() {}
+var Ns = 0.7,
+    Wo = 1 / Ns,
+    To = "\\s*([+-]?\\d+)\\s*",
+    Dc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
+    yr = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
+    YF = /^#([0-9a-f]{3,8})$/,
+    WF = new RegExp(`^rgb\\(${To},${To},${To}\\)$`),
+    XF = new RegExp(`^rgb\\(${yr},${yr},${yr}\\)$`),
+    GF = new RegExp(`^rgba\\(${To},${To},${To},${Dc}\\)$`),
+    HF = new RegExp(`^rgba\\(${yr},${yr},${yr},${Dc}\\)$`),
+    JF = new RegExp(`^hsl\\(${Dc},${yr},${yr}\\)$`),
+    ZF = new RegExp(`^hsla\\(${Dc},${yr},${yr},${Dc}\\)$`),
+    Eb = {
         aliceblue: 15792383,
         antiquewhite: 16444375,
         aqua: 65535,
         aquamarine: 8388564,
         azure: 15794175,
         beige: 16119260,
         bisque: 16770244,
@@ -13512,1501 +14075,1501 @@
         violet: 15631086,
         wheat: 16113331,
         white: 16777215,
         whitesmoke: 16119285,
         yellow: 16776960,
         yellowgreen: 10145074
     };
-nl(so, Gs, {
+pa(Hi, Ui, {
     copy(e) {
         return Object.assign(new this.constructor(), this, e);
     },
     displayable() {
         return this.rgb().displayable();
     },
-    hex: p2,
+    hex: Nb,
     // Deprecated! Use color.formatHex.
-    formatHex: p2,
-    formatHex8: jV,
-    formatHsl: qV,
-    formatRgb: y2,
-    toString: y2
+    formatHex: Nb,
+    formatHex8: KF,
+    formatHsl: QF,
+    formatRgb: Db,
+    toString: Db
 });
 
-function p2() {
+function Nb() {
     return this.rgb().formatHex();
 }
 
-function jV() {
+function KF() {
     return this.rgb().formatHex8();
 }
 
-function qV() {
-    return T3(this).formatHsl();
+function QF() {
+    return vS(this).formatHsl();
 }
 
-function y2() {
+function Db() {
     return this.rgb().formatRgb();
 }
 
-function Gs(e) {
+function Ui(e) {
     var t, n;
-    return e = (e + "").trim().toLowerCase(), (t = RV.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? m2(t) : n === 3 ? new qe(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? ah(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? ah(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = CV.exec(e)) ? new qe(t[1], t[2], t[3], 1) : (t = kV.exec(e)) ? new qe(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = UV.exec(e)) ? ah(t[1], t[2], t[3], t[4]) : (t = zV.exec(e)) ? ah(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = PV.exec(e)) ? w2(t[1], t[2] / 100, t[3] / 100, 1) : (t = VV.exec(e)) ? w2(t[1], t[2] / 100, t[3] / 100, t[4]) : d2.hasOwnProperty(e) ? m2(d2[e]) : e === "transparent" ? new qe(NaN, NaN, NaN, 0) : null;
+    return e = (e + "").trim().toLowerCase(), (t = YF.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Ob(t) : n === 3 ? new we(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Wu(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Wu(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = WF.exec(e)) ? new we(t[1], t[2], t[3], 1) : (t = XF.exec(e)) ? new we(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = GF.exec(e)) ? Wu(t[1], t[2], t[3], t[4]) : (t = HF.exec(e)) ? Wu(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = JF.exec(e)) ? Rb(t[1], t[2] / 100, t[3] / 100, 1) : (t = ZF.exec(e)) ? Rb(t[1], t[2] / 100, t[3] / 100, t[4]) : Eb.hasOwnProperty(e) ? Ob(Eb[e]) : e === "transparent" ? new we(NaN, NaN, NaN, 0) : null;
 }
 
-function m2(e) {
-    return new qe(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
+function Ob(e) {
+    return new we(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
 }
 
-function ah(e, t, n, i) {
-    return i <= 0 && (e = t = n = NaN), new qe(e, t, n, i);
+function Wu(e, t, n, r) {
+    return r <= 0 && (e = t = n = NaN), new we(e, t, n, r);
 }
 
-function Xb(e) {
-    return e instanceof so || (e = Gs(e)), e ? (e = e.rgb(), new qe(e.r, e.g, e.b, e.opacity)) : new qe();
+function Im(e) {
+    return e instanceof Hi || (e = Ui(e)), e ? (e = e.rgb(), new we(e.r, e.g, e.b, e.opacity)) : new we();
 }
 
-function Pn(e, t, n, i) {
-    return arguments.length === 1 ? Xb(e) : new qe(e, t, n, i ?? 1);
+function un(e, t, n, r) {
+    return arguments.length === 1 ? Im(e) : new we(e, t, n, r ?? 1);
 }
 
-function qe(e, t, n, i) {
-    this.r = +e, this.g = +t, this.b = +n, this.opacity = +i;
+function we(e, t, n, r) {
+    this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
 }
-nl(qe, Pn, wf(so, {
+pa(we, un, uu(Hi, {
     brighter(e) {
-        return e = e == null ? Nc : Math.pow(Nc, e), new qe(this.r * e, this.g * e, this.b * e, this.opacity);
+        return e = e == null ? Wo : Math.pow(Wo, e), new we(this.r * e, this.g * e, this.b * e, this.opacity);
     },
     darker(e) {
-        return e = e == null ? Zo : Math.pow(Zo, e), new qe(this.r * e, this.g * e, this.b * e, this.opacity);
+        return e = e == null ? Ns : Math.pow(Ns, e), new we(this.r * e, this.g * e, this.b * e, this.opacity);
     },
     rgb() {
         return this;
     },
     clamp() {
-        return new qe(zo(this.r), zo(this.g), zo(this.b), Qd(this.opacity));
+        return new we(ws(this.r), ws(this.g), ws(this.b), $f(this.opacity));
     },
     displayable() {
         return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
     },
-    hex: g2,
+    hex: Lb,
     // Deprecated! Use color.formatHex.
-    formatHex: g2,
-    formatHex8: YV,
-    formatRgb: b2,
-    toString: b2
+    formatHex: Lb,
+    formatHex8: tB,
+    formatRgb: kb,
+    toString: kb
 }));
 
-function g2() {
-    return `#${Oo(this.r)}${Oo(this.g)}${Oo(this.b)}`;
+function Lb() {
+    return `#${ds(this.r)}${ds(this.g)}${ds(this.b)}`;
 }
 
-function YV() {
-    return `#${Oo(this.r)}${Oo(this.g)}${Oo(this.b)}${Oo((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
+function tB() {
+    return `#${ds(this.r)}${ds(this.g)}${ds(this.b)}${ds((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
 }
 
-function b2() {
-    const e = Qd(this.opacity);
-    return `${e === 1 ? "rgb(" : "rgba("}${zo(this.r)}, ${zo(this.g)}, ${zo(this.b)}${e === 1 ? ")" : `, ${e})`}`;
+function kb() {
+    const e = $f(this.opacity);
+    return `${e === 1 ? "rgb(" : "rgba("}${ws(this.r)}, ${ws(this.g)}, ${ws(this.b)}${e === 1 ? ")" : `, ${e})`}`;
 }
 
-function Qd(e) {
+function $f(e) {
     return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
 }
 
-function zo(e) {
+function ws(e) {
     return Math.max(0, Math.min(255, Math.round(e) || 0));
 }
 
-function Oo(e) {
-    return e = zo(e), (e < 16 ? "0" : "") + e.toString(16);
+function ds(e) {
+    return e = ws(e), (e < 16 ? "0" : "") + e.toString(16);
 }
 
-function w2(e, t, n, i) {
-    return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new wi(e, t, n, i);
+function Rb(e, t, n, r) {
+    return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Rn(e, t, n, r);
 }
 
-function T3(e) {
-    if (e instanceof wi)
-        return new wi(e.h, e.s, e.l, e.opacity);
-    if (e instanceof so || (e = Gs(e)), !e)
-        return new wi();
-    if (e instanceof wi)
+function vS(e) {
+    if (e instanceof Rn)
+        return new Rn(e.h, e.s, e.l, e.opacity);
+    if (e instanceof Hi || (e = Ui(e)), !e)
+        return new Rn();
+    if (e instanceof Rn)
         return e;
     e = e.rgb();
     var t = e.r / 255,
         n = e.g / 255,
-        i = e.b / 255,
-        r = Math.min(t, n, i),
-        s = Math.max(t, n, i),
+        r = e.b / 255,
+        i = Math.min(t, n, r),
+        s = Math.max(t, n, r),
         o = NaN,
-        a = s - r,
-        c = (s + r) / 2;
-    return a ? (t === s ? o = (n - i) / a + (n < i) * 6 : n === s ? o = (i - t) / a + 2 : o = (t - n) / a + 4, a /= c < 0.5 ? s + r : 2 - s - r, o *= 60) : a = c > 0 && c < 1 ? 0 : o, new wi(o, a, c, e.opacity);
+        a = s - i,
+        c = (s + i) / 2;
+    return a ? (t === s ? o = (n - r) / a + (n < r) * 6 : n === s ? o = (r - t) / a + 2 : o = (t - n) / a + 4, a /= c < 0.5 ? s + i : 2 - s - i, o *= 60) : a = c > 0 && c < 1 ? 0 : o, new Rn(o, a, c, e.opacity);
 }
 
-function Pg(e, t, n, i) {
-    return arguments.length === 1 ? T3(e) : new wi(e, t, n, i ?? 1);
+function E0(e, t, n, r) {
+    return arguments.length === 1 ? vS(e) : new Rn(e, t, n, r ?? 1);
 }
 
-function wi(e, t, n, i) {
-    this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
+function Rn(e, t, n, r) {
+    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
 }
-nl(wi, Pg, wf(so, {
+pa(Rn, E0, uu(Hi, {
     brighter(e) {
-        return e = e == null ? Nc : Math.pow(Nc, e), new wi(this.h, this.s, this.l * e, this.opacity);
+        return e = e == null ? Wo : Math.pow(Wo, e), new Rn(this.h, this.s, this.l * e, this.opacity);
     },
     darker(e) {
-        return e = e == null ? Zo : Math.pow(Zo, e), new wi(this.h, this.s, this.l * e, this.opacity);
+        return e = e == null ? Ns : Math.pow(Ns, e), new Rn(this.h, this.s, this.l * e, this.opacity);
     },
     rgb() {
         var e = this.h % 360 + (this.h < 0) * 360,
             t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
             n = this.l,
-            i = n + (n < 0.5 ? n : 1 - n) * t,
-            r = 2 * n - i;
-        return new qe(
-            cm(e >= 240 ? e - 240 : e + 120, r, i),
-            cm(e, r, i),
-            cm(e < 120 ? e + 240 : e - 120, r, i),
+            r = n + (n < 0.5 ? n : 1 - n) * t,
+            i = 2 * n - r;
+        return new we(
+            rp(e >= 240 ? e - 240 : e + 120, i, r),
+            rp(e, i, r),
+            rp(e < 120 ? e + 240 : e - 120, i, r),
             this.opacity
         );
     },
     clamp() {
-        return new wi(v2(this.h), ch(this.s), ch(this.l), Qd(this.opacity));
+        return new Rn(Fb(this.h), Xu(this.s), Xu(this.l), $f(this.opacity));
     },
     displayable() {
         return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
     },
     formatHsl() {
-        const e = Qd(this.opacity);
-        return `${e === 1 ? "hsl(" : "hsla("}${v2(this.h)}, ${ch(this.s) * 100}%, ${ch(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
+        const e = $f(this.opacity);
+        return `${e === 1 ? "hsl(" : "hsla("}${Fb(this.h)}, ${Xu(this.s) * 100}%, ${Xu(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
     }
 }));
 
-function v2(e) {
+function Fb(e) {
     return e = (e || 0) % 360, e < 0 ? e + 360 : e;
 }
 
-function ch(e) {
+function Xu(e) {
     return Math.max(0, Math.min(1, e || 0));
 }
 
-function cm(e, t, n) {
+function rp(e, t, n) {
     return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
 }
-const D3 = Math.PI / 180,
-    N3 = 180 / Math.PI,
-    tp = 18,
-    B3 = 0.96422,
-    O3 = 1,
-    F3 = 0.82521,
-    E3 = 4 / 29,
-    hc = 6 / 29,
-    L3 = 3 * hc * hc,
-    WV = hc * hc * hc;
+const _S = Math.PI / 180,
+    xS = 180 / Math.PI,
+    If = 18,
+    SS = 0.96422,
+    MS = 1,
+    AS = 0.82521,
+    $S = 4 / 29,
+    Eo = 6 / 29,
+    IS = 3 * Eo * Eo,
+    eB = Eo * Eo * Eo;
 
-function R3(e) {
-    if (e instanceof ar)
-        return new ar(e.l, e.a, e.b, e.opacity);
-    if (e instanceof Gr)
-        return C3(e);
-    e instanceof qe || (e = Xb(e));
-    var t = hm(e.r),
-        n = hm(e.g),
-        i = hm(e.b),
-        r = lm((0.2225045 * t + 0.7168786 * n + 0.0606169 * i) / O3),
+function TS(e) {
+    if (e instanceof mr)
+        return new mr(e.l, e.a, e.b, e.opacity);
+    if (e instanceof Xr)
+        return ES(e);
+    e instanceof we || (e = Im(e));
+    var t = ap(e.r),
+        n = ap(e.g),
+        r = ap(e.b),
+        i = ip((0.2225045 * t + 0.7168786 * n + 0.0606169 * r) / MS),
         s, o;
-    return t === n && n === i ? s = o = r : (s = lm((0.4360747 * t + 0.3850649 * n + 0.1430804 * i) / B3), o = lm((0.0139322 * t + 0.0971045 * n + 0.7141733 * i) / F3)), new ar(116 * r - 16, 500 * (s - r), 200 * (r - o), e.opacity);
+    return t === n && n === r ? s = o = i : (s = ip((0.4360747 * t + 0.3850649 * n + 0.1430804 * r) / SS), o = ip((0.0139322 * t + 0.0971045 * n + 0.7141733 * r) / AS)), new mr(116 * i - 16, 500 * (s - i), 200 * (i - o), e.opacity);
 }
 
-function Vg(e, t, n, i) {
-    return arguments.length === 1 ? R3(e) : new ar(e, t, n, i ?? 1);
+function N0(e, t, n, r) {
+    return arguments.length === 1 ? TS(e) : new mr(e, t, n, r ?? 1);
 }
 
-function ar(e, t, n, i) {
-    this.l = +e, this.a = +t, this.b = +n, this.opacity = +i;
+function mr(e, t, n, r) {
+    this.l = +e, this.a = +t, this.b = +n, this.opacity = +r;
 }
-nl(ar, Vg, wf(so, {
+pa(mr, N0, uu(Hi, {
     brighter(e) {
-        return new ar(this.l + tp * (e ?? 1), this.a, this.b, this.opacity);
+        return new mr(this.l + If * (e ?? 1), this.a, this.b, this.opacity);
     },
     darker(e) {
-        return new ar(this.l - tp * (e ?? 1), this.a, this.b, this.opacity);
+        return new mr(this.l - If * (e ?? 1), this.a, this.b, this.opacity);
     },
     rgb() {
         var e = (this.l + 16) / 116,
             t = isNaN(this.a) ? e : e + this.a / 500,
             n = isNaN(this.b) ? e : e - this.b / 200;
-        return t = B3 * um(t), e = O3 * um(e), n = F3 * um(n), new qe(
-            fm(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
-            fm(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
-            fm(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
+        return t = SS * sp(t), e = MS * sp(e), n = AS * sp(n), new we(
+            op(3.1338561 * t - 1.6168667 * e - 0.4906146 * n),
+            op(-0.9787684 * t + 1.9161415 * e + 0.033454 * n),
+            op(0.0719453 * t - 0.2289914 * e + 1.4052427 * n),
             this.opacity
         );
     }
 }));
 
-function lm(e) {
-    return e > WV ? Math.pow(e, 1 / 3) : e / L3 + E3;
+function ip(e) {
+    return e > eB ? Math.pow(e, 1 / 3) : e / IS + $S;
 }
 
-function um(e) {
-    return e > hc ? e * e * e : L3 * (e - E3);
+function sp(e) {
+    return e > Eo ? e * e * e : IS * (e - $S);
 }
 
-function fm(e) {
+function op(e) {
     return 255 * (e <= 31308e-7 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
 }
 
-function hm(e) {
+function ap(e) {
     return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
 }
 
-function GV(e) {
-    if (e instanceof Gr)
-        return new Gr(e.h, e.c, e.l, e.opacity);
-    if (e instanceof ar || (e = R3(e)), e.a === 0 && e.b === 0)
-        return new Gr(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
-    var t = Math.atan2(e.b, e.a) * N3;
-    return new Gr(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
+function nB(e) {
+    if (e instanceof Xr)
+        return new Xr(e.h, e.c, e.l, e.opacity);
+    if (e instanceof mr || (e = TS(e)), e.a === 0 && e.b === 0)
+        return new Xr(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
+    var t = Math.atan2(e.b, e.a) * xS;
+    return new Xr(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
 }
 
-function jg(e, t, n, i) {
-    return arguments.length === 1 ? GV(e) : new Gr(e, t, n, i ?? 1);
+function D0(e, t, n, r) {
+    return arguments.length === 1 ? nB(e) : new Xr(e, t, n, r ?? 1);
 }
 
-function Gr(e, t, n, i) {
-    this.h = +e, this.c = +t, this.l = +n, this.opacity = +i;
+function Xr(e, t, n, r) {
+    this.h = +e, this.c = +t, this.l = +n, this.opacity = +r;
 }
 
-function C3(e) {
+function ES(e) {
     if (isNaN(e.h))
-        return new ar(e.l, 0, 0, e.opacity);
-    var t = e.h * D3;
-    return new ar(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
+        return new mr(e.l, 0, 0, e.opacity);
+    var t = e.h * _S;
+    return new mr(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
 }
-nl(Gr, jg, wf(so, {
+pa(Xr, D0, uu(Hi, {
     brighter(e) {
-        return new Gr(this.h, this.c, this.l + tp * (e ?? 1), this.opacity);
+        return new Xr(this.h, this.c, this.l + If * (e ?? 1), this.opacity);
     },
     darker(e) {
-        return new Gr(this.h, this.c, this.l - tp * (e ?? 1), this.opacity);
+        return new Xr(this.h, this.c, this.l - If * (e ?? 1), this.opacity);
     },
     rgb() {
-        return C3(this).rgb();
+        return ES(this).rgb();
     }
 }));
-var k3 = -0.14861,
-    Hb = 1.78277,
-    Jb = -0.29227,
-    Zy = -0.90649,
-    Lu = 1.97294,
-    _2 = Lu * Zy,
-    x2 = Lu * Hb,
-    S2 = Hb * Jb - Zy * k3;
-
-function XV(e) {
-    if (e instanceof Po)
-        return new Po(e.h, e.s, e.l, e.opacity);
-    e instanceof qe || (e = Xb(e));
+var NS = -0.14861,
+    Tm = 1.78277,
+    Em = -0.29227,
+    Gh = -0.90649,
+    Oc = 1.97294,
+    Bb = Oc * Gh,
+    Cb = Oc * Tm,
+    Pb = Tm * Em - Gh * NS;
+
+function rB(e) {
+    if (e instanceof vs)
+        return new vs(e.h, e.s, e.l, e.opacity);
+    e instanceof we || (e = Im(e));
     var t = e.r / 255,
         n = e.g / 255,
-        i = e.b / 255,
-        r = (S2 * i + _2 * t - x2 * n) / (S2 + _2 - x2),
-        s = i - r,
-        o = (Lu * (n - r) - Jb * s) / Zy,
-        a = Math.sqrt(o * o + s * s) / (Lu * r * (1 - r)),
-        c = a ? Math.atan2(o, s) * N3 - 120 : NaN;
-    return new Po(c < 0 ? c + 360 : c, a, r, e.opacity);
+        r = e.b / 255,
+        i = (Pb * r + Bb * t - Cb * n) / (Pb + Bb - Cb),
+        s = r - i,
+        o = (Oc * (n - i) - Em * s) / Gh,
+        a = Math.sqrt(o * o + s * s) / (Oc * i * (1 - i)),
+        c = a ? Math.atan2(o, s) * xS - 120 : NaN;
+    return new vs(c < 0 ? c + 360 : c, a, i, e.opacity);
 }
 
-function hr(e, t, n, i) {
-    return arguments.length === 1 ? XV(e) : new Po(e, t, n, i ?? 1);
+function vr(e, t, n, r) {
+    return arguments.length === 1 ? rB(e) : new vs(e, t, n, r ?? 1);
 }
 
-function Po(e, t, n, i) {
-    this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
+function vs(e, t, n, r) {
+    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
 }
-nl(Po, hr, wf(so, {
+pa(vs, vr, uu(Hi, {
     brighter(e) {
-        return e = e == null ? Nc : Math.pow(Nc, e), new Po(this.h, this.s, this.l * e, this.opacity);
+        return e = e == null ? Wo : Math.pow(Wo, e), new vs(this.h, this.s, this.l * e, this.opacity);
     },
     darker(e) {
-        return e = e == null ? Zo : Math.pow(Zo, e), new Po(this.h, this.s, this.l * e, this.opacity);
+        return e = e == null ? Ns : Math.pow(Ns, e), new vs(this.h, this.s, this.l * e, this.opacity);
     },
     rgb() {
-        var e = isNaN(this.h) ? 0 : (this.h + 120) * D3,
+        var e = isNaN(this.h) ? 0 : (this.h + 120) * _S,
             t = +this.l,
             n = isNaN(this.s) ? 0 : this.s * t * (1 - t),
-            i = Math.cos(e),
-            r = Math.sin(e);
-        return new qe(
-            255 * (t + n * (k3 * i + Hb * r)),
-            255 * (t + n * (Jb * i + Zy * r)),
-            255 * (t + n * (Lu * i)),
+            r = Math.cos(e),
+            i = Math.sin(e);
+        return new we(
+            255 * (t + n * (NS * r + Tm * i)),
+            255 * (t + n * (Em * r + Gh * i)),
+            255 * (t + n * (Oc * r)),
             this.opacity
         );
     }
 }));
 
-function HV(e, t, n, i, r) {
+function iB(e, t, n, r, i) {
     var s = e * e,
         o = s * e;
-    return ((1 - 3 * e + 3 * s - o) * t + (4 - 6 * s + 3 * o) * n + (1 + 3 * e + 3 * s - 3 * o) * i + o * r) / 6;
+    return ((1 - 3 * e + 3 * s - o) * t + (4 - 6 * s + 3 * o) * n + (1 + 3 * e + 3 * s - 3 * o) * r + o * i) / 6;
 }
 
-function JV(e) {
+function sB(e) {
     var t = e.length - 1;
     return function(n) {
-        var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t),
-            r = e[i],
-            s = e[i + 1],
-            o = i > 0 ? e[i - 1] : 2 * r - s,
-            a = i < t - 1 ? e[i + 2] : 2 * s - r;
-        return HV((n - i / t) * t, o, r, s, a);
+        var r = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t),
+            i = e[r],
+            s = e[r + 1],
+            o = r > 0 ? e[r - 1] : 2 * i - s,
+            a = r < t - 1 ? e[r + 2] : 2 * s - i;
+        return iB((n - r / t) * t, o, i, s, a);
     };
 }
-const Qy = (e) => () => e;
+const Hh = (e) => () => e;
 
-function U3(e, t) {
+function DS(e, t) {
     return function(n) {
         return e + n * t;
     };
 }
 
-function KV(e, t, n) {
+function oB(e, t, n) {
     return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n,
-        function(i) {
-            return Math.pow(e + i * t, n);
+        function(r) {
+            return Math.pow(e + r * t, n);
         };
 }
 
-function Kb(e, t) {
+function Nm(e, t) {
     var n = t - e;
-    return n ? U3(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : Qy(isNaN(e) ? t : e);
+    return n ? DS(e, n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) : Hh(isNaN(e) ? t : e);
 }
 
-function ZV(e) {
-    return (e = +e) == 1 ? en : function(t, n) {
-        return n - t ? KV(t, n, e) : Qy(isNaN(t) ? n : t);
+function aB(e) {
+    return (e = +e) == 1 ? Ne : function(t, n) {
+        return n - t ? oB(t, n, e) : Hh(isNaN(t) ? n : t);
     };
 }
 
-function en(e, t) {
+function Ne(e, t) {
     var n = t - e;
-    return n ? U3(e, n) : Qy(isNaN(e) ? t : e);
+    return n ? DS(e, n) : Hh(isNaN(e) ? t : e);
 }
-const Qo = function e(t) {
-    var n = ZV(t);
+const Ds = function e(t) {
+    var n = aB(t);
 
-    function i(r, s) {
-        var o = n((r = Pn(r)).r, (s = Pn(s)).r),
-            a = n(r.g, s.g),
-            c = n(r.b, s.b),
-            l = en(r.opacity, s.opacity);
-        return function(u) {
-            return r.r = o(u), r.g = a(u), r.b = c(u), r.opacity = l(u), r + "";
+    function r(i, s) {
+        var o = n((i = un(i)).r, (s = un(s)).r),
+            a = n(i.g, s.g),
+            c = n(i.b, s.b),
+            u = Ne(i.opacity, s.opacity);
+        return function(l) {
+            return i.r = o(l), i.g = a(l), i.b = c(l), i.opacity = u(l), i + "";
         };
     }
-    return i.gamma = e, i;
+    return r.gamma = e, r;
 }(1);
 
-function QV(e) {
+function cB(e) {
     return function(t) {
         var n = t.length,
-            i = new Array(n),
             r = new Array(n),
+            i = new Array(n),
             s = new Array(n),
             o, a;
         for (o = 0; o < n; ++o)
-            a = Pn(t[o]), i[o] = a.r || 0, r[o] = a.g || 0, s[o] = a.b || 0;
-        return i = e(i), r = e(r), s = e(s), a.opacity = 1,
+            a = un(t[o]), r[o] = a.r || 0, i[o] = a.g || 0, s[o] = a.b || 0;
+        return r = e(r), i = e(i), s = e(s), a.opacity = 1,
             function(c) {
-                return a.r = i(c), a.g = r(c), a.b = s(c), a + "";
+                return a.r = r(c), a.g = i(c), a.b = s(c), a + "";
             };
     };
 }
-var tj = QV(JV);
+var uB = cB(sB);
 
-function ej(e, t) {
+function lB(e, t) {
     t || (t = []);
     var n = e ? Math.min(t.length, e.length) : 0,
-        i = t.slice(),
-        r;
+        r = t.slice(),
+        i;
     return function(s) {
-        for (r = 0; r < n; ++r)
-            i[r] = e[r] * (1 - s) + t[r] * s;
-        return i;
+        for (i = 0; i < n; ++i)
+            r[i] = e[i] * (1 - s) + t[i] * s;
+        return r;
     };
 }
 
-function nj(e) {
+function fB(e) {
     return ArrayBuffer.isView(e) && !(e instanceof DataView);
 }
 
-function ij(e, t) {
+function hB(e, t) {
     var n = t ? t.length : 0,
-        i = e ? Math.min(n, e.length) : 0,
-        r = new Array(i),
+        r = e ? Math.min(n, e.length) : 0,
+        i = new Array(r),
         s = new Array(n),
         o;
-    for (o = 0; o < i; ++o)
-        r[o] = il(e[o], t[o]);
+    for (o = 0; o < r; ++o)
+        i[o] = ya(e[o], t[o]);
     for (; o < n; ++o)
         s[o] = t[o];
     return function(a) {
-        for (o = 0; o < i; ++o)
-            s[o] = r[o](a);
+        for (o = 0; o < r; ++o)
+            s[o] = i[o](a);
         return s;
     };
 }
 
-function rj(e, t) {
+function dB(e, t) {
     var n = /* @__PURE__ */ new Date();
     return e = +e, t = +t,
-        function(i) {
-            return n.setTime(e * (1 - i) + t * i), n;
+        function(r) {
+            return n.setTime(e * (1 - r) + t * r), n;
         };
 }
 
-function Qe(e, t) {
+function Te(e, t) {
     return e = +e, t = +t,
         function(n) {
             return e * (1 - n) + t * n;
         };
 }
 
-function sj(e, t) {
+function pB(e, t) {
     var n = {},
-        i = {},
-        r;
+        r = {},
+        i;
     (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
-    for (r in t)
-        r in e ? n[r] = il(e[r], t[r]) : i[r] = t[r];
+    for (i in t)
+        i in e ? n[i] = ya(e[i], t[i]) : r[i] = t[i];
     return function(s) {
-        for (r in n)
-            i[r] = n[r](s);
-        return i;
+        for (i in n)
+            r[i] = n[i](s);
+        return r;
     };
 }
-var qg = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
-    dm = new RegExp(qg.source, "g");
+var O0 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
+    cp = new RegExp(O0.source, "g");
 
-function oj(e) {
+function yB(e) {
     return function() {
         return e;
     };
 }
 
-function aj(e) {
+function mB(e) {
     return function(t) {
         return e(t) + "";
     };
 }
 
-function z3(e, t) {
-    var n = qg.lastIndex = dm.lastIndex = 0,
-        i, r, s, o = -1,
+function OS(e, t) {
+    var n = O0.lastIndex = cp.lastIndex = 0,
+        r, i, s, o = -1,
         a = [],
         c = [];
     for (e = e + "", t = t + "";
-        (i = qg.exec(e)) && (r = dm.exec(t));)
-        (s = r.index) > n && (s = t.slice(n, s), a[o] ? a[o] += s : a[++o] = s), (i = i[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, c.push({
+        (r = O0.exec(e)) && (i = cp.exec(t));)
+        (s = i.index) > n && (s = t.slice(n, s), a[o] ? a[o] += s : a[++o] = s), (r = r[0]) === (i = i[0]) ? a[o] ? a[o] += i : a[++o] = i : (a[++o] = null, c.push({
             i: o,
-            x: Qe(i, r)
-        })), n = dm.lastIndex;
-    return n < t.length && (s = t.slice(n), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? c[0] ? aj(c[0].x) : oj(t) : (t = c.length, function(l) {
-        for (var u = 0, f; u < t; ++u)
-            a[(f = c[u]).i] = f.x(l);
+            x: Te(r, i)
+        })), n = cp.lastIndex;
+    return n < t.length && (s = t.slice(n), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? c[0] ? mB(c[0].x) : yB(t) : (t = c.length, function(u) {
+        for (var l = 0, f; l < t; ++l)
+            a[(f = c[l]).i] = f.x(u);
         return a.join("");
     });
 }
 
-function il(e, t) {
+function ya(e, t) {
     var n = typeof t,
-        i;
-    return t == null || n === "boolean" ? Qy(t) : (n === "number" ? Qe : n === "string" ? (i = Gs(t)) ? (t = i, Qo) : z3 : t instanceof Gs ? Qo : t instanceof Date ? rj : nj(t) ? ej : Array.isArray(t) ? ij : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? sj : Qe)(e, t);
+        r;
+    return t == null || n === "boolean" ? Hh(t) : (n === "number" ? Te : n === "string" ? (r = Ui(t)) ? (t = r, Ds) : OS : t instanceof Ui ? Ds : t instanceof Date ? dB : fB(t) ? lB : Array.isArray(t) ? hB : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? pB : Te)(e, t);
 }
 
-function Zb(e, t) {
+function Dm(e, t) {
     return e = +e, t = +t,
         function(n) {
             return Math.round(e * (1 - n) + t * n);
         };
 }
-var I2 = 180 / Math.PI,
-    Yg = {
+var Ub = 180 / Math.PI,
+    L0 = {
         translateX: 0,
         translateY: 0,
         rotate: 0,
         skewX: 0,
         scaleX: 1,
         scaleY: 1
     };
 
-function P3(e, t, n, i, r, s) {
+function LS(e, t, n, r, i, s) {
     var o, a, c;
-    return (o = Math.sqrt(e * e + t * t)) && (e /= o, t /= o), (c = e * n + t * i) && (n -= e * c, i -= t * c), (a = Math.sqrt(n * n + i * i)) && (n /= a, i /= a, c /= a), e * i < t * n && (e = -e, t = -t, c = -c, o = -o), {
-        translateX: r,
+    return (o = Math.sqrt(e * e + t * t)) && (e /= o, t /= o), (c = e * n + t * r) && (n -= e * c, r -= t * c), (a = Math.sqrt(n * n + r * r)) && (n /= a, r /= a, c /= a), e * r < t * n && (e = -e, t = -t, c = -c, o = -o), {
+        translateX: i,
         translateY: s,
-        rotate: Math.atan2(t, e) * I2,
-        skewX: Math.atan(c) * I2,
+        rotate: Math.atan2(t, e) * Ub,
+        skewX: Math.atan(c) * Ub,
         scaleX: o,
         scaleY: a
     };
 }
-var lh;
+var Gu;
 
-function cj(e) {
+function gB(e) {
     const t = new(typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
-    return t.isIdentity ? Yg : P3(t.a, t.b, t.c, t.d, t.e, t.f);
+    return t.isIdentity ? L0 : LS(t.a, t.b, t.c, t.d, t.e, t.f);
 }
 
-function lj(e) {
-    return e == null || (lh || (lh = document.createElementNS("http://www.w3.org/2000/svg", "g")), lh.setAttribute("transform", e), !(e = lh.transform.baseVal.consolidate())) ? Yg : (e = e.matrix, P3(e.a, e.b, e.c, e.d, e.e, e.f));
+function bB(e) {
+    return e == null || (Gu || (Gu = document.createElementNS("http://www.w3.org/2000/svg", "g")), Gu.setAttribute("transform", e), !(e = Gu.transform.baseVal.consolidate())) ? L0 : (e = e.matrix, LS(e.a, e.b, e.c, e.d, e.e, e.f));
 }
 
-function V3(e, t, n, i) {
-    function r(l) {
-        return l.length ? l.pop() + " " : "";
+function kS(e, t, n, r) {
+    function i(u) {
+        return u.length ? u.pop() + " " : "";
     }
 
-    function s(l, u, f, h, d, p) {
-        if (l !== f || u !== h) {
-            var m = d.push("translate(", null, t, null, n);
+    function s(u, l, f, h, d, p) {
+        if (u !== f || l !== h) {
+            var y = d.push("translate(", null, t, null, n);
             p.push({
-                i: m - 4,
-                x: Qe(l, f)
+                i: y - 4,
+                x: Te(u, f)
             }, {
-                i: m - 2,
-                x: Qe(u, h)
+                i: y - 2,
+                x: Te(l, h)
             });
         } else
             (f || h) && d.push("translate(" + f + t + h + n);
     }
 
-    function o(l, u, f, h) {
-        l !== u ? (l - u > 180 ? u += 360 : u - l > 180 && (l += 360), h.push({
-            i: f.push(r(f) + "rotate(", null, i) - 2,
-            x: Qe(l, u)
-        })) : u && f.push(r(f) + "rotate(" + u + i);
-    }
-
-    function a(l, u, f, h) {
-        l !== u ? h.push({
-            i: f.push(r(f) + "skewX(", null, i) - 2,
-            x: Qe(l, u)
-        }) : u && f.push(r(f) + "skewX(" + u + i);
-    }
-
-    function c(l, u, f, h, d, p) {
-        if (l !== f || u !== h) {
-            var m = d.push(r(d) + "scale(", null, ",", null, ")");
+    function o(u, l, f, h) {
+        u !== l ? (u - l > 180 ? l += 360 : l - u > 180 && (u += 360), h.push({
+            i: f.push(i(f) + "rotate(", null, r) - 2,
+            x: Te(u, l)
+        })) : l && f.push(i(f) + "rotate(" + l + r);
+    }
+
+    function a(u, l, f, h) {
+        u !== l ? h.push({
+            i: f.push(i(f) + "skewX(", null, r) - 2,
+            x: Te(u, l)
+        }) : l && f.push(i(f) + "skewX(" + l + r);
+    }
+
+    function c(u, l, f, h, d, p) {
+        if (u !== f || l !== h) {
+            var y = d.push(i(d) + "scale(", null, ",", null, ")");
             p.push({
-                i: m - 4,
-                x: Qe(l, f)
+                i: y - 4,
+                x: Te(u, f)
             }, {
-                i: m - 2,
-                x: Qe(u, h)
+                i: y - 2,
+                x: Te(l, h)
             });
         } else
-            (f !== 1 || h !== 1) && d.push(r(d) + "scale(" + f + "," + h + ")");
+            (f !== 1 || h !== 1) && d.push(i(d) + "scale(" + f + "," + h + ")");
     }
-    return function(l, u) {
+    return function(u, l) {
         var f = [],
             h = [];
-        return l = e(l), u = e(u), s(l.translateX, l.translateY, u.translateX, u.translateY, f, h), o(l.rotate, u.rotate, f, h), a(l.skewX, u.skewX, f, h), c(l.scaleX, l.scaleY, u.scaleX, u.scaleY, f, h), l = u = null,
+        return u = e(u), l = e(l), s(u.translateX, u.translateY, l.translateX, l.translateY, f, h), o(u.rotate, l.rotate, f, h), a(u.skewX, l.skewX, f, h), c(u.scaleX, u.scaleY, l.scaleX, l.scaleY, f, h), u = l = null,
             function(d) {
-                for (var p = -1, m = h.length, g; ++p < m;)
-                    f[(g = h[p]).i] = g.x(d);
+                for (var p = -1, y = h.length, m; ++p < y;)
+                    f[(m = h[p]).i] = m.x(d);
                 return f.join("");
             };
     };
 }
-var uj = V3(cj, "px, ", "px)", "deg)"),
-    fj = V3(lj, ", ", ")", ")"),
-    hj = 1e-12;
+var wB = kS(gB, "px, ", "px)", "deg)"),
+    vB = kS(bB, ", ", ")", ")"),
+    _B = 1e-12;
 
-function A2(e) {
+function zb(e) {
     return ((e = Math.exp(e)) + 1 / e) / 2;
 }
 
-function dj(e) {
+function xB(e) {
     return ((e = Math.exp(e)) - 1 / e) / 2;
 }
 
-function pj(e) {
+function SB(e) {
     return ((e = Math.exp(2 * e)) - 1) / (e + 1);
 }
-const yj = function e(t, n, i) {
-    function r(s, o) {
+const MB = function e(t, n, r) {
+    function i(s, o) {
         var a = s[0],
             c = s[1],
-            l = s[2],
-            u = o[0],
+            u = s[2],
+            l = o[0],
             f = o[1],
             h = o[2],
-            d = u - a,
+            d = l - a,
             p = f - c,
-            m = d * d + p * p,
-            g, y;
-        if (m < hj)
-            y = Math.log(h / l) / t, g = function(I) {
+            y = d * d + p * p,
+            m, g;
+        if (y < _B)
+            g = Math.log(h / u) / t, m = function(M) {
                 return [
-                    a + I * d,
-                    c + I * p,
-                    l * Math.exp(t * I * y)
+                    a + M * d,
+                    c + M * p,
+                    u * Math.exp(t * M * g)
                 ];
             };
         else {
-            var b = Math.sqrt(m),
-                w = (h * h - l * l + i * m) / (2 * l * n * b),
-                v = (h * h - l * l - i * m) / (2 * h * n * b),
+            var b = Math.sqrt(y),
+                w = (h * h - u * u + r * y) / (2 * u * n * b),
+                v = (h * h - u * u - r * y) / (2 * h * n * b),
                 x = Math.log(Math.sqrt(w * w + 1) - w),
                 _ = Math.log(Math.sqrt(v * v + 1) - v);
-            y = (_ - x) / t, g = function(I) {
-                var A = I * y,
-                    M = A2(x),
-                    N = l / (n * b) * (M * pj(t * A + x) - dj(x));
+            g = (_ - x) / t, m = function(M) {
+                var T = M * g,
+                    $ = zb(x),
+                    N = u / (n * b) * ($ * SB(t * T + x) - xB(x));
                 return [
                     a + N * d,
                     c + N * p,
-                    l * M / A2(t * A + x)
+                    u * $ / zb(t * T + x)
                 ];
             };
         }
-        return g.duration = y * 1e3 * t / Math.SQRT2, g;
+        return m.duration = g * 1e3 * t / Math.SQRT2, m;
     }
-    return r.rho = function(s) {
+    return i.rho = function(s) {
         var o = Math.max(1e-3, +s),
             a = o * o,
             c = a * a;
         return e(o, a, c);
-    }, r;
+    }, i;
 }(Math.SQRT2, 2, 4);
 
-function mj(e) {
+function AB(e) {
     return function(t, n) {
-        var i = e((t = Pg(t)).h, (n = Pg(n)).h),
-            r = en(t.s, n.s),
-            s = en(t.l, n.l),
-            o = en(t.opacity, n.opacity);
+        var r = e((t = E0(t)).h, (n = E0(n)).h),
+            i = Ne(t.s, n.s),
+            s = Ne(t.l, n.l),
+            o = Ne(t.opacity, n.opacity);
         return function(a) {
-            return t.h = i(a), t.s = r(a), t.l = s(a), t.opacity = o(a), t + "";
+            return t.h = r(a), t.s = i(a), t.l = s(a), t.opacity = o(a), t + "";
         };
     };
 }
-const gj = mj(Kb);
+const $B = AB(Nm);
 
-function bj(e, t) {
-    var n = en((e = Vg(e)).l, (t = Vg(t)).l),
-        i = en(e.a, t.a),
-        r = en(e.b, t.b),
-        s = en(e.opacity, t.opacity);
+function IB(e, t) {
+    var n = Ne((e = N0(e)).l, (t = N0(t)).l),
+        r = Ne(e.a, t.a),
+        i = Ne(e.b, t.b),
+        s = Ne(e.opacity, t.opacity);
     return function(o) {
-        return e.l = n(o), e.a = i(o), e.b = r(o), e.opacity = s(o), e + "";
+        return e.l = n(o), e.a = r(o), e.b = i(o), e.opacity = s(o), e + "";
     };
 }
 
-function wj(e) {
+function TB(e) {
     return function(t, n) {
-        var i = e((t = jg(t)).h, (n = jg(n)).h),
-            r = en(t.c, n.c),
-            s = en(t.l, n.l),
-            o = en(t.opacity, n.opacity);
+        var r = e((t = D0(t)).h, (n = D0(n)).h),
+            i = Ne(t.c, n.c),
+            s = Ne(t.l, n.l),
+            o = Ne(t.opacity, n.opacity);
         return function(a) {
-            return t.h = i(a), t.c = r(a), t.l = s(a), t.opacity = o(a), t + "";
+            return t.h = r(a), t.c = i(a), t.l = s(a), t.opacity = o(a), t + "";
         };
     };
 }
-const vj = wj(Kb);
+const EB = TB(Nm);
 
-function j3(e) {
+function RS(e) {
     return function t(n) {
         n = +n;
 
-        function i(r, s) {
-            var o = e((r = hr(r)).h, (s = hr(s)).h),
-                a = en(r.s, s.s),
-                c = en(r.l, s.l),
-                l = en(r.opacity, s.opacity);
-            return function(u) {
-                return r.h = o(u), r.s = a(u), r.l = c(Math.pow(u, n)), r.opacity = l(u), r + "";
+        function r(i, s) {
+            var o = e((i = vr(i)).h, (s = vr(s)).h),
+                a = Ne(i.s, s.s),
+                c = Ne(i.l, s.l),
+                u = Ne(i.opacity, s.opacity);
+            return function(l) {
+                return i.h = o(l), i.s = a(l), i.l = c(Math.pow(l, n)), i.opacity = u(l), i + "";
             };
         }
-        return i.gamma = t, i;
+        return r.gamma = t, r;
     }(1);
 }
-j3(Kb);
-var Qb = j3(en);
+RS(Nm);
+var Om = RS(Ne);
 
-function t0(e, t) {
-    t === void 0 && (t = e, e = il);
-    for (var n = 0, i = t.length - 1, r = t[0], s = new Array(i < 0 ? 0 : i); n < i;)
-        s[n] = e(r, r = t[++n]);
+function Jh(e, t) {
+    t === void 0 && (t = e, e = ya);
+    for (var n = 0, r = t.length - 1, i = t[0], s = new Array(r < 0 ? 0 : r); n < r;)
+        s[n] = e(i, i = t[++n]);
     return function(o) {
-        var a = Math.max(0, Math.min(i - 1, Math.floor(o *= i)));
+        var a = Math.max(0, Math.min(r - 1, Math.floor(o *= r)));
         return s[a](o - a);
     };
 }
 
-function $i(e, t) {
-    for (var n = new Array(t), i = 0; i < t; ++i)
-        n[i] = e(i / (t - 1));
+function jn(e, t) {
+    for (var n = new Array(t), r = 0; r < t; ++r)
+        n[r] = e(r / (t - 1));
     return n;
 }
-var Bc = 0,
-    Yl = 0,
-    _l = 0,
-    q3 = 1e3,
-    ep, Wl, np = 0,
-    ta = 0,
-    e0 = 0,
-    Ru = typeof performance == "object" && performance.now ? performance : Date,
-    Y3 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
+var Xo = 0,
+    Za = 0,
+    Oa = 0,
+    FS = 1e3,
+    Tf, Ka, Ef = 0,
+    Os = 0,
+    Zh = 0,
+    Lc = typeof performance == "object" && performance.now ? performance : Date,
+    BS = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
         setTimeout(e, 17);
     };
 
-function tw() {
-    return ta || (Y3(_j), ta = Ru.now() + e0);
+function Lm() {
+    return Os || (BS(NB), Os = Lc.now() + Zh);
 }
 
-function _j() {
-    ta = 0;
+function NB() {
+    Os = 0;
 }
 
-function ip() {
+function Nf() {
     this._call = this._time = this._next = null;
 }
-ip.prototype = W3.prototype = {
-    constructor: ip,
+Nf.prototype = CS.prototype = {
+    constructor: Nf,
     restart: function(e, t, n) {
         if (typeof e != "function")
             throw new TypeError("callback is not a function");
-        n = (n == null ? tw() : +n) + (t == null ? 0 : +t), !this._next && Wl !== this && (Wl ? Wl._next = this : ep = this, Wl = this), this._call = e, this._time = n, Wg();
+        n = (n == null ? Lm() : +n) + (t == null ? 0 : +t), !this._next && Ka !== this && (Ka ? Ka._next = this : Tf = this, Ka = this), this._call = e, this._time = n, k0();
     },
     stop: function() {
-        this._call && (this._call = null, this._time = 1 / 0, Wg());
+        this._call && (this._call = null, this._time = 1 / 0, k0());
     }
 };
 
-function W3(e, t, n) {
-    var i = new ip();
-    return i.restart(e, t, n), i;
+function CS(e, t, n) {
+    var r = new Nf();
+    return r.restart(e, t, n), r;
 }
 
-function xj() {
-    tw(), ++Bc;
-    for (var e = ep, t; e;)
-        (t = ta - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
-    --Bc;
+function DB() {
+    Lm(), ++Xo;
+    for (var e = Tf, t; e;)
+        (t = Os - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
+    --Xo;
 }
 
-function M2() {
-    ta = (np = Ru.now()) + e0, Bc = Yl = 0;
+function qb() {
+    Os = (Ef = Lc.now()) + Zh, Xo = Za = 0;
     try {
-        xj();
+        DB();
     } finally {
-        Bc = 0, Ij(), ta = 0;
+        Xo = 0, LB(), Os = 0;
     }
 }
 
-function Sj() {
-    var e = Ru.now(),
-        t = e - np;
-    t > q3 && (e0 -= t, np = e);
+function OB() {
+    var e = Lc.now(),
+        t = e - Ef;
+    t > FS && (Zh -= t, Ef = e);
 }
 
-function Ij() {
-    for (var e, t = ep, n, i = 1 / 0; t;)
-        t._call ? (i > t._time && (i = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : ep = n);
-    Wl = e, Wg(i);
+function LB() {
+    for (var e, t = Tf, n, r = 1 / 0; t;)
+        t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Tf = n);
+    Ka = e, k0(r);
 }
 
-function Wg(e) {
-    if (!Bc) {
-        Yl && (Yl = clearTimeout(Yl));
-        var t = e - ta;
-        t > 24 ? (e < 1 / 0 && (Yl = setTimeout(M2, e - Ru.now() - e0)), _l && (_l = clearInterval(_l))) : (_l || (np = Ru.now(), _l = setInterval(Sj, q3)), Bc = 1, Y3(M2));
+function k0(e) {
+    if (!Xo) {
+        Za && (Za = clearTimeout(Za));
+        var t = e - Os;
+        t > 24 ? (e < 1 / 0 && (Za = setTimeout(qb, e - Lc.now() - Zh)), Oa && (Oa = clearInterval(Oa))) : (Oa || (Ef = Lc.now(), Oa = setInterval(OB, FS)), Xo = 1, BS(qb));
     }
 }
 
-function $2(e, t, n) {
-    var i = new ip();
-    return t = t == null ? 0 : +t, i.restart((r) => {
-        i.stop(), e(r + t);
-    }, t, n), i;
-}
-var Aj = Hy("start", "end", "cancel", "interrupt"),
-    Mj = [],
-    G3 = 0,
-    T2 = 1,
-    Gg = 2,
-    td = 3,
-    D2 = 4,
-    Xg = 5,
-    ed = 6;
+function jb(e, t, n) {
+    var r = new Nf();
+    return t = t == null ? 0 : +t, r.restart((i) => {
+        r.stop(), e(i + t);
+    }, t, n), r;
+}
+var kB = Yh("start", "end", "cancel", "interrupt"),
+    RB = [],
+    PS = 0,
+    Vb = 1,
+    R0 = 2,
+    kl = 3,
+    Yb = 4,
+    F0 = 5,
+    Rl = 6;
 
-function n0(e, t, n, i, r, s) {
+function Kh(e, t, n, r, i, s) {
     var o = e.__transition;
     if (!o)
         e.__transition = {};
     else if (n in o)
         return;
-    $j(e, n, {
+    FB(e, n, {
         name: t,
-        index: i,
+        index: r,
         // For context during callback.
-        group: r,
+        group: i,
         // For context during callback.
-        on: Aj,
-        tween: Mj,
+        on: kB,
+        tween: RB,
         time: s.time,
         delay: s.delay,
         duration: s.duration,
         ease: s.ease,
         timer: null,
-        state: G3
+        state: PS
     });
 }
 
-function ew(e, t) {
-    var n = Ri(e, t);
-    if (n.state > G3)
+function km(e, t) {
+    var n = Hn(e, t);
+    if (n.state > PS)
         throw new Error("too late; already scheduled");
     return n;
 }
 
-function gr(e, t) {
-    var n = Ri(e, t);
-    if (n.state > td)
+function Sr(e, t) {
+    var n = Hn(e, t);
+    if (n.state > kl)
         throw new Error("too late; already running");
     return n;
 }
 
-function Ri(e, t) {
+function Hn(e, t) {
     var n = e.__transition;
     if (!n || !(n = n[t]))
         throw new Error("transition not found");
     return n;
 }
 
-function $j(e, t, n) {
-    var i = e.__transition,
-        r;
-    i[t] = n, n.timer = W3(s, 0, n.time);
+function FB(e, t, n) {
+    var r = e.__transition,
+        i;
+    r[t] = n, n.timer = CS(s, 0, n.time);
 
-    function s(l) {
-        n.state = T2, n.timer.restart(o, n.delay, n.time), n.delay <= l && o(l - n.delay);
+    function s(u) {
+        n.state = Vb, n.timer.restart(o, n.delay, n.time), n.delay <= u && o(u - n.delay);
     }
 
-    function o(l) {
-        var u, f, h, d;
-        if (n.state !== T2)
+    function o(u) {
+        var l, f, h, d;
+        if (n.state !== Vb)
             return c();
-        for (u in i)
-            if (d = i[u], d.name === n.name) {
-                if (d.state === td)
-                    return $2(o);
-                d.state === D2 ? (d.state = ed, d.timer.stop(), d.on.call("interrupt", e, e.__data__, d.index, d.group), delete i[u]) : +u < t && (d.state = ed, d.timer.stop(), d.on.call("cancel", e, e.__data__, d.index, d.group), delete i[u]);
-            }
-        if ($2(function() {
-                n.state === td && (n.state = D2, n.timer.restart(a, n.delay, n.time), a(l));
-            }), n.state = Gg, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Gg) {
-            for (n.state = td, r = new Array(h = n.tween.length), u = 0, f = -1; u < h; ++u)
-                (d = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (r[++f] = d);
-            r.length = f + 1;
+        for (l in r)
+            if (d = r[l], d.name === n.name) {
+                if (d.state === kl)
+                    return jb(o);
+                d.state === Yb ? (d.state = Rl, d.timer.stop(), d.on.call("interrupt", e, e.__data__, d.index, d.group), delete r[l]) : +l < t && (d.state = Rl, d.timer.stop(), d.on.call("cancel", e, e.__data__, d.index, d.group), delete r[l]);
+            }
+        if (jb(function() {
+                n.state === kl && (n.state = Yb, n.timer.restart(a, n.delay, n.time), a(u));
+            }), n.state = R0, n.on.call("start", e, e.__data__, n.index, n.group), n.state === R0) {
+            for (n.state = kl, i = new Array(h = n.tween.length), l = 0, f = -1; l < h; ++l)
+                (d = n.tween[l].value.call(e, e.__data__, n.index, n.group)) && (i[++f] = d);
+            i.length = f + 1;
         }
     }
 
-    function a(l) {
-        for (var u = l < n.duration ? n.ease.call(null, l / n.duration) : (n.timer.restart(c), n.state = Xg, 1), f = -1, h = r.length; ++f < h;)
-            r[f].call(e, u);
-        n.state === Xg && (n.on.call("end", e, e.__data__, n.index, n.group), c());
+    function a(u) {
+        for (var l = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(c), n.state = F0, 1), f = -1, h = i.length; ++f < h;)
+            i[f].call(e, l);
+        n.state === F0 && (n.on.call("end", e, e.__data__, n.index, n.group), c());
     }
 
     function c() {
-        n.state = ed, n.timer.stop(), delete i[t];
-        for (var l in i)
+        n.state = Rl, n.timer.stop(), delete r[t];
+        for (var u in r)
             return;
         delete e.__transition;
     }
 }
 
-function dc(e, t) {
+function No(e, t) {
     var n = e.__transition,
-        i, r, s = !0,
+        r, i, s = !0,
         o;
     if (n) {
         t = t == null ? null : t + "";
         for (o in n) {
-            if ((i = n[o]).name !== t) {
+            if ((r = n[o]).name !== t) {
                 s = !1;
                 continue;
             }
-            r = i.state > Gg && i.state < Xg, i.state = ed, i.timer.stop(), i.on.call(r ? "interrupt" : "cancel", e, e.__data__, i.index, i.group), delete n[o];
+            i = r.state > R0 && r.state < F0, r.state = Rl, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[o];
         }
         s && delete e.__transition;
     }
 }
 
-function Tj(e) {
+function BB(e) {
     return this.each(function() {
-        dc(this, e);
+        No(this, e);
     });
 }
 
-function Dj(e, t) {
-    var n, i;
+function CB(e, t) {
+    var n, r;
     return function() {
-        var r = gr(this, e),
-            s = r.tween;
+        var i = Sr(this, e),
+            s = i.tween;
         if (s !== n) {
-            i = n = s;
-            for (var o = 0, a = i.length; o < a; ++o)
-                if (i[o].name === t) {
-                    i = i.slice(), i.splice(o, 1);
+            r = n = s;
+            for (var o = 0, a = r.length; o < a; ++o)
+                if (r[o].name === t) {
+                    r = r.slice(), r.splice(o, 1);
                     break;
                 }
         }
-        r.tween = i;
+        i.tween = r;
     };
 }
 
-function Nj(e, t, n) {
-    var i, r;
+function PB(e, t, n) {
+    var r, i;
     if (typeof n != "function")
         throw new Error();
     return function() {
-        var s = gr(this, e),
+        var s = Sr(this, e),
             o = s.tween;
-        if (o !== i) {
-            r = (i = o).slice();
+        if (o !== r) {
+            i = (r = o).slice();
             for (var a = {
                     name: t,
                     value: n
-                }, c = 0, l = r.length; c < l; ++c)
-                if (r[c].name === t) {
-                    r[c] = a;
+                }, c = 0, u = i.length; c < u; ++c)
+                if (i[c].name === t) {
+                    i[c] = a;
                     break;
                 }
-            c === l && r.push(a);
+            c === u && i.push(a);
         }
-        s.tween = r;
+        s.tween = i;
     };
 }
 
-function Bj(e, t) {
+function UB(e, t) {
     var n = this._id;
     if (e += "", arguments.length < 2) {
-        for (var i = Ri(this.node(), n).tween, r = 0, s = i.length, o; r < s; ++r)
-            if ((o = i[r]).name === e)
+        for (var r = Hn(this.node(), n).tween, i = 0, s = r.length, o; i < s; ++i)
+            if ((o = r[i]).name === e)
                 return o.value;
         return null;
     }
-    return this.each((t == null ? Dj : Nj)(n, e, t));
+    return this.each((t == null ? CB : PB)(n, e, t));
 }
 
-function nw(e, t, n) {
-    var i = e._id;
+function Rm(e, t, n) {
+    var r = e._id;
     return e.each(function() {
-            var r = gr(this, i);
-            (r.value || (r.value = {}))[t] = n.apply(this, arguments);
+            var i = Sr(this, r);
+            (i.value || (i.value = {}))[t] = n.apply(this, arguments);
         }),
-        function(r) {
-            return Ri(r, i).value[t];
+        function(i) {
+            return Hn(i, r).value[t];
         };
 }
 
-function X3(e, t) {
+function US(e, t) {
     var n;
-    return (typeof t == "number" ? Qe : t instanceof Gs ? Qo : (n = Gs(t)) ? (t = n, Qo) : z3)(e, t);
+    return (typeof t == "number" ? Te : t instanceof Ui ? Ds : (n = Ui(t)) ? (t = n, Ds) : OS)(e, t);
 }
 
-function Oj(e) {
+function zB(e) {
     return function() {
         this.removeAttribute(e);
     };
 }
 
-function Fj(e) {
+function qB(e) {
     return function() {
         this.removeAttributeNS(e.space, e.local);
     };
 }
 
-function Ej(e, t, n) {
-    var i, r = n + "",
+function jB(e, t, n) {
+    var r, i = n + "",
         s;
     return function() {
         var o = this.getAttribute(e);
-        return o === r ? null : o === i ? s : s = t(i = o, n);
+        return o === i ? null : o === r ? s : s = t(r = o, n);
     };
 }
 
-function Lj(e, t, n) {
-    var i, r = n + "",
+function VB(e, t, n) {
+    var r, i = n + "",
         s;
     return function() {
         var o = this.getAttributeNS(e.space, e.local);
-        return o === r ? null : o === i ? s : s = t(i = o, n);
+        return o === i ? null : o === r ? s : s = t(r = o, n);
     };
 }
 
-function Rj(e, t, n) {
-    var i, r, s;
+function YB(e, t, n) {
+    var r, i, s;
     return function() {
         var o, a = n(this),
             c;
-        return a == null ? void this.removeAttribute(e) : (o = this.getAttribute(e), c = a + "", o === c ? null : o === i && c === r ? s : (r = c, s = t(i = o, a)));
+        return a == null ? void this.removeAttribute(e) : (o = this.getAttribute(e), c = a + "", o === c ? null : o === r && c === i ? s : (i = c, s = t(r = o, a)));
     };
 }
 
-function Cj(e, t, n) {
-    var i, r, s;
+function WB(e, t, n) {
+    var r, i, s;
     return function() {
         var o, a = n(this),
             c;
-        return a == null ? void this.removeAttributeNS(e.space, e.local) : (o = this.getAttributeNS(e.space, e.local), c = a + "", o === c ? null : o === i && c === r ? s : (r = c, s = t(i = o, a)));
+        return a == null ? void this.removeAttributeNS(e.space, e.local) : (o = this.getAttributeNS(e.space, e.local), c = a + "", o === c ? null : o === r && c === i ? s : (i = c, s = t(r = o, a)));
     };
 }
 
-function kj(e, t) {
-    var n = Jy(e),
-        i = n === "transform" ? fj : X3;
-    return this.attrTween(e, typeof t == "function" ? (n.local ? Cj : Rj)(n, i, nw(this, "attr." + e, t)) : t == null ? (n.local ? Fj : Oj)(n) : (n.local ? Lj : Ej)(n, i, t));
+function XB(e, t) {
+    var n = Wh(e),
+        r = n === "transform" ? vB : US;
+    return this.attrTween(e, typeof t == "function" ? (n.local ? WB : YB)(n, r, Rm(this, "attr." + e, t)) : t == null ? (n.local ? qB : zB)(n) : (n.local ? VB : jB)(n, r, t));
 }
 
-function Uj(e, t) {
+function GB(e, t) {
     return function(n) {
         this.setAttribute(e, t.call(this, n));
     };
 }
 
-function zj(e, t) {
+function HB(e, t) {
     return function(n) {
         this.setAttributeNS(e.space, e.local, t.call(this, n));
     };
 }
 
-function Pj(e, t) {
-    var n, i;
+function JB(e, t) {
+    var n, r;
 
-    function r() {
+    function i() {
         var s = t.apply(this, arguments);
-        return s !== i && (n = (i = s) && zj(e, s)), n;
+        return s !== r && (n = (r = s) && HB(e, s)), n;
     }
-    return r._value = t, r;
+    return i._value = t, i;
 }
 
-function Vj(e, t) {
-    var n, i;
+function ZB(e, t) {
+    var n, r;
 
-    function r() {
+    function i() {
         var s = t.apply(this, arguments);
-        return s !== i && (n = (i = s) && Uj(e, s)), n;
+        return s !== r && (n = (r = s) && GB(e, s)), n;
     }
-    return r._value = t, r;
+    return i._value = t, i;
 }
 
-function jj(e, t) {
+function KB(e, t) {
     var n = "attr." + e;
     if (arguments.length < 2)
         return (n = this.tween(n)) && n._value;
     if (t == null)
         return this.tween(n, null);
     if (typeof t != "function")
         throw new Error();
-    var i = Jy(e);
-    return this.tween(n, (i.local ? Pj : Vj)(i, t));
+    var r = Wh(e);
+    return this.tween(n, (r.local ? JB : ZB)(r, t));
 }
 
-function qj(e, t) {
+function QB(e, t) {
     return function() {
-        ew(this, e).delay = +t.apply(this, arguments);
+        km(this, e).delay = +t.apply(this, arguments);
     };
 }
 
-function Yj(e, t) {
+function tC(e, t) {
     return t = +t,
         function() {
-            ew(this, e).delay = t;
+            km(this, e).delay = t;
         };
 }
 
-function Wj(e) {
+function eC(e) {
     var t = this._id;
-    return arguments.length ? this.each((typeof e == "function" ? qj : Yj)(t, e)) : Ri(this.node(), t).delay;
+    return arguments.length ? this.each((typeof e == "function" ? QB : tC)(t, e)) : Hn(this.node(), t).delay;
 }
 
-function Gj(e, t) {
+function nC(e, t) {
     return function() {
-        gr(this, e).duration = +t.apply(this, arguments);
+        Sr(this, e).duration = +t.apply(this, arguments);
     };
 }
 
-function Xj(e, t) {
+function rC(e, t) {
     return t = +t,
         function() {
-            gr(this, e).duration = t;
+            Sr(this, e).duration = t;
         };
 }
 
-function Hj(e) {
+function iC(e) {
     var t = this._id;
-    return arguments.length ? this.each((typeof e == "function" ? Gj : Xj)(t, e)) : Ri(this.node(), t).duration;
+    return arguments.length ? this.each((typeof e == "function" ? nC : rC)(t, e)) : Hn(this.node(), t).duration;
 }
 
-function Jj(e, t) {
+function sC(e, t) {
     if (typeof t != "function")
         throw new Error();
     return function() {
-        gr(this, e).ease = t;
+        Sr(this, e).ease = t;
     };
 }
 
-function Kj(e) {
+function oC(e) {
     var t = this._id;
-    return arguments.length ? this.each(Jj(t, e)) : Ri(this.node(), t).ease;
+    return arguments.length ? this.each(sC(t, e)) : Hn(this.node(), t).ease;
 }
 
-function Zj(e, t) {
+function aC(e, t) {
     return function() {
         var n = t.apply(this, arguments);
         if (typeof n != "function")
             throw new Error();
-        gr(this, e).ease = n;
+        Sr(this, e).ease = n;
     };
 }
 
-function Qj(e) {
+function cC(e) {
     if (typeof e != "function")
         throw new Error();
-    return this.each(Zj(this._id, e));
+    return this.each(aC(this._id, e));
 }
 
-function tq(e) {
-    typeof e != "function" && (e = m3(e));
-    for (var t = this._groups, n = t.length, i = new Array(n), r = 0; r < n; ++r)
-        for (var s = t[r], o = s.length, a = i[r] = [], c, l = 0; l < o; ++l)
-            (c = s[l]) && e.call(c, c.__data__, l, s) && a.push(c);
-    return new rs(i, this._parents, this._name, this._id);
+function uC(e) {
+    typeof e != "function" && (e = cS(e));
+    for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
+        for (var s = t[i], o = s.length, a = r[i] = [], c, u = 0; u < o; ++u)
+            (c = s[u]) && e.call(c, c.__data__, u, s) && a.push(c);
+    return new ri(r, this._parents, this._name, this._id);
 }
 
-function eq(e) {
+function lC(e) {
     if (e._id !== this._id)
         throw new Error();
-    for (var t = this._groups, n = e._groups, i = t.length, r = n.length, s = Math.min(i, r), o = new Array(i), a = 0; a < s; ++a)
-        for (var c = t[a], l = n[a], u = c.length, f = o[a] = new Array(u), h, d = 0; d < u; ++d)
-            (h = c[d] || l[d]) && (f[d] = h);
-    for (; a < i; ++a)
+    for (var t = this._groups, n = e._groups, r = t.length, i = n.length, s = Math.min(r, i), o = new Array(r), a = 0; a < s; ++a)
+        for (var c = t[a], u = n[a], l = c.length, f = o[a] = new Array(l), h, d = 0; d < l; ++d)
+            (h = c[d] || u[d]) && (f[d] = h);
+    for (; a < r; ++a)
         o[a] = t[a];
-    return new rs(o, this._parents, this._name, this._id);
+    return new ri(o, this._parents, this._name, this._id);
 }
 
-function nq(e) {
+function fC(e) {
     return (e + "").trim().split(/^|\s+/).every(function(t) {
         var n = t.indexOf(".");
         return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
     });
 }
 
-function iq(e, t, n) {
-    var i, r, s = nq(t) ? ew : gr;
+function hC(e, t, n) {
+    var r, i, s = fC(t) ? km : Sr;
     return function() {
         var o = s(this, e),
             a = o.on;
-        a !== i && (r = (i = a).copy()).on(t, n), o.on = r;
+        a !== r && (i = (r = a).copy()).on(t, n), o.on = i;
     };
 }
 
-function rq(e, t) {
+function dC(e, t) {
     var n = this._id;
-    return arguments.length < 2 ? Ri(this.node(), n).on.on(e) : this.each(iq(n, e, t));
+    return arguments.length < 2 ? Hn(this.node(), n).on.on(e) : this.each(hC(n, e, t));
 }
 
-function sq(e) {
+function pC(e) {
     return function() {
         var t = this.parentNode;
         for (var n in this.__transition)
             if (+n !== e)
                 return;
         t && t.removeChild(this);
     };
 }
 
-function oq() {
-    return this.on("end.remove", sq(this._id));
+function yC() {
+    return this.on("end.remove", pC(this._id));
 }
 
-function aq(e) {
+function mC(e) {
     var t = this._name,
         n = this._id;
-    typeof e != "function" && (e = Wb(e));
-    for (var i = this._groups, r = i.length, s = new Array(r), o = 0; o < r; ++o)
-        for (var a = i[o], c = a.length, l = s[o] = new Array(c), u, f, h = 0; h < c; ++h)
-            (u = a[h]) && (f = e.call(u, u.__data__, h, a)) && ("__data__" in u && (f.__data__ = u.__data__), l[h] = f, n0(l[h], t, n, h, l, Ri(u, n)));
-    return new rs(s, this._parents, t, n);
+    typeof e != "function" && (e = Am(e));
+    for (var r = this._groups, i = r.length, s = new Array(i), o = 0; o < i; ++o)
+        for (var a = r[o], c = a.length, u = s[o] = new Array(c), l, f, h = 0; h < c; ++h)
+            (l = a[h]) && (f = e.call(l, l.__data__, h, a)) && ("__data__" in l && (f.__data__ = l.__data__), u[h] = f, Kh(u[h], t, n, h, u, Hn(l, n)));
+    return new ri(s, this._parents, t, n);
 }
 
-function cq(e) {
+function gC(e) {
     var t = this._name,
         n = this._id;
-    typeof e != "function" && (e = y3(e));
-    for (var i = this._groups, r = i.length, s = [], o = [], a = 0; a < r; ++a)
-        for (var c = i[a], l = c.length, u, f = 0; f < l; ++f)
-            if (u = c[f]) {
-                for (var h = e.call(u, u.__data__, f, c), d, p = Ri(u, n), m = 0, g = h.length; m < g; ++m)
-                    (d = h[m]) && n0(d, t, n, m, h, p);
-                s.push(h), o.push(u);
+    typeof e != "function" && (e = aS(e));
+    for (var r = this._groups, i = r.length, s = [], o = [], a = 0; a < i; ++a)
+        for (var c = r[a], u = c.length, l, f = 0; f < u; ++f)
+            if (l = c[f]) {
+                for (var h = e.call(l, l.__data__, f, c), d, p = Hn(l, n), y = 0, m = h.length; y < m; ++y)
+                    (d = h[y]) && Kh(d, t, n, y, h, p);
+                s.push(h), o.push(l);
             }
-    return new rs(s, o, t, n);
+    return new ri(s, o, t, n);
 }
-var lq = bf.prototype.constructor;
+var bC = cu.prototype.constructor;
 
-function uq() {
-    return new lq(this._groups, this._parents);
+function wC() {
+    return new bC(this._groups, this._parents);
 }
 
-function fq(e, t) {
-    var n, i, r;
+function vC(e, t) {
+    var n, r, i;
     return function() {
-        var s = Dc(this, e),
-            o = (this.style.removeProperty(e), Dc(this, e));
-        return s === o ? null : s === n && o === i ? r : r = t(n = s, i = o);
+        var s = Yo(this, e),
+            o = (this.style.removeProperty(e), Yo(this, e));
+        return s === o ? null : s === n && o === r ? i : i = t(n = s, r = o);
     };
 }
 
-function H3(e) {
+function zS(e) {
     return function() {
         this.style.removeProperty(e);
     };
 }
 
-function hq(e, t, n) {
-    var i, r = n + "",
+function _C(e, t, n) {
+    var r, i = n + "",
         s;
     return function() {
-        var o = Dc(this, e);
-        return o === r ? null : o === i ? s : s = t(i = o, n);
+        var o = Yo(this, e);
+        return o === i ? null : o === r ? s : s = t(r = o, n);
     };
 }
 
-function dq(e, t, n) {
-    var i, r, s;
+function xC(e, t, n) {
+    var r, i, s;
     return function() {
-        var o = Dc(this, e),
+        var o = Yo(this, e),
             a = n(this),
             c = a + "";
-        return a == null && (c = a = (this.style.removeProperty(e), Dc(this, e))), o === c ? null : o === i && c === r ? s : (r = c, s = t(i = o, a));
+        return a == null && (c = a = (this.style.removeProperty(e), Yo(this, e))), o === c ? null : o === r && c === i ? s : (i = c, s = t(r = o, a));
     };
 }
 
-function pq(e, t) {
-    var n, i, r, s = "style." + t,
+function SC(e, t) {
+    var n, r, i, s = "style." + t,
         o = "end." + s,
         a;
     return function() {
-        var c = gr(this, e),
-            l = c.on,
-            u = c.value[s] == null ? a || (a = H3(t)) : void 0;
-        (l !== n || r !== u) && (i = (n = l).copy()).on(o, r = u), c.on = i;
+        var c = Sr(this, e),
+            u = c.on,
+            l = c.value[s] == null ? a || (a = zS(t)) : void 0;
+        (u !== n || i !== l) && (r = (n = u).copy()).on(o, i = l), c.on = r;
     };
 }
 
-function yq(e, t, n) {
-    var i = (e += "") == "transform" ? uj : X3;
-    return t == null ? this.styleTween(e, fq(e, i)).on("end.style." + e, H3(e)) : typeof t == "function" ? this.styleTween(e, dq(e, i, nw(this, "style." + e, t))).each(pq(this._id, e)) : this.styleTween(e, hq(e, i, t), n).on("end.style." + e, null);
+function MC(e, t, n) {
+    var r = (e += "") == "transform" ? wB : US;
+    return t == null ? this.styleTween(e, vC(e, r)).on("end.style." + e, zS(e)) : typeof t == "function" ? this.styleTween(e, xC(e, r, Rm(this, "style." + e, t))).each(SC(this._id, e)) : this.styleTween(e, _C(e, r, t), n).on("end.style." + e, null);
 }
 
-function mq(e, t, n) {
-    return function(i) {
-        this.style.setProperty(e, t.call(this, i), n);
+function AC(e, t, n) {
+    return function(r) {
+        this.style.setProperty(e, t.call(this, r), n);
     };
 }
 
-function gq(e, t, n) {
-    var i, r;
+function $C(e, t, n) {
+    var r, i;
 
     function s() {
         var o = t.apply(this, arguments);
-        return o !== r && (i = (r = o) && mq(e, o, n)), i;
+        return o !== i && (r = (i = o) && AC(e, o, n)), r;
     }
     return s._value = t, s;
 }
 
-function bq(e, t, n) {
-    var i = "style." + (e += "");
+function IC(e, t, n) {
+    var r = "style." + (e += "");
     if (arguments.length < 2)
-        return (i = this.tween(i)) && i._value;
+        return (r = this.tween(r)) && r._value;
     if (t == null)
-        return this.tween(i, null);
+        return this.tween(r, null);
     if (typeof t != "function")
         throw new Error();
-    return this.tween(i, gq(e, t, n ?? ""));
+    return this.tween(r, $C(e, t, n ?? ""));
 }
 
-function wq(e) {
+function TC(e) {
     return function() {
         this.textContent = e;
     };
 }
 
-function vq(e) {
+function EC(e) {
     return function() {
         var t = e(this);
         this.textContent = t ?? "";
     };
 }
 
-function _q(e) {
-    return this.tween("text", typeof e == "function" ? vq(nw(this, "text", e)) : wq(e == null ? "" : e + ""));
+function NC(e) {
+    return this.tween("text", typeof e == "function" ? EC(Rm(this, "text", e)) : TC(e == null ? "" : e + ""));
 }
 
-function xq(e) {
+function DC(e) {
     return function(t) {
         this.textContent = e.call(this, t);
     };
 }
 
-function Sq(e) {
+function OC(e) {
     var t, n;
 
-    function i() {
-        var r = e.apply(this, arguments);
-        return r !== n && (t = (n = r) && xq(r)), t;
+    function r() {
+        var i = e.apply(this, arguments);
+        return i !== n && (t = (n = i) && DC(i)), t;
     }
-    return i._value = e, i;
+    return r._value = e, r;
 }
 
-function Iq(e) {
+function LC(e) {
     var t = "text";
     if (arguments.length < 1)
         return (t = this.tween(t)) && t._value;
     if (e == null)
         return this.tween(t, null);
     if (typeof e != "function")
         throw new Error();
-    return this.tween(t, Sq(e));
+    return this.tween(t, OC(e));
 }
 
-function Aq() {
-    for (var e = this._name, t = this._id, n = J3(), i = this._groups, r = i.length, s = 0; s < r; ++s)
-        for (var o = i[s], a = o.length, c, l = 0; l < a; ++l)
-            if (c = o[l]) {
-                var u = Ri(c, t);
-                n0(c, e, n, l, o, {
-                    time: u.time + u.delay + u.duration,
+function kC() {
+    for (var e = this._name, t = this._id, n = qS(), r = this._groups, i = r.length, s = 0; s < i; ++s)
+        for (var o = r[s], a = o.length, c, u = 0; u < a; ++u)
+            if (c = o[u]) {
+                var l = Hn(c, t);
+                Kh(c, e, n, u, o, {
+                    time: l.time + l.delay + l.duration,
                     delay: 0,
-                    duration: u.duration,
-                    ease: u.ease
+                    duration: l.duration,
+                    ease: l.ease
                 });
             }
-    return new rs(i, this._parents, e, n);
+    return new ri(r, this._parents, e, n);
 }
 
-function Mq() {
+function RC() {
     var e, t, n = this,
-        i = n._id,
-        r = n.size();
+        r = n._id,
+        i = n.size();
     return new Promise(function(s, o) {
         var a = {
                 value: o
             },
             c = {
                 value: function() {
-                    --r === 0 && s();
+                    --i === 0 && s();
                 }
             };
         n.each(function() {
-            var l = gr(this, i),
-                u = l.on;
-            u !== e && (t = (e = u).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(c)), l.on = t;
-        }), r === 0 && s();
-    });
-}
-var $q = 0;
-
-function rs(e, t, n, i) {
-    this._groups = e, this._parents = t, this._name = n, this._id = i;
-}
-
-function J3() {
-    return ++$q;
-}
-var Sr = bf.prototype;
-rs.prototype = {
-    constructor: rs,
-    select: aq,
-    selectAll: cq,
-    selectChild: Sr.selectChild,
-    selectChildren: Sr.selectChildren,
-    filter: tq,
-    merge: eq,
-    selection: uq,
-    transition: Aq,
-    call: Sr.call,
-    nodes: Sr.nodes,
-    node: Sr.node,
-    size: Sr.size,
-    empty: Sr.empty,
-    each: Sr.each,
-    on: rq,
-    attr: kj,
-    attrTween: jj,
-    style: yq,
-    styleTween: bq,
-    text: _q,
-    textTween: Iq,
-    remove: oq,
-    tween: Bj,
-    delay: Wj,
-    duration: Hj,
-    ease: Kj,
-    easeVarying: Qj,
-    end: Mq,
-    [Symbol.iterator]: Sr[Symbol.iterator]
+            var u = Sr(this, r),
+                l = u.on;
+            l !== e && (t = (e = l).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(c)), u.on = t;
+        }), i === 0 && s();
+    });
+}
+var FC = 0;
+
+function ri(e, t, n, r) {
+    this._groups = e, this._parents = t, this._name = n, this._id = r;
+}
+
+function qS() {
+    return ++FC;
+}
+var Nr = cu.prototype;
+ri.prototype = {
+    constructor: ri,
+    select: mC,
+    selectAll: gC,
+    selectChild: Nr.selectChild,
+    selectChildren: Nr.selectChildren,
+    filter: uC,
+    merge: lC,
+    selection: wC,
+    transition: kC,
+    call: Nr.call,
+    nodes: Nr.nodes,
+    node: Nr.node,
+    size: Nr.size,
+    empty: Nr.empty,
+    each: Nr.each,
+    on: dC,
+    attr: XB,
+    attrTween: KB,
+    style: MC,
+    styleTween: IC,
+    text: NC,
+    textTween: LC,
+    remove: yC,
+    tween: UB,
+    delay: eC,
+    duration: iC,
+    ease: oC,
+    easeVarying: cC,
+    end: RC,
+    [Symbol.iterator]: Nr[Symbol.iterator]
 };
 
-function Tq(e) {
+function BC(e) {
     return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
 }
-var Dq = {
+var CC = {
     time: null,
     // Set on use.
     delay: 0,
     duration: 250,
-    ease: Tq
+    ease: BC
 };
 
-function Nq(e, t) {
+function PC(e, t) {
     for (var n; !(n = e.__transition) || !(n = n[t]);)
         if (!(e = e.parentNode))
             throw new Error(`transition ${t} not found`);
     return n;
 }
 
-function Bq(e) {
+function UC(e) {
     var t, n;
-    e instanceof rs ? (t = e._id, e = e._name) : (t = J3(), (n = Dq).time = tw(), e = e == null ? null : e + "");
-    for (var i = this._groups, r = i.length, s = 0; s < r; ++s)
-        for (var o = i[s], a = o.length, c, l = 0; l < a; ++l)
-            (c = o[l]) && n0(c, e, t, l, o, n || Nq(c, t));
-    return new rs(i, this._parents, e, t);
-}
-bf.prototype.interrupt = Tj;
-bf.prototype.transition = Bq;
-const pm = (e) => () => e;
+    e instanceof ri ? (t = e._id, e = e._name) : (t = qS(), (n = CC).time = Lm(), e = e == null ? null : e + "");
+    for (var r = this._groups, i = r.length, s = 0; s < i; ++s)
+        for (var o = r[s], a = o.length, c, u = 0; u < a; ++u)
+            (c = o[u]) && Kh(c, e, t, u, o, n || PC(c, t));
+    return new ri(r, this._parents, e, t);
+}
+cu.prototype.interrupt = BB;
+cu.prototype.transition = UC;
+const up = (e) => () => e;
 
-function Oq(e, {
+function zC(e, {
     sourceEvent: t,
     target: n,
-    selection: i,
-    mode: r,
+    selection: r,
+    mode: i,
     dispatch: s
 }) {
     Object.defineProperties(this, {
         type: {
             value: e,
             enumerable: !0,
             configurable: !0
@@ -15018,618 +15581,618 @@
         },
         target: {
             value: n,
             enumerable: !0,
             configurable: !0
         },
         selection: {
-            value: i,
+            value: r,
             enumerable: !0,
             configurable: !0
         },
         mode: {
-            value: r,
+            value: i,
             enumerable: !0,
             configurable: !0
         },
         _: {
             value: s
         }
     });
 }
 
-function Fq(e) {
+function qC(e) {
     e.stopImmediatePropagation();
 }
 
-function ym(e) {
+function lp(e) {
     e.preventDefault(), e.stopImmediatePropagation();
 }
-var N2 = {
+var Wb = {
         name: "drag"
     },
-    mm = {
+    fp = {
         name: "space"
     },
-    wa = {
+    Hs = {
         name: "handle"
     },
-    va = {
+    Js = {
         name: "center"
     };
 const {
-    abs: B2,
-    max: Je,
-    min: Ke
+    abs: Xb,
+    max: Ae,
+    min: $e
 } = Math;
 
-function O2(e) {
+function Gb(e) {
     return [+e[0], +e[1]];
 }
 
-function Hg(e) {
-    return [O2(e[0]), O2(e[1])];
+function B0(e) {
+    return [Gb(e[0]), Gb(e[1])];
 }
-var nd = {
+var Fl = {
         name: "x",
-        handles: ["w", "e"].map(Cu),
+        handles: ["w", "e"].map(kc),
         input: function(e, t) {
             return e == null ? null : [
                 [+e[0], t[0][1]],
                 [+e[1], t[1][1]]
             ];
         },
         output: function(e) {
             return e && [e[0][0], e[1][0]];
         }
     },
-    id = {
+    Bl = {
         name: "y",
-        handles: ["n", "s"].map(Cu),
+        handles: ["n", "s"].map(kc),
         input: function(e, t) {
             return e == null ? null : [
                 [t[0][0], +e[0]],
                 [t[1][0], +e[1]]
             ];
         },
         output: function(e) {
             return e && [e[0][1], e[1][1]];
         }
     },
-    Eq = {
+    jC = {
         name: "xy",
-        handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(Cu),
+        handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(kc),
         input: function(e) {
-            return e == null ? null : Hg(e);
+            return e == null ? null : B0(e);
         },
         output: function(e) {
             return e;
         }
     },
-    Ir = {
+    Dr = {
         overlay: "crosshair",
         selection: "move",
         n: "ns-resize",
         e: "ew-resize",
         s: "ns-resize",
         w: "ew-resize",
         nw: "nwse-resize",
         ne: "nesw-resize",
         se: "nwse-resize",
         sw: "nesw-resize"
     },
-    F2 = {
+    Hb = {
         e: "w",
         w: "e",
         nw: "ne",
         ne: "nw",
         se: "sw",
         sw: "se"
     },
-    E2 = {
+    Jb = {
         n: "s",
         s: "n",
         nw: "sw",
         ne: "se",
         se: "ne",
         sw: "nw"
     },
-    Lq = {
+    VC = {
         overlay: 1,
         selection: 1,
         n: null,
         e: 1,
         s: null,
         w: -1,
         nw: -1,
         ne: 1,
         se: 1,
         sw: -1
     },
-    Rq = {
+    YC = {
         overlay: 1,
         selection: 1,
         n: -1,
         e: null,
         s: 1,
         w: null,
         nw: -1,
         ne: -1,
         se: 1,
         sw: 1
     };
 
-function Cu(e) {
+function kc(e) {
     return {
         type: e
     };
 }
 
-function Cq(e) {
+function WC(e) {
     return !e.ctrlKey && !e.button;
 }
 
-function kq() {
+function XC() {
     var e = this.ownerSVGElement || this;
     return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [
         [e.x, e.y],
         [e.x + e.width, e.y + e.height]
     ]) : [
         [0, 0],
         [e.width.baseVal.value, e.height.baseVal.value]
     ];
 }
 
-function Uq() {
+function GC() {
     return navigator.maxTouchPoints || "ontouchstart" in this;
 }
 
-function gm(e) {
+function hp(e) {
     for (; !e.__brush;)
         if (!(e = e.parentNode))
             return;
     return e.__brush;
 }
 
-function zq(e) {
+function HC(e) {
     return e[0][0] === e[1][0] || e[0][1] === e[1][1];
 }
 
-function Pq() {
-    return iw(nd);
+function JC() {
+    return Fm(Fl);
 }
 
-function Vq() {
-    return iw(id);
+function ZC() {
+    return Fm(Bl);
 }
 
-function jq() {
-    return iw(Eq);
+function KC() {
+    return Fm(jC);
 }
 
-function iw(e) {
-    var t = kq,
-        n = Cq,
-        i = Uq,
-        r = !0,
-        s = Hy("start", "brush", "end"),
+function Fm(e) {
+    var t = XC,
+        n = WC,
+        r = GC,
+        i = !0,
+        s = Yh("start", "brush", "end"),
         o = 6,
         a;
 
-    function c(g) {
-        var y = g.property("__brush", m).selectAll(".overlay").data([Cu("overlay")]);
-        y.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", Ir.overlay).merge(y).each(function() {
-            var w = gm(this).extent;
-            ce(this).attr("x", w[0][0]).attr("y", w[0][1]).attr("width", w[1][0] - w[0][0]).attr("height", w[1][1] - w[0][1]);
-        }), g.selectAll(".selection").data([Cu("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", Ir.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
-        var b = g.selectAll(".handle").data(e.handles, function(w) {
+    function c(m) {
+        var g = m.property("__brush", y).selectAll(".overlay").data([kc("overlay")]);
+        g.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", Dr.overlay).merge(g).each(function() {
+            var w = hp(this).extent;
+            Wt(this).attr("x", w[0][0]).attr("y", w[0][1]).attr("width", w[1][0] - w[0][0]).attr("height", w[1][1] - w[0][1]);
+        }), m.selectAll(".selection").data([kc("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", Dr.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
+        var b = m.selectAll(".handle").data(e.handles, function(w) {
             return w.type;
         });
         b.exit().remove(), b.enter().append("rect").attr("class", function(w) {
             return "handle handle--" + w.type;
         }).attr("cursor", function(w) {
-            return Ir[w.type];
-        }), g.each(l).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", h).filter(i).on("touchstart.brush", h).on("touchmove.brush", d).on("touchend.brush touchcancel.brush", p).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
+            return Dr[w.type];
+        }), m.each(u).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", h).filter(r).on("touchstart.brush", h).on("touchmove.brush", d).on("touchend.brush touchcancel.brush", p).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
     }
-    c.move = function(g, y, b) {
-        g.tween ? g.on("start.brush", function(w) {
-            u(this, arguments).beforestart().start(w);
+    c.move = function(m, g, b) {
+        m.tween ? m.on("start.brush", function(w) {
+            l(this, arguments).beforestart().start(w);
         }).on("interrupt.brush end.brush", function(w) {
-            u(this, arguments).end(w);
+            l(this, arguments).end(w);
         }).tween("brush", function() {
             var w = this,
                 v = w.__brush,
-                x = u(w, arguments),
+                x = l(w, arguments),
                 _ = v.selection,
-                I = e.input(typeof y == "function" ? y.apply(this, arguments) : y, v.extent),
-                A = il(_, I);
+                M = e.input(typeof g == "function" ? g.apply(this, arguments) : g, v.extent),
+                T = ya(_, M);
 
-            function M(N) {
-                v.selection = N === 1 && I === null ? null : A(N), l.call(w), x.brush();
+            function $(N) {
+                v.selection = N === 1 && M === null ? null : T(N), u.call(w), x.brush();
             }
-            return _ !== null && I !== null ? M : M(1);
-        }) : g.each(function() {
+            return _ !== null && M !== null ? $ : $(1);
+        }) : m.each(function() {
             var w = this,
                 v = arguments,
                 x = w.__brush,
-                _ = e.input(typeof y == "function" ? y.apply(w, v) : y, x.extent),
-                I = u(w, v).beforestart();
-            dc(w), x.selection = _ === null ? null : _, l.call(w), I.start(b).brush(b).end(b);
+                _ = e.input(typeof g == "function" ? g.apply(w, v) : g, x.extent),
+                M = l(w, v).beforestart();
+            No(w), x.selection = _ === null ? null : _, u.call(w), M.start(b).brush(b).end(b);
         });
-    }, c.clear = function(g, y) {
-        c.move(g, null, y);
+    }, c.clear = function(m, g) {
+        c.move(m, null, g);
     };
 
-    function l() {
-        var g = ce(this),
-            y = gm(this).selection;
-        y ? (g.selectAll(".selection").style("display", null).attr("x", y[0][0]).attr("y", y[0][1]).attr("width", y[1][0] - y[0][0]).attr("height", y[1][1] - y[0][1]), g.selectAll(".handle").style("display", null).attr("x", function(b) {
-            return b.type[b.type.length - 1] === "e" ? y[1][0] - o / 2 : y[0][0] - o / 2;
+    function u() {
+        var m = Wt(this),
+            g = hp(this).selection;
+        g ? (m.selectAll(".selection").style("display", null).attr("x", g[0][0]).attr("y", g[0][1]).attr("width", g[1][0] - g[0][0]).attr("height", g[1][1] - g[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(b) {
+            return b.type[b.type.length - 1] === "e" ? g[1][0] - o / 2 : g[0][0] - o / 2;
         }).attr("y", function(b) {
-            return b.type[0] === "s" ? y[1][1] - o / 2 : y[0][1] - o / 2;
+            return b.type[0] === "s" ? g[1][1] - o / 2 : g[0][1] - o / 2;
         }).attr("width", function(b) {
-            return b.type === "n" || b.type === "s" ? y[1][0] - y[0][0] + o : o;
+            return b.type === "n" || b.type === "s" ? g[1][0] - g[0][0] + o : o;
         }).attr("height", function(b) {
-            return b.type === "e" || b.type === "w" ? y[1][1] - y[0][1] + o : o;
-        })) : g.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
+            return b.type === "e" || b.type === "w" ? g[1][1] - g[0][1] + o : o;
+        })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
     }
 
-    function u(g, y, b) {
-        var w = g.__brush.emitter;
-        return w && (!b || !w.clean) ? w : new f(g, y, b);
+    function l(m, g, b) {
+        var w = m.__brush.emitter;
+        return w && (!b || !w.clean) ? w : new f(m, g, b);
     }
 
-    function f(g, y, b) {
-        this.that = g, this.args = y, this.state = g.__brush, this.active = 0, this.clean = b;
+    function f(m, g, b) {
+        this.that = m, this.args = g, this.state = m.__brush, this.active = 0, this.clean = b;
     }
     f.prototype = {
         beforestart: function() {
             return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
         },
-        start: function(g, y) {
-            return this.starting ? (this.starting = !1, this.emit("start", g, y)) : this.emit("brush", g), this;
+        start: function(m, g) {
+            return this.starting ? (this.starting = !1, this.emit("start", m, g)) : this.emit("brush", m), this;
         },
-        brush: function(g, y) {
-            return this.emit("brush", g, y), this;
+        brush: function(m, g) {
+            return this.emit("brush", m, g), this;
         },
-        end: function(g, y) {
-            return --this.active === 0 && (delete this.state.emitter, this.emit("end", g, y)), this;
+        end: function(m, g) {
+            return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, g)), this;
         },
-        emit: function(g, y, b) {
-            var w = ce(this.that).datum();
+        emit: function(m, g, b) {
+            var w = Wt(this.that).datum();
             s.call(
-                g,
+                m,
                 this.that,
-                new Oq(g, {
-                    sourceEvent: y,
+                new zC(m, {
+                    sourceEvent: g,
                     target: c,
                     selection: e.output(this.state.selection),
                     mode: b,
                     dispatch: s
                 }),
                 w
             );
         }
     };
 
-    function h(g) {
-        if (a && !g.touches || !n.apply(this, arguments))
+    function h(m) {
+        if (a && !m.touches || !n.apply(this, arguments))
             return;
-        var y = this,
-            b = g.target.__data__.type,
-            w = (r && g.metaKey ? b = "overlay" : b) === "selection" ? N2 : r && g.altKey ? va : wa,
-            v = e === id ? null : Lq[b],
-            x = e === nd ? null : Rq[b],
-            _ = gm(y),
-            I = _.extent,
-            A = _.selection,
-            M = I[0][0],
-            N, $, B = I[0][1],
-            R, S, T = I[1][0],
-            D, L, k = I[1][1],
-            U, C, z = 0,
-            P = 0,
-            G, K = v && x && r && g.shiftKey,
-            et, Z, Y = Array.from(g.touches || [g], (Q) => {
-                const Zt = Q.identifier;
-                return Q = yi(Q, y), Q.point0 = Q.slice(), Q.identifier = Zt, Q;
+        var g = this,
+            b = m.target.__data__.type,
+            w = (i && m.metaKey ? b = "overlay" : b) === "selection" ? Wb : i && m.altKey ? Js : Hs,
+            v = e === Bl ? null : VC[b],
+            x = e === Fl ? null : YC[b],
+            _ = hp(g),
+            M = _.extent,
+            T = _.selection,
+            $ = M[0][0],
+            N, A, D = M[0][1],
+            R, S, I = M[1][0],
+            E, k, B = M[1][1],
+            C, F, P = 0,
+            U = 0,
+            Y, G = v && x && i && m.shiftKey,
+            K, H, V = Array.from(m.touches || [m], (J) => {
+                const Bt = J.identifier;
+                return J = On(J, g), J.point0 = J.slice(), J.identifier = Bt, J;
             });
-        dc(y);
-        var X = u(y, arguments, !0).beforestart();
+        No(g);
+        var W = l(g, arguments, !0).beforestart();
         if (b === "overlay") {
-            A && (G = !0);
-            const Q = [Y[0], Y[1] || Y[0]];
-            _.selection = A = [
+            T && (Y = !0);
+            const J = [V[0], V[1] || V[0]];
+            _.selection = T = [
                 [
-                    N = e === id ? M : Ke(Q[0][0], Q[1][0]),
-                    R = e === nd ? B : Ke(Q[0][1], Q[1][1])
+                    N = e === Bl ? $ : $e(J[0][0], J[1][0]),
+                    R = e === Fl ? D : $e(J[0][1], J[1][1])
                 ],
                 [
-                    D = e === id ? T : Je(Q[0][0], Q[1][0]),
-                    U = e === nd ? k : Je(Q[0][1], Q[1][1])
+                    E = e === Bl ? I : Ae(J[0][0], J[1][0]),
+                    C = e === Fl ? B : Ae(J[0][1], J[1][1])
                 ]
-            ], Y.length > 1 && Ft(g);
+            ], V.length > 1 && wt(m);
         } else
-            N = A[0][0], R = A[0][1], D = A[1][0], U = A[1][1];
-        $ = N, S = R, L = D, C = U;
-        var j = ce(y).attr("pointer-events", "none"),
-            J = j.selectAll(".overlay").attr("cursor", Ir[b]);
-        if (g.touches)
-            X.moved = V, X.ended = rt;
+            N = T[0][0], R = T[0][1], E = T[1][0], C = T[1][1];
+        A = N, S = R, k = E, F = C;
+        var q = Wt(g).attr("pointer-events", "none"),
+            X = q.selectAll(".overlay").attr("cursor", Dr[b]);
+        if (m.touches)
+            W.moved = z, W.ended = tt;
         else {
-            var tt = ce(g.view).on("mousemove.brush", V, !0).on("mouseup.brush", rt, !0);
-            r && tt.on("keydown.brush", Vt, !0).on("keyup.brush", jt, !0), M3(g.view);
+            var Z = Wt(m.view).on("mousemove.brush", z, !0).on("mouseup.brush", tt, !0);
+            i && Z.on("keydown.brush", It, !0).on("keyup.brush", Et, !0), bS(m.view);
         }
-        l.call(y), X.start(g, w.name);
+        u.call(g), W.start(m, w.name);
 
-        function V(Q) {
-            for (const Zt of Q.changedTouches || [Q])
-                for (const En of Y)
-                    En.identifier === Zt.identifier && (En.cur = yi(Zt, y));
-            if (K && !et && !Z && Y.length === 1) {
-                const Zt = Y[0];
-                B2(Zt.cur[0] - Zt[0]) > B2(Zt.cur[1] - Zt[1]) ? Z = !0 : et = !0;
-            }
-            for (const Zt of Y)
-                Zt.cur && (Zt[0] = Zt.cur[0], Zt[1] = Zt.cur[1]);
-            G = !0, ym(Q), Ft(Q);
-        }
-
-        function Ft(Q) {
-            const Zt = Y[0],
-                En = Zt.point0;
-            var zi;
-            switch (z = Zt[0] - En[0], P = Zt[1] - En[1], w) {
-                case mm:
-                case N2: {
-                    v && (z = Je(M - N, Ke(T - D, z)), $ = N + z, L = D + z), x && (P = Je(B - R, Ke(k - U, P)), S = R + P, C = U + P);
+        function z(J) {
+            for (const Bt of J.changedTouches || [J])
+                for (const en of V)
+                    en.identifier === Bt.identifier && (en.cur = On(Bt, g));
+            if (G && !K && !H && V.length === 1) {
+                const Bt = V[0];
+                Xb(Bt.cur[0] - Bt[0]) > Xb(Bt.cur[1] - Bt[1]) ? H = !0 : K = !0;
+            }
+            for (const Bt of V)
+                Bt.cur && (Bt[0] = Bt.cur[0], Bt[1] = Bt.cur[1]);
+            Y = !0, lp(J), wt(J);
+        }
+
+        function wt(J) {
+            const Bt = V[0],
+                en = Bt.point0;
+            var Zn;
+            switch (P = Bt[0] - en[0], U = Bt[1] - en[1], w) {
+                case fp:
+                case Wb: {
+                    v && (P = Ae($ - N, $e(I - E, P)), A = N + P, k = E + P), x && (U = Ae(D - R, $e(B - C, U)), S = R + U, F = C + U);
                     break;
                 }
-                case wa: {
-                    Y[1] ? (v && ($ = Je(M, Ke(T, Y[0][0])), L = Je(M, Ke(T, Y[1][0])), v = 1), x && (S = Je(B, Ke(k, Y[0][1])), C = Je(B, Ke(k, Y[1][1])), x = 1)) : (v < 0 ? (z = Je(M - N, Ke(T - N, z)), $ = N + z, L = D) : v > 0 && (z = Je(M - D, Ke(T - D, z)), $ = N, L = D + z), x < 0 ? (P = Je(B - R, Ke(k - R, P)), S = R + P, C = U) : x > 0 && (P = Je(B - U, Ke(k - U, P)), S = R, C = U + P));
+                case Hs: {
+                    V[1] ? (v && (A = Ae($, $e(I, V[0][0])), k = Ae($, $e(I, V[1][0])), v = 1), x && (S = Ae(D, $e(B, V[0][1])), F = Ae(D, $e(B, V[1][1])), x = 1)) : (v < 0 ? (P = Ae($ - N, $e(I - N, P)), A = N + P, k = E) : v > 0 && (P = Ae($ - E, $e(I - E, P)), A = N, k = E + P), x < 0 ? (U = Ae(D - R, $e(B - R, U)), S = R + U, F = C) : x > 0 && (U = Ae(D - C, $e(B - C, U)), S = R, F = C + U));
                     break;
                 }
-                case va: {
-                    v && ($ = Je(M, Ke(T, N - z * v)), L = Je(M, Ke(T, D + z * v))), x && (S = Je(B, Ke(k, R - P * x)), C = Je(B, Ke(k, U + P * x)));
+                case Js: {
+                    v && (A = Ae($, $e(I, N - P * v)), k = Ae($, $e(I, E + P * v))), x && (S = Ae(D, $e(B, R - U * x)), F = Ae(D, $e(B, C + U * x)));
                     break;
                 }
             }
-            L < $ && (v *= -1, zi = N, N = D, D = zi, zi = $, $ = L, L = zi, b in F2 && J.attr("cursor", Ir[b = F2[b]])), C < S && (x *= -1, zi = R, R = U, U = zi, zi = S, S = C, C = zi, b in E2 && J.attr("cursor", Ir[b = E2[b]])), _.selection && (A = _.selection), et && ($ = A[0][0], L = A[1][0]), Z && (S = A[0][1], C = A[1][1]), (A[0][0] !== $ || A[0][1] !== S || A[1][0] !== L || A[1][1] !== C) && (_.selection = [
-                [$, S],
-                [L, C]
-            ], l.call(y), X.brush(Q, w.name));
+            k < A && (v *= -1, Zn = N, N = E, E = Zn, Zn = A, A = k, k = Zn, b in Hb && X.attr("cursor", Dr[b = Hb[b]])), F < S && (x *= -1, Zn = R, R = C, C = Zn, Zn = S, S = F, F = Zn, b in Jb && X.attr("cursor", Dr[b = Jb[b]])), _.selection && (T = _.selection), K && (A = T[0][0], k = T[1][0]), H && (S = T[0][1], F = T[1][1]), (T[0][0] !== A || T[0][1] !== S || T[1][0] !== k || T[1][1] !== F) && (_.selection = [
+                [A, S],
+                [k, F]
+            ], u.call(g), W.brush(J, w.name));
         }
 
-        function rt(Q) {
-            if (Fq(Q), Q.touches) {
-                if (Q.touches.length)
+        function tt(J) {
+            if (qC(J), J.touches) {
+                if (J.touches.length)
                     return;
                 a && clearTimeout(a), a = setTimeout(function() {
                     a = null;
                 }, 500);
             } else
-                $3(Q.view, G), tt.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
-            j.attr("pointer-events", "all"), J.attr("cursor", Ir.overlay), _.selection && (A = _.selection), zq(A) && (_.selection = null, l.call(y)), X.end(Q, w.name);
+                wS(J.view, Y), Z.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
+            q.attr("pointer-events", "all"), X.attr("cursor", Dr.overlay), _.selection && (T = _.selection), HC(T) && (_.selection = null, u.call(g)), W.end(J, w.name);
         }
 
-        function Vt(Q) {
-            switch (Q.keyCode) {
+        function It(J) {
+            switch (J.keyCode) {
                 case 16: {
-                    K = v && x;
+                    G = v && x;
                     break;
                 }
                 case 18: {
-                    w === wa && (v && (D = L - z * v, N = $ + z * v), x && (U = C - P * x, R = S + P * x), w = va, Ft(Q));
+                    w === Hs && (v && (E = k - P * v, N = A + P * v), x && (C = F - U * x, R = S + U * x), w = Js, wt(J));
                     break;
                 }
                 case 32: {
-                    (w === wa || w === va) && (v < 0 ? D = L - z : v > 0 && (N = $ - z), x < 0 ? U = C - P : x > 0 && (R = S - P), w = mm, J.attr("cursor", Ir.selection), Ft(Q));
+                    (w === Hs || w === Js) && (v < 0 ? E = k - P : v > 0 && (N = A - P), x < 0 ? C = F - U : x > 0 && (R = S - U), w = fp, X.attr("cursor", Dr.selection), wt(J));
                     break;
                 }
                 default:
                     return;
             }
-            ym(Q);
+            lp(J);
         }
 
-        function jt(Q) {
-            switch (Q.keyCode) {
+        function Et(J) {
+            switch (J.keyCode) {
                 case 16: {
-                    K && (et = Z = K = !1, Ft(Q));
+                    G && (K = H = G = !1, wt(J));
                     break;
                 }
                 case 18: {
-                    w === va && (v < 0 ? D = L : v > 0 && (N = $), x < 0 ? U = C : x > 0 && (R = S), w = wa, Ft(Q));
+                    w === Js && (v < 0 ? E = k : v > 0 && (N = A), x < 0 ? C = F : x > 0 && (R = S), w = Hs, wt(J));
                     break;
                 }
                 case 32: {
-                    w === mm && (Q.altKey ? (v && (D = L - z * v, N = $ + z * v), x && (U = C - P * x, R = S + P * x), w = va) : (v < 0 ? D = L : v > 0 && (N = $), x < 0 ? U = C : x > 0 && (R = S), w = wa), J.attr("cursor", Ir[b]), Ft(Q));
+                    w === fp && (J.altKey ? (v && (E = k - P * v, N = A + P * v), x && (C = F - U * x, R = S + U * x), w = Js) : (v < 0 ? E = k : v > 0 && (N = A), x < 0 ? C = F : x > 0 && (R = S), w = Hs), X.attr("cursor", Dr[b]), wt(J));
                     break;
                 }
                 default:
                     return;
             }
-            ym(Q);
+            lp(J);
         }
     }
 
-    function d(g) {
-        u(this, arguments).moved(g);
+    function d(m) {
+        l(this, arguments).moved(m);
     }
 
-    function p(g) {
-        u(this, arguments).ended(g);
+    function p(m) {
+        l(this, arguments).ended(m);
     }
 
-    function m() {
-        var g = this.__brush || {
+    function y() {
+        var m = this.__brush || {
             selection: null
         };
-        return g.extent = Hg(t.apply(this, arguments)), g.dim = e, g;
+        return m.extent = B0(t.apply(this, arguments)), m.dim = e, m;
     }
-    return c.extent = function(g) {
-        return arguments.length ? (t = typeof g == "function" ? g : pm(Hg(g)), c) : t;
-    }, c.filter = function(g) {
-        return arguments.length ? (n = typeof g == "function" ? g : pm(!!g), c) : n;
-    }, c.touchable = function(g) {
-        return arguments.length ? (i = typeof g == "function" ? g : pm(!!g), c) : i;
-    }, c.handleSize = function(g) {
-        return arguments.length ? (o = +g, c) : o;
-    }, c.keyModifiers = function(g) {
-        return arguments.length ? (r = !!g, c) : r;
+    return c.extent = function(m) {
+        return arguments.length ? (t = typeof m == "function" ? m : up(B0(m)), c) : t;
+    }, c.filter = function(m) {
+        return arguments.length ? (n = typeof m == "function" ? m : up(!!m), c) : n;
+    }, c.touchable = function(m) {
+        return arguments.length ? (r = typeof m == "function" ? m : up(!!m), c) : r;
+    }, c.handleSize = function(m) {
+        return arguments.length ? (o = +m, c) : o;
+    }, c.keyModifiers = function(m) {
+        return arguments.length ? (i = !!m, c) : i;
     }, c.on = function() {
-        var g = s.on.apply(s, arguments);
-        return g === s ? c : g;
+        var m = s.on.apply(s, arguments);
+        return m === s ? c : m;
     }, c;
 }
-const Jg = Math.PI,
-    Kg = 2 * Jg,
-    To = 1e-6,
-    qq = Kg - To;
+const C0 = Math.PI,
+    P0 = 2 * C0,
+    cs = 1e-6,
+    QC = P0 - cs;
 
-function K3(e) {
+function jS(e) {
     this._ += e[0];
     for (let t = 1, n = e.length; t < n; ++t)
         this._ += arguments[t] + e[t];
 }
 
-function Yq(e) {
+function tP(e) {
     let t = Math.floor(e);
     if (!(t >= 0))
         throw new Error(`invalid digits: ${e}`);
     if (t > 15)
-        return K3;
+        return jS;
     const n = 10 ** t;
-    return function(i) {
-        this._ += i[0];
-        for (let r = 1, s = i.length; r < s; ++r)
-            this._ += Math.round(arguments[r] * n) / n + i[r];
+    return function(r) {
+        this._ += r[0];
+        for (let i = 1, s = r.length; i < s; ++i)
+            this._ += Math.round(arguments[i] * n) / n + r[i];
     };
 }
-let Z3 = class {
+let VS = class {
     constructor(t) {
         this._x0 = this._y0 = // start of current subpath
-            this._x1 = this._y1 = null, this._ = "", this._append = t == null ? K3 : Yq(t);
+            this._x1 = this._y1 = null, this._ = "", this._append = t == null ? jS : tP(t);
     }
     moveTo(t, n) {
         this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
     }
     closePath() {
         this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
     }
     lineTo(t, n) {
         this._append`L${this._x1 = +t},${this._y1 = +n}`;
     }
-    quadraticCurveTo(t, n, i, r) {
-        this._append`Q${+t},${+n},${this._x1 = +i},${this._y1 = +r}`;
+    quadraticCurveTo(t, n, r, i) {
+        this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
     }
-    bezierCurveTo(t, n, i, r, s, o) {
-        this._append`C${+t},${+n},${+i},${+r},${this._x1 = +s},${this._y1 = +o}`;
+    bezierCurveTo(t, n, r, i, s, o) {
+        this._append`C${+t},${+n},${+r},${+i},${this._x1 = +s},${this._y1 = +o}`;
     }
-    arcTo(t, n, i, r, s) {
-        if (t = +t, n = +n, i = +i, r = +r, s = +s, s < 0)
+    arcTo(t, n, r, i, s) {
+        if (t = +t, n = +n, r = +r, i = +i, s = +s, s < 0)
             throw new Error(`negative radius: ${s}`);
         let o = this._x1,
             a = this._y1,
-            c = i - t,
-            l = r - n,
-            u = o - t,
+            c = r - t,
+            u = i - n,
+            l = o - t,
             f = a - n,
-            h = u * u + f * f;
+            h = l * l + f * f;
         if (this._x1 === null)
             this._append`M${this._x1 = t},${this._y1 = n}`;
-        else if (h > To)
-            if (!(Math.abs(f * c - l * u) > To) || !s)
+        else if (h > cs)
+            if (!(Math.abs(f * c - u * l) > cs) || !s)
                 this._append`L${this._x1 = t},${this._y1 = n}`;
             else {
-                let d = i - o,
-                    p = r - a,
-                    m = c * c + l * l,
-                    g = d * d + p * p,
-                    y = Math.sqrt(m),
+                let d = r - o,
+                    p = i - a,
+                    y = c * c + u * u,
+                    m = d * d + p * p,
+                    g = Math.sqrt(y),
                     b = Math.sqrt(h),
-                    w = s * Math.tan((Jg - Math.acos((m + h - g) / (2 * y * b))) / 2),
+                    w = s * Math.tan((C0 - Math.acos((y + h - m) / (2 * g * b))) / 2),
                     v = w / b,
-                    x = w / y;
-                Math.abs(v - 1) > To && this._append`L${t + v * u},${n + v * f}`, this._append`A${s},${s},0,0,${+(f * d > u * p)},${this._x1 = t + x * c},${this._y1 = n + x * l}`;
+                    x = w / g;
+                Math.abs(v - 1) > cs && this._append`L${t + v * l},${n + v * f}`, this._append`A${s},${s},0,0,${+(f * d > l * p)},${this._x1 = t + x * c},${this._y1 = n + x * u}`;
             }
     }
-    arc(t, n, i, r, s, o) {
-        if (t = +t, n = +n, i = +i, o = !!o, i < 0)
-            throw new Error(`negative radius: ${i}`);
-        let a = i * Math.cos(r),
-            c = i * Math.sin(r),
-            l = t + a,
-            u = n + c,
+    arc(t, n, r, i, s, o) {
+        if (t = +t, n = +n, r = +r, o = !!o, r < 0)
+            throw new Error(`negative radius: ${r}`);
+        let a = r * Math.cos(i),
+            c = r * Math.sin(i),
+            u = t + a,
+            l = n + c,
             f = 1 ^ o,
-            h = o ? r - s : s - r;
-        this._x1 === null ? this._append`M${l},${u}` : (Math.abs(this._x1 - l) > To || Math.abs(this._y1 - u) > To) && this._append`L${l},${u}`, i && (h < 0 && (h = h % Kg + Kg), h > qq ? this._append`A${i},${i},0,1,${f},${t - a},${n - c}A${i},${i},0,1,${f},${this._x1 = l},${this._y1 = u}` : h > To && this._append`A${i},${i},0,${+(h >= Jg)},${f},${this._x1 = t + i * Math.cos(s)},${this._y1 = n + i * Math.sin(s)}`);
+            h = o ? i - s : s - i;
+        this._x1 === null ? this._append`M${u},${l}` : (Math.abs(this._x1 - u) > cs || Math.abs(this._y1 - l) > cs) && this._append`L${u},${l}`, r && (h < 0 && (h = h % P0 + P0), h > QC ? this._append`A${r},${r},0,1,${f},${t - a},${n - c}A${r},${r},0,1,${f},${this._x1 = u},${this._y1 = l}` : h > cs && this._append`A${r},${r},0,${+(h >= C0)},${f},${this._x1 = t + r * Math.cos(s)},${this._y1 = n + r * Math.sin(s)}`);
     }
-    rect(t, n, i, r) {
-        this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${i = +i}v${+r}h${-i}Z`;
+    rect(t, n, r, i) {
+        this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
     }
     toString() {
         return this._;
     }
 };
 
-function Xr(e = 3) {
-    return new Z3(+e);
+function Gr(e = 3) {
+    return new VS(+e);
 }
-var Wq = Array.prototype,
-    Q3 = Wq.slice;
+var eP = Array.prototype,
+    YS = eP.slice;
 
-function Gq(e, t) {
+function nP(e, t) {
     return e - t;
 }
 
-function Xq(e) {
-    for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n;)
-        i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
-    return i;
+function rP(e) {
+    for (var t = 0, n = e.length, r = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n;)
+        r += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
+    return r;
 }
-const $s = (e) => () => e;
+const xi = (e) => () => e;
 
-function Hq(e, t) {
-    for (var n = -1, i = t.length, r; ++n < i;)
-        if (r = Jq(e, t[n]))
-            return r;
+function iP(e, t) {
+    for (var n = -1, r = t.length, i; ++n < r;)
+        if (i = sP(e, t[n]))
+            return i;
     return 0;
 }
 
-function Jq(e, t) {
-    for (var n = t[0], i = t[1], r = -1, s = 0, o = e.length, a = o - 1; s < o; a = s++) {
+function sP(e, t) {
+    for (var n = t[0], r = t[1], i = -1, s = 0, o = e.length, a = o - 1; s < o; a = s++) {
         var c = e[s],
-            l = c[0],
-            u = c[1],
+            u = c[0],
+            l = c[1],
             f = e[a],
             h = f[0],
             d = f[1];
-        if (Kq(c, f, t))
+        if (oP(c, f, t))
             return 0;
-        u > i != d > i && n < (h - l) * (i - u) / (d - u) + l && (r = -r);
+        l > r != d > r && n < (h - u) * (r - l) / (d - l) + u && (i = -i);
     }
-    return r;
+    return i;
 }
 
-function Kq(e, t, n) {
-    var i;
-    return Zq(e, t, n) && Qq(e[i = +(e[0] === t[0])], n[i], t[i]);
+function oP(e, t, n) {
+    var r;
+    return aP(e, t, n) && cP(e[r = +(e[0] === t[0])], n[r], t[r]);
 }
 
-function Zq(e, t, n) {
+function aP(e, t, n) {
     return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
 }
 
-function Qq(e, t, n) {
+function cP(e, t, n) {
     return e <= t && t <= n || n <= t && t <= e;
 }
 
-function tY() {}
-var Ar = [
+function uP() {}
+var Or = [
     [],
     [
         [
             [1, 1.5],
             [0.5, 1]
         ]
     ],
@@ -15718,646 +16281,646 @@
             [0.5, 1],
             [1, 1.5]
         ]
     ],
     []
 ];
 
-function rp() {
+function Df() {
     var e = 1,
         t = 1,
-        n = qb,
-        i = c;
+        n = Sm,
+        r = c;
 
-    function r(l) {
-        var u = n(l);
-        if (Array.isArray(u))
-            u = u.slice().sort(Gq);
+    function i(u) {
+        var l = n(u);
+        if (Array.isArray(l))
+            l = l.slice().sort(nP);
         else {
-            const f = ke(l, eY);
-            for (u = Ys(...l3(f[0], f[1], u), u); u[u.length - 1] >= f[1];)
-                u.pop();
-            for (; u[1] < f[0];)
-                u.shift();
+            const f = de(u, lP);
+            for (l = Ci(...eS(f[0], f[1], l), l); l[l.length - 1] >= f[1];)
+                l.pop();
+            for (; l[1] < f[0];)
+                l.shift();
         }
-        return u.map((f) => s(l, f));
+        return l.map((f) => s(u, f));
     }
 
-    function s(l, u) {
-        const f = u == null ? NaN : +u;
+    function s(u, l) {
+        const f = l == null ? NaN : +l;
         if (isNaN(f))
-            throw new Error(`invalid value: ${u}`);
+            throw new Error(`invalid value: ${l}`);
         var h = [],
             d = [];
-        return o(l, f, function(p) {
-            i(p, l, f), Xq(p) > 0 ? h.push([p]) : d.push(p);
+        return o(u, f, function(p) {
+            r(p, u, f), rP(p) > 0 ? h.push([p]) : d.push(p);
         }), d.forEach(function(p) {
-            for (var m = 0, g = h.length, y; m < g; ++m)
-                if (Hq((y = h[m])[0], p) !== -1) {
-                    y.push(p);
+            for (var y = 0, m = h.length, g; y < m; ++y)
+                if (iP((g = h[y])[0], p) !== -1) {
+                    g.push(p);
                     return;
                 }
         }), {
             type: "MultiPolygon",
-            value: u,
+            value: l,
             coordinates: h
         };
     }
 
-    function o(l, u, f) {
+    function o(u, l, f) {
         var h = new Array(),
             d = new Array(),
-            p, m, g, y, b, w;
-        for (p = m = -1, y = mo(l[0], u), Ar[y << 1].forEach(v); ++p < e - 1;)
-            g = y, y = mo(l[p + 1], u), Ar[g | y << 1].forEach(v);
-        for (Ar[y << 0].forEach(v); ++m < t - 1;) {
-            for (p = -1, y = mo(l[m * e + e], u), b = mo(l[m * e], u), Ar[y << 1 | b << 2].forEach(v); ++p < e - 1;)
-                g = y, y = mo(l[m * e + e + p + 1], u), w = b, b = mo(l[m * e + p + 1], u), Ar[g | y << 1 | b << 2 | w << 3].forEach(v);
-            Ar[y | b << 3].forEach(v);
-        }
-        for (p = -1, b = l[m * e] >= u, Ar[b << 2].forEach(v); ++p < e - 1;)
-            w = b, b = mo(l[m * e + p + 1], u), Ar[b << 2 | w << 3].forEach(v);
-        Ar[b << 3].forEach(v);
+            p, y, m, g, b, w;
+        for (p = y = -1, g = ss(u[0], l), Or[g << 1].forEach(v); ++p < e - 1;)
+            m = g, g = ss(u[p + 1], l), Or[m | g << 1].forEach(v);
+        for (Or[g << 0].forEach(v); ++y < t - 1;) {
+            for (p = -1, g = ss(u[y * e + e], l), b = ss(u[y * e], l), Or[g << 1 | b << 2].forEach(v); ++p < e - 1;)
+                m = g, g = ss(u[y * e + e + p + 1], l), w = b, b = ss(u[y * e + p + 1], l), Or[m | g << 1 | b << 2 | w << 3].forEach(v);
+            Or[g | b << 3].forEach(v);
+        }
+        for (p = -1, b = u[y * e] >= l, Or[b << 2].forEach(v); ++p < e - 1;)
+            w = b, b = ss(u[y * e + p + 1], l), Or[b << 2 | w << 3].forEach(v);
+        Or[b << 3].forEach(v);
 
         function v(x) {
-            var _ = [x[0][0] + p, x[0][1] + m],
-                I = [x[1][0] + p, x[1][1] + m],
-                A = a(_),
-                M = a(I),
-                N, $;
-            (N = d[A]) ? ($ = h[M]) ? (delete d[N.end], delete h[$.start], N === $ ? (N.ring.push(I), f(N.ring)) : h[N.start] = d[$.end] = {
+            var _ = [x[0][0] + p, x[0][1] + y],
+                M = [x[1][0] + p, x[1][1] + y],
+                T = a(_),
+                $ = a(M),
+                N, A;
+            (N = d[T]) ? (A = h[$]) ? (delete d[N.end], delete h[A.start], N === A ? (N.ring.push(M), f(N.ring)) : h[N.start] = d[A.end] = {
                 start: N.start,
-                end: $.end,
-                ring: N.ring.concat($.ring)
-            }) : (delete d[N.end], N.ring.push(I), d[N.end = M] = N) : (N = h[M]) ? ($ = d[A]) ? (delete h[N.start], delete d[$.end], N === $ ? (N.ring.push(I), f(N.ring)) : h[$.start] = d[N.end] = {
-                start: $.start,
+                end: A.end,
+                ring: N.ring.concat(A.ring)
+            }) : (delete d[N.end], N.ring.push(M), d[N.end = $] = N) : (N = h[$]) ? (A = d[T]) ? (delete h[N.start], delete d[A.end], N === A ? (N.ring.push(M), f(N.ring)) : h[A.start] = d[N.end] = {
+                start: A.start,
                 end: N.end,
-                ring: $.ring.concat(N.ring)
-            }) : (delete h[N.start], N.ring.unshift(_), h[N.start = A] = N) : h[A] = d[M] = {
-                start: A,
-                end: M,
-                ring: [_, I]
+                ring: A.ring.concat(N.ring)
+            }) : (delete h[N.start], N.ring.unshift(_), h[N.start = T] = N) : h[T] = d[$] = {
+                start: T,
+                end: $,
+                ring: [_, M]
             };
         }
     }
 
-    function a(l) {
-        return l[0] * 2 + l[1] * (e + 1) * 4;
+    function a(u) {
+        return u[0] * 2 + u[1] * (e + 1) * 4;
     }
 
-    function c(l, u, f) {
-        l.forEach(function(h) {
+    function c(u, l, f) {
+        u.forEach(function(h) {
             var d = h[0],
                 p = h[1],
-                m = d | 0,
-                g = p | 0,
-                y = bm(u[g * e + m]);
-            d > 0 && d < e && m === d && (h[0] = L2(d, bm(u[g * e + m - 1]), y, f)), p > 0 && p < t && g === p && (h[1] = L2(p, bm(u[(g - 1) * e + m]), y, f));
+                y = d | 0,
+                m = p | 0,
+                g = dp(l[m * e + y]);
+            d > 0 && d < e && y === d && (h[0] = Zb(d, dp(l[m * e + y - 1]), g, f)), p > 0 && p < t && m === p && (h[1] = Zb(p, dp(l[(m - 1) * e + y]), g, f));
         });
     }
-    return r.contour = s, r.size = function(l) {
+    return i.contour = s, i.size = function(u) {
         if (!arguments.length)
             return [e, t];
-        var u = Math.floor(l[0]),
-            f = Math.floor(l[1]);
-        if (!(u >= 0 && f >= 0))
+        var l = Math.floor(u[0]),
+            f = Math.floor(u[1]);
+        if (!(l >= 0 && f >= 0))
             throw new Error("invalid size");
-        return e = u, t = f, r;
-    }, r.thresholds = function(l) {
-        return arguments.length ? (n = typeof l == "function" ? l : Array.isArray(l) ? $s(Q3.call(l)) : $s(l), r) : n;
-    }, r.smooth = function(l) {
-        return arguments.length ? (i = l ? c : tY, r) : i === c;
-    }, r;
+        return e = l, t = f, i;
+    }, i.thresholds = function(u) {
+        return arguments.length ? (n = typeof u == "function" ? u : Array.isArray(u) ? xi(YS.call(u)) : xi(u), i) : n;
+    }, i.smooth = function(u) {
+        return arguments.length ? (r = u ? c : uP, i) : r === c;
+    }, i;
 }
 
-function eY(e) {
+function lP(e) {
     return isFinite(e) ? e : NaN;
 }
 
-function mo(e, t) {
+function ss(e, t) {
     return e == null ? !1 : +e >= t;
 }
 
-function bm(e) {
+function dp(e) {
     return e == null || isNaN(e = +e) ? -1 / 0 : e;
 }
 
-function L2(e, t, n, i) {
-    const r = i - t,
+function Zb(e, t, n, r) {
+    const i = r - t,
         s = n - t,
-        o = isFinite(r) || isFinite(s) ? r / s : Math.sign(r) / Math.sign(s);
+        o = isFinite(i) || isFinite(s) ? i / s : Math.sign(i) / Math.sign(s);
     return isNaN(o) ? e : e + o - 0.5;
 }
 
-function nY(e) {
+function fP(e) {
     return e[0];
 }
 
-function iY(e) {
+function hP(e) {
     return e[1];
 }
 
-function rY() {
+function dP() {
     return 1;
 }
 
-function sY() {
-    var e = nY,
-        t = iY,
-        n = rY,
-        i = 960,
-        r = 500,
+function pP() {
+    var e = fP,
+        t = hP,
+        n = dP,
+        r = 960,
+        i = 500,
         s = 20,
         o = 2,
         a = s * 3,
-        c = i + a * 2 >> o,
-        l = r + a * 2 >> o,
-        u = $s(20);
+        c = r + a * 2 >> o,
+        u = i + a * 2 >> o,
+        l = xi(20);
 
     function f(b) {
-        var w = new Float32Array(c * l),
+        var w = new Float32Array(c * u),
             v = Math.pow(2, -o),
             x = -1;
         for (const R of b) {
             var _ = (e(R, ++x, b) + a) * v,
-                I = (t(R, x, b) + a) * v,
-                A = +n(R, x, b);
-            if (A && _ >= 0 && _ < c && I >= 0 && I < l) {
-                var M = Math.floor(_),
-                    N = Math.floor(I),
-                    $ = _ - M - 0.5,
-                    B = I - N - 0.5;
-                w[M + N * c] += (1 - $) * (1 - B) * A, w[M + 1 + N * c] += $ * (1 - B) * A, w[M + 1 + (N + 1) * c] += $ * B * A, w[M + (N + 1) * c] += (1 - $) * B * A;
+                M = (t(R, x, b) + a) * v,
+                T = +n(R, x, b);
+            if (T && _ >= 0 && _ < c && M >= 0 && M < u) {
+                var $ = Math.floor(_),
+                    N = Math.floor(M),
+                    A = _ - $ - 0.5,
+                    D = M - N - 0.5;
+                w[$ + N * c] += (1 - A) * (1 - D) * T, w[$ + 1 + N * c] += A * (1 - D) * T, w[$ + 1 + (N + 1) * c] += A * D * T, w[$ + (N + 1) * c] += (1 - A) * D * T;
             }
         }
-        return i3({
+        return Hx({
             data: w,
             width: c,
-            height: l
+            height: u
         }, s * v), w;
     }
 
     function h(b) {
         var w = f(b),
-            v = u(w),
+            v = l(w),
             x = Math.pow(2, 2 * o);
-        return Array.isArray(v) || (v = Ys(Number.MIN_VALUE, De(w) / x, v)), rp().size([c, l]).thresholds(v.map((_) => _ * x))(w).map((_, I) => (_.value = +v[I], d(_)));
+        return Array.isArray(v) || (v = Ci(Number.MIN_VALUE, ae(w) / x, v)), Df().size([c, u]).thresholds(v.map((_) => _ * x))(w).map((_, M) => (_.value = +v[M], d(_)));
     }
     h.contours = function(b) {
         var w = f(b),
-            v = rp().size([c, l]),
+            v = Df().size([c, u]),
             x = Math.pow(2, 2 * o),
-            _ = (I) => {
-                I = +I;
-                var A = d(v.contour(w, I * x));
-                return A.value = I, A;
+            _ = (M) => {
+                M = +M;
+                var T = d(v.contour(w, M * x));
+                return T.value = M, T;
             };
         return Object.defineProperty(_, "max", {
-            get: () => De(w) / x
+            get: () => ae(w) / x
         }), _;
     };
 
     function d(b) {
         return b.coordinates.forEach(p), b;
     }
 
     function p(b) {
-        b.forEach(m);
+        b.forEach(y);
     }
 
-    function m(b) {
-        b.forEach(g);
+    function y(b) {
+        b.forEach(m);
     }
 
-    function g(b) {
+    function m(b) {
         b[0] = b[0] * Math.pow(2, o) - a, b[1] = b[1] * Math.pow(2, o) - a;
     }
 
-    function y() {
-        return a = s * 3, c = i + a * 2 >> o, l = r + a * 2 >> o, h;
+    function g() {
+        return a = s * 3, c = r + a * 2 >> o, u = i + a * 2 >> o, h;
     }
     return h.x = function(b) {
-        return arguments.length ? (e = typeof b == "function" ? b : $s(+b), h) : e;
+        return arguments.length ? (e = typeof b == "function" ? b : xi(+b), h) : e;
     }, h.y = function(b) {
-        return arguments.length ? (t = typeof b == "function" ? b : $s(+b), h) : t;
+        return arguments.length ? (t = typeof b == "function" ? b : xi(+b), h) : t;
     }, h.weight = function(b) {
-        return arguments.length ? (n = typeof b == "function" ? b : $s(+b), h) : n;
+        return arguments.length ? (n = typeof b == "function" ? b : xi(+b), h) : n;
     }, h.size = function(b) {
         if (!arguments.length)
-            return [i, r];
+            return [r, i];
         var w = +b[0],
             v = +b[1];
         if (!(w >= 0 && v >= 0))
             throw new Error("invalid size");
-        return i = w, r = v, y();
+        return r = w, i = v, g();
     }, h.cellSize = function(b) {
         if (!arguments.length)
             return 1 << o;
         if (!((b = +b) >= 1))
             throw new Error("invalid cell size");
-        return o = Math.floor(Math.log(b) / Math.LN2), y();
+        return o = Math.floor(Math.log(b) / Math.LN2), g();
     }, h.thresholds = function(b) {
-        return arguments.length ? (u = typeof b == "function" ? b : Array.isArray(b) ? $s(Q3.call(b)) : $s(b), h) : u;
+        return arguments.length ? (l = typeof b == "function" ? b : Array.isArray(b) ? xi(YS.call(b)) : xi(b), h) : l;
     }, h.bandwidth = function(b) {
         if (!arguments.length)
             return Math.sqrt(s * (s + 1));
         if (!((b = +b) >= 0))
             throw new Error("invalid bandwidth");
-        return s = (Math.sqrt(4 * b * b + 1) - 1) / 2, y();
+        return s = (Math.sqrt(4 * b * b + 1) - 1) / 2, g();
     }, h;
 }
-const Zr = 11102230246251565e-32,
-    Ze = 134217729,
-    oY = (3 + 8 * Zr) * Zr;
-
-function wm(e, t, n, i, r) {
-    let s, o, a, c, l = t[0],
-        u = i[0],
+const Kr = 11102230246251565e-32,
+    Ie = 134217729,
+    yP = (3 + 8 * Kr) * Kr;
+
+function pp(e, t, n, r, i) {
+    let s, o, a, c, u = t[0],
+        l = r[0],
         f = 0,
         h = 0;
-    u > l == u > -l ? (s = l, l = t[++f]) : (s = u, u = i[++h]);
+    l > u == l > -u ? (s = u, u = t[++f]) : (s = l, l = r[++h]);
     let d = 0;
     if (f < e && h < n)
-        for (u > l == u > -l ? (o = l + s, a = s - (o - l), l = t[++f]) : (o = u + s, a = s - (o - u), u = i[++h]), s = o, a !== 0 && (r[d++] = a); f < e && h < n;)
-            u > l == u > -l ? (o = s + l, c = o - s, a = s - (o - c) + (l - c), l = t[++f]) : (o = s + u, c = o - s, a = s - (o - c) + (u - c), u = i[++h]), s = o, a !== 0 && (r[d++] = a);
+        for (l > u == l > -u ? (o = u + s, a = s - (o - u), u = t[++f]) : (o = l + s, a = s - (o - l), l = r[++h]), s = o, a !== 0 && (i[d++] = a); f < e && h < n;)
+            l > u == l > -u ? (o = s + u, c = o - s, a = s - (o - c) + (u - c), u = t[++f]) : (o = s + l, c = o - s, a = s - (o - c) + (l - c), l = r[++h]), s = o, a !== 0 && (i[d++] = a);
     for (; f < e;)
-        o = s + l, c = o - s, a = s - (o - c) + (l - c), l = t[++f], s = o, a !== 0 && (r[d++] = a);
+        o = s + u, c = o - s, a = s - (o - c) + (u - c), u = t[++f], s = o, a !== 0 && (i[d++] = a);
     for (; h < n;)
-        o = s + u, c = o - s, a = s - (o - c) + (u - c), u = i[++h], s = o, a !== 0 && (r[d++] = a);
-    return (s !== 0 || d === 0) && (r[d++] = s), d;
+        o = s + l, c = o - s, a = s - (o - c) + (l - c), l = r[++h], s = o, a !== 0 && (i[d++] = a);
+    return (s !== 0 || d === 0) && (i[d++] = s), d;
 }
 
-function aY(e, t) {
+function mP(e, t) {
     let n = t[0];
-    for (let i = 1; i < e; i++)
-        n += t[i];
+    for (let r = 1; r < e; r++)
+        n += t[r];
     return n;
 }
 
-function vf(e) {
+function lu(e) {
     return new Float64Array(e);
 }
-const cY = (3 + 16 * Zr) * Zr,
-    lY = (2 + 12 * Zr) * Zr,
-    uY = (9 + 64 * Zr) * Zr * Zr,
-    _a = vf(4),
-    R2 = vf(8),
-    C2 = vf(12),
-    k2 = vf(16),
-    sn = vf(4);
-
-function fY(e, t, n, i, r, s, o) {
-    let a, c, l, u, f, h, d, p, m, g, y, b, w, v, x, _, I, A;
-    const M = e - r,
-        N = n - r,
-        $ = t - s,
-        B = i - s;
-    v = M * B, h = Ze * M, d = h - (h - M), p = M - d, h = Ze * B, m = h - (h - B), g = B - m, x = p * g - (v - d * m - p * m - d * g), _ = $ * N, h = Ze * $, d = h - (h - $), p = $ - d, h = Ze * N, m = h - (h - N), g = N - m, I = p * g - (_ - d * m - p * m - d * g), y = x - I, f = x - y, _a[0] = x - (y + f) + (f - I), b = v + y, f = b - v, w = v - (b - f) + (y - f), y = w - _, f = w - y, _a[1] = w - (y + f) + (f - _), A = b + y, f = A - b, _a[2] = b - (A - f) + (y - f), _a[3] = A;
-    let R = aY(4, _a),
-        S = lY * o;
-    if (R >= S || -R >= S || (f = e - M, a = e - (M + f) + (f - r), f = n - N, l = n - (N + f) + (f - r), f = t - $, c = t - ($ + f) + (f - s), f = i - B, u = i - (B + f) + (f - s), a === 0 && c === 0 && l === 0 && u === 0) || (S = uY * o + oY * Math.abs(R), R += M * u + B * a - ($ * l + N * c), R >= S || -R >= S))
+const gP = (3 + 16 * Kr) * Kr,
+    bP = (2 + 12 * Kr) * Kr,
+    wP = (9 + 64 * Kr) * Kr * Kr,
+    Zs = lu(4),
+    Kb = lu(8),
+    Qb = lu(12),
+    tw = lu(16),
+    Oe = lu(4);
+
+function vP(e, t, n, r, i, s, o) {
+    let a, c, u, l, f, h, d, p, y, m, g, b, w, v, x, _, M, T;
+    const $ = e - i,
+        N = n - i,
+        A = t - s,
+        D = r - s;
+    v = $ * D, h = Ie * $, d = h - (h - $), p = $ - d, h = Ie * D, y = h - (h - D), m = D - y, x = p * m - (v - d * y - p * y - d * m), _ = A * N, h = Ie * A, d = h - (h - A), p = A - d, h = Ie * N, y = h - (h - N), m = N - y, M = p * m - (_ - d * y - p * y - d * m), g = x - M, f = x - g, Zs[0] = x - (g + f) + (f - M), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, Zs[1] = w - (g + f) + (f - _), T = b + g, f = T - b, Zs[2] = b - (T - f) + (g - f), Zs[3] = T;
+    let R = mP(4, Zs),
+        S = bP * o;
+    if (R >= S || -R >= S || (f = e - $, a = e - ($ + f) + (f - i), f = n - N, u = n - (N + f) + (f - i), f = t - A, c = t - (A + f) + (f - s), f = r - D, l = r - (D + f) + (f - s), a === 0 && c === 0 && u === 0 && l === 0) || (S = wP * o + yP * Math.abs(R), R += $ * l + D * a - (A * u + N * c), R >= S || -R >= S))
         return R;
-    v = a * B, h = Ze * a, d = h - (h - a), p = a - d, h = Ze * B, m = h - (h - B), g = B - m, x = p * g - (v - d * m - p * m - d * g), _ = c * N, h = Ze * c, d = h - (h - c), p = c - d, h = Ze * N, m = h - (h - N), g = N - m, I = p * g - (_ - d * m - p * m - d * g), y = x - I, f = x - y, sn[0] = x - (y + f) + (f - I), b = v + y, f = b - v, w = v - (b - f) + (y - f), y = w - _, f = w - y, sn[1] = w - (y + f) + (f - _), A = b + y, f = A - b, sn[2] = b - (A - f) + (y - f), sn[3] = A;
-    const T = wm(4, _a, 4, sn, R2);
-    v = M * u, h = Ze * M, d = h - (h - M), p = M - d, h = Ze * u, m = h - (h - u), g = u - m, x = p * g - (v - d * m - p * m - d * g), _ = $ * l, h = Ze * $, d = h - (h - $), p = $ - d, h = Ze * l, m = h - (h - l), g = l - m, I = p * g - (_ - d * m - p * m - d * g), y = x - I, f = x - y, sn[0] = x - (y + f) + (f - I), b = v + y, f = b - v, w = v - (b - f) + (y - f), y = w - _, f = w - y, sn[1] = w - (y + f) + (f - _), A = b + y, f = A - b, sn[2] = b - (A - f) + (y - f), sn[3] = A;
-    const D = wm(T, R2, 4, sn, C2);
-    v = a * u, h = Ze * a, d = h - (h - a), p = a - d, h = Ze * u, m = h - (h - u), g = u - m, x = p * g - (v - d * m - p * m - d * g), _ = c * l, h = Ze * c, d = h - (h - c), p = c - d, h = Ze * l, m = h - (h - l), g = l - m, I = p * g - (_ - d * m - p * m - d * g), y = x - I, f = x - y, sn[0] = x - (y + f) + (f - I), b = v + y, f = b - v, w = v - (b - f) + (y - f), y = w - _, f = w - y, sn[1] = w - (y + f) + (f - _), A = b + y, f = A - b, sn[2] = b - (A - f) + (y - f), sn[3] = A;
-    const L = wm(D, C2, 4, sn, k2);
-    return k2[L - 1];
+    v = a * D, h = Ie * a, d = h - (h - a), p = a - d, h = Ie * D, y = h - (h - D), m = D - y, x = p * m - (v - d * y - p * y - d * m), _ = c * N, h = Ie * c, d = h - (h - c), p = c - d, h = Ie * N, y = h - (h - N), m = N - y, M = p * m - (_ - d * y - p * y - d * m), g = x - M, f = x - g, Oe[0] = x - (g + f) + (f - M), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, Oe[1] = w - (g + f) + (f - _), T = b + g, f = T - b, Oe[2] = b - (T - f) + (g - f), Oe[3] = T;
+    const I = pp(4, Zs, 4, Oe, Kb);
+    v = $ * l, h = Ie * $, d = h - (h - $), p = $ - d, h = Ie * l, y = h - (h - l), m = l - y, x = p * m - (v - d * y - p * y - d * m), _ = A * u, h = Ie * A, d = h - (h - A), p = A - d, h = Ie * u, y = h - (h - u), m = u - y, M = p * m - (_ - d * y - p * y - d * m), g = x - M, f = x - g, Oe[0] = x - (g + f) + (f - M), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, Oe[1] = w - (g + f) + (f - _), T = b + g, f = T - b, Oe[2] = b - (T - f) + (g - f), Oe[3] = T;
+    const E = pp(I, Kb, 4, Oe, Qb);
+    v = a * l, h = Ie * a, d = h - (h - a), p = a - d, h = Ie * l, y = h - (h - l), m = l - y, x = p * m - (v - d * y - p * y - d * m), _ = c * u, h = Ie * c, d = h - (h - c), p = c - d, h = Ie * u, y = h - (h - u), m = u - y, M = p * m - (_ - d * y - p * y - d * m), g = x - M, f = x - g, Oe[0] = x - (g + f) + (f - M), b = v + g, f = b - v, w = v - (b - f) + (g - f), g = w - _, f = w - g, Oe[1] = w - (g + f) + (f - _), T = b + g, f = T - b, Oe[2] = b - (T - f) + (g - f), Oe[3] = T;
+    const k = pp(E, Qb, 4, Oe, tw);
+    return tw[k - 1];
 }
 
-function uh(e, t, n, i, r, s) {
-    const o = (t - s) * (n - r),
-        a = (e - r) * (i - s),
+function Hu(e, t, n, r, i, s) {
+    const o = (t - s) * (n - i),
+        a = (e - i) * (r - s),
         c = o - a,
-        l = Math.abs(o + a);
-    return Math.abs(c) >= cY * l ? c : -fY(e, t, n, i, r, s, l);
+        u = Math.abs(o + a);
+    return Math.abs(c) >= gP * u ? c : -vP(e, t, n, r, i, s, u);
 }
-const U2 = Math.pow(2, -52),
-    fh = new Uint32Array(512);
-class sp {
-    static from(t, n = mY, i = gY) {
-        const r = t.length,
-            s = new Float64Array(r * 2);
-        for (let o = 0; o < r; o++) {
+const ew = Math.pow(2, -52),
+    Ju = new Uint32Array(512);
+class Of {
+    static from(t, n = AP, r = $P) {
+        const i = t.length,
+            s = new Float64Array(i * 2);
+        for (let o = 0; o < i; o++) {
             const a = t[o];
-            s[2 * o] = n(a), s[2 * o + 1] = i(a);
+            s[2 * o] = n(a), s[2 * o + 1] = r(a);
         }
-        return new sp(s);
+        return new Of(s);
     }
     constructor(t) {
         const n = t.length >> 1;
         if (n > 0 && typeof t[0] != "number")
             throw new Error("Expected coords to contain numbers.");
         this.coords = t;
-        const i = Math.max(2 * n - 5, 0);
-        this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
+        const r = Math.max(2 * n - 5, 0);
+        this._triangles = new Uint32Array(r * 3), this._halfedges = new Int32Array(r * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
     }
     update() {
         const {
             coords: t,
             _hullPrev: n,
-            _hullNext: i,
-            _hullTri: r,
+            _hullNext: r,
+            _hullTri: i,
             _hullHash: s
         } = this, o = t.length >> 1;
         let a = 1 / 0,
             c = 1 / 0,
-            l = -1 / 0,
-            u = -1 / 0;
-        for (let M = 0; M < o; M++) {
-            const N = t[2 * M],
-                $ = t[2 * M + 1];
-            N < a && (a = N), $ < c && (c = $), N > l && (l = N), $ > u && (u = $), this._ids[M] = M;
-        }
-        const f = (a + l) / 2,
-            h = (c + u) / 2;
-        let d, p, m;
-        for (let M = 0, N = 1 / 0; M < o; M++) {
-            const $ = vm(f, h, t[2 * M], t[2 * M + 1]);
-            $ < N && (d = M, N = $);
-        }
-        const g = t[2 * d],
-            y = t[2 * d + 1];
-        for (let M = 0, N = 1 / 0; M < o; M++) {
-            if (M === d)
+            u = -1 / 0,
+            l = -1 / 0;
+        for (let $ = 0; $ < o; $++) {
+            const N = t[2 * $],
+                A = t[2 * $ + 1];
+            N < a && (a = N), A < c && (c = A), N > u && (u = N), A > l && (l = A), this._ids[$] = $;
+        }
+        const f = (a + u) / 2,
+            h = (c + l) / 2;
+        let d, p, y;
+        for (let $ = 0, N = 1 / 0; $ < o; $++) {
+            const A = yp(f, h, t[2 * $], t[2 * $ + 1]);
+            A < N && (d = $, N = A);
+        }
+        const m = t[2 * d],
+            g = t[2 * d + 1];
+        for (let $ = 0, N = 1 / 0; $ < o; $++) {
+            if ($ === d)
                 continue;
-            const $ = vm(g, y, t[2 * M], t[2 * M + 1]);
-            $ < N && $ > 0 && (p = M, N = $);
+            const A = yp(m, g, t[2 * $], t[2 * $ + 1]);
+            A < N && A > 0 && (p = $, N = A);
         }
         let b = t[2 * p],
             w = t[2 * p + 1],
             v = 1 / 0;
-        for (let M = 0; M < o; M++) {
-            if (M === d || M === p)
+        for (let $ = 0; $ < o; $++) {
+            if ($ === d || $ === p)
                 continue;
-            const N = pY(g, y, b, w, t[2 * M], t[2 * M + 1]);
-            N < v && (m = M, v = N);
+            const N = SP(m, g, b, w, t[2 * $], t[2 * $ + 1]);
+            N < v && (y = $, v = N);
         }
-        let x = t[2 * m],
-            _ = t[2 * m + 1];
+        let x = t[2 * y],
+            _ = t[2 * y + 1];
         if (v === 1 / 0) {
-            for (let $ = 0; $ < o; $++)
-                this._dists[$] = t[2 * $] - t[0] || t[2 * $ + 1] - t[1];
-            Za(this._ids, this._dists, 0, o - 1);
-            const M = new Uint32Array(o);
+            for (let A = 0; A < o; A++)
+                this._dists[A] = t[2 * A] - t[0] || t[2 * A + 1] - t[1];
+            yo(this._ids, this._dists, 0, o - 1);
+            const $ = new Uint32Array(o);
             let N = 0;
-            for (let $ = 0, B = -1 / 0; $ < o; $++) {
-                const R = this._ids[$],
+            for (let A = 0, D = -1 / 0; A < o; A++) {
+                const R = this._ids[A],
                     S = this._dists[R];
-                S > B && (M[N++] = R, B = S);
+                S > D && ($[N++] = R, D = S);
             }
-            this.hull = M.subarray(0, N), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
+            this.hull = $.subarray(0, N), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
             return;
         }
-        if (uh(g, y, b, w, x, _) < 0) {
-            const M = p,
+        if (Hu(m, g, b, w, x, _) < 0) {
+            const $ = p,
                 N = b,
-                $ = w;
-            p = m, b = x, w = _, m = M, x = N, _ = $;
+                A = w;
+            p = y, b = x, w = _, y = $, x = N, _ = A;
         }
-        const I = yY(g, y, b, w, x, _);
-        this._cx = I.x, this._cy = I.y;
-        for (let M = 0; M < o; M++)
-            this._dists[M] = vm(t[2 * M], t[2 * M + 1], I.x, I.y);
-        Za(this._ids, this._dists, 0, o - 1), this._hullStart = d;
-        let A = 3;
-        i[d] = n[m] = p, i[p] = n[d] = m, i[m] = n[p] = d, r[d] = 0, r[p] = 1, r[m] = 2, s.fill(-1), s[this._hashKey(g, y)] = d, s[this._hashKey(b, w)] = p, s[this._hashKey(x, _)] = m, this.trianglesLen = 0, this._addTriangle(d, p, m, -1, -1, -1);
-        for (let M = 0, N, $; M < this._ids.length; M++) {
-            const B = this._ids[M],
-                R = t[2 * B],
-                S = t[2 * B + 1];
-            if (M > 0 && Math.abs(R - N) <= U2 && Math.abs(S - $) <= U2 || (N = R, $ = S, B === d || B === p || B === m))
+        const M = MP(m, g, b, w, x, _);
+        this._cx = M.x, this._cy = M.y;
+        for (let $ = 0; $ < o; $++)
+            this._dists[$] = yp(t[2 * $], t[2 * $ + 1], M.x, M.y);
+        yo(this._ids, this._dists, 0, o - 1), this._hullStart = d;
+        let T = 3;
+        r[d] = n[y] = p, r[p] = n[d] = y, r[y] = n[p] = d, i[d] = 0, i[p] = 1, i[y] = 2, s.fill(-1), s[this._hashKey(m, g)] = d, s[this._hashKey(b, w)] = p, s[this._hashKey(x, _)] = y, this.trianglesLen = 0, this._addTriangle(d, p, y, -1, -1, -1);
+        for (let $ = 0, N, A; $ < this._ids.length; $++) {
+            const D = this._ids[$],
+                R = t[2 * D],
+                S = t[2 * D + 1];
+            if ($ > 0 && Math.abs(R - N) <= ew && Math.abs(S - A) <= ew || (N = R, A = S, D === d || D === p || D === y))
                 continue;
-            let T = 0;
-            for (let C = 0, z = this._hashKey(R, S); C < this._hashSize && (T = s[(z + C) % this._hashSize], !(T !== -1 && T !== i[T])); C++)
+            let I = 0;
+            for (let F = 0, P = this._hashKey(R, S); F < this._hashSize && (I = s[(P + F) % this._hashSize], !(I !== -1 && I !== r[I])); F++)
             ;
-            T = n[T];
-            let D = T,
-                L;
-            for (; L = i[D], uh(R, S, t[2 * D], t[2 * D + 1], t[2 * L], t[2 * L + 1]) >= 0;)
-                if (D = L, D === T) {
-                    D = -1;
+            I = n[I];
+            let E = I,
+                k;
+            for (; k = r[E], Hu(R, S, t[2 * E], t[2 * E + 1], t[2 * k], t[2 * k + 1]) >= 0;)
+                if (E = k, E === I) {
+                    E = -1;
                     break;
                 }
-            if (D === -1)
+            if (E === -1)
                 continue;
-            let k = this._addTriangle(D, B, i[D], -1, -1, r[D]);
-            r[B] = this._legalize(k + 2), r[D] = k, A++;
-            let U = i[D];
-            for (; L = i[U], uh(R, S, t[2 * U], t[2 * U + 1], t[2 * L], t[2 * L + 1]) < 0;)
-                k = this._addTriangle(U, B, L, r[B], -1, r[U]), r[B] = this._legalize(k + 2), i[U] = U, A--, U = L;
-            if (D === T)
-                for (; L = n[D], uh(R, S, t[2 * L], t[2 * L + 1], t[2 * D], t[2 * D + 1]) < 0;)
-                    k = this._addTriangle(L, B, D, -1, r[D], r[L]), this._legalize(k + 2), r[L] = k, i[D] = D, A--, D = L;
-            this._hullStart = n[B] = D, i[D] = n[U] = B, i[B] = U, s[this._hashKey(R, S)] = B, s[this._hashKey(t[2 * D], t[2 * D + 1])] = D;
-        }
-        this.hull = new Uint32Array(A);
-        for (let M = 0, N = this._hullStart; M < A; M++)
-            this.hull[M] = N, N = i[N];
+            let B = this._addTriangle(E, D, r[E], -1, -1, i[E]);
+            i[D] = this._legalize(B + 2), i[E] = B, T++;
+            let C = r[E];
+            for (; k = r[C], Hu(R, S, t[2 * C], t[2 * C + 1], t[2 * k], t[2 * k + 1]) < 0;)
+                B = this._addTriangle(C, D, k, i[D], -1, i[C]), i[D] = this._legalize(B + 2), r[C] = C, T--, C = k;
+            if (E === I)
+                for (; k = n[E], Hu(R, S, t[2 * k], t[2 * k + 1], t[2 * E], t[2 * E + 1]) < 0;)
+                    B = this._addTriangle(k, D, E, -1, i[E], i[k]), this._legalize(B + 2), i[k] = B, r[E] = E, T--, E = k;
+            this._hullStart = n[D] = E, r[E] = n[C] = D, r[D] = C, s[this._hashKey(R, S)] = D, s[this._hashKey(t[2 * E], t[2 * E + 1])] = E;
+        }
+        this.hull = new Uint32Array(T);
+        for (let $ = 0, N = this._hullStart; $ < T; $++)
+            this.hull[$] = N, N = r[N];
         this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
     }
     _hashKey(t, n) {
-        return Math.floor(hY(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
+        return Math.floor(_P(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
     }
     _legalize(t) {
         const {
             _triangles: n,
-            _halfedges: i,
-            coords: r
+            _halfedges: r,
+            coords: i
         } = this;
         let s = 0,
             o = 0;
         for (;;) {
-            const a = i[t],
+            const a = r[t],
                 c = t - t % 3;
             if (o = c + (t + 2) % 3, a === -1) {
                 if (s === 0)
                     break;
-                t = fh[--s];
+                t = Ju[--s];
                 continue;
             }
-            const l = a - a % 3,
-                u = c + (t + 1) % 3,
-                f = l + (a + 2) % 3,
+            const u = a - a % 3,
+                l = c + (t + 1) % 3,
+                f = u + (a + 2) % 3,
                 h = n[o],
                 d = n[t],
-                p = n[u],
-                m = n[f];
-            if (dY(
-                    r[2 * h],
-                    r[2 * h + 1],
-                    r[2 * d],
-                    r[2 * d + 1],
-                    r[2 * p],
-                    r[2 * p + 1],
-                    r[2 * m],
-                    r[2 * m + 1]
+                p = n[l],
+                y = n[f];
+            if (xP(
+                    i[2 * h],
+                    i[2 * h + 1],
+                    i[2 * d],
+                    i[2 * d + 1],
+                    i[2 * p],
+                    i[2 * p + 1],
+                    i[2 * y],
+                    i[2 * y + 1]
                 )) {
-                n[t] = m, n[a] = h;
-                const y = i[f];
-                if (y === -1) {
+                n[t] = y, n[a] = h;
+                const g = r[f];
+                if (g === -1) {
                     let w = this._hullStart;
                     do {
                         if (this._hullTri[w] === f) {
                             this._hullTri[w] = t;
                             break;
                         }
                         w = this._hullPrev[w];
                     } while (w !== this._hullStart);
                 }
-                this._link(t, y), this._link(a, i[o]), this._link(o, f);
-                const b = l + (a + 1) % 3;
-                s < fh.length && (fh[s++] = b);
+                this._link(t, g), this._link(a, r[o]), this._link(o, f);
+                const b = u + (a + 1) % 3;
+                s < Ju.length && (Ju[s++] = b);
             } else {
                 if (s === 0)
                     break;
-                t = fh[--s];
+                t = Ju[--s];
             }
         }
         return o;
     }
     _link(t, n) {
         this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
     }
     // add a new triangle given vertex indices and adjacent half-edge ids
-    _addTriangle(t, n, i, r, s, o) {
+    _addTriangle(t, n, r, i, s, o) {
         const a = this.trianglesLen;
-        return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = i, this._link(a, r), this._link(a + 1, s), this._link(a + 2, o), this.trianglesLen += 3, a;
+        return this._triangles[a] = t, this._triangles[a + 1] = n, this._triangles[a + 2] = r, this._link(a, i), this._link(a + 1, s), this._link(a + 2, o), this.trianglesLen += 3, a;
     }
 }
 
-function hY(e, t) {
+function _P(e, t) {
     const n = e / (Math.abs(e) + Math.abs(t));
     return (t > 0 ? 3 - n : 1 + n) / 4;
 }
 
-function vm(e, t, n, i) {
-    const r = e - n,
-        s = t - i;
-    return r * r + s * s;
+function yp(e, t, n, r) {
+    const i = e - n,
+        s = t - r;
+    return i * i + s * s;
 }
 
-function dY(e, t, n, i, r, s, o, a) {
+function xP(e, t, n, r, i, s, o, a) {
     const c = e - o,
-        l = t - a,
-        u = n - o,
-        f = i - a,
-        h = r - o,
+        u = t - a,
+        l = n - o,
+        f = r - a,
+        h = i - o,
         d = s - a,
-        p = c * c + l * l,
-        m = u * u + f * f,
-        g = h * h + d * d;
-    return c * (f * g - m * d) - l * (u * g - m * h) + p * (u * d - f * h) < 0;
+        p = c * c + u * u,
+        y = l * l + f * f,
+        m = h * h + d * d;
+    return c * (f * m - y * d) - u * (l * m - y * h) + p * (l * d - f * h) < 0;
 }
 
-function pY(e, t, n, i, r, s) {
+function SP(e, t, n, r, i, s) {
     const o = n - e,
-        a = i - t,
-        c = r - e,
-        l = s - t,
-        u = o * o + a * a,
-        f = c * c + l * l,
-        h = 0.5 / (o * l - a * c),
-        d = (l * u - a * f) * h,
-        p = (o * f - c * u) * h;
+        a = r - t,
+        c = i - e,
+        u = s - t,
+        l = o * o + a * a,
+        f = c * c + u * u,
+        h = 0.5 / (o * u - a * c),
+        d = (u * l - a * f) * h,
+        p = (o * f - c * l) * h;
     return d * d + p * p;
 }
 
-function yY(e, t, n, i, r, s) {
+function MP(e, t, n, r, i, s) {
     const o = n - e,
-        a = i - t,
-        c = r - e,
-        l = s - t,
-        u = o * o + a * a,
-        f = c * c + l * l,
-        h = 0.5 / (o * l - a * c),
-        d = e + (l * u - a * f) * h,
-        p = t + (o * f - c * u) * h;
+        a = r - t,
+        c = i - e,
+        u = s - t,
+        l = o * o + a * a,
+        f = c * c + u * u,
+        h = 0.5 / (o * u - a * c),
+        d = e + (u * l - a * f) * h,
+        p = t + (o * f - c * l) * h;
     return {
         x: d,
         y: p
     };
 }
 
-function Za(e, t, n, i) {
-    if (i - n <= 20)
-        for (let r = n + 1; r <= i; r++) {
-            const s = e[r],
+function yo(e, t, n, r) {
+    if (r - n <= 20)
+        for (let i = n + 1; i <= r; i++) {
+            const s = e[i],
                 o = t[s];
-            let a = r - 1;
+            let a = i - 1;
             for (; a >= n && t[e[a]] > o;)
                 e[a + 1] = e[a--];
             e[a + 1] = s;
         }
     else {
-        const r = n + i >> 1;
+        const i = n + r >> 1;
         let s = n + 1,
-            o = i;
-        xl(e, r, s), t[e[n]] > t[e[i]] && xl(e, n, i), t[e[s]] > t[e[i]] && xl(e, s, i), t[e[n]] > t[e[s]] && xl(e, n, s);
+            o = r;
+        La(e, i, s), t[e[n]] > t[e[r]] && La(e, n, r), t[e[s]] > t[e[r]] && La(e, s, r), t[e[n]] > t[e[s]] && La(e, n, s);
         const a = e[s],
             c = t[a];
         for (;;) {
             do
                 s++;
             while (t[e[s]] < c);
             do
                 o--;
             while (t[e[o]] > c);
             if (o < s)
                 break;
-            xl(e, s, o);
+            La(e, s, o);
         }
-        e[n + 1] = e[o], e[o] = a, i - s + 1 >= o - n ? (Za(e, t, s, i), Za(e, t, n, o - 1)) : (Za(e, t, n, o - 1), Za(e, t, s, i));
+        e[n + 1] = e[o], e[o] = a, r - s + 1 >= o - n ? (yo(e, t, s, r), yo(e, t, n, o - 1)) : (yo(e, t, n, o - 1), yo(e, t, s, r));
     }
 }
 
-function xl(e, t, n) {
-    const i = e[t];
-    e[t] = e[n], e[n] = i;
+function La(e, t, n) {
+    const r = e[t];
+    e[t] = e[n], e[n] = r;
 }
 
-function mY(e) {
+function AP(e) {
     return e[0];
 }
 
-function gY(e) {
+function $P(e) {
     return e[1];
 }
-const z2 = 1e-6;
-class Fo {
+const nw = 1e-6;
+class ps {
     constructor() {
         this._x0 = this._y0 = // start of current subpath
             this._x1 = this._y1 = null, this._ = "";
     }
     moveTo(t, n) {
         this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
     }
     closePath() {
         this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
     }
     lineTo(t, n) {
         this._ += `L${this._x1 = +t},${this._y1 = +n}`;
     }
-    arc(t, n, i) {
-        t = +t, n = +n, i = +i;
-        const r = t + i,
+    arc(t, n, r) {
+        t = +t, n = +n, r = +r;
+        const i = t + r,
             s = n;
-        if (i < 0)
+        if (r < 0)
             throw new Error("negative radius");
-        this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > z2 || Math.abs(this._y1 - s) > z2) && (this._ += "L" + r + "," + s), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = s}`);
+        this._x1 === null ? this._ += `M${i},${s}` : (Math.abs(this._x1 - i) > nw || Math.abs(this._y1 - s) > nw) && (this._ += "L" + i + "," + s), r && (this._ += `A${r},${r},0,1,1,${t - r},${n}A${r},${r},0,1,1,${this._x1 = i},${this._y1 = s}`);
     }
-    rect(t, n, i, r) {
-        this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+i}v${+r}h${-i}Z`;
+    rect(t, n, r, i) {
+        this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+r}v${+i}h${-r}Z`;
     }
     value() {
         return this._ || null;
     }
 }
-class Zg {
+class U0 {
     constructor() {
         this._ = [];
     }
     moveTo(t, n) {
         this._.push([t, n]);
     }
     closePath() {
@@ -16366,251 +16929,251 @@
     lineTo(t, n) {
         this._.push([t, n]);
     }
     value() {
         return this._.length ? this._ : null;
     }
 }
-let bY = class {
-    constructor(t, [n, i, r, s] = [0, 0, 960, 500]) {
-        if (!((r = +r) >= (n = +n)) || !((s = +s) >= (i = +i)))
+let IP = class {
+    constructor(t, [n, r, i, s] = [0, 0, 960, 500]) {
+        if (!((i = +i) >= (n = +n)) || !((s = +s) >= (r = +r)))
             throw new Error("invalid bounds");
-        this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = s, this.ymin = i, this._init();
+        this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = i, this.xmin = n, this.ymax = s, this.ymin = r, this._init();
     }
     update() {
         return this.delaunay.update(), this._init(), this;
     }
     _init() {
         const {
             delaunay: {
                 points: t,
                 hull: n,
-                triangles: i
+                triangles: r
             },
-            vectors: r
+            vectors: i
         } = this;
         let s, o;
-        const a = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
-        for (let m = 0, g = 0, y = i.length, b, w; m < y; m += 3, g += 2) {
-            const v = i[m] * 2,
-                x = i[m + 1] * 2,
-                _ = i[m + 2] * 2,
-                I = t[v],
-                A = t[v + 1],
-                M = t[x],
+        const a = this.circumcenters = this._circumcenters.subarray(0, r.length / 3 * 2);
+        for (let y = 0, m = 0, g = r.length, b, w; y < g; y += 3, m += 2) {
+            const v = r[y] * 2,
+                x = r[y + 1] * 2,
+                _ = r[y + 2] * 2,
+                M = t[v],
+                T = t[v + 1],
+                $ = t[x],
                 N = t[x + 1],
-                $ = t[_],
-                B = t[_ + 1],
-                R = M - I,
-                S = N - A,
-                T = $ - I,
-                D = B - A,
-                L = (R * D - S * T) * 2;
-            if (Math.abs(L) < 1e-9) {
+                A = t[_],
+                D = t[_ + 1],
+                R = $ - M,
+                S = N - T,
+                I = A - M,
+                E = D - T,
+                k = (R * E - S * I) * 2;
+            if (Math.abs(k) < 1e-9) {
                 if (s === void 0) {
                     s = o = 0;
-                    for (const U of n)
-                        s += t[U * 2], o += t[U * 2 + 1];
+                    for (const C of n)
+                        s += t[C * 2], o += t[C * 2 + 1];
                     s /= n.length, o /= n.length;
                 }
-                const k = 1e9 * Math.sign((s - I) * D - (o - A) * T);
-                b = (I + $) / 2 - k * D, w = (A + B) / 2 + k * T;
+                const B = 1e9 * Math.sign((s - M) * E - (o - T) * I);
+                b = (M + A) / 2 - B * E, w = (T + D) / 2 + B * I;
             } else {
-                const k = 1 / L,
-                    U = R * R + S * S,
-                    C = T * T + D * D;
-                b = I + (D * U - S * C) * k, w = A + (R * C - T * U) * k;
+                const B = 1 / k,
+                    C = R * R + S * S,
+                    F = I * I + E * E;
+                b = M + (E * C - S * F) * B, w = T + (R * F - I * C) * B;
             }
-            a[g] = b, a[g + 1] = w;
+            a[m] = b, a[m + 1] = w;
         }
         let c = n[n.length - 1],
-            l, u = c * 4,
+            u, l = c * 4,
             f, h = t[2 * c],
             d, p = t[2 * c + 1];
-        r.fill(0);
-        for (let m = 0; m < n.length; ++m)
-            c = n[m], l = u, f = h, d = p, u = c * 4, h = t[2 * c], p = t[2 * c + 1], r[l + 2] = r[u] = d - p, r[l + 3] = r[u + 1] = h - f;
+        i.fill(0);
+        for (let y = 0; y < n.length; ++y)
+            c = n[y], u = l, f = h, d = p, l = c * 4, h = t[2 * c], p = t[2 * c + 1], i[u + 2] = i[l] = d - p, i[u + 3] = i[l + 1] = h - f;
     }
     render(t) {
-        const n = t == null ? t = new Fo() : void 0,
+        const n = t == null ? t = new ps() : void 0,
             {
                 delaunay: {
-                    halfedges: i,
-                    inedges: r,
+                    halfedges: r,
+                    inedges: i,
                     hull: s
                 },
                 circumcenters: o,
                 vectors: a
             } = this;
         if (s.length <= 1)
             return null;
-        for (let u = 0, f = i.length; u < f; ++u) {
-            const h = i[u];
-            if (h < u)
+        for (let l = 0, f = r.length; l < f; ++l) {
+            const h = r[l];
+            if (h < l)
                 continue;
-            const d = Math.floor(u / 3) * 2,
+            const d = Math.floor(l / 3) * 2,
                 p = Math.floor(h / 3) * 2,
-                m = o[d],
-                g = o[d + 1],
-                y = o[p],
+                y = o[d],
+                m = o[d + 1],
+                g = o[p],
                 b = o[p + 1];
-            this._renderSegment(m, g, y, b, t);
+            this._renderSegment(y, m, g, b, t);
         }
-        let c, l = s[s.length - 1];
-        for (let u = 0; u < s.length; ++u) {
-            c = l, l = s[u];
-            const f = Math.floor(r[l] / 3) * 2,
+        let c, u = s[s.length - 1];
+        for (let l = 0; l < s.length; ++l) {
+            c = u, u = s[l];
+            const f = Math.floor(i[u] / 3) * 2,
                 h = o[f],
                 d = o[f + 1],
                 p = c * 4,
-                m = this._project(h, d, a[p + 2], a[p + 3]);
-            m && this._renderSegment(h, d, m[0], m[1], t);
+                y = this._project(h, d, a[p + 2], a[p + 3]);
+            y && this._renderSegment(h, d, y[0], y[1], t);
         }
         return n && n.value();
     }
     renderBounds(t) {
-        const n = t == null ? t = new Fo() : void 0;
+        const n = t == null ? t = new ps() : void 0;
         return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
     }
     renderCell(t, n) {
-            const i = n == null ? n = new Fo() : void 0,
-                r = this._clip(t);
-            if (r === null || !r.length)
+            const r = n == null ? n = new ps() : void 0,
+                i = this._clip(t);
+            if (i === null || !i.length)
                 return;
-            n.moveTo(r[0], r[1]);
-            let s = r.length;
-            for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1;)
+            n.moveTo(i[0], i[1]);
+            let s = i.length;
+            for (; i[0] === i[s - 2] && i[1] === i[s - 1] && s > 1;)
                 s -= 2;
             for (let o = 2; o < s; o += 2)
-                (r[o] !== r[o - 2] || r[o + 1] !== r[o - 1]) && n.lineTo(r[o], r[o + 1]);
-            return n.closePath(), i && i.value();
+                (i[o] !== i[o - 2] || i[o + 1] !== i[o - 1]) && n.lineTo(i[o], i[o + 1]);
+            return n.closePath(), r && r.value();
         }
         * cellPolygons() {
             const {
                 delaunay: {
                     points: t
                 }
             } = this;
-            for (let n = 0, i = t.length / 2; n < i; ++n) {
-                const r = this.cellPolygon(n);
-                r && (r.index = n, yield r);
+            for (let n = 0, r = t.length / 2; n < r; ++n) {
+                const i = this.cellPolygon(n);
+                i && (i.index = n, yield i);
             }
         }
     cellPolygon(t) {
-        const n = new Zg();
+        const n = new U0();
         return this.renderCell(t, n), n.value();
     }
-    _renderSegment(t, n, i, r, s) {
+    _renderSegment(t, n, r, i, s) {
         let o;
         const a = this._regioncode(t, n),
-            c = this._regioncode(i, r);
-        a === 0 && c === 0 ? (s.moveTo(t, n), s.lineTo(i, r)) : (o = this._clipSegment(t, n, i, r, a, c)) && (s.moveTo(o[0], o[1]), s.lineTo(o[2], o[3]));
+            c = this._regioncode(r, i);
+        a === 0 && c === 0 ? (s.moveTo(t, n), s.lineTo(r, i)) : (o = this._clipSegment(t, n, r, i, a, c)) && (s.moveTo(o[0], o[1]), s.lineTo(o[2], o[3]));
     }
-    contains(t, n, i) {
-            return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t;
+    contains(t, n, r) {
+            return n = +n, n !== n || (r = +r, r !== r) ? !1 : this.delaunay._step(t, n, r) === t;
         }
         * neighbors(t) {
             const n = this._clip(t);
             if (n)
-                for (const i of this.delaunay.neighbors(t)) {
-                    const r = this._clip(i);
-                    if (r) {
+                for (const r of this.delaunay.neighbors(t)) {
+                    const i = this._clip(r);
+                    if (i) {
                         t: for (let s = 0, o = n.length; s < o; s += 2)
-                            for (let a = 0, c = r.length; a < c; a += 2)
-                                if (n[s] === r[a] && n[s + 1] === r[a + 1] && n[(s + 2) % o] === r[(a + c - 2) % c] && n[(s + 3) % o] === r[(a + c - 1) % c]) {
-                                    yield i;
+                            for (let a = 0, c = i.length; a < c; a += 2)
+                                if (n[s] === i[a] && n[s + 1] === i[a + 1] && n[(s + 2) % o] === i[(a + c - 2) % c] && n[(s + 3) % o] === i[(a + c - 1) % c]) {
+                                    yield r;
                                     break t;
                                 }
                     }
                 }
         }
     _cell(t) {
         const {
             circumcenters: n,
             delaunay: {
-                inedges: i,
-                halfedges: r,
+                inedges: r,
+                halfedges: i,
                 triangles: s
             }
-        } = this, o = i[t];
+        } = this, o = r[t];
         if (o === -1)
             return null;
         const a = [];
         let c = o;
         do {
-            const l = Math.floor(c / 3);
-            if (a.push(n[l * 2], n[l * 2 + 1]), c = c % 3 === 2 ? c - 2 : c + 1, s[c] !== t)
+            const u = Math.floor(c / 3);
+            if (a.push(n[u * 2], n[u * 2 + 1]), c = c % 3 === 2 ? c - 2 : c + 1, s[c] !== t)
                 break;
-            c = r[c];
+            c = i[c];
         } while (c !== o && c !== -1);
         return a;
     }
     _clip(t) {
         if (t === 0 && this.delaunay.hull.length === 1)
             return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
         const n = this._cell(t);
         if (n === null)
             return null;
         const {
-            vectors: i
-        } = this, r = t * 4;
-        return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n));
+            vectors: r
+        } = this, i = t * 4;
+        return this._simplify(r[i] || r[i + 1] ? this._clipInfinite(t, n, r[i], r[i + 1], r[i + 2], r[i + 3]) : this._clipFinite(t, n));
     }
     _clipFinite(t, n) {
-        const i = n.length;
-        let r = null,
-            s, o, a = n[i - 2],
-            c = n[i - 1],
-            l, u = this._regioncode(a, c),
+        const r = n.length;
+        let i = null,
+            s, o, a = n[r - 2],
+            c = n[r - 1],
+            u, l = this._regioncode(a, c),
             f, h = 0;
-        for (let d = 0; d < i; d += 2)
-            if (s = a, o = c, a = n[d], c = n[d + 1], l = u, u = this._regioncode(a, c), l === 0 && u === 0)
-                f = h, h = 0, r ? r.push(a, c) : r = [a, c];
+        for (let d = 0; d < r; d += 2)
+            if (s = a, o = c, a = n[d], c = n[d + 1], u = l, l = this._regioncode(a, c), u === 0 && l === 0)
+                f = h, h = 0, i ? i.push(a, c) : i = [a, c];
             else {
-                let p, m, g, y, b;
-                if (l === 0) {
-                    if ((p = this._clipSegment(s, o, a, c, l, u)) === null)
+                let p, y, m, g, b;
+                if (u === 0) {
+                    if ((p = this._clipSegment(s, o, a, c, u, l)) === null)
                         continue;
-                    [m, g, y, b] = p;
+                    [y, m, g, b] = p;
                 } else {
-                    if ((p = this._clipSegment(a, c, s, o, u, l)) === null)
+                    if ((p = this._clipSegment(a, c, s, o, l, u)) === null)
                         continue;
-                    [y, b, m, g] = p, f = h, h = this._edgecode(m, g), f && h && this._edge(t, f, h, r, r.length), r ? r.push(m, g) : r = [m, g];
+                    [g, b, y, m] = p, f = h, h = this._edgecode(y, m), f && h && this._edge(t, f, h, i, i.length), i ? i.push(y, m) : i = [y, m];
                 }
-                f = h, h = this._edgecode(y, b), f && h && this._edge(t, f, h, r, r.length), r ? r.push(y, b) : r = [y, b];
+                f = h, h = this._edgecode(g, b), f && h && this._edge(t, f, h, i, i.length), i ? i.push(g, b) : i = [g, b];
             }
-        if (r)
-            f = h, h = this._edgecode(r[0], r[1]), f && h && this._edge(t, f, h, r, r.length);
+        if (i)
+            f = h, h = this._edgecode(i[0], i[1]), f && h && this._edge(t, f, h, i, i.length);
         else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
             return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
-        return r;
+        return i;
     }
-    _clipSegment(t, n, i, r, s, o) {
+    _clipSegment(t, n, r, i, s, o) {
         const a = s < o;
-        for (a && ([t, n, i, r, s, o] = [i, r, t, n, o, s]);;) {
+        for (a && ([t, n, r, i, s, o] = [r, i, t, n, o, s]);;) {
             if (s === 0 && o === 0)
-                return a ? [i, r, t, n] : [t, n, i, r];
+                return a ? [r, i, t, n] : [t, n, r, i];
             if (s & o)
                 return null;
-            let c, l, u = s || o;
-            u & 8 ? (c = t + (i - t) * (this.ymax - n) / (r - n), l = this.ymax) : u & 4 ? (c = t + (i - t) * (this.ymin - n) / (r - n), l = this.ymin) : u & 2 ? (l = n + (r - n) * (this.xmax - t) / (i - t), c = this.xmax) : (l = n + (r - n) * (this.xmin - t) / (i - t), c = this.xmin), s ? (t = c, n = l, s = this._regioncode(t, n)) : (i = c, r = l, o = this._regioncode(i, r));
+            let c, u, l = s || o;
+            l & 8 ? (c = t + (r - t) * (this.ymax - n) / (i - n), u = this.ymax) : l & 4 ? (c = t + (r - t) * (this.ymin - n) / (i - n), u = this.ymin) : l & 2 ? (u = n + (i - n) * (this.xmax - t) / (r - t), c = this.xmax) : (u = n + (i - n) * (this.xmin - t) / (r - t), c = this.xmin), s ? (t = c, n = u, s = this._regioncode(t, n)) : (r = c, i = u, o = this._regioncode(r, i));
         }
     }
-    _clipInfinite(t, n, i, r, s, o) {
+    _clipInfinite(t, n, r, i, s, o) {
         let a = Array.from(n),
             c;
-        if ((c = this._project(a[0], a[1], i, r)) && a.unshift(c[0], c[1]), (c = this._project(a[a.length - 2], a[a.length - 1], s, o)) && a.push(c[0], c[1]), a = this._clipFinite(t, a))
-            for (let l = 0, u = a.length, f, h = this._edgecode(a[u - 2], a[u - 1]); l < u; l += 2)
-                f = h, h = this._edgecode(a[l], a[l + 1]), f && h && (l = this._edge(t, f, h, a, l), u = a.length);
+        if ((c = this._project(a[0], a[1], r, i)) && a.unshift(c[0], c[1]), (c = this._project(a[a.length - 2], a[a.length - 1], s, o)) && a.push(c[0], c[1]), a = this._clipFinite(t, a))
+            for (let u = 0, l = a.length, f, h = this._edgecode(a[l - 2], a[l - 1]); u < l; u += 2)
+                f = h, h = this._edgecode(a[u], a[u + 1]), f && h && (u = this._edge(t, f, h, a, u), l = a.length);
         else
             this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (a = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
         return a;
     }
-    _edge(t, n, i, r, s) {
-        for (; n !== i;) {
+    _edge(t, n, r, i, s) {
+        for (; n !== r;) {
             let o, a;
             switch (n) {
                 case 5:
                     n = 4;
                     continue;
                 case 4:
                     n = 6, o = this.xmax, a = this.ymin;
@@ -16630,1520 +17193,1520 @@
                 case 9:
                     n = 1;
                     continue;
                 case 1:
                     n = 5, o = this.xmin, a = this.ymin;
                     break;
             }
-            (r[s] !== o || r[s + 1] !== a) && this.contains(t, o, a) && (r.splice(s, 0, o, a), s += 2);
+            (i[s] !== o || i[s + 1] !== a) && this.contains(t, o, a) && (i.splice(s, 0, o, a), s += 2);
         }
         return s;
     }
-    _project(t, n, i, r) {
+    _project(t, n, r, i) {
         let s = 1 / 0,
             o, a, c;
-        if (r < 0) {
+        if (i < 0) {
             if (n <= this.ymin)
                 return null;
-            (o = (this.ymin - n) / r) < s && (c = this.ymin, a = t + (s = o) * i);
-        } else if (r > 0) {
+            (o = (this.ymin - n) / i) < s && (c = this.ymin, a = t + (s = o) * r);
+        } else if (i > 0) {
             if (n >= this.ymax)
                 return null;
-            (o = (this.ymax - n) / r) < s && (c = this.ymax, a = t + (s = o) * i);
+            (o = (this.ymax - n) / i) < s && (c = this.ymax, a = t + (s = o) * r);
         }
-        if (i > 0) {
+        if (r > 0) {
             if (t >= this.xmax)
                 return null;
-            (o = (this.xmax - t) / i) < s && (a = this.xmax, c = n + (s = o) * r);
-        } else if (i < 0) {
+            (o = (this.xmax - t) / r) < s && (a = this.xmax, c = n + (s = o) * i);
+        } else if (r < 0) {
             if (t <= this.xmin)
                 return null;
-            (o = (this.xmin - t) / i) < s && (a = this.xmin, c = n + (s = o) * r);
+            (o = (this.xmin - t) / r) < s && (a = this.xmin, c = n + (s = o) * i);
         }
         return [a, c];
     }
     _edgecode(t, n) {
         return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
     }
     _regioncode(t, n) {
         return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
     }
     _simplify(t) {
         if (t && t.length > 4) {
             for (let n = 0; n < t.length; n += 2) {
-                const i = (n + 2) % t.length,
-                    r = (n + 4) % t.length;
-                (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2);
+                const r = (n + 2) % t.length,
+                    i = (n + 4) % t.length;
+                (t[n] === t[r] && t[r] === t[i] || t[n + 1] === t[r + 1] && t[r + 1] === t[i + 1]) && (t.splice(r, 2), n -= 2);
             }
             t.length || (t = null);
         }
         return t;
     }
 };
-const wY = 2 * Math.PI,
-    xa = Math.pow;
+const TP = 2 * Math.PI,
+    Ks = Math.pow;
 
-function vY(e) {
+function EP(e) {
     return e[0];
 }
 
-function _Y(e) {
+function NP(e) {
     return e[1];
 }
 
-function xY(e) {
+function DP(e) {
     const {
         triangles: t,
         coords: n
     } = e;
-    for (let i = 0; i < t.length; i += 3) {
-        const r = 2 * t[i],
-            s = 2 * t[i + 1],
-            o = 2 * t[i + 2];
-        if ((n[o] - n[r]) * (n[s + 1] - n[r + 1]) - (n[s] - n[r]) * (n[o + 1] - n[r + 1]) > 1e-10)
+    for (let r = 0; r < t.length; r += 3) {
+        const i = 2 * t[r],
+            s = 2 * t[r + 1],
+            o = 2 * t[r + 2];
+        if ((n[o] - n[i]) * (n[s + 1] - n[i + 1]) - (n[s] - n[i]) * (n[o + 1] - n[i + 1]) > 1e-10)
             return !1;
     }
     return !0;
 }
 
-function SY(e, t, n) {
+function OP(e, t, n) {
     return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n];
 }
-class Ci {
-    static from(t, n = vY, i = _Y, r) {
-        return new Ci("length" in t ? IY(t, n, i, r) : Float64Array.from(AY(t, n, i, r)));
+class Ji {
+    static from(t, n = EP, r = NP, i) {
+        return new Ji("length" in t ? LP(t, n, r, i) : Float64Array.from(kP(t, n, r, i)));
     }
     constructor(t) {
-        this._delaunator = new sp(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
+        this._delaunator = new Of(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
     }
     update() {
         return this._delaunator.update(), this._init(), this;
     }
     _init() {
         const t = this._delaunator,
             n = this.points;
-        if (t.hull && t.hull.length > 2 && xY(t)) {
+        if (t.hull && t.hull.length > 2 && DP(t)) {
             this.collinear = Int32Array.from({
                 length: n.length / 2
             }, (h, d) => d).sort((h, d) => n[2 * h] - n[2 * d] || n[2 * h + 1] - n[2 * d + 1]);
             const c = this.collinear[0],
-                l = this.collinear[this.collinear.length - 1],
-                u = [n[2 * c], n[2 * c + 1], n[2 * l], n[2 * l + 1]],
-                f = 1e-8 * Math.hypot(u[3] - u[1], u[2] - u[0]);
+                u = this.collinear[this.collinear.length - 1],
+                l = [n[2 * c], n[2 * c + 1], n[2 * u], n[2 * u + 1]],
+                f = 1e-8 * Math.hypot(l[3] - l[1], l[2] - l[0]);
             for (let h = 0, d = n.length / 2; h < d; ++h) {
-                const p = SY(n[2 * h], n[2 * h + 1], f);
+                const p = OP(n[2 * h], n[2 * h + 1], f);
                 n[2 * h] = p[0], n[2 * h + 1] = p[1];
             }
-            this._delaunator = new sp(n);
+            this._delaunator = new Of(n);
         } else
             delete this.collinear;
-        const i = this.halfedges = this._delaunator.halfedges,
-            r = this.hull = this._delaunator.hull,
+        const r = this.halfedges = this._delaunator.halfedges,
+            i = this.hull = this._delaunator.hull,
             s = this.triangles = this._delaunator.triangles,
             o = this.inedges.fill(-1),
             a = this._hullIndex.fill(-1);
-        for (let c = 0, l = i.length; c < l; ++c) {
-            const u = s[c % 3 === 2 ? c - 2 : c + 1];
-            (i[c] === -1 || o[u] === -1) && (o[u] = c);
-        }
-        for (let c = 0, l = r.length; c < l; ++c)
-            a[r[c]] = c;
-        r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], o[r[0]] = 1, r.length === 2 && (o[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
+        for (let c = 0, u = r.length; c < u; ++c) {
+            const l = s[c % 3 === 2 ? c - 2 : c + 1];
+            (r[c] === -1 || o[l] === -1) && (o[l] = c);
+        }
+        for (let c = 0, u = i.length; c < u; ++c)
+            a[i[c]] = c;
+        i.length <= 2 && i.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = i[0], o[i[0]] = 1, i.length === 2 && (o[i[1]] = 0, this.triangles[1] = i[1], this.triangles[2] = i[1]));
     }
     voronoi(t) {
-            return new bY(this, t);
+            return new IP(this, t);
         }
         * neighbors(t) {
             const {
                 inedges: n,
-                hull: i,
-                _hullIndex: r,
+                hull: r,
+                _hullIndex: i,
                 halfedges: s,
                 triangles: o,
                 collinear: a
             } = this;
             if (a) {
                 const f = a.indexOf(t);
                 f > 0 && (yield a[f - 1]), f < a.length - 1 && (yield a[f + 1]);
                 return;
             }
             const c = n[t];
             if (c === -1)
                 return;
-            let l = c,
-                u = -1;
+            let u = c,
+                l = -1;
             do {
-                if (yield u = o[l], l = l % 3 === 2 ? l - 2 : l + 1, o[l] !== t)
+                if (yield l = o[u], u = u % 3 === 2 ? u - 2 : u + 1, o[u] !== t)
                     return;
-                if (l = s[l], l === -1) {
-                    const f = i[(r[t] + 1) % i.length];
-                    f !== u && (yield f);
+                if (u = s[u], u === -1) {
+                    const f = r[(i[t] + 1) % r.length];
+                    f !== l && (yield f);
                     return;
                 }
-            } while (l !== c);
+            } while (u !== c);
         }
-    find(t, n, i = 0) {
+    find(t, n, r = 0) {
         if (t = +t, t !== t || (n = +n, n !== n))
             return -1;
-        const r = i;
+        const i = r;
         let s;
         for (;
-            (s = this._step(i, t, n)) >= 0 && s !== i && s !== r;)
-            i = s;
+            (s = this._step(r, t, n)) >= 0 && s !== r && s !== i;)
+            r = s;
         return s;
     }
-    _step(t, n, i) {
+    _step(t, n, r) {
         const {
-            inedges: r,
+            inedges: i,
             hull: s,
             _hullIndex: o,
             halfedges: a,
             triangles: c,
-            points: l
+            points: u
         } = this;
-        if (r[t] === -1 || !l.length)
-            return (t + 1) % (l.length >> 1);
-        let u = t,
-            f = xa(n - l[t * 2], 2) + xa(i - l[t * 2 + 1], 2);
-        const h = r[t];
+        if (i[t] === -1 || !u.length)
+            return (t + 1) % (u.length >> 1);
+        let l = t,
+            f = Ks(n - u[t * 2], 2) + Ks(r - u[t * 2 + 1], 2);
+        const h = i[t];
         let d = h;
         do {
             let p = c[d];
-            const m = xa(n - l[p * 2], 2) + xa(i - l[p * 2 + 1], 2);
-            if (m < f && (f = m, u = p), d = d % 3 === 2 ? d - 2 : d + 1, c[d] !== t)
+            const y = Ks(n - u[p * 2], 2) + Ks(r - u[p * 2 + 1], 2);
+            if (y < f && (f = y, l = p), d = d % 3 === 2 ? d - 2 : d + 1, c[d] !== t)
                 break;
             if (d = a[d], d === -1) {
-                if (d = s[(o[t] + 1) % s.length], d !== p && xa(n - l[d * 2], 2) + xa(i - l[d * 2 + 1], 2) < f)
+                if (d = s[(o[t] + 1) % s.length], d !== p && Ks(n - u[d * 2], 2) + Ks(r - u[d * 2 + 1], 2) < f)
                     return d;
                 break;
             }
         } while (d !== h);
-        return u;
+        return l;
     }
     render(t) {
-        const n = t == null ? t = new Fo() : void 0,
+        const n = t == null ? t = new ps() : void 0,
             {
-                points: i,
-                halfedges: r,
+                points: r,
+                halfedges: i,
                 triangles: s
             } = this;
-        for (let o = 0, a = r.length; o < a; ++o) {
-            const c = r[o];
+        for (let o = 0, a = i.length; o < a; ++o) {
+            const c = i[o];
             if (c < o)
                 continue;
-            const l = s[o] * 2,
-                u = s[c] * 2;
-            t.moveTo(i[l], i[l + 1]), t.lineTo(i[u], i[u + 1]);
+            const u = s[o] * 2,
+                l = s[c] * 2;
+            t.moveTo(r[u], r[u + 1]), t.lineTo(r[l], r[l + 1]);
         }
         return this.renderHull(t), n && n.value();
     }
     renderPoints(t, n) {
         n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
-        const i = t == null ? t = new Fo() : void 0,
+        const r = t == null ? t = new ps() : void 0,
             {
-                points: r
+                points: i
             } = this;
-        for (let s = 0, o = r.length; s < o; s += 2) {
-            const a = r[s],
-                c = r[s + 1];
-            t.moveTo(a + n, c), t.arc(a, c, n, 0, wY);
+        for (let s = 0, o = i.length; s < o; s += 2) {
+            const a = i[s],
+                c = i[s + 1];
+            t.moveTo(a + n, c), t.arc(a, c, n, 0, TP);
         }
-        return i && i.value();
+        return r && r.value();
     }
     renderHull(t) {
-        const n = t == null ? t = new Fo() : void 0,
+        const n = t == null ? t = new ps() : void 0,
             {
-                hull: i,
-                points: r
+                hull: r,
+                points: i
             } = this,
-            s = i[0] * 2,
-            o = i.length;
-        t.moveTo(r[s], r[s + 1]);
+            s = r[0] * 2,
+            o = r.length;
+        t.moveTo(i[s], i[s + 1]);
         for (let a = 1; a < o; ++a) {
-            const c = 2 * i[a];
-            t.lineTo(r[c], r[c + 1]);
+            const c = 2 * r[a];
+            t.lineTo(i[c], i[c + 1]);
         }
         return t.closePath(), n && n.value();
     }
     hullPolygon() {
-        const t = new Zg();
+        const t = new U0();
         return this.renderHull(t), t.value();
     }
     renderTriangle(t, n) {
-            const i = n == null ? n = new Fo() : void 0,
+            const r = n == null ? n = new ps() : void 0,
                 {
-                    points: r,
+                    points: i,
                     triangles: s
                 } = this,
                 o = s[t *= 3] * 2,
                 a = s[t + 1] * 2,
                 c = s[t + 2] * 2;
-            return n.moveTo(r[o], r[o + 1]), n.lineTo(r[a], r[a + 1]), n.lineTo(r[c], r[c + 1]), n.closePath(), i && i.value();
+            return n.moveTo(i[o], i[o + 1]), n.lineTo(i[a], i[a + 1]), n.lineTo(i[c], i[c + 1]), n.closePath(), r && r.value();
         }
         * trianglePolygons() {
             const {
                 triangles: t
             } = this;
-            for (let n = 0, i = t.length / 3; n < i; ++n)
+            for (let n = 0, r = t.length / 3; n < r; ++n)
                 yield this.trianglePolygon(n);
         }
     trianglePolygon(t) {
-        const n = new Zg();
+        const n = new U0();
         return this.renderTriangle(t, n), n.value();
     }
 }
 
-function IY(e, t, n, i) {
-    const r = e.length,
-        s = new Float64Array(r * 2);
-    for (let o = 0; o < r; ++o) {
+function LP(e, t, n, r) {
+    const i = e.length,
+        s = new Float64Array(i * 2);
+    for (let o = 0; o < i; ++o) {
         const a = e[o];
-        s[o * 2] = t.call(i, a, o, e), s[o * 2 + 1] = n.call(i, a, o, e);
+        s[o * 2] = t.call(r, a, o, e), s[o * 2 + 1] = n.call(r, a, o, e);
     }
     return s;
 }
 
-function* AY(e, t, n, i) {
-    let r = 0;
+function* kP(e, t, n, r) {
+    let i = 0;
     for (const s of e)
-        yield t.call(i, s, r, e), yield n.call(i, s, r, e), ++r;
+        yield t.call(r, s, i, e), yield n.call(r, s, i, e), ++i;
 }
 
-function MY(e) {
+function RP(e) {
     return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
 }
 
-function op(e, t) {
+function Lf(e, t) {
     if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
         return null;
-    var n, i = e.slice(0, n);
+    var n, r = e.slice(0, n);
     return [
-        i.length > 1 ? i[0] + i.slice(2) : i,
+        r.length > 1 ? r[0] + r.slice(2) : r,
         +e.slice(n + 1)
     ];
 }
 
-function Oc(e) {
-    return e = op(Math.abs(e)), e ? e[1] : NaN;
+function Go(e) {
+    return e = Lf(Math.abs(e)), e ? e[1] : NaN;
 }
 
-function $Y(e, t) {
-    return function(n, i) {
-        for (var r = n.length, s = [], o = 0, a = e[0], c = 0; r > 0 && a > 0 && (c + a + 1 > i && (a = Math.max(1, i - c)), s.push(n.substring(r -= a, r + a)), !((c += a + 1) > i));)
+function FP(e, t) {
+    return function(n, r) {
+        for (var i = n.length, s = [], o = 0, a = e[0], c = 0; i > 0 && a > 0 && (c + a + 1 > r && (a = Math.max(1, r - c)), s.push(n.substring(i -= a, i + a)), !((c += a + 1) > r));)
             a = e[o = (o + 1) % e.length];
         return s.reverse().join(t);
     };
 }
 
-function TY(e) {
+function BP(e) {
     return function(t) {
         return t.replace(/[0-9]/g, function(n) {
             return e[+n];
         });
     };
 }
-var DY = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
+var CP = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
 
-function ku(e) {
-    if (!(t = DY.exec(e)))
+function Rc(e) {
+    if (!(t = CP.exec(e)))
         throw new Error("invalid format: " + e);
     var t;
-    return new rw({
+    return new Bm({
         fill: t[1],
         align: t[2],
         sign: t[3],
         symbol: t[4],
         zero: t[5],
         width: t[6],
         comma: t[7],
         precision: t[8] && t[8].slice(1),
         trim: t[9],
         type: t[10]
     });
 }
-ku.prototype = rw.prototype;
+Rc.prototype = Bm.prototype;
 
-function rw(e) {
+function Bm(e) {
     this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
 }
-rw.prototype.toString = function() {
+Bm.prototype.toString = function() {
     return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
 };
 
-function NY(e) {
-    t: for (var t = e.length, n = 1, i = -1, r; n < t; ++n)
+function PP(e) {
+    t: for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
         switch (e[n]) {
             case ".":
-                i = r = n;
+                r = i = n;
                 break;
             case "0":
-                i === 0 && (i = n), r = n;
+                r === 0 && (r = n), i = n;
                 break;
             default:
                 if (!+e[n])
                     break t;
-                i > 0 && (i = 0);
+                r > 0 && (r = 0);
                 break;
         }
-    return i > 0 ? e.slice(0, i) + e.slice(r + 1) : e;
+    return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
 }
-var t$;
+var WS;
 
-function BY(e, t) {
-    var n = op(e, t);
+function UP(e, t) {
+    var n = Lf(e, t);
     if (!n)
         return e + "";
-    var i = n[0],
-        r = n[1],
-        s = r - (t$ = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1,
-        o = i.length;
-    return s === o ? i : s > o ? i + new Array(s - o + 1).join("0") : s > 0 ? i.slice(0, s) + "." + i.slice(s) : "0." + new Array(1 - s).join("0") + op(e, Math.max(0, t + s - 1))[0];
+    var r = n[0],
+        i = n[1],
+        s = i - (WS = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1,
+        o = r.length;
+    return s === o ? r : s > o ? r + new Array(s - o + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + Lf(e, Math.max(0, t + s - 1))[0];
 }
 
-function P2(e, t) {
-    var n = op(e, t);
+function rw(e, t) {
+    var n = Lf(e, t);
     if (!n)
         return e + "";
-    var i = n[0],
-        r = n[1];
-    return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
+    var r = n[0],
+        i = n[1];
+    return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
 }
-const V2 = {
+const iw = {
     "%": (e, t) => (e * 100).toFixed(t),
     b: (e) => Math.round(e).toString(2),
     c: (e) => e + "",
-    d: MY,
+    d: RP,
     e: (e, t) => e.toExponential(t),
     f: (e, t) => e.toFixed(t),
     g: (e, t) => e.toPrecision(t),
     o: (e) => Math.round(e).toString(8),
-    p: (e, t) => P2(e * 100, t),
-    r: P2,
-    s: BY,
+    p: (e, t) => rw(e * 100, t),
+    r: rw,
+    s: UP,
     X: (e) => Math.round(e).toString(16).toUpperCase(),
     x: (e) => Math.round(e).toString(16)
 };
 
-function j2(e) {
+function sw(e) {
     return e;
 }
-var q2 = Array.prototype.map,
-    Y2 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
+var ow = Array.prototype.map,
+    aw = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
 
-function OY(e) {
-    var t = e.grouping === void 0 || e.thousands === void 0 ? j2 : $Y(q2.call(e.grouping, Number), e.thousands + ""),
+function zP(e) {
+    var t = e.grouping === void 0 || e.thousands === void 0 ? sw : FP(ow.call(e.grouping, Number), e.thousands + ""),
         n = e.currency === void 0 ? "" : e.currency[0] + "",
-        i = e.currency === void 0 ? "" : e.currency[1] + "",
-        r = e.decimal === void 0 ? "." : e.decimal + "",
-        s = e.numerals === void 0 ? j2 : TY(q2.call(e.numerals, String)),
+        r = e.currency === void 0 ? "" : e.currency[1] + "",
+        i = e.decimal === void 0 ? "." : e.decimal + "",
+        s = e.numerals === void 0 ? sw : BP(ow.call(e.numerals, String)),
         o = e.percent === void 0 ? "%" : e.percent + "",
         a = e.minus === void 0 ? "" : e.minus + "",
         c = e.nan === void 0 ? "NaN" : e.nan + "";
 
-    function l(f) {
-        f = ku(f);
+    function u(f) {
+        f = Rc(f);
         var h = f.fill,
             d = f.align,
             p = f.sign,
-            m = f.symbol,
-            g = f.zero,
-            y = f.width,
+            y = f.symbol,
+            m = f.zero,
+            g = f.width,
             b = f.comma,
             w = f.precision,
             v = f.trim,
             x = f.type;
-        x === "n" ? (b = !0, x = "g") : V2[x] || (w === void 0 && (w = 12), v = !0, x = "g"), (g || h === "0" && d === "=") && (g = !0, h = "0", d = "=");
-        var _ = m === "$" ? n : m === "#" && /[boxX]/.test(x) ? "0" + x.toLowerCase() : "",
-            I = m === "$" ? i : /[%p]/.test(x) ? o : "",
-            A = V2[x],
-            M = /[defgprs%]/.test(x);
+        x === "n" ? (b = !0, x = "g") : iw[x] || (w === void 0 && (w = 12), v = !0, x = "g"), (m || h === "0" && d === "=") && (m = !0, h = "0", d = "=");
+        var _ = y === "$" ? n : y === "#" && /[boxX]/.test(x) ? "0" + x.toLowerCase() : "",
+            M = y === "$" ? r : /[%p]/.test(x) ? o : "",
+            T = iw[x],
+            $ = /[defgprs%]/.test(x);
         w = w === void 0 ? 6 : /[gprs]/.test(x) ? Math.max(1, Math.min(21, w)) : Math.max(0, Math.min(20, w));
 
-        function N($) {
-            var B = _,
-                R = I,
-                S, T, D;
+        function N(A) {
+            var D = _,
+                R = M,
+                S, I, E;
             if (x === "c")
-                R = A($) + R, $ = "";
+                R = T(A) + R, A = "";
             else {
-                $ = +$;
-                var L = $ < 0 || 1 / $ < 0;
-                if ($ = isNaN($) ? c : A(Math.abs($), w), v && ($ = NY($)), L && +$ == 0 && p !== "+" && (L = !1), B = (L ? p === "(" ? p : a : p === "-" || p === "(" ? "" : p) + B, R = (x === "s" ? Y2[8 + t$ / 3] : "") + R + (L && p === "(" ? ")" : ""), M) {
-                    for (S = -1, T = $.length; ++S < T;)
-                        if (D = $.charCodeAt(S), 48 > D || D > 57) {
-                            R = (D === 46 ? r + $.slice(S + 1) : $.slice(S)) + R, $ = $.slice(0, S);
+                A = +A;
+                var k = A < 0 || 1 / A < 0;
+                if (A = isNaN(A) ? c : T(Math.abs(A), w), v && (A = PP(A)), k && +A == 0 && p !== "+" && (k = !1), D = (k ? p === "(" ? p : a : p === "-" || p === "(" ? "" : p) + D, R = (x === "s" ? aw[8 + WS / 3] : "") + R + (k && p === "(" ? ")" : ""), $) {
+                    for (S = -1, I = A.length; ++S < I;)
+                        if (E = A.charCodeAt(S), 48 > E || E > 57) {
+                            R = (E === 46 ? i + A.slice(S + 1) : A.slice(S)) + R, A = A.slice(0, S);
                             break;
                         }
                 }
             }
-            b && !g && ($ = t($, 1 / 0));
-            var k = B.length + $.length + R.length,
-                U = k < y ? new Array(y - k + 1).join(h) : "";
-            switch (b && g && ($ = t(U + $, U.length ? y - R.length : 1 / 0), U = ""), d) {
+            b && !m && (A = t(A, 1 / 0));
+            var B = D.length + A.length + R.length,
+                C = B < g ? new Array(g - B + 1).join(h) : "";
+            switch (b && m && (A = t(C + A, C.length ? g - R.length : 1 / 0), C = ""), d) {
                 case "<":
-                    $ = B + $ + R + U;
+                    A = D + A + R + C;
                     break;
                 case "=":
-                    $ = B + U + $ + R;
+                    A = D + C + A + R;
                     break;
                 case "^":
-                    $ = U.slice(0, k = U.length >> 1) + B + $ + R + U.slice(k);
+                    A = C.slice(0, B = C.length >> 1) + D + A + R + C.slice(B);
                     break;
                 default:
-                    $ = U + B + $ + R;
+                    A = C + D + A + R;
                     break;
             }
-            return s($);
+            return s(A);
         }
         return N.toString = function() {
             return f + "";
         }, N;
     }
 
-    function u(f, h) {
-        var d = l((f = ku(f), f.type = "f", f)),
-            p = Math.max(-8, Math.min(8, Math.floor(Oc(h) / 3))) * 3,
-            m = Math.pow(10, -p),
-            g = Y2[8 + p / 3];
-        return function(y) {
-            return d(m * y) + g;
+    function l(f, h) {
+        var d = u((f = Rc(f), f.type = "f", f)),
+            p = Math.max(-8, Math.min(8, Math.floor(Go(h) / 3))) * 3,
+            y = Math.pow(10, -p),
+            m = aw[8 + p / 3];
+        return function(g) {
+            return d(y * g) + m;
         };
     }
     return {
-        format: l,
-        formatPrefix: u
+        format: u,
+        formatPrefix: l
     };
 }
-var hh, rl, e$;
-FY({
+var Zu, ma, XS;
+qP({
     thousands: ",",
     grouping: [3],
     currency: ["$", ""]
 });
 
-function FY(e) {
-    return hh = OY(e), rl = hh.format, e$ = hh.formatPrefix, hh;
+function qP(e) {
+    return Zu = zP(e), ma = Zu.format, XS = Zu.formatPrefix, Zu;
 }
 
-function EY(e) {
-    return Math.max(0, -Oc(Math.abs(e)));
+function jP(e) {
+    return Math.max(0, -Go(Math.abs(e)));
 }
 
-function LY(e, t) {
-    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Oc(t) / 3))) * 3 - Oc(Math.abs(e)));
-}
-
-function RY(e, t) {
-    return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Oc(t) - Oc(e)) + 1;
-}
-var wt = 1e-6,
-    ap = 1e-12,
-    kt = Math.PI,
-    $e = kt / 2,
-    W2 = kt / 4,
-    Vn = kt * 2,
-    Xe = 180 / kt,
-    Xt = kt / 180,
-    Jt = Math.abs,
-    sl = Math.atan,
-    Ti = Math.atan2,
-    $t = Math.cos,
-    dh = Math.ceil,
-    n$ = Math.exp,
-    Qg = Math.hypot,
-    cp = Math.log,
-    _m = Math.pow,
-    ot = Math.sin,
-    ii = Math.sign || function(e) {
+function VP(e, t) {
+    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Go(t) / 3))) * 3 - Go(Math.abs(e)));
+}
+
+function YP(e, t) {
+    return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Go(t) - Go(e)) + 1;
+}
+var ut = 1e-6,
+    kf = 1e-12,
+    Mt = Math.PI,
+    oe = Mt / 2,
+    cw = Mt / 4,
+    ln = Mt * 2,
+    Se = 180 / Mt,
+    Lt = Mt / 180,
+    Ft = Math.abs,
+    ga = Math.atan,
+    Vn = Math.atan2,
+    pt = Math.cos,
+    Ku = Math.ceil,
+    GS = Math.exp,
+    z0 = Math.hypot,
+    Rf = Math.log,
+    mp = Math.pow,
+    et = Math.sin,
+    _n = Math.sign || function(e) {
         return e > 0 ? 1 : e < 0 ? -1 : 0;
     },
-    yn = Math.sqrt,
-    sw = Math.tan;
+    Ue = Math.sqrt,
+    Cm = Math.tan;
 
-function i$(e) {
-    return e > 1 ? 0 : e < -1 ? kt : Math.acos(e);
+function HS(e) {
+    return e > 1 ? 0 : e < -1 ? Mt : Math.acos(e);
 }
 
-function Dn(e) {
-    return e > 1 ? $e : e < -1 ? -$e : Math.asin(e);
+function Ke(e) {
+    return e > 1 ? oe : e < -1 ? -oe : Math.asin(e);
 }
 
-function kn() {}
+function on() {}
 
-function lp(e, t) {
-    e && X2.hasOwnProperty(e.type) && X2[e.type](e, t);
+function Ff(e, t) {
+    e && lw.hasOwnProperty(e.type) && lw[e.type](e, t);
 }
-var G2 = {
+var uw = {
         Feature: function(e, t) {
-            lp(e.geometry, t);
+            Ff(e.geometry, t);
         },
         FeatureCollection: function(e, t) {
-            for (var n = e.features, i = -1, r = n.length; ++i < r;)
-                lp(n[i].geometry, t);
+            for (var n = e.features, r = -1, i = n.length; ++r < i;)
+                Ff(n[r].geometry, t);
         }
     },
-    X2 = {
+    lw = {
         Sphere: function(e, t) {
             t.sphere();
         },
         Point: function(e, t) {
             e = e.coordinates, t.point(e[0], e[1], e[2]);
         },
         MultiPoint: function(e, t) {
-            for (var n = e.coordinates, i = -1, r = n.length; ++i < r;)
-                e = n[i], t.point(e[0], e[1], e[2]);
+            for (var n = e.coordinates, r = -1, i = n.length; ++r < i;)
+                e = n[r], t.point(e[0], e[1], e[2]);
         },
         LineString: function(e, t) {
-            t1(e.coordinates, t, 0);
+            q0(e.coordinates, t, 0);
         },
         MultiLineString: function(e, t) {
-            for (var n = e.coordinates, i = -1, r = n.length; ++i < r;)
-                t1(n[i], t, 0);
+            for (var n = e.coordinates, r = -1, i = n.length; ++r < i;)
+                q0(n[r], t, 0);
         },
         Polygon: function(e, t) {
-            H2(e.coordinates, t);
+            fw(e.coordinates, t);
         },
         MultiPolygon: function(e, t) {
-            for (var n = e.coordinates, i = -1, r = n.length; ++i < r;)
-                H2(n[i], t);
+            for (var n = e.coordinates, r = -1, i = n.length; ++r < i;)
+                fw(n[r], t);
         },
         GeometryCollection: function(e, t) {
-            for (var n = e.geometries, i = -1, r = n.length; ++i < r;)
-                lp(n[i], t);
+            for (var n = e.geometries, r = -1, i = n.length; ++r < i;)
+                Ff(n[r], t);
         }
     };
 
-function t1(e, t, n) {
-    var i = -1,
-        r = e.length - n,
+function q0(e, t, n) {
+    var r = -1,
+        i = e.length - n,
         s;
-    for (t.lineStart(); ++i < r;)
-        s = e[i], t.point(s[0], s[1], s[2]);
+    for (t.lineStart(); ++r < i;)
+        s = e[r], t.point(s[0], s[1], s[2]);
     t.lineEnd();
 }
 
-function H2(e, t) {
+function fw(e, t) {
     var n = -1,
-        i = e.length;
-    for (t.polygonStart(); ++n < i;)
-        t1(e[n], t, 1);
+        r = e.length;
+    for (t.polygonStart(); ++n < r;)
+        q0(e[n], t, 1);
     t.polygonEnd();
 }
 
-function Ns(e, t) {
-    e && G2.hasOwnProperty(e.type) ? G2[e.type](e, t) : lp(e, t);
+function Mi(e, t) {
+    e && uw.hasOwnProperty(e.type) ? uw[e.type](e, t) : Ff(e, t);
 }
 
-function e1(e) {
-    return [Ti(e[1], e[0]), Dn(e[2])];
+function j0(e) {
+    return [Vn(e[1], e[0]), Ke(e[2])];
 }
 
-function Fc(e) {
+function Ho(e) {
     var t = e[0],
         n = e[1],
-        i = $t(n);
-    return [i * $t(t), i * ot(t), ot(n)];
+        r = pt(n);
+    return [r * pt(t), r * et(t), et(n)];
 }
 
-function ph(e, t) {
+function Qu(e, t) {
     return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
 }
 
-function up(e, t) {
+function Bf(e, t) {
     return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
 }
 
-function xm(e, t) {
+function gp(e, t) {
     e[0] += t[0], e[1] += t[1], e[2] += t[2];
 }
 
-function yh(e, t) {
+function tl(e, t) {
     return [e[0] * t, e[1] * t, e[2] * t];
 }
 
-function n1(e) {
-    var t = yn(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
+function V0(e) {
+    var t = Ue(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
     e[0] /= t, e[1] /= t, e[2] /= t;
 }
-var Gl, fp, hp, dp, pp, yp, mp, gp, i1, r1, s1, r$, s$, cn, ln, un, _i = {
-    sphere: kn,
-    point: ow,
-    lineStart: J2,
-    lineEnd: K2,
+var Qa, Cf, Pf, Uf, zf, qf, jf, Vf, Y0, W0, X0, JS, ZS, ke, Re, Fe, Fn = {
+    sphere: on,
+    point: Pm,
+    lineStart: hw,
+    lineEnd: dw,
     polygonStart: function() {
-        _i.lineStart = UY, _i.lineEnd = zY;
+        Fn.lineStart = GP, Fn.lineEnd = HP;
     },
     polygonEnd: function() {
-        _i.lineStart = J2, _i.lineEnd = K2;
+        Fn.lineStart = hw, Fn.lineEnd = dw;
     }
 };
 
-function ow(e, t) {
-    e *= Xt, t *= Xt;
-    var n = $t(t);
-    _f(n * $t(e), n * ot(e), ot(t));
+function Pm(e, t) {
+    e *= Lt, t *= Lt;
+    var n = pt(t);
+    fu(n * pt(e), n * et(e), et(t));
 }
 
-function _f(e, t, n) {
-    ++Gl, hp += (e - hp) / Gl, dp += (t - dp) / Gl, pp += (n - pp) / Gl;
+function fu(e, t, n) {
+    ++Qa, Pf += (e - Pf) / Qa, Uf += (t - Uf) / Qa, zf += (n - zf) / Qa;
 }
 
-function J2() {
-    _i.point = CY;
+function hw() {
+    Fn.point = WP;
 }
 
-function CY(e, t) {
-    e *= Xt, t *= Xt;
-    var n = $t(t);
-    cn = n * $t(e), ln = n * ot(e), un = ot(t), _i.point = kY, _f(cn, ln, un);
+function WP(e, t) {
+    e *= Lt, t *= Lt;
+    var n = pt(t);
+    ke = n * pt(e), Re = n * et(e), Fe = et(t), Fn.point = XP, fu(ke, Re, Fe);
 }
 
-function kY(e, t) {
-    e *= Xt, t *= Xt;
-    var n = $t(t),
-        i = n * $t(e),
-        r = n * ot(e),
-        s = ot(t),
-        o = Ti(yn((o = ln * s - un * r) * o + (o = un * i - cn * s) * o + (o = cn * r - ln * i) * o), cn * i + ln * r + un * s);
-    fp += o, yp += o * (cn + (cn = i)), mp += o * (ln + (ln = r)), gp += o * (un + (un = s)), _f(cn, ln, un);
+function XP(e, t) {
+    e *= Lt, t *= Lt;
+    var n = pt(t),
+        r = n * pt(e),
+        i = n * et(e),
+        s = et(t),
+        o = Vn(Ue((o = Re * s - Fe * i) * o + (o = Fe * r - ke * s) * o + (o = ke * i - Re * r) * o), ke * r + Re * i + Fe * s);
+    Cf += o, qf += o * (ke + (ke = r)), jf += o * (Re + (Re = i)), Vf += o * (Fe + (Fe = s)), fu(ke, Re, Fe);
 }
 
-function K2() {
-    _i.point = ow;
+function dw() {
+    Fn.point = Pm;
 }
 
-function UY() {
-    _i.point = PY;
+function GP() {
+    Fn.point = JP;
 }
 
-function zY() {
-    o$(r$, s$), _i.point = ow;
+function HP() {
+    KS(JS, ZS), Fn.point = Pm;
 }
 
-function PY(e, t) {
-    r$ = e, s$ = t, e *= Xt, t *= Xt, _i.point = o$;
-    var n = $t(t);
-    cn = n * $t(e), ln = n * ot(e), un = ot(t), _f(cn, ln, un);
+function JP(e, t) {
+    JS = e, ZS = t, e *= Lt, t *= Lt, Fn.point = KS;
+    var n = pt(t);
+    ke = n * pt(e), Re = n * et(e), Fe = et(t), fu(ke, Re, Fe);
 }
 
-function o$(e, t) {
-    e *= Xt, t *= Xt;
-    var n = $t(t),
-        i = n * $t(e),
-        r = n * ot(e),
-        s = ot(t),
-        o = ln * s - un * r,
-        a = un * i - cn * s,
-        c = cn * r - ln * i,
-        l = Qg(o, a, c),
-        u = Dn(l),
-        f = l && -u / l;
-    i1.add(f * o), r1.add(f * a), s1.add(f * c), fp += u, yp += u * (cn + (cn = i)), mp += u * (ln + (ln = r)), gp += u * (un + (un = s)), _f(cn, ln, un);
+function KS(e, t) {
+    e *= Lt, t *= Lt;
+    var n = pt(t),
+        r = n * pt(e),
+        i = n * et(e),
+        s = et(t),
+        o = Re * s - Fe * i,
+        a = Fe * r - ke * s,
+        c = ke * i - Re * r,
+        u = z0(o, a, c),
+        l = Ke(u),
+        f = u && -l / u;
+    Y0.add(f * o), W0.add(f * a), X0.add(f * c), Cf += l, qf += l * (ke + (ke = r)), jf += l * (Re + (Re = i)), Vf += l * (Fe + (Fe = s)), fu(ke, Re, Fe);
 }
 
-function VY(e) {
-    Gl = fp = hp = dp = pp = yp = mp = gp = 0, i1 = new sr(), r1 = new sr(), s1 = new sr(), Ns(e, _i);
-    var t = +i1,
-        n = +r1,
-        i = +s1,
-        r = Qg(t, n, i);
-    return r < ap && (t = yp, n = mp, i = gp, fp < wt && (t = hp, n = dp, i = pp), r = Qg(t, n, i), r < ap) ? [NaN, NaN] : [Ti(n, t) * Xe, Dn(i / r) * Xe];
+function ZP(e) {
+    Qa = Cf = Pf = Uf = zf = qf = jf = Vf = 0, Y0 = new pr(), W0 = new pr(), X0 = new pr(), Mi(e, Fn);
+    var t = +Y0,
+        n = +W0,
+        r = +X0,
+        i = z0(t, n, r);
+    return i < kf && (t = qf, n = jf, r = Vf, Cf < ut && (t = Pf, n = Uf, r = zf), i = z0(t, n, r), i < kf) ? [NaN, NaN] : [Vn(n, t) * Se, Ke(r / i) * Se];
 }
 
-function o1(e, t) {
-    function n(i, r) {
-        return i = e(i, r), t(i[0], i[1]);
+function G0(e, t) {
+    function n(r, i) {
+        return r = e(r, i), t(r[0], r[1]);
     }
-    return e.invert && t.invert && (n.invert = function(i, r) {
-        return i = t.invert(i, r), i && e.invert(i[0], i[1]);
+    return e.invert && t.invert && (n.invert = function(r, i) {
+        return r = t.invert(r, i), r && e.invert(r[0], r[1]);
     }), n;
 }
 
-function a1(e, t) {
-    return Jt(e) > kt && (e -= Math.round(e / Vn) * Vn), [e, t];
+function H0(e, t) {
+    return Ft(e) > Mt && (e -= Math.round(e / ln) * ln), [e, t];
 }
-a1.invert = a1;
+H0.invert = H0;
 
-function a$(e, t, n) {
-    return (e %= Vn) ? t || n ? o1(Q2(e), tx(t, n)) : Q2(e) : t || n ? tx(t, n) : a1;
+function QS(e, t, n) {
+    return (e %= ln) ? t || n ? G0(yw(e), mw(t, n)) : yw(e) : t || n ? mw(t, n) : H0;
 }
 
-function Z2(e) {
+function pw(e) {
     return function(t, n) {
-        return t += e, Jt(t) > kt && (t -= Math.round(t / Vn) * Vn), [t, n];
+        return t += e, Ft(t) > Mt && (t -= Math.round(t / ln) * ln), [t, n];
     };
 }
 
-function Q2(e) {
-    var t = Z2(e);
-    return t.invert = Z2(-e), t;
+function yw(e) {
+    var t = pw(e);
+    return t.invert = pw(-e), t;
 }
 
-function tx(e, t) {
-    var n = $t(e),
-        i = ot(e),
-        r = $t(t),
-        s = ot(t);
+function mw(e, t) {
+    var n = pt(e),
+        r = et(e),
+        i = pt(t),
+        s = et(t);
 
     function o(a, c) {
-        var l = $t(c),
-            u = $t(a) * l,
-            f = ot(a) * l,
-            h = ot(c),
-            d = h * n + u * i;
+        var u = pt(c),
+            l = pt(a) * u,
+            f = et(a) * u,
+            h = et(c),
+            d = h * n + l * r;
         return [
-            Ti(f * r - d * s, u * n - h * i),
-            Dn(d * r + f * s)
+            Vn(f * i - d * s, l * n - h * r),
+            Ke(d * i + f * s)
         ];
     }
     return o.invert = function(a, c) {
-        var l = $t(c),
-            u = $t(a) * l,
-            f = ot(a) * l,
-            h = ot(c),
-            d = h * r - f * s;
+        var u = pt(c),
+            l = pt(a) * u,
+            f = et(a) * u,
+            h = et(c),
+            d = h * i - f * s;
         return [
-            Ti(f * r + h * s, u * n + d * i),
-            Dn(d * n - u * i)
+            Vn(f * i + h * s, l * n + d * r),
+            Ke(d * n - l * r)
         ];
     }, o;
 }
 
-function jY(e) {
-    e = a$(e[0] * Xt, e[1] * Xt, e.length > 2 ? e[2] * Xt : 0);
+function KP(e) {
+    e = QS(e[0] * Lt, e[1] * Lt, e.length > 2 ? e[2] * Lt : 0);
 
     function t(n) {
-        return n = e(n[0] * Xt, n[1] * Xt), n[0] *= Xe, n[1] *= Xe, n;
+        return n = e(n[0] * Lt, n[1] * Lt), n[0] *= Se, n[1] *= Se, n;
     }
     return t.invert = function(n) {
-        return n = e.invert(n[0] * Xt, n[1] * Xt), n[0] *= Xe, n[1] *= Xe, n;
+        return n = e.invert(n[0] * Lt, n[1] * Lt), n[0] *= Se, n[1] *= Se, n;
     }, t;
 }
 
-function qY(e, t, n, i, r, s) {
+function QP(e, t, n, r, i, s) {
     if (n) {
-        var o = $t(t),
-            a = ot(t),
-            c = i * n;
-        r == null ? (r = t + i * Vn, s = t - c / 2) : (r = ex(o, r), s = ex(o, s), (i > 0 ? r < s : r > s) && (r += i * Vn));
-        for (var l, u = r; i > 0 ? u > s : u < s; u -= c)
-            l = e1([o, -a * $t(u), -a * ot(u)]), e.point(l[0], l[1]);
+        var o = pt(t),
+            a = et(t),
+            c = r * n;
+        i == null ? (i = t + r * ln, s = t - c / 2) : (i = gw(o, i), s = gw(o, s), (r > 0 ? i < s : i > s) && (i += r * ln));
+        for (var u, l = i; r > 0 ? l > s : l < s; l -= c)
+            u = j0([o, -a * pt(l), -a * et(l)]), e.point(u[0], u[1]);
     }
 }
 
-function ex(e, t) {
-    t = Fc(t), t[0] -= e, n1(t);
-    var n = i$(-t[1]);
-    return ((-t[2] < 0 ? -n : n) + Vn - wt) % Vn;
+function gw(e, t) {
+    t = Ho(t), t[0] -= e, V0(t);
+    var n = HS(-t[1]);
+    return ((-t[2] < 0 ? -n : n) + ln - ut) % ln;
 }
 
-function c$() {
+function t3() {
     var e = [],
         t;
     return {
-        point: function(n, i, r) {
-            t.push([n, i, r]);
+        point: function(n, r, i) {
+            t.push([n, r, i]);
         },
         lineStart: function() {
             e.push(t = []);
         },
-        lineEnd: kn,
+        lineEnd: on,
         rejoin: function() {
             e.length > 1 && e.push(e.pop().concat(e.shift()));
         },
         result: function() {
             var n = e;
             return e = [], t = null, n;
         }
     };
 }
 
-function rd(e, t) {
-    return Jt(e[0] - t[0]) < wt && Jt(e[1] - t[1]) < wt;
+function Cl(e, t) {
+    return Ft(e[0] - t[0]) < ut && Ft(e[1] - t[1]) < ut;
 }
 
-function mh(e, t, n, i) {
-    this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null;
+function el(e, t, n, r) {
+    this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;
 }
 
-function l$(e, t, n, i, r) {
+function e3(e, t, n, r, i) {
     var s = [],
         o = [],
         a, c;
     if (e.forEach(function(p) {
-            if (!((m = p.length - 1) <= 0)) {
-                var m, g = p[0],
-                    y = p[m],
+            if (!((y = p.length - 1) <= 0)) {
+                var y, m = p[0],
+                    g = p[y],
                     b;
-                if (rd(g, y)) {
-                    if (!g[2] && !y[2]) {
-                        for (r.lineStart(), a = 0; a < m; ++a)
-                            r.point((g = p[a])[0], g[1]);
-                        r.lineEnd();
+                if (Cl(m, g)) {
+                    if (!m[2] && !g[2]) {
+                        for (i.lineStart(), a = 0; a < y; ++a)
+                            i.point((m = p[a])[0], m[1]);
+                        i.lineEnd();
                         return;
                     }
-                    y[0] += 2 * wt;
+                    g[0] += 2 * ut;
                 }
-                s.push(b = new mh(g, p, null, !0)), o.push(b.o = new mh(g, null, b, !1)), s.push(b = new mh(y, p, null, !1)), o.push(b.o = new mh(y, null, b, !0));
+                s.push(b = new el(m, p, null, !0)), o.push(b.o = new el(m, null, b, !1)), s.push(b = new el(g, p, null, !1)), o.push(b.o = new el(g, null, b, !0));
             }
         }), !!s.length) {
-        for (o.sort(t), nx(s), nx(o), a = 0, c = o.length; a < c; ++a)
+        for (o.sort(t), bw(s), bw(o), a = 0, c = o.length; a < c; ++a)
             o[a].e = n = !n;
-        for (var l = s[0], u, f;;) {
-            for (var h = l, d = !0; h.v;)
-                if ((h = h.n) === l)
+        for (var u = s[0], l, f;;) {
+            for (var h = u, d = !0; h.v;)
+                if ((h = h.n) === u)
                     return;
-            u = h.z, r.lineStart();
+            l = h.z, i.lineStart();
             do {
                 if (h.v = h.o.v = !0, h.e) {
                     if (d)
-                        for (a = 0, c = u.length; a < c; ++a)
-                            r.point((f = u[a])[0], f[1]);
+                        for (a = 0, c = l.length; a < c; ++a)
+                            i.point((f = l[a])[0], f[1]);
                     else
-                        i(h.x, h.n.x, 1, r);
+                        r(h.x, h.n.x, 1, i);
                     h = h.n;
                 } else {
                     if (d)
-                        for (u = h.p.z, a = u.length - 1; a >= 0; --a)
-                            r.point((f = u[a])[0], f[1]);
+                        for (l = h.p.z, a = l.length - 1; a >= 0; --a)
+                            i.point((f = l[a])[0], f[1]);
                     else
-                        i(h.x, h.p.x, -1, r);
+                        r(h.x, h.p.x, -1, i);
                     h = h.p;
                 }
-                h = h.o, u = h.z, d = !d;
+                h = h.o, l = h.z, d = !d;
             } while (!h.v);
-            r.lineEnd();
+            i.lineEnd();
         }
     }
 }
 
-function nx(e) {
+function bw(e) {
     if (t = e.length) {
-        for (var t, n = 0, i = e[0], r; ++n < t;)
-            i.n = r = e[n], r.p = i, i = r;
-        i.n = r = e[0], r.p = i;
+        for (var t, n = 0, r = e[0], i; ++n < t;)
+            r.n = i = e[n], i.p = r, r = i;
+        r.n = i = e[0], i.p = r;
     }
 }
 
-function Sm(e) {
-    return Jt(e[0]) <= kt ? e[0] : ii(e[0]) * ((Jt(e[0]) + kt) % Vn - kt);
+function bp(e) {
+    return Ft(e[0]) <= Mt ? e[0] : _n(e[0]) * ((Ft(e[0]) + Mt) % ln - Mt);
 }
 
-function YY(e, t) {
-    var n = Sm(t),
-        i = t[1],
-        r = ot(i),
-        s = [ot(n), -$t(n), 0],
+function tU(e, t) {
+    var n = bp(t),
+        r = t[1],
+        i = et(r),
+        s = [et(n), -pt(n), 0],
         o = 0,
         a = 0,
-        c = new sr();
-    r === 1 ? i = $e + wt : r === -1 && (i = -$e - wt);
-    for (var l = 0, u = e.length; l < u; ++l)
-        if (h = (f = e[l]).length)
-            for (var f, h, d = f[h - 1], p = Sm(d), m = d[1] / 2 + W2, g = ot(m), y = $t(m), b = 0; b < h; ++b, p = v, g = _, y = I, d = w) {
+        c = new pr();
+    i === 1 ? r = oe + ut : i === -1 && (r = -oe - ut);
+    for (var u = 0, l = e.length; u < l; ++u)
+        if (h = (f = e[u]).length)
+            for (var f, h, d = f[h - 1], p = bp(d), y = d[1] / 2 + cw, m = et(y), g = pt(y), b = 0; b < h; ++b, p = v, m = _, g = M, d = w) {
                 var w = f[b],
-                    v = Sm(w),
-                    x = w[1] / 2 + W2,
-                    _ = ot(x),
-                    I = $t(x),
-                    A = v - p,
-                    M = A >= 0 ? 1 : -1,
-                    N = M * A,
-                    $ = N > kt,
-                    B = g * _;
-                if (c.add(Ti(B * M * ot(N), y * I + B * $t(N))), o += $ ? A + M * Vn : A, $ ^ p >= n ^ v >= n) {
-                    var R = up(Fc(d), Fc(w));
-                    n1(R);
-                    var S = up(s, R);
-                    n1(S);
-                    var T = ($ ^ A >= 0 ? -1 : 1) * Dn(S[2]);
-                    (i > T || i === T && (R[0] || R[1])) && (a += $ ^ A >= 0 ? 1 : -1);
+                    v = bp(w),
+                    x = w[1] / 2 + cw,
+                    _ = et(x),
+                    M = pt(x),
+                    T = v - p,
+                    $ = T >= 0 ? 1 : -1,
+                    N = $ * T,
+                    A = N > Mt,
+                    D = m * _;
+                if (c.add(Vn(D * $ * et(N), g * M + D * pt(N))), o += A ? T + $ * ln : T, A ^ p >= n ^ v >= n) {
+                    var R = Bf(Ho(d), Ho(w));
+                    V0(R);
+                    var S = Bf(s, R);
+                    V0(S);
+                    var I = (A ^ T >= 0 ? -1 : 1) * Ke(S[2]);
+                    (r > I || r === I && (R[0] || R[1])) && (a += A ^ T >= 0 ? 1 : -1);
                 }
             }
-    return (o < -wt || o < wt && c < -ap) ^ a & 1;
+    return (o < -ut || o < ut && c < -kf) ^ a & 1;
 }
 
-function u$(e, t, n, i) {
-    return function(r) {
-        var s = t(r),
-            o = c$(),
+function n3(e, t, n, r) {
+    return function(i) {
+        var s = t(i),
+            o = t3(),
             a = t(o),
             c = !1,
-            l, u, f, h = {
+            u, l, f, h = {
                 point: d,
-                lineStart: m,
-                lineEnd: g,
+                lineStart: y,
+                lineEnd: m,
                 polygonStart: function() {
-                    h.point = y, h.lineStart = b, h.lineEnd = w, u = [], l = [];
+                    h.point = g, h.lineStart = b, h.lineEnd = w, l = [], u = [];
                 },
                 polygonEnd: function() {
-                    h.point = d, h.lineStart = m, h.lineEnd = g, u = h3(u);
-                    var v = YY(l, i);
-                    u.length ? (c || (r.polygonStart(), c = !0), l$(u, GY, v, n, r)) : v && (c || (r.polygonStart(), c = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), c && (r.polygonEnd(), c = !1), u = l = null;
+                    h.point = d, h.lineStart = y, h.lineEnd = m, l = iS(l);
+                    var v = tU(u, r);
+                    l.length ? (c || (i.polygonStart(), c = !0), e3(l, nU, v, n, i)) : v && (c || (i.polygonStart(), c = !0), i.lineStart(), n(null, null, 1, i), i.lineEnd()), c && (i.polygonEnd(), c = !1), l = u = null;
                 },
                 sphere: function() {
-                    r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd();
+                    i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd();
                 }
             };
 
         function d(v, x) {
-            e(v, x) && r.point(v, x);
+            e(v, x) && i.point(v, x);
         }
 
         function p(v, x) {
             s.point(v, x);
         }
 
-        function m() {
+        function y() {
             h.point = p, s.lineStart();
         }
 
-        function g() {
+        function m() {
             h.point = d, s.lineEnd();
         }
 
-        function y(v, x) {
+        function g(v, x) {
             f.push([v, x]), a.point(v, x);
         }
 
         function b() {
             a.lineStart(), f = [];
         }
 
         function w() {
-            y(f[0][0], f[0][1]), a.lineEnd();
+            g(f[0][0], f[0][1]), a.lineEnd();
             var v = a.clean(),
                 x = o.result(),
-                _, I = x.length,
-                A, M, N;
-            if (f.pop(), l.push(f), f = null, !!I) {
+                _, M = x.length,
+                T, $, N;
+            if (f.pop(), u.push(f), f = null, !!M) {
                 if (v & 1) {
-                    if (M = x[0], (A = M.length - 1) > 0) {
-                        for (c || (r.polygonStart(), c = !0), r.lineStart(), _ = 0; _ < A; ++_)
-                            r.point((N = M[_])[0], N[1]);
-                        r.lineEnd();
+                    if ($ = x[0], (T = $.length - 1) > 0) {
+                        for (c || (i.polygonStart(), c = !0), i.lineStart(), _ = 0; _ < T; ++_)
+                            i.point((N = $[_])[0], N[1]);
+                        i.lineEnd();
                     }
                     return;
                 }
-                I > 1 && v & 2 && x.push(x.pop().concat(x.shift())), u.push(x.filter(WY));
+                M > 1 && v & 2 && x.push(x.pop().concat(x.shift())), l.push(x.filter(eU));
             }
         }
         return h;
     };
 }
 
-function WY(e) {
+function eU(e) {
     return e.length > 1;
 }
 
-function GY(e, t) {
-    return ((e = e.x)[0] < 0 ? e[1] - $e - wt : $e - e[1]) - ((t = t.x)[0] < 0 ? t[1] - $e - wt : $e - t[1]);
+function nU(e, t) {
+    return ((e = e.x)[0] < 0 ? e[1] - oe - ut : oe - e[1]) - ((t = t.x)[0] < 0 ? t[1] - oe - ut : oe - t[1]);
 }
-const ix = u$(
+const ww = n3(
     function() {
         return !0;
     },
-    XY,
-    JY,
-    [-kt, -$e]
+    rU,
+    sU,
+    [-Mt, -oe]
 );
 
-function XY(e) {
+function rU(e) {
     var t = NaN,
         n = NaN,
-        i = NaN,
-        r;
+        r = NaN,
+        i;
     return {
         lineStart: function() {
-            e.lineStart(), r = 1;
+            e.lineStart(), i = 1;
         },
         point: function(s, o) {
-            var a = s > 0 ? kt : -kt,
-                c = Jt(s - t);
-            Jt(c - kt) < wt ? (e.point(t, n = (n + o) / 2 > 0 ? $e : -$e), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), e.point(s, n), r = 0) : i !== a && c >= kt && (Jt(t - i) < wt && (t -= i * wt), Jt(s - a) < wt && (s -= a * wt), n = HY(t, n, s, o), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(a, n), r = 0), e.point(t = s, n = o), i = a;
+            var a = s > 0 ? Mt : -Mt,
+                c = Ft(s - t);
+            Ft(c - Mt) < ut ? (e.point(t, n = (n + o) / 2 > 0 ? oe : -oe), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(a, n), e.point(s, n), i = 0) : r !== a && c >= Mt && (Ft(t - r) < ut && (t -= r * ut), Ft(s - a) < ut && (s -= a * ut), n = iU(t, n, s, o), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(a, n), i = 0), e.point(t = s, n = o), r = a;
         },
         lineEnd: function() {
             e.lineEnd(), t = n = NaN;
         },
         clean: function() {
-            return 2 - r;
+            return 2 - i;
         }
     };
 }
 
-function HY(e, t, n, i) {
-    var r, s, o = ot(e - n);
-    return Jt(o) > wt ? sl((ot(t) * (s = $t(i)) * ot(n) - ot(i) * (r = $t(t)) * ot(e)) / (r * s * o)) : (t + i) / 2;
+function iU(e, t, n, r) {
+    var i, s, o = et(e - n);
+    return Ft(o) > ut ? ga((et(t) * (s = pt(r)) * et(n) - et(r) * (i = pt(t)) * et(e)) / (i * s * o)) : (t + r) / 2;
 }
 
-function JY(e, t, n, i) {
-    var r;
+function sU(e, t, n, r) {
+    var i;
     if (e == null)
-        r = n * $e, i.point(-kt, r), i.point(0, r), i.point(kt, r), i.point(kt, 0), i.point(kt, -r), i.point(0, -r), i.point(-kt, -r), i.point(-kt, 0), i.point(-kt, r);
-    else if (Jt(e[0] - t[0]) > wt) {
-        var s = e[0] < t[0] ? kt : -kt;
-        r = n * s / 2, i.point(-s, r), i.point(0, r), i.point(s, r);
+        i = n * oe, r.point(-Mt, i), r.point(0, i), r.point(Mt, i), r.point(Mt, 0), r.point(Mt, -i), r.point(0, -i), r.point(-Mt, -i), r.point(-Mt, 0), r.point(-Mt, i);
+    else if (Ft(e[0] - t[0]) > ut) {
+        var s = e[0] < t[0] ? Mt : -Mt;
+        i = n * s / 2, r.point(-s, i), r.point(0, i), r.point(s, i);
     } else
-        i.point(t[0], t[1]);
+        r.point(t[0], t[1]);
 }
 
-function KY(e) {
-    var t = $t(e),
-        n = 6 * Xt,
-        i = t > 0,
-        r = Jt(t) > wt;
+function oU(e) {
+    var t = pt(e),
+        n = 6 * Lt,
+        r = t > 0,
+        i = Ft(t) > ut;
 
-    function s(u, f, h, d) {
-        qY(d, e, n, h, u, f);
+    function s(l, f, h, d) {
+        QP(d, e, n, h, l, f);
     }
 
-    function o(u, f) {
-        return $t(u) * $t(f) > t;
+    function o(l, f) {
+        return pt(l) * pt(f) > t;
     }
 
-    function a(u) {
-        var f, h, d, p, m;
+    function a(l) {
+        var f, h, d, p, y;
         return {
             lineStart: function() {
-                p = d = !1, m = 1;
+                p = d = !1, y = 1;
             },
-            point: function(g, y) {
-                var b = [g, y],
-                    w, v = o(g, y),
-                    x = i ? v ? 0 : l(g, y) : v ? l(g + (g < 0 ? kt : -kt), y) : 0;
-                if (!f && (p = d = v) && u.lineStart(), v !== d && (w = c(f, b), (!w || rd(f, w) || rd(b, w)) && (b[2] = 1)), v !== d)
-                    m = 0, v ? (u.lineStart(), w = c(b, f), u.point(w[0], w[1])) : (w = c(f, b), u.point(w[0], w[1], 2), u.lineEnd()), f = w;
-                else if (r && f && i ^ v) {
+            point: function(m, g) {
+                var b = [m, g],
+                    w, v = o(m, g),
+                    x = r ? v ? 0 : u(m, g) : v ? u(m + (m < 0 ? Mt : -Mt), g) : 0;
+                if (!f && (p = d = v) && l.lineStart(), v !== d && (w = c(f, b), (!w || Cl(f, w) || Cl(b, w)) && (b[2] = 1)), v !== d)
+                    y = 0, v ? (l.lineStart(), w = c(b, f), l.point(w[0], w[1])) : (w = c(f, b), l.point(w[0], w[1], 2), l.lineEnd()), f = w;
+                else if (i && f && r ^ v) {
                     var _;
-                    !(x & h) && (_ = c(b, f, !0)) && (m = 0, i ? (u.lineStart(), u.point(_[0][0], _[0][1]), u.point(_[1][0], _[1][1]), u.lineEnd()) : (u.point(_[1][0], _[1][1]), u.lineEnd(), u.lineStart(), u.point(_[0][0], _[0][1], 3)));
+                    !(x & h) && (_ = c(b, f, !0)) && (y = 0, r ? (l.lineStart(), l.point(_[0][0], _[0][1]), l.point(_[1][0], _[1][1]), l.lineEnd()) : (l.point(_[1][0], _[1][1]), l.lineEnd(), l.lineStart(), l.point(_[0][0], _[0][1], 3)));
                 }
-                v && (!f || !rd(f, b)) && u.point(b[0], b[1]), f = b, d = v, h = x;
+                v && (!f || !Cl(f, b)) && l.point(b[0], b[1]), f = b, d = v, h = x;
             },
             lineEnd: function() {
-                d && u.lineEnd(), f = null;
+                d && l.lineEnd(), f = null;
             },
             // Rejoin first and last segments if there were intersections and the first
             // and last points were visible.
             clean: function() {
-                return m | (p && d) << 1;
+                return y | (p && d) << 1;
             }
         };
     }
 
-    function c(u, f, h) {
-        var d = Fc(u),
-            p = Fc(f),
-            m = [1, 0, 0],
-            g = up(d, p),
-            y = ph(g, g),
-            b = g[0],
-            w = y - b * b;
+    function c(l, f, h) {
+        var d = Ho(l),
+            p = Ho(f),
+            y = [1, 0, 0],
+            m = Bf(d, p),
+            g = Qu(m, m),
+            b = m[0],
+            w = g - b * b;
         if (!w)
-            return !h && u;
-        var v = t * y / w,
+            return !h && l;
+        var v = t * g / w,
             x = -t * b / w,
-            _ = up(m, g),
-            I = yh(m, v),
-            A = yh(g, x);
-        xm(I, A);
-        var M = _,
-            N = ph(I, M),
-            $ = ph(M, M),
-            B = N * N - $ * (ph(I, I) - 1);
-        if (!(B < 0)) {
-            var R = yn(B),
-                S = yh(M, (-N - R) / $);
-            if (xm(S, I), S = e1(S), !h)
+            _ = Bf(y, m),
+            M = tl(y, v),
+            T = tl(m, x);
+        gp(M, T);
+        var $ = _,
+            N = Qu(M, $),
+            A = Qu($, $),
+            D = N * N - A * (Qu(M, M) - 1);
+        if (!(D < 0)) {
+            var R = Ue(D),
+                S = tl($, (-N - R) / A);
+            if (gp(S, M), S = j0(S), !h)
                 return S;
-            var T = u[0],
-                D = f[0],
-                L = u[1],
-                k = f[1],
-                U;
-            D < T && (U = T, T = D, D = U);
-            var C = D - T,
-                z = Jt(C - kt) < wt,
-                P = z || C < wt;
-            if (!z && k < L && (U = L, L = k, k = U), P ? z ? L + k > 0 ^ S[1] < (Jt(S[0] - T) < wt ? L : k) : L <= S[1] && S[1] <= k : C > kt ^ (T <= S[0] && S[0] <= D)) {
-                var G = yh(M, (-N + R) / $);
-                return xm(G, I), [S, e1(G)];
+            var I = l[0],
+                E = f[0],
+                k = l[1],
+                B = f[1],
+                C;
+            E < I && (C = I, I = E, E = C);
+            var F = E - I,
+                P = Ft(F - Mt) < ut,
+                U = P || F < ut;
+            if (!P && B < k && (C = k, k = B, B = C), U ? P ? k + B > 0 ^ S[1] < (Ft(S[0] - I) < ut ? k : B) : k <= S[1] && S[1] <= B : F > Mt ^ (I <= S[0] && S[0] <= E)) {
+                var Y = tl($, (-N + R) / A);
+                return gp(Y, M), [S, j0(Y)];
             }
         }
     }
 
-    function l(u, f) {
-        var h = i ? e : kt - e,
+    function u(l, f) {
+        var h = r ? e : Mt - e,
             d = 0;
-        return u < -h ? d |= 1 : u > h && (d |= 2), f < -h ? d |= 4 : f > h && (d |= 8), d;
+        return l < -h ? d |= 1 : l > h && (d |= 2), f < -h ? d |= 4 : f > h && (d |= 8), d;
     }
-    return u$(o, a, s, i ? [0, -e] : [-kt, e - kt]);
+    return n3(o, a, s, r ? [0, -e] : [-Mt, e - Mt]);
 }
 
-function ZY(e, t, n, i, r, s) {
+function aU(e, t, n, r, i, s) {
     var o = e[0],
         a = e[1],
         c = t[0],
-        l = t[1],
-        u = 0,
+        u = t[1],
+        l = 0,
         f = 1,
         h = c - o,
-        d = l - a,
+        d = u - a,
         p;
     if (p = n - o, !(!h && p > 0)) {
         if (p /= h, h < 0) {
-            if (p < u)
+            if (p < l)
                 return;
             p < f && (f = p);
         } else if (h > 0) {
             if (p > f)
                 return;
-            p > u && (u = p);
+            p > l && (l = p);
         }
-        if (p = r - o, !(!h && p < 0)) {
+        if (p = i - o, !(!h && p < 0)) {
             if (p /= h, h < 0) {
                 if (p > f)
                     return;
-                p > u && (u = p);
+                p > l && (l = p);
             } else if (h > 0) {
-                if (p < u)
+                if (p < l)
                     return;
                 p < f && (f = p);
             }
-            if (p = i - a, !(!d && p > 0)) {
+            if (p = r - a, !(!d && p > 0)) {
                 if (p /= d, d < 0) {
-                    if (p < u)
+                    if (p < l)
                         return;
                     p < f && (f = p);
                 } else if (d > 0) {
                     if (p > f)
                         return;
-                    p > u && (u = p);
+                    p > l && (l = p);
                 }
                 if (p = s - a, !(!d && p < 0)) {
                     if (p /= d, d < 0) {
                         if (p > f)
                             return;
-                        p > u && (u = p);
+                        p > l && (l = p);
                     } else if (d > 0) {
-                        if (p < u)
+                        if (p < l)
                             return;
                         p < f && (f = p);
                     }
-                    return u > 0 && (e[0] = o + u * h, e[1] = a + u * d), f < 1 && (t[0] = o + f * h, t[1] = a + f * d), !0;
+                    return l > 0 && (e[0] = o + l * h, e[1] = a + l * d), f < 1 && (t[0] = o + f * h, t[1] = a + f * d), !0;
                 }
             }
         }
     }
 }
-var Xl = 1e9,
-    gh = -Xl;
+var tc = 1e9,
+    nl = -tc;
 
-function f$(e, t, n, i) {
-    function r(l, u) {
-        return e <= l && l <= n && t <= u && u <= i;
+function r3(e, t, n, r) {
+    function i(u, l) {
+        return e <= u && u <= n && t <= l && l <= r;
     }
 
-    function s(l, u, f, h) {
+    function s(u, l, f, h) {
         var d = 0,
             p = 0;
-        if (l == null || (d = o(l, f)) !== (p = o(u, f)) || c(l, u) < 0 ^ f > 0)
+        if (u == null || (d = o(u, f)) !== (p = o(l, f)) || c(u, l) < 0 ^ f > 0)
             do
-                h.point(d === 0 || d === 3 ? e : n, d > 1 ? i : t);
+                h.point(d === 0 || d === 3 ? e : n, d > 1 ? r : t);
             while ((d = (d + f + 4) % 4) !== p);
         else
-            h.point(u[0], u[1]);
+            h.point(l[0], l[1]);
     }
 
-    function o(l, u) {
-        return Jt(l[0] - e) < wt ? u > 0 ? 0 : 3 : Jt(l[0] - n) < wt ? u > 0 ? 2 : 1 : Jt(l[1] - t) < wt ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;
+    function o(u, l) {
+        return Ft(u[0] - e) < ut ? l > 0 ? 0 : 3 : Ft(u[0] - n) < ut ? l > 0 ? 2 : 1 : Ft(u[1] - t) < ut ? l > 0 ? 1 : 0 : l > 0 ? 3 : 2;
     }
 
-    function a(l, u) {
-        return c(l.x, u.x);
+    function a(u, l) {
+        return c(u.x, l.x);
     }
 
-    function c(l, u) {
-        var f = o(l, 1),
-            h = o(u, 1);
-        return f !== h ? f - h : f === 0 ? u[1] - l[1] : f === 1 ? l[0] - u[0] : f === 2 ? l[1] - u[1] : u[0] - l[0];
+    function c(u, l) {
+        var f = o(u, 1),
+            h = o(l, 1);
+        return f !== h ? f - h : f === 0 ? l[1] - u[1] : f === 1 ? u[0] - l[0] : f === 2 ? u[1] - l[1] : l[0] - u[0];
     }
-    return function(l) {
-        var u = l,
-            f = c$(),
-            h, d, p, m, g, y, b, w, v, x, _, I = {
-                point: A,
-                lineStart: B,
+    return function(u) {
+        var l = u,
+            f = t3(),
+            h, d, p, y, m, g, b, w, v, x, _, M = {
+                point: T,
+                lineStart: D,
                 lineEnd: R,
                 polygonStart: N,
-                polygonEnd: $
+                polygonEnd: A
             };
 
-        function A(T, D) {
-            r(T, D) && u.point(T, D);
+        function T(I, E) {
+            i(I, E) && l.point(I, E);
         }
 
-        function M() {
-            for (var T = 0, D = 0, L = d.length; D < L; ++D)
-                for (var k = d[D], U = 1, C = k.length, z = k[0], P, G, K = z[0], et = z[1]; U < C; ++U)
-                    P = K, G = et, z = k[U], K = z[0], et = z[1], G <= i ? et > i && (K - P) * (i - G) > (et - G) * (e - P) && ++T : et <= i && (K - P) * (i - G) < (et - G) * (e - P) && --T;
-            return T;
+        function $() {
+            for (var I = 0, E = 0, k = d.length; E < k; ++E)
+                for (var B = d[E], C = 1, F = B.length, P = B[0], U, Y, G = P[0], K = P[1]; C < F; ++C)
+                    U = G, Y = K, P = B[C], G = P[0], K = P[1], Y <= r ? K > r && (G - U) * (r - Y) > (K - Y) * (e - U) && ++I : K <= r && (G - U) * (r - Y) < (K - Y) * (e - U) && --I;
+            return I;
         }
 
         function N() {
-            u = f, h = [], d = [], _ = !0;
+            l = f, h = [], d = [], _ = !0;
         }
 
-        function $() {
-            var T = M(),
-                D = _ && T,
-                L = (h = h3(h)).length;
-            (D || L) && (l.polygonStart(), D && (l.lineStart(), s(null, null, 1, l), l.lineEnd()), L && l$(h, a, T, s, l), l.polygonEnd()), u = l, h = d = p = null;
+        function A() {
+            var I = $(),
+                E = _ && I,
+                k = (h = iS(h)).length;
+            (E || k) && (u.polygonStart(), E && (u.lineStart(), s(null, null, 1, u), u.lineEnd()), k && e3(h, a, I, s, u), u.polygonEnd()), l = u, h = d = p = null;
         }
 
-        function B() {
-            I.point = S, d && d.push(p = []), x = !0, v = !1, b = w = NaN;
+        function D() {
+            M.point = S, d && d.push(p = []), x = !0, v = !1, b = w = NaN;
         }
 
         function R() {
-            h && (S(m, g), y && v && f.rejoin(), h.push(f.result())), I.point = A, v && u.lineEnd();
+            h && (S(y, m), g && v && f.rejoin(), h.push(f.result())), M.point = T, v && l.lineEnd();
         }
 
-        function S(T, D) {
-            var L = r(T, D);
-            if (d && p.push([T, D]), x)
-                m = T, g = D, y = L, x = !1, L && (u.lineStart(), u.point(T, D));
-            else if (L && v)
-                u.point(T, D);
+        function S(I, E) {
+            var k = i(I, E);
+            if (d && p.push([I, E]), x)
+                y = I, m = E, g = k, x = !1, k && (l.lineStart(), l.point(I, E));
+            else if (k && v)
+                l.point(I, E);
             else {
-                var k = [b = Math.max(gh, Math.min(Xl, b)), w = Math.max(gh, Math.min(Xl, w))],
-                    U = [T = Math.max(gh, Math.min(Xl, T)), D = Math.max(gh, Math.min(Xl, D))];
-                ZY(k, U, e, t, n, i) ? (v || (u.lineStart(), u.point(k[0], k[1])), u.point(U[0], U[1]), L || u.lineEnd(), _ = !1) : L && (u.lineStart(), u.point(T, D), _ = !1);
+                var B = [b = Math.max(nl, Math.min(tc, b)), w = Math.max(nl, Math.min(tc, w))],
+                    C = [I = Math.max(nl, Math.min(tc, I)), E = Math.max(nl, Math.min(tc, E))];
+                aU(B, C, e, t, n, r) ? (v || (l.lineStart(), l.point(B[0], B[1])), l.point(C[0], C[1]), k || l.lineEnd(), _ = !1) : k && (l.lineStart(), l.point(I, E), _ = !1);
             }
-            b = T, w = D, v = L;
+            b = I, w = E, v = k;
         }
-        return I;
+        return M;
     };
 }
 
-function rx(e, t, n) {
-    var i = Cn(e, t - wt, n).concat(t);
-    return function(r) {
-        return i.map(function(s) {
-            return [r, s];
+function vw(e, t, n) {
+    var r = sn(e, t - ut, n).concat(t);
+    return function(i) {
+        return r.map(function(s) {
+            return [i, s];
         });
     };
 }
 
-function sx(e, t, n) {
-    var i = Cn(e, t - wt, n).concat(t);
-    return function(r) {
-        return i.map(function(s) {
-            return [s, r];
+function _w(e, t, n) {
+    var r = sn(e, t - ut, n).concat(t);
+    return function(i) {
+        return r.map(function(s) {
+            return [s, i];
         });
     };
 }
 
-function QY() {
-    var e, t, n, i, r, s, o, a, c = 10,
-        l = c,
-        u = 90,
+function cU() {
+    var e, t, n, r, i, s, o, a, c = 10,
+        u = c,
+        l = 90,
         f = 360,
-        h, d, p, m, g = 2.5;
+        h, d, p, y, m = 2.5;
 
-    function y() {
+    function g() {
         return {
             type: "MultiLineString",
             coordinates: b()
         };
     }
 
     function b() {
-        return Cn(dh(i / u) * u, n, u).map(p).concat(Cn(dh(a / f) * f, o, f).map(m)).concat(Cn(dh(t / c) * c, e, c).filter(function(w) {
-            return Jt(w % u) > wt;
-        }).map(h)).concat(Cn(dh(s / l) * l, r, l).filter(function(w) {
-            return Jt(w % f) > wt;
+        return sn(Ku(r / l) * l, n, l).map(p).concat(sn(Ku(a / f) * f, o, f).map(y)).concat(sn(Ku(t / c) * c, e, c).filter(function(w) {
+            return Ft(w % l) > ut;
+        }).map(h)).concat(sn(Ku(s / u) * u, i, u).filter(function(w) {
+            return Ft(w % f) > ut;
         }).map(d));
     }
-    return y.lines = function() {
+    return g.lines = function() {
         return b().map(function(w) {
             return {
                 type: "LineString",
                 coordinates: w
             };
         });
-    }, y.outline = function() {
+    }, g.outline = function() {
         return {
             type: "Polygon",
             coordinates: [
-                p(i).concat(
-                    m(o).slice(1),
+                p(r).concat(
+                    y(o).slice(1),
                     p(n).reverse().slice(1),
-                    m(a).reverse().slice(1)
+                    y(a).reverse().slice(1)
                 )
             ]
         };
-    }, y.extent = function(w) {
-        return arguments.length ? y.extentMajor(w).extentMinor(w) : y.extentMinor();
-    }, y.extentMajor = function(w) {
-        return arguments.length ? (i = +w[0][0], n = +w[1][0], a = +w[0][1], o = +w[1][1], i > n && (w = i, i = n, n = w), a > o && (w = a, a = o, o = w), y.precision(g)) : [
-            [i, a],
+    }, g.extent = function(w) {
+        return arguments.length ? g.extentMajor(w).extentMinor(w) : g.extentMinor();
+    }, g.extentMajor = function(w) {
+        return arguments.length ? (r = +w[0][0], n = +w[1][0], a = +w[0][1], o = +w[1][1], r > n && (w = r, r = n, n = w), a > o && (w = a, a = o, o = w), g.precision(m)) : [
+            [r, a],
             [n, o]
         ];
-    }, y.extentMinor = function(w) {
-        return arguments.length ? (t = +w[0][0], e = +w[1][0], s = +w[0][1], r = +w[1][1], t > e && (w = t, t = e, e = w), s > r && (w = s, s = r, r = w), y.precision(g)) : [
+    }, g.extentMinor = function(w) {
+        return arguments.length ? (t = +w[0][0], e = +w[1][0], s = +w[0][1], i = +w[1][1], t > e && (w = t, t = e, e = w), s > i && (w = s, s = i, i = w), g.precision(m)) : [
             [t, s],
-            [e, r]
+            [e, i]
         ];
-    }, y.step = function(w) {
-        return arguments.length ? y.stepMajor(w).stepMinor(w) : y.stepMinor();
-    }, y.stepMajor = function(w) {
-        return arguments.length ? (u = +w[0], f = +w[1], y) : [u, f];
-    }, y.stepMinor = function(w) {
-        return arguments.length ? (c = +w[0], l = +w[1], y) : [c, l];
-    }, y.precision = function(w) {
-        return arguments.length ? (g = +w, h = rx(s, r, 90), d = sx(t, e, g), p = rx(a, o, 90), m = sx(i, n, g), y) : g;
-    }, y.extentMajor([
-        [-180, -90 + wt],
-        [180, 90 - wt]
+    }, g.step = function(w) {
+        return arguments.length ? g.stepMajor(w).stepMinor(w) : g.stepMinor();
+    }, g.stepMajor = function(w) {
+        return arguments.length ? (l = +w[0], f = +w[1], g) : [l, f];
+    }, g.stepMinor = function(w) {
+        return arguments.length ? (c = +w[0], u = +w[1], g) : [c, u];
+    }, g.precision = function(w) {
+        return arguments.length ? (m = +w, h = vw(s, i, 90), d = _w(t, e, m), p = vw(a, o, 90), y = _w(r, n, m), g) : m;
+    }, g.extentMajor([
+        [-180, -90 + ut],
+        [180, 90 - ut]
     ]).extentMinor([
-        [-180, -80 - wt],
-        [180, 80 + wt]
+        [-180, -80 - ut],
+        [180, 80 + ut]
     ]);
 }
 
-function tW() {
-    return QY()();
+function uU() {
+    return cU()();
 }
-const c1 = (e) => e;
-var Im = new sr(),
-    l1 = new sr(),
-    h$, d$, u1, f1, jr = {
-        point: kn,
-        lineStart: kn,
-        lineEnd: kn,
+const J0 = (e) => e;
+var wp = new pr(),
+    Z0 = new pr(),
+    i3, s3, K0, Q0, Vr = {
+        point: on,
+        lineStart: on,
+        lineEnd: on,
         polygonStart: function() {
-            jr.lineStart = eW, jr.lineEnd = iW;
+            Vr.lineStart = lU, Vr.lineEnd = hU;
         },
         polygonEnd: function() {
-            jr.lineStart = jr.lineEnd = jr.point = kn, Im.add(Jt(l1)), l1 = new sr();
+            Vr.lineStart = Vr.lineEnd = Vr.point = on, wp.add(Ft(Z0)), Z0 = new pr();
         },
         result: function() {
-            var e = Im / 2;
-            return Im = new sr(), e;
+            var e = wp / 2;
+            return wp = new pr(), e;
         }
     };
 
-function eW() {
-    jr.point = nW;
+function lU() {
+    Vr.point = fU;
 }
 
-function nW(e, t) {
-    jr.point = p$, h$ = u1 = e, d$ = f1 = t;
+function fU(e, t) {
+    Vr.point = o3, i3 = K0 = e, s3 = Q0 = t;
 }
 
-function p$(e, t) {
-    l1.add(f1 * e - u1 * t), u1 = e, f1 = t;
+function o3(e, t) {
+    Z0.add(Q0 * e - K0 * t), K0 = e, Q0 = t;
 }
 
-function iW() {
-    p$(h$, d$);
+function hU() {
+    o3(i3, s3);
 }
-var Ec = 1 / 0,
-    bp = Ec,
-    Uu = -Ec,
-    wp = Uu,
-    vp = {
-        point: rW,
-        lineStart: kn,
-        lineEnd: kn,
-        polygonStart: kn,
-        polygonEnd: kn,
+var Jo = 1 / 0,
+    Yf = Jo,
+    Fc = -Jo,
+    Wf = Fc,
+    Xf = {
+        point: dU,
+        lineStart: on,
+        lineEnd: on,
+        polygonStart: on,
+        polygonEnd: on,
         result: function() {
             var e = [
-                [Ec, bp],
-                [Uu, wp]
+                [Jo, Yf],
+                [Fc, Wf]
             ];
-            return Uu = wp = -(bp = Ec = 1 / 0), e;
+            return Fc = Wf = -(Yf = Jo = 1 / 0), e;
         }
     };
 
-function rW(e, t) {
-    e < Ec && (Ec = e), e > Uu && (Uu = e), t < bp && (bp = t), t > wp && (wp = t);
+function dU(e, t) {
+    e < Jo && (Jo = e), e > Fc && (Fc = e), t < Yf && (Yf = t), t > Wf && (Wf = t);
 }
-var h1 = 0,
-    d1 = 0,
-    Hl = 0,
-    _p = 0,
-    xp = 0,
-    Qa = 0,
-    p1 = 0,
-    y1 = 0,
-    Jl = 0,
-    y$, m$, Zi, Qi, ei = {
-        point: ea,
-        lineStart: ox,
-        lineEnd: ax,
+var ty = 0,
+    ey = 0,
+    ec = 0,
+    Gf = 0,
+    Hf = 0,
+    mo = 0,
+    ny = 0,
+    ry = 0,
+    nc = 0,
+    a3, c3, cr, ur, vn = {
+        point: Ls,
+        lineStart: xw,
+        lineEnd: Sw,
         polygonStart: function() {
-            ei.lineStart = aW, ei.lineEnd = cW;
+            vn.lineStart = mU, vn.lineEnd = gU;
         },
         polygonEnd: function() {
-            ei.point = ea, ei.lineStart = ox, ei.lineEnd = ax;
+            vn.point = Ls, vn.lineStart = xw, vn.lineEnd = Sw;
         },
         result: function() {
-            var e = Jl ? [p1 / Jl, y1 / Jl] : Qa ? [_p / Qa, xp / Qa] : Hl ? [h1 / Hl, d1 / Hl] : [NaN, NaN];
-            return h1 = d1 = Hl = _p = xp = Qa = p1 = y1 = Jl = 0, e;
+            var e = nc ? [ny / nc, ry / nc] : mo ? [Gf / mo, Hf / mo] : ec ? [ty / ec, ey / ec] : [NaN, NaN];
+            return ty = ey = ec = Gf = Hf = mo = ny = ry = nc = 0, e;
         }
     };
 
-function ea(e, t) {
-    h1 += e, d1 += t, ++Hl;
+function Ls(e, t) {
+    ty += e, ey += t, ++ec;
 }
 
-function ox() {
-    ei.point = sW;
+function xw() {
+    vn.point = pU;
 }
 
-function sW(e, t) {
-    ei.point = oW, ea(Zi = e, Qi = t);
+function pU(e, t) {
+    vn.point = yU, Ls(cr = e, ur = t);
 }
 
-function oW(e, t) {
-    var n = e - Zi,
-        i = t - Qi,
-        r = yn(n * n + i * i);
-    _p += r * (Zi + e) / 2, xp += r * (Qi + t) / 2, Qa += r, ea(Zi = e, Qi = t);
+function yU(e, t) {
+    var n = e - cr,
+        r = t - ur,
+        i = Ue(n * n + r * r);
+    Gf += i * (cr + e) / 2, Hf += i * (ur + t) / 2, mo += i, Ls(cr = e, ur = t);
 }
 
-function ax() {
-    ei.point = ea;
+function Sw() {
+    vn.point = Ls;
 }
 
-function aW() {
-    ei.point = lW;
+function mU() {
+    vn.point = bU;
 }
 
-function cW() {
-    g$(y$, m$);
+function gU() {
+    u3(a3, c3);
 }
 
-function lW(e, t) {
-    ei.point = g$, ea(y$ = Zi = e, m$ = Qi = t);
+function bU(e, t) {
+    vn.point = u3, Ls(a3 = cr = e, c3 = ur = t);
 }
 
-function g$(e, t) {
-    var n = e - Zi,
-        i = t - Qi,
-        r = yn(n * n + i * i);
-    _p += r * (Zi + e) / 2, xp += r * (Qi + t) / 2, Qa += r, r = Qi * e - Zi * t, p1 += r * (Zi + e), y1 += r * (Qi + t), Jl += r * 3, ea(Zi = e, Qi = t);
+function u3(e, t) {
+    var n = e - cr,
+        r = t - ur,
+        i = Ue(n * n + r * r);
+    Gf += i * (cr + e) / 2, Hf += i * (ur + t) / 2, mo += i, i = ur * e - cr * t, ny += i * (cr + e), ry += i * (ur + t), nc += i * 3, Ls(cr = e, ur = t);
 }
 
-function b$(e) {
+function l3(e) {
     this._context = e;
 }
-b$.prototype = {
+l3.prototype = {
     _radius: 4.5,
     pointRadius: function(e) {
         return this._radius = e, this;
     },
     polygonStart: function() {
         this._line = 0;
     },
@@ -18163,53 +18726,53 @@
                 break;
             }
             case 1: {
                 this._context.lineTo(e, t);
                 break;
             }
             default: {
-                this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, Vn);
+                this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, ln);
                 break;
             }
         }
     },
-    result: kn
+    result: on
 };
-var m1 = new sr(),
-    Am, w$, v$, Kl, Zl, zu = {
-        point: kn,
+var iy = new pr(),
+    vp, f3, h3, rc, ic, Bc = {
+        point: on,
         lineStart: function() {
-            zu.point = uW;
+            Bc.point = wU;
         },
         lineEnd: function() {
-            Am && _$(w$, v$), zu.point = kn;
+            vp && d3(f3, h3), Bc.point = on;
         },
         polygonStart: function() {
-            Am = !0;
+            vp = !0;
         },
         polygonEnd: function() {
-            Am = null;
+            vp = null;
         },
         result: function() {
-            var e = +m1;
-            return m1 = new sr(), e;
+            var e = +iy;
+            return iy = new pr(), e;
         }
     };
 
-function uW(e, t) {
-    zu.point = _$, w$ = Kl = e, v$ = Zl = t;
+function wU(e, t) {
+    Bc.point = d3, f3 = rc = e, h3 = ic = t;
 }
 
-function _$(e, t) {
-    Kl -= e, Zl -= t, m1.add(yn(Kl * Kl + Zl * Zl)), Kl = e, Zl = t;
+function d3(e, t) {
+    rc -= e, ic -= t, iy.add(Ue(rc * rc + ic * ic)), rc = e, ic = t;
 }
-let cx, Sp, lx, ux;
-class fx {
+let Mw, Jf, Aw, $w;
+class Iw {
     constructor(t) {
-        this._append = t == null ? x$ : fW(t), this._radius = 4.5, this._ = "";
+        this._append = t == null ? p3 : vU(t), this._radius = 4.5, this._ = "";
     }
     pointRadius(t) {
         return this._radius = +t, this;
     }
     polygonStart() {
         this._line = 0;
     }
@@ -18229,110 +18792,110 @@
                 break;
             }
             case 1: {
                 this._append`L${t},${n}`;
                 break;
             }
             default: {
-                if (this._append`M${t},${n}`, this._radius !== lx || this._append !== Sp) {
-                    const i = this._radius,
-                        r = this._;
-                    this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, lx = i, Sp = this._append, ux = this._, this._ = r;
+                if (this._append`M${t},${n}`, this._radius !== Aw || this._append !== Jf) {
+                    const r = this._radius,
+                        i = this._;
+                    this._ = "", this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`, Aw = r, Jf = this._append, $w = this._, this._ = i;
                 }
-                this._ += ux;
+                this._ += $w;
                 break;
             }
         }
     }
     result() {
         const t = this._;
         return this._ = "", t.length ? t : null;
     }
 }
 
-function x$(e) {
+function p3(e) {
     let t = 1;
     this._ += e[0];
     for (const n = e.length; t < n; ++t)
         this._ += arguments[t] + e[t];
 }
 
-function fW(e) {
+function vU(e) {
     const t = Math.floor(e);
     if (!(t >= 0))
         throw new RangeError(`invalid digits: ${e}`);
     if (t > 15)
-        return x$;
-    if (t !== cx) {
+        return p3;
+    if (t !== Mw) {
         const n = 10 ** t;
-        cx = t, Sp = function(r) {
+        Mw = t, Jf = function(i) {
             let s = 1;
-            this._ += r[0];
-            for (const o = r.length; s < o; ++s)
-                this._ += Math.round(arguments[s] * n) / n + r[s];
+            this._ += i[0];
+            for (const o = i.length; s < o; ++s)
+                this._ += Math.round(arguments[s] * n) / n + i[s];
         };
     }
-    return Sp;
+    return Jf;
 }
 
-function oo(e, t) {
+function Zi(e, t) {
     let n = 3,
-        i = 4.5,
-        r, s;
+        r = 4.5,
+        i, s;
 
     function o(a) {
-        return a && (typeof i == "function" && s.pointRadius(+i.apply(this, arguments)), Ns(a, r(s))), s.result();
+        return a && (typeof r == "function" && s.pointRadius(+r.apply(this, arguments)), Mi(a, i(s))), s.result();
     }
     return o.area = function(a) {
-        return Ns(a, r(jr)), jr.result();
+        return Mi(a, i(Vr)), Vr.result();
     }, o.measure = function(a) {
-        return Ns(a, r(zu)), zu.result();
+        return Mi(a, i(Bc)), Bc.result();
     }, o.bounds = function(a) {
-        return Ns(a, r(vp)), vp.result();
+        return Mi(a, i(Xf)), Xf.result();
     }, o.centroid = function(a) {
-        return Ns(a, r(ei)), ei.result();
+        return Mi(a, i(vn)), vn.result();
     }, o.projection = function(a) {
-        return arguments.length ? (r = a == null ? (e = null, c1) : (e = a).stream, o) : e;
+        return arguments.length ? (i = a == null ? (e = null, J0) : (e = a).stream, o) : e;
     }, o.context = function(a) {
-        return arguments.length ? (s = a == null ? (t = null, new fx(n)) : new b$(t = a), typeof i != "function" && s.pointRadius(i), o) : t;
+        return arguments.length ? (s = a == null ? (t = null, new Iw(n)) : new l3(t = a), typeof r != "function" && s.pointRadius(r), o) : t;
     }, o.pointRadius = function(a) {
-        return arguments.length ? (i = typeof a == "function" ? a : (s.pointRadius(+a), +a), o) : i;
+        return arguments.length ? (r = typeof a == "function" ? a : (s.pointRadius(+a), +a), o) : r;
     }, o.digits = function(a) {
         if (!arguments.length)
             return n;
         if (a == null)
             n = null;
         else {
             const c = Math.floor(a);
             if (!(c >= 0))
                 throw new RangeError(`invalid digits: ${a}`);
             n = c;
         }
-        return t === null && (s = new fx(n)), o;
+        return t === null && (s = new Iw(n)), o;
     }, o.projection(e).digits(n).context(t);
 }
 
-function Ip(e) {
+function Zf(e) {
     return {
-        stream: i0(e)
+        stream: Qh(e)
     };
 }
 
-function i0(e) {
+function Qh(e) {
     return function(t) {
-        var n = new g1();
-        for (var i in e)
-            n[i] = e[i];
+        var n = new sy();
+        for (var r in e)
+            n[r] = e[r];
         return n.stream = t, n;
     };
 }
 
-function g1() {}
-g1.prototype = {
-    constructor: g1,
+function sy() {}
+sy.prototype = {
+    constructor: sy,
     point: function(e, t) {
         this.stream.point(e, t);
     },
     sphere: function() {
         this.stream.sphere();
     },
     lineStart: function() {
@@ -18345,319 +18908,319 @@
         this.stream.polygonStart();
     },
     polygonEnd: function() {
         this.stream.polygonEnd();
     }
 };
 
-function aw(e, t, n) {
-    var i = e.clipExtent && e.clipExtent();
-    return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), Ns(n, e.stream(vp)), t(vp.result()), i != null && e.clipExtent(i), e;
+function Um(e, t, n) {
+    var r = e.clipExtent && e.clipExtent();
+    return e.scale(150).translate([0, 0]), r != null && e.clipExtent(null), Mi(n, e.stream(Xf)), t(Xf.result()), r != null && e.clipExtent(r), e;
 }
 
-function cw(e, t, n) {
-    return aw(e, function(i) {
-        var r = t[1][0] - t[0][0],
+function zm(e, t, n) {
+    return Um(e, function(r) {
+        var i = t[1][0] - t[0][0],
             s = t[1][1] - t[0][1],
-            o = Math.min(r / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])),
-            a = +t[0][0] + (r - o * (i[1][0] + i[0][0])) / 2,
-            c = +t[0][1] + (s - o * (i[1][1] + i[0][1])) / 2;
+            o = Math.min(i / (r[1][0] - r[0][0]), s / (r[1][1] - r[0][1])),
+            a = +t[0][0] + (i - o * (r[1][0] + r[0][0])) / 2,
+            c = +t[0][1] + (s - o * (r[1][1] + r[0][1])) / 2;
         e.scale(150 * o).translate([a, c]);
     }, n);
 }
 
-function S$(e, t, n) {
-    return cw(e, [
+function y3(e, t, n) {
+    return zm(e, [
         [0, 0], t
     ], n);
 }
 
-function I$(e, t, n) {
-    return aw(e, function(i) {
-        var r = +t,
-            s = r / (i[1][0] - i[0][0]),
-            o = (r - s * (i[1][0] + i[0][0])) / 2,
-            a = -s * i[0][1];
+function m3(e, t, n) {
+    return Um(e, function(r) {
+        var i = +t,
+            s = i / (r[1][0] - r[0][0]),
+            o = (i - s * (r[1][0] + r[0][0])) / 2,
+            a = -s * r[0][1];
         e.scale(150 * s).translate([o, a]);
     }, n);
 }
 
-function A$(e, t, n) {
-    return aw(e, function(i) {
-        var r = +t,
-            s = r / (i[1][1] - i[0][1]),
-            o = -s * i[0][0],
-            a = (r - s * (i[1][1] + i[0][1])) / 2;
+function g3(e, t, n) {
+    return Um(e, function(r) {
+        var i = +t,
+            s = i / (r[1][1] - r[0][1]),
+            o = -s * r[0][0],
+            a = (i - s * (r[1][1] + r[0][1])) / 2;
         e.scale(150 * s).translate([o, a]);
     }, n);
 }
-var hx = 16,
-    hW = $t(30 * Xt);
+var Tw = 16,
+    _U = pt(30 * Lt);
 
-function dx(e, t) {
-    return +t ? pW(e, t) : dW(e);
+function Ew(e, t) {
+    return +t ? SU(e, t) : xU(e);
 }
 
-function dW(e) {
-    return i0({
+function xU(e) {
+    return Qh({
         point: function(t, n) {
             t = e(t, n), this.stream.point(t[0], t[1]);
         }
     });
 }
 
-function pW(e, t) {
-    function n(i, r, s, o, a, c, l, u, f, h, d, p, m, g) {
-        var y = l - i,
-            b = u - r,
-            w = y * y + b * b;
-        if (w > 4 * t && m--) {
+function SU(e, t) {
+    function n(r, i, s, o, a, c, u, l, f, h, d, p, y, m) {
+        var g = u - r,
+            b = l - i,
+            w = g * g + b * b;
+        if (w > 4 * t && y--) {
             var v = o + h,
                 x = a + d,
                 _ = c + p,
-                I = yn(v * v + x * x + _ * _),
-                A = Dn(_ /= I),
-                M = Jt(Jt(_) - 1) < wt || Jt(s - f) < wt ? (s + f) / 2 : Ti(x, v),
-                N = e(M, A),
-                $ = N[0],
-                B = N[1],
-                R = $ - i,
-                S = B - r,
-                T = b * R - y * S;
-            (T * T / w > t || Jt((y * R + b * S) / w - 0.5) > 0.3 || o * h + a * d + c * p < hW) && (n(i, r, s, o, a, c, $, B, M, v /= I, x /= I, _, m, g), g.point($, B), n($, B, M, v, x, _, l, u, f, h, d, p, m, g));
+                M = Ue(v * v + x * x + _ * _),
+                T = Ke(_ /= M),
+                $ = Ft(Ft(_) - 1) < ut || Ft(s - f) < ut ? (s + f) / 2 : Vn(x, v),
+                N = e($, T),
+                A = N[0],
+                D = N[1],
+                R = A - r,
+                S = D - i,
+                I = b * R - g * S;
+            (I * I / w > t || Ft((g * R + b * S) / w - 0.5) > 0.3 || o * h + a * d + c * p < _U) && (n(r, i, s, o, a, c, A, D, $, v /= M, x /= M, _, y, m), m.point(A, D), n(A, D, $, v, x, _, u, l, f, h, d, p, y, m));
         }
     }
-    return function(i) {
-        var r, s, o, a, c, l, u, f, h, d, p, m, g = {
-            point: y,
+    return function(r) {
+        var i, s, o, a, c, u, l, f, h, d, p, y, m = {
+            point: g,
             lineStart: b,
             lineEnd: v,
             polygonStart: function() {
-                i.polygonStart(), g.lineStart = x;
+                r.polygonStart(), m.lineStart = x;
             },
             polygonEnd: function() {
-                i.polygonEnd(), g.lineStart = b;
+                r.polygonEnd(), m.lineStart = b;
             }
         };
 
-        function y(A, M) {
-            A = e(A, M), i.point(A[0], A[1]);
+        function g(T, $) {
+            T = e(T, $), r.point(T[0], T[1]);
         }
 
         function b() {
-            f = NaN, g.point = w, i.lineStart();
+            f = NaN, m.point = w, r.lineStart();
         }
 
-        function w(A, M) {
-            var N = Fc([A, M]),
-                $ = e(A, M);
-            n(f, h, u, d, p, m, f = $[0], h = $[1], u = A, d = N[0], p = N[1], m = N[2], hx, i), i.point(f, h);
+        function w(T, $) {
+            var N = Ho([T, $]),
+                A = e(T, $);
+            n(f, h, l, d, p, y, f = A[0], h = A[1], l = T, d = N[0], p = N[1], y = N[2], Tw, r), r.point(f, h);
         }
 
         function v() {
-            g.point = y, i.lineEnd();
+            m.point = g, r.lineEnd();
         }
 
         function x() {
-            b(), g.point = _, g.lineEnd = I;
+            b(), m.point = _, m.lineEnd = M;
         }
 
-        function _(A, M) {
-            w(r = A, M), s = f, o = h, a = d, c = p, l = m, g.point = w;
+        function _(T, $) {
+            w(i = T, $), s = f, o = h, a = d, c = p, u = y, m.point = w;
         }
 
-        function I() {
-            n(f, h, u, d, p, m, s, o, r, a, c, l, hx, i), g.lineEnd = v, v();
+        function M() {
+            n(f, h, l, d, p, y, s, o, i, a, c, u, Tw, r), m.lineEnd = v, v();
         }
-        return g;
+        return m;
     };
 }
-var yW = i0({
+var MU = Qh({
     point: function(e, t) {
-        this.stream.point(e * Xt, t * Xt);
+        this.stream.point(e * Lt, t * Lt);
     }
 });
 
-function mW(e) {
-    return i0({
+function AU(e) {
+    return Qh({
         point: function(t, n) {
-            var i = e(t, n);
-            return this.stream.point(i[0], i[1]);
+            var r = e(t, n);
+            return this.stream.point(r[0], r[1]);
         }
     });
 }
 
-function gW(e, t, n, i, r) {
+function $U(e, t, n, r, i) {
     function s(o, a) {
-        return o *= i, a *= r, [t + e * o, n - e * a];
+        return o *= r, a *= i, [t + e * o, n - e * a];
     }
     return s.invert = function(o, a) {
-        return [(o - t) / e * i, (n - a) / e * r];
+        return [(o - t) / e * r, (n - a) / e * i];
     }, s;
 }
 
-function px(e, t, n, i, r, s) {
+function Nw(e, t, n, r, i, s) {
     if (!s)
-        return gW(e, t, n, i, r);
-    var o = $t(s),
-        a = ot(s),
+        return $U(e, t, n, r, i);
+    var o = pt(s),
+        a = et(s),
         c = o * e,
-        l = a * e,
-        u = o / e,
+        u = a * e,
+        l = o / e,
         f = a / e,
         h = (a * n - o * t) / e,
         d = (a * t + o * n) / e;
 
-    function p(m, g) {
-        return m *= i, g *= r, [c * m - l * g + t, n - l * m - c * g];
+    function p(y, m) {
+        return y *= r, m *= i, [c * y - u * m + t, n - u * y - c * m];
     }
-    return p.invert = function(m, g) {
-        return [i * (u * m - f * g + h), r * (d - f * m - u * g)];
+    return p.invert = function(y, m) {
+        return [r * (l * y - f * m + h), i * (d - f * y - l * m)];
     }, p;
 }
 
-function ao(e) {
-    return M$(function() {
+function Ki(e) {
+    return b3(function() {
         return e;
     })();
 }
 
-function M$(e) {
+function b3(e) {
     var t, n = 150,
-        i = 480,
-        r = 250,
+        r = 480,
+        i = 250,
         s = 0,
         o = 0,
         a = 0,
         c = 0,
-        l = 0,
-        u, f = 0,
+        u = 0,
+        l, f = 0,
         h = 1,
         d = 1,
         p = null,
-        m = ix,
-        g = null,
-        y, b, w, v = c1,
+        y = ww,
+        m = null,
+        g, b, w, v = J0,
         x = 0.5,
-        _, I, A, M, N;
+        _, M, T, $, N;
 
-    function $(T) {
-        return A(T[0] * Xt, T[1] * Xt);
+    function A(I) {
+        return T(I[0] * Lt, I[1] * Lt);
     }
 
-    function B(T) {
-        return T = A.invert(T[0], T[1]), T && [T[0] * Xe, T[1] * Xe];
+    function D(I) {
+        return I = T.invert(I[0], I[1]), I && [I[0] * Se, I[1] * Se];
     }
-    $.stream = function(T) {
-        return M && N === T ? M : M = yW(mW(u)(m(_(v(N = T)))));
-    }, $.preclip = function(T) {
-        return arguments.length ? (m = T, p = void 0, S()) : m;
-    }, $.postclip = function(T) {
-        return arguments.length ? (v = T, g = y = b = w = null, S()) : v;
-    }, $.clipAngle = function(T) {
-        return arguments.length ? (m = +T ? KY(p = T * Xt) : (p = null, ix), S()) : p * Xe;
-    }, $.clipExtent = function(T) {
-        return arguments.length ? (v = T == null ? (g = y = b = w = null, c1) : f$(g = +T[0][0], y = +T[0][1], b = +T[1][0], w = +T[1][1]), S()) : g == null ? null : [
-            [g, y],
+    A.stream = function(I) {
+        return $ && N === I ? $ : $ = MU(AU(l)(y(_(v(N = I)))));
+    }, A.preclip = function(I) {
+        return arguments.length ? (y = I, p = void 0, S()) : y;
+    }, A.postclip = function(I) {
+        return arguments.length ? (v = I, m = g = b = w = null, S()) : v;
+    }, A.clipAngle = function(I) {
+        return arguments.length ? (y = +I ? oU(p = I * Lt) : (p = null, ww), S()) : p * Se;
+    }, A.clipExtent = function(I) {
+        return arguments.length ? (v = I == null ? (m = g = b = w = null, J0) : r3(m = +I[0][0], g = +I[0][1], b = +I[1][0], w = +I[1][1]), S()) : m == null ? null : [
+            [m, g],
             [b, w]
         ];
-    }, $.scale = function(T) {
-        return arguments.length ? (n = +T, R()) : n;
-    }, $.translate = function(T) {
-        return arguments.length ? (i = +T[0], r = +T[1], R()) : [i, r];
-    }, $.center = function(T) {
-        return arguments.length ? (s = T[0] % 360 * Xt, o = T[1] % 360 * Xt, R()) : [s * Xe, o * Xe];
-    }, $.rotate = function(T) {
-        return arguments.length ? (a = T[0] % 360 * Xt, c = T[1] % 360 * Xt, l = T.length > 2 ? T[2] % 360 * Xt : 0, R()) : [a * Xe, c * Xe, l * Xe];
-    }, $.angle = function(T) {
-        return arguments.length ? (f = T % 360 * Xt, R()) : f * Xe;
-    }, $.reflectX = function(T) {
-        return arguments.length ? (h = T ? -1 : 1, R()) : h < 0;
-    }, $.reflectY = function(T) {
-        return arguments.length ? (d = T ? -1 : 1, R()) : d < 0;
-    }, $.precision = function(T) {
-        return arguments.length ? (_ = dx(I, x = T * T), S()) : yn(x);
-    }, $.fitExtent = function(T, D) {
-        return cw($, T, D);
-    }, $.fitSize = function(T, D) {
-        return S$($, T, D);
-    }, $.fitWidth = function(T, D) {
-        return I$($, T, D);
-    }, $.fitHeight = function(T, D) {
-        return A$($, T, D);
+    }, A.scale = function(I) {
+        return arguments.length ? (n = +I, R()) : n;
+    }, A.translate = function(I) {
+        return arguments.length ? (r = +I[0], i = +I[1], R()) : [r, i];
+    }, A.center = function(I) {
+        return arguments.length ? (s = I[0] % 360 * Lt, o = I[1] % 360 * Lt, R()) : [s * Se, o * Se];
+    }, A.rotate = function(I) {
+        return arguments.length ? (a = I[0] % 360 * Lt, c = I[1] % 360 * Lt, u = I.length > 2 ? I[2] % 360 * Lt : 0, R()) : [a * Se, c * Se, u * Se];
+    }, A.angle = function(I) {
+        return arguments.length ? (f = I % 360 * Lt, R()) : f * Se;
+    }, A.reflectX = function(I) {
+        return arguments.length ? (h = I ? -1 : 1, R()) : h < 0;
+    }, A.reflectY = function(I) {
+        return arguments.length ? (d = I ? -1 : 1, R()) : d < 0;
+    }, A.precision = function(I) {
+        return arguments.length ? (_ = Ew(M, x = I * I), S()) : Ue(x);
+    }, A.fitExtent = function(I, E) {
+        return zm(A, I, E);
+    }, A.fitSize = function(I, E) {
+        return y3(A, I, E);
+    }, A.fitWidth = function(I, E) {
+        return m3(A, I, E);
+    }, A.fitHeight = function(I, E) {
+        return g3(A, I, E);
     };
 
     function R() {
-        var T = px(n, 0, 0, h, d, f).apply(null, t(s, o)),
-            D = px(n, i - T[0], r - T[1], h, d, f);
-        return u = a$(a, c, l), I = o1(t, D), A = o1(u, I), _ = dx(I, x), S();
+        var I = Nw(n, 0, 0, h, d, f).apply(null, t(s, o)),
+            E = Nw(n, r - I[0], i - I[1], h, d, f);
+        return l = QS(a, c, u), M = G0(t, E), T = G0(l, M), _ = Ew(M, x), S();
     }
 
     function S() {
-        return M = N = null, $;
+        return $ = N = null, A;
     }
     return function() {
-        return t = e.apply(this, arguments), $.invert = t.invert && B, R();
+        return t = e.apply(this, arguments), A.invert = t.invert && D, R();
     };
 }
 
-function lw(e) {
+function qm(e) {
     var t = 0,
-        n = kt / 3,
-        i = M$(e),
-        r = i(t, n);
-    return r.parallels = function(s) {
-        return arguments.length ? i(t = s[0] * Xt, n = s[1] * Xt) : [t * Xe, n * Xe];
-    }, r;
+        n = Mt / 3,
+        r = b3(e),
+        i = r(t, n);
+    return i.parallels = function(s) {
+        return arguments.length ? r(t = s[0] * Lt, n = s[1] * Lt) : [t * Se, n * Se];
+    }, i;
 }
 
-function bW(e) {
-    var t = $t(e);
+function IU(e) {
+    var t = pt(e);
 
-    function n(i, r) {
-        return [i * t, ot(r) / t];
+    function n(r, i) {
+        return [r * t, et(i) / t];
     }
-    return n.invert = function(i, r) {
-        return [i / t, Dn(r * t)];
+    return n.invert = function(r, i) {
+        return [r / t, Ke(i * t)];
     }, n;
 }
 
-function wW(e, t) {
-    var n = ot(e),
-        i = (n + ot(t)) / 2;
-    if (Jt(i) < wt)
-        return bW(e);
-    var r = 1 + n * (2 * i - n),
-        s = yn(r) / i;
+function TU(e, t) {
+    var n = et(e),
+        r = (n + et(t)) / 2;
+    if (Ft(r) < ut)
+        return IU(e);
+    var i = 1 + n * (2 * r - n),
+        s = Ue(i) / r;
 
     function o(a, c) {
-        var l = yn(r - 2 * i * ot(c)) / i;
-        return [l * ot(a *= i), s - l * $t(a)];
+        var u = Ue(i - 2 * r * et(c)) / r;
+        return [u * et(a *= r), s - u * pt(a)];
     }
     return o.invert = function(a, c) {
-        var l = s - c,
-            u = Ti(a, Jt(l)) * ii(l);
-        return l * i < 0 && (u -= kt * ii(a) * ii(l)), [u / i, Dn((r - (a * a + l * l) * i * i) / (2 * i))];
+        var u = s - c,
+            l = Vn(a, Ft(u)) * _n(u);
+        return u * r < 0 && (l -= Mt * _n(a) * _n(u)), [l / r, Ke((i - (a * a + u * u) * r * r) / (2 * r))];
     }, o;
 }
 
-function Ap() {
-    return lw(wW).scale(155.424).center([0, 33.6442]);
+function Kf() {
+    return qm(TU).scale(155.424).center([0, 33.6442]);
 }
 
-function $$() {
-    return Ap().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
+function w3() {
+    return Kf().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
 }
 
-function vW(e) {
+function EU(e) {
     var t = e.length;
     return {
-        point: function(n, i) {
-            for (var r = -1; ++r < t;)
-                e[r].point(n, i);
+        point: function(n, r) {
+            for (var i = -1; ++i < t;)
+                e[i].point(n, r);
         },
         sphere: function() {
             for (var n = -1; ++n < t;)
                 e[n].sphere();
         },
         lineStart: function() {
             for (var n = -1; ++n < t;)
@@ -18674,2636 +19237,2636 @@
         polygonEnd: function() {
             for (var n = -1; ++n < t;)
                 e[n].polygonEnd();
         }
     };
 }
 
-function _W() {
-    var e, t, n = $$(),
-        i, r = Ap().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
-        s, o = Ap().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
-        a, c, l = {
+function NU() {
+    var e, t, n = w3(),
+        r, i = Kf().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
+        s, o = Kf().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
+        a, c, u = {
             point: function(h, d) {
                 c = [h, d];
             }
         };
 
-    function u(h) {
+    function l(h) {
         var d = h[0],
             p = h[1];
-        return c = null, i.point(d, p), c || (s.point(d, p), c) || (a.point(d, p), c);
+        return c = null, r.point(d, p), c || (s.point(d, p), c) || (a.point(d, p), c);
     }
-    u.invert = function(h) {
+    l.invert = function(h) {
         var d = n.scale(),
             p = n.translate(),
-            m = (h[0] - p[0]) / d,
-            g = (h[1] - p[1]) / d;
-        return (g >= 0.12 && g < 0.234 && m >= -0.425 && m < -0.214 ? r : g >= 0.166 && g < 0.234 && m >= -0.214 && m < -0.115 ? o : n).invert(h);
-    }, u.stream = function(h) {
-        return e && t === h ? e : e = vW([n.stream(t = h), r.stream(h), o.stream(h)]);
-    }, u.precision = function(h) {
-        return arguments.length ? (n.precision(h), r.precision(h), o.precision(h), f()) : n.precision();
-    }, u.scale = function(h) {
-        return arguments.length ? (n.scale(h), r.scale(h * 0.35), o.scale(h), u.translate(n.translate())) : n.scale();
-    }, u.translate = function(h) {
+            y = (h[0] - p[0]) / d,
+            m = (h[1] - p[1]) / d;
+        return (m >= 0.12 && m < 0.234 && y >= -0.425 && y < -0.214 ? i : m >= 0.166 && m < 0.234 && y >= -0.214 && y < -0.115 ? o : n).invert(h);
+    }, l.stream = function(h) {
+        return e && t === h ? e : e = EU([n.stream(t = h), i.stream(h), o.stream(h)]);
+    }, l.precision = function(h) {
+        return arguments.length ? (n.precision(h), i.precision(h), o.precision(h), f()) : n.precision();
+    }, l.scale = function(h) {
+        return arguments.length ? (n.scale(h), i.scale(h * 0.35), o.scale(h), l.translate(n.translate())) : n.scale();
+    }, l.translate = function(h) {
         if (!arguments.length)
             return n.translate();
         var d = n.scale(),
             p = +h[0],
-            m = +h[1];
-        return i = n.translate(h).clipExtent([
-            [p - 0.455 * d, m - 0.238 * d],
-            [p + 0.455 * d, m + 0.238 * d]
-        ]).stream(l), s = r.translate([p - 0.307 * d, m + 0.201 * d]).clipExtent([
-            [p - 0.425 * d + wt, m + 0.12 * d + wt],
-            [p - 0.214 * d - wt, m + 0.234 * d - wt]
-        ]).stream(l), a = o.translate([p - 0.205 * d, m + 0.212 * d]).clipExtent([
-            [p - 0.214 * d + wt, m + 0.166 * d + wt],
-            [p - 0.115 * d - wt, m + 0.234 * d - wt]
-        ]).stream(l), f();
-    }, u.fitExtent = function(h, d) {
-        return cw(u, h, d);
-    }, u.fitSize = function(h, d) {
-        return S$(u, h, d);
-    }, u.fitWidth = function(h, d) {
-        return I$(u, h, d);
-    }, u.fitHeight = function(h, d) {
-        return A$(u, h, d);
+            y = +h[1];
+        return r = n.translate(h).clipExtent([
+            [p - 0.455 * d, y - 0.238 * d],
+            [p + 0.455 * d, y + 0.238 * d]
+        ]).stream(u), s = i.translate([p - 0.307 * d, y + 0.201 * d]).clipExtent([
+            [p - 0.425 * d + ut, y + 0.12 * d + ut],
+            [p - 0.214 * d - ut, y + 0.234 * d - ut]
+        ]).stream(u), a = o.translate([p - 0.205 * d, y + 0.212 * d]).clipExtent([
+            [p - 0.214 * d + ut, y + 0.166 * d + ut],
+            [p - 0.115 * d - ut, y + 0.234 * d - ut]
+        ]).stream(u), f();
+    }, l.fitExtent = function(h, d) {
+        return zm(l, h, d);
+    }, l.fitSize = function(h, d) {
+        return y3(l, h, d);
+    }, l.fitWidth = function(h, d) {
+        return m3(l, h, d);
+    }, l.fitHeight = function(h, d) {
+        return g3(l, h, d);
     };
 
     function f() {
-        return e = t = null, u;
+        return e = t = null, l;
     }
-    return u.scale(1070);
+    return l.scale(1070);
 }
 
-function T$(e) {
+function v3(e) {
     return function(t, n) {
-        var i = $t(t),
-            r = $t(n),
-            s = e(i * r);
+        var r = pt(t),
+            i = pt(n),
+            s = e(r * i);
         return s === 1 / 0 ? [2, 0] : [
-            s * r * ot(t),
-            s * ot(n)
+            s * i * et(t),
+            s * et(n)
         ];
     };
 }
 
-function xf(e) {
+function hu(e) {
     return function(t, n) {
-        var i = yn(t * t + n * n),
-            r = e(i),
-            s = ot(r),
-            o = $t(r);
+        var r = Ue(t * t + n * n),
+            i = e(r),
+            s = et(i),
+            o = pt(i);
         return [
-            Ti(t * s, i * o),
-            Dn(i && n * s / i)
+            Vn(t * s, r * o),
+            Ke(r && n * s / r)
         ];
     };
 }
-var D$ = T$(function(e) {
-    return yn(2 / (1 + e));
+var _3 = v3(function(e) {
+    return Ue(2 / (1 + e));
 });
-D$.invert = xf(function(e) {
-    return 2 * Dn(e / 2);
+_3.invert = hu(function(e) {
+    return 2 * Ke(e / 2);
 });
 
-function xW() {
-    return ao(D$).scale(124.75).clipAngle(180 - 1e-3);
+function DU() {
+    return Ki(_3).scale(124.75).clipAngle(180 - 1e-3);
 }
-var N$ = T$(function(e) {
-    return (e = i$(e)) && e / ot(e);
+var x3 = v3(function(e) {
+    return (e = HS(e)) && e / et(e);
 });
-N$.invert = xf(function(e) {
+x3.invert = hu(function(e) {
     return e;
 });
 
-function SW() {
-    return ao(N$).scale(79.4188).clipAngle(180 - 1e-3);
+function OU() {
+    return Ki(x3).scale(79.4188).clipAngle(180 - 1e-3);
 }
 
-function r0(e, t) {
-    return [e, cp(sw(($e + t) / 2))];
+function td(e, t) {
+    return [e, Rf(Cm((oe + t) / 2))];
 }
-r0.invert = function(e, t) {
-    return [e, 2 * sl(n$(t)) - $e];
+td.invert = function(e, t) {
+    return [e, 2 * ga(GS(t)) - oe];
 };
 
-function IW() {
-    return B$(r0).scale(961 / Vn);
+function LU() {
+    return S3(td).scale(961 / ln);
 }
 
-function B$(e) {
-    var t = ao(e),
+function S3(e) {
+    var t = Ki(e),
         n = t.center,
-        i = t.scale,
-        r = t.translate,
+        r = t.scale,
+        i = t.translate,
         s = t.clipExtent,
         o = null,
-        a, c, l;
+        a, c, u;
     t.scale = function(f) {
-        return arguments.length ? (i(f), u()) : i();
+        return arguments.length ? (r(f), l()) : r();
     }, t.translate = function(f) {
-        return arguments.length ? (r(f), u()) : r();
+        return arguments.length ? (i(f), l()) : i();
     }, t.center = function(f) {
-        return arguments.length ? (n(f), u()) : n();
+        return arguments.length ? (n(f), l()) : n();
     }, t.clipExtent = function(f) {
-        return arguments.length ? (f == null ? o = a = c = l = null : (o = +f[0][0], a = +f[0][1], c = +f[1][0], l = +f[1][1]), u()) : o == null ? null : [
+        return arguments.length ? (f == null ? o = a = c = u = null : (o = +f[0][0], a = +f[0][1], c = +f[1][0], u = +f[1][1]), l()) : o == null ? null : [
             [o, a],
-            [c, l]
+            [c, u]
         ];
     };
 
-    function u() {
-        var f = kt * i(),
-            h = t(jY(t.rotate()).invert([0, 0]));
+    function l() {
+        var f = Mt * r(),
+            h = t(KP(t.rotate()).invert([0, 0]));
         return s(o == null ? [
             [h[0] - f, h[1] - f],
             [h[0] + f, h[1] + f]
-        ] : e === r0 ? [
+        ] : e === td ? [
             [Math.max(h[0] - f, o), a],
-            [Math.min(h[0] + f, c), l]
+            [Math.min(h[0] + f, c), u]
         ] : [
             [o, Math.max(h[1] - f, a)],
-            [c, Math.min(h[1] + f, l)]
+            [c, Math.min(h[1] + f, u)]
         ]);
     }
-    return u();
+    return l();
 }
 
-function bh(e) {
-    return sw(($e + e) / 2);
+function rl(e) {
+    return Cm((oe + e) / 2);
 }
 
-function AW(e, t) {
-    var n = $t(e),
-        i = e === t ? ot(e) : cp(n / $t(t)) / cp(bh(t) / bh(e)),
-        r = n * _m(bh(e), i) / i;
-    if (!i)
-        return r0;
+function kU(e, t) {
+    var n = pt(e),
+        r = e === t ? et(e) : Rf(n / pt(t)) / Rf(rl(t) / rl(e)),
+        i = n * mp(rl(e), r) / r;
+    if (!r)
+        return td;
 
     function s(o, a) {
-        r > 0 ? a < -$e + wt && (a = -$e + wt) : a > $e - wt && (a = $e - wt);
-        var c = r / _m(bh(a), i);
-        return [c * ot(i * o), r - c * $t(i * o)];
+        i > 0 ? a < -oe + ut && (a = -oe + ut) : a > oe - ut && (a = oe - ut);
+        var c = i / mp(rl(a), r);
+        return [c * et(r * o), i - c * pt(r * o)];
     }
     return s.invert = function(o, a) {
-        var c = r - a,
-            l = ii(i) * yn(o * o + c * c),
-            u = Ti(o, Jt(c)) * ii(c);
-        return c * i < 0 && (u -= kt * ii(o) * ii(c)), [u / i, 2 * sl(_m(r / l, 1 / i)) - $e];
+        var c = i - a,
+            u = _n(r) * Ue(o * o + c * c),
+            l = Vn(o, Ft(c)) * _n(c);
+        return c * r < 0 && (l -= Mt * _n(o) * _n(c)), [l / r, 2 * ga(mp(i / u, 1 / r)) - oe];
     }, s;
 }
 
-function MW() {
-    return lw(AW).scale(109.5).parallels([30, 30]);
+function RU() {
+    return qm(kU).scale(109.5).parallels([30, 30]);
 }
 
-function Mp(e, t) {
+function Qf(e, t) {
     return [e, t];
 }
-Mp.invert = Mp;
+Qf.invert = Qf;
 
-function $W() {
-    return ao(Mp).scale(152.63);
+function FU() {
+    return Ki(Qf).scale(152.63);
 }
 
-function TW(e, t) {
-    var n = $t(e),
-        i = e === t ? ot(e) : (n - $t(t)) / (t - e),
-        r = n / i + e;
-    if (Jt(i) < wt)
-        return Mp;
+function BU(e, t) {
+    var n = pt(e),
+        r = e === t ? et(e) : (n - pt(t)) / (t - e),
+        i = n / r + e;
+    if (Ft(r) < ut)
+        return Qf;
 
     function s(o, a) {
-        var c = r - a,
-            l = i * o;
-        return [c * ot(l), r - c * $t(l)];
+        var c = i - a,
+            u = r * o;
+        return [c * et(u), i - c * pt(u)];
     }
     return s.invert = function(o, a) {
-        var c = r - a,
-            l = Ti(o, Jt(c)) * ii(c);
-        return c * i < 0 && (l -= kt * ii(o) * ii(c)), [l / i, r - ii(i) * yn(o * o + c * c)];
+        var c = i - a,
+            u = Vn(o, Ft(c)) * _n(c);
+        return c * r < 0 && (u -= Mt * _n(o) * _n(c)), [u / r, i - _n(r) * Ue(o * o + c * c)];
     }, s;
 }
 
-function DW() {
-    return lw(TW).scale(131.154).center([0, 13.9389]);
+function CU() {
+    return qm(BU).scale(131.154).center([0, 13.9389]);
 }
-var fu = 1.340264,
-    hu = -0.081106,
-    du = 893e-6,
-    pu = 3796e-6,
-    $p = yn(3) / 2,
-    NW = 12;
-
-function O$(e, t) {
-    var n = Dn($p * ot(t)),
-        i = n * n,
-        r = i * i * i;
+var cc = 1.340264,
+    uc = -0.081106,
+    lc = 893e-6,
+    fc = 3796e-6,
+    th = Ue(3) / 2,
+    PU = 12;
+
+function M3(e, t) {
+    var n = Ke(th * et(t)),
+        r = n * n,
+        i = r * r * r;
     return [
-        e * $t(n) / ($p * (fu + 3 * hu * i + r * (7 * du + 9 * pu * i))),
-        n * (fu + hu * i + r * (du + pu * i))
+        e * pt(n) / (th * (cc + 3 * uc * r + i * (7 * lc + 9 * fc * r))),
+        n * (cc + uc * r + i * (lc + fc * r))
     ];
 }
-O$.invert = function(e, t) {
-    for (var n = t, i = n * n, r = i * i * i, s = 0, o, a, c; s < NW && (a = n * (fu + hu * i + r * (du + pu * i)) - t, c = fu + 3 * hu * i + r * (7 * du + 9 * pu * i), n -= o = a / c, i = n * n, r = i * i * i, !(Jt(o) < ap)); ++s)
+M3.invert = function(e, t) {
+    for (var n = t, r = n * n, i = r * r * r, s = 0, o, a, c; s < PU && (a = n * (cc + uc * r + i * (lc + fc * r)) - t, c = cc + 3 * uc * r + i * (7 * lc + 9 * fc * r), n -= o = a / c, r = n * n, i = r * r * r, !(Ft(o) < kf)); ++s)
     ;
     return [
-        $p * e * (fu + 3 * hu * i + r * (7 * du + 9 * pu * i)) / $t(n),
-        Dn(ot(n) / $p)
+        th * e * (cc + 3 * uc * r + i * (7 * lc + 9 * fc * r)) / pt(n),
+        Ke(et(n) / th)
     ];
 };
 
-function BW() {
-    return ao(O$).scale(177.158);
+function UU() {
+    return Ki(M3).scale(177.158);
 }
 
-function F$(e, t) {
-    var n = $t(t),
-        i = $t(e) * n;
-    return [n * ot(e) / i, ot(t) / i];
+function A3(e, t) {
+    var n = pt(t),
+        r = pt(e) * n;
+    return [n * et(e) / r, et(t) / r];
 }
-F$.invert = xf(sl);
+A3.invert = hu(ga);
 
-function OW() {
-    return ao(F$).scale(144.049).clipAngle(60);
+function zU() {
+    return Ki(A3).scale(144.049).clipAngle(60);
 }
 
-function E$(e, t) {
-    return [$t(t) * ot(e), ot(t)];
+function $3(e, t) {
+    return [pt(t) * et(e), et(t)];
 }
-E$.invert = xf(Dn);
+$3.invert = hu(Ke);
 
-function FW() {
-    return ao(E$).scale(249.5).clipAngle(90 + wt);
+function qU() {
+    return Ki($3).scale(249.5).clipAngle(90 + ut);
 }
 
-function L$(e, t) {
-    var n = $t(t),
-        i = 1 + $t(e) * n;
-    return [n * ot(e) / i, ot(t) / i];
+function I3(e, t) {
+    var n = pt(t),
+        r = 1 + pt(e) * n;
+    return [n * et(e) / r, et(t) / r];
 }
-L$.invert = xf(function(e) {
-    return 2 * sl(e);
+I3.invert = hu(function(e) {
+    return 2 * ga(e);
 });
 
-function EW() {
-    return ao(L$).scale(250).clipAngle(142);
+function jU() {
+    return Ki(I3).scale(250).clipAngle(142);
 }
 
-function R$(e, t) {
-    return [cp(sw(($e + t) / 2)), -e];
+function T3(e, t) {
+    return [Rf(Cm((oe + t) / 2)), -e];
 }
-R$.invert = function(e, t) {
-    return [-t, 2 * sl(n$(e)) - $e];
+T3.invert = function(e, t) {
+    return [-t, 2 * ga(GS(e)) - oe];
 };
 
-function LW() {
-    var e = B$(R$),
+function VU() {
+    var e = S3(T3),
         t = e.center,
         n = e.rotate;
-    return e.center = function(i) {
-        return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]]);
-    }, e.rotate = function(i) {
-        return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90]);
+    return e.center = function(r) {
+        return arguments.length ? t([-r[1], r[0]]) : (r = t(), [r[1], -r[0]]);
+    }, e.rotate = function(r) {
+        return arguments.length ? n([r[0], r[1], r.length > 2 ? r[2] + 90 : 90]) : (r = n(), [r[0], r[1], r[2] - 90]);
     }, n([0, 0, 90]).scale(159.155);
 }
 
-function RW(e, t) {
+function YU(e, t) {
     return e.parent === t.parent ? 1 : 2;
 }
 
-function CW(e) {
-    return e.reduce(kW, 0) / e.length;
+function WU(e) {
+    return e.reduce(XU, 0) / e.length;
 }
 
-function kW(e, t) {
+function XU(e, t) {
     return e + t.x;
 }
 
-function UW(e) {
-    return 1 + e.reduce(zW, 0);
+function GU(e) {
+    return 1 + e.reduce(HU, 0);
 }
 
-function zW(e, t) {
+function HU(e, t) {
     return Math.max(e, t.y);
 }
 
-function PW(e) {
+function JU(e) {
     for (var t; t = e.children;)
         e = t[0];
     return e;
 }
 
-function VW(e) {
+function ZU(e) {
     for (var t; t = e.children;)
         e = t[t.length - 1];
     return e;
 }
 
-function C$() {
-    var e = RW,
+function E3() {
+    var e = YU,
         t = 1,
         n = 1,
-        i = !1;
+        r = !1;
 
-    function r(s) {
+    function i(s) {
         var o, a = 0;
         s.eachAfter(function(h) {
             var d = h.children;
-            d ? (h.x = CW(d), h.y = UW(d)) : (h.x = o ? a += e(h, o) : 0, h.y = 0, o = h);
+            d ? (h.x = WU(d), h.y = GU(d)) : (h.x = o ? a += e(h, o) : 0, h.y = 0, o = h);
         });
-        var c = PW(s),
-            l = VW(s),
-            u = c.x - e(c, l) / 2,
-            f = l.x + e(l, c) / 2;
-        return s.eachAfter(i ? function(h) {
+        var c = JU(s),
+            u = ZU(s),
+            l = c.x - e(c, u) / 2,
+            f = u.x + e(u, c) / 2;
+        return s.eachAfter(r ? function(h) {
             h.x = (h.x - s.x) * t, h.y = (s.y - h.y) * n;
         } : function(h) {
-            h.x = (h.x - u) / (f - u) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n;
+            h.x = (h.x - l) / (f - l) * t, h.y = (1 - (s.y ? h.y / s.y : 1)) * n;
         });
     }
-    return r.separation = function(s) {
-        return arguments.length ? (e = s, r) : e;
-    }, r.size = function(s) {
-        return arguments.length ? (i = !1, t = +s[0], n = +s[1], r) : i ? null : [t, n];
-    }, r.nodeSize = function(s) {
-        return arguments.length ? (i = !0, t = +s[0], n = +s[1], r) : i ? [t, n] : null;
-    }, r;
+    return i.separation = function(s) {
+        return arguments.length ? (e = s, i) : e;
+    }, i.size = function(s) {
+        return arguments.length ? (r = !1, t = +s[0], n = +s[1], i) : r ? null : [t, n];
+    }, i.nodeSize = function(s) {
+        return arguments.length ? (r = !0, t = +s[0], n = +s[1], i) : r ? [t, n] : null;
+    }, i;
 }
 
-function jW(e) {
+function KU(e) {
     var t = 0,
         n = e.children,
-        i = n && n.length;
-    if (!i)
+        r = n && n.length;
+    if (!r)
         t = 1;
     else
-        for (; --i >= 0;)
-            t += n[i].value;
+        for (; --r >= 0;)
+            t += n[r].value;
     e.value = t;
 }
 
-function qW() {
-    return this.eachAfter(jW);
+function QU() {
+    return this.eachAfter(KU);
 }
 
-function YW(e, t) {
+function tz(e, t) {
     let n = -1;
-    for (const i of this)
-        e.call(t, i, ++n, this);
+    for (const r of this)
+        e.call(t, r, ++n, this);
     return this;
 }
 
-function WW(e, t) {
-    for (var n = this, i = [n], r, s, o = -1; n = i.pop();)
-        if (e.call(t, n, ++o, this), r = n.children)
-            for (s = r.length - 1; s >= 0; --s)
-                i.push(r[s]);
+function ez(e, t) {
+    for (var n = this, r = [n], i, s, o = -1; n = r.pop();)
+        if (e.call(t, n, ++o, this), i = n.children)
+            for (s = i.length - 1; s >= 0; --s)
+                r.push(i[s]);
     return this;
 }
 
-function GW(e, t) {
-    for (var n = this, i = [n], r = [], s, o, a, c = -1; n = i.pop();)
-        if (r.push(n), s = n.children)
+function nz(e, t) {
+    for (var n = this, r = [n], i = [], s, o, a, c = -1; n = r.pop();)
+        if (i.push(n), s = n.children)
             for (o = 0, a = s.length; o < a; ++o)
-                i.push(s[o]);
-    for (; n = r.pop();)
+                r.push(s[o]);
+    for (; n = i.pop();)
         e.call(t, n, ++c, this);
     return this;
 }
 
-function XW(e, t) {
+function rz(e, t) {
     let n = -1;
-    for (const i of this)
-        if (e.call(t, i, ++n, this))
-            return i;
+    for (const r of this)
+        if (e.call(t, r, ++n, this))
+            return r;
 }
 
-function HW(e) {
+function iz(e) {
     return this.eachAfter(function(t) {
-        for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0;)
-            n += i[r].value;
+        for (var n = +e(t.data) || 0, r = t.children, i = r && r.length; --i >= 0;)
+            n += r[i].value;
         t.value = n;
     });
 }
 
-function JW(e) {
+function sz(e) {
     return this.eachBefore(function(t) {
         t.children && t.children.sort(e);
     });
 }
 
-function KW(e) {
-    for (var t = this, n = ZW(t, e), i = [t]; t !== n;)
-        t = t.parent, i.push(t);
-    for (var r = i.length; e !== n;)
-        i.splice(r, 0, e), e = e.parent;
-    return i;
+function oz(e) {
+    for (var t = this, n = az(t, e), r = [t]; t !== n;)
+        t = t.parent, r.push(t);
+    for (var i = r.length; e !== n;)
+        r.splice(i, 0, e), e = e.parent;
+    return r;
 }
 
-function ZW(e, t) {
+function az(e, t) {
     if (e === t)
         return e;
     var n = e.ancestors(),
-        i = t.ancestors(),
-        r = null;
-    for (e = n.pop(), t = i.pop(); e === t;)
-        r = e, e = n.pop(), t = i.pop();
-    return r;
+        r = t.ancestors(),
+        i = null;
+    for (e = n.pop(), t = r.pop(); e === t;)
+        i = e, e = n.pop(), t = r.pop();
+    return i;
 }
 
-function QW() {
+function cz() {
     for (var e = this, t = [e]; e = e.parent;)
         t.push(e);
     return t;
 }
 
-function tG() {
+function uz() {
     return Array.from(this);
 }
 
-function eG() {
+function lz() {
     var e = [];
     return this.eachBefore(function(t) {
         t.children || e.push(t);
     }), e;
 }
 
-function nG() {
+function fz() {
     var e = this,
         t = [];
     return e.each(function(n) {
         n !== e && t.push({
             source: n.parent,
             target: n
         });
     }), t;
 }
 
-function* iG() {
+function* hz() {
     var e = this,
         t, n = [e],
-        i, r, s;
+        r, i, s;
     do
         for (t = n.reverse(), n = []; e = t.pop();)
-            if (yield e, i = e.children)
-                for (r = 0, s = i.length; r < s; ++r)
-                    n.push(i[r]);
+            if (yield e, r = e.children)
+                for (i = 0, s = r.length; i < s; ++i)
+                    n.push(r[i]);
     while (n.length);
 }
 
-function k$(e, t) {
-    e instanceof Map ? (e = [void 0, e], t === void 0 && (t = oG)) : t === void 0 && (t = sG);
-    for (var n = new Lc(e), i, r = [n], s, o, a, c; i = r.pop();)
-        if ((o = t(i.data)) && (c = (o = Array.from(o)).length))
-            for (i.children = o, a = c - 1; a >= 0; --a)
-                r.push(s = o[a] = new Lc(o[a])), s.parent = i, s.depth = i.depth + 1;
-    return n.eachBefore(U$);
+function N3(e, t) {
+    e instanceof Map ? (e = [void 0, e], t === void 0 && (t = yz)) : t === void 0 && (t = pz);
+    for (var n = new Zo(e), r, i = [n], s, o, a, c; r = i.pop();)
+        if ((o = t(r.data)) && (c = (o = Array.from(o)).length))
+            for (r.children = o, a = c - 1; a >= 0; --a)
+                i.push(s = o[a] = new Zo(o[a])), s.parent = r, s.depth = r.depth + 1;
+    return n.eachBefore(D3);
 }
 
-function rG() {
-    return k$(this).eachBefore(aG);
+function dz() {
+    return N3(this).eachBefore(mz);
 }
 
-function sG(e) {
+function pz(e) {
     return e.children;
 }
 
-function oG(e) {
+function yz(e) {
     return Array.isArray(e) ? e[1] : null;
 }
 
-function aG(e) {
+function mz(e) {
     e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
 }
 
-function U$(e) {
+function D3(e) {
     var t = 0;
     do
         e.height = t;
     while ((e = e.parent) && e.height < ++t);
 }
 
-function Lc(e) {
+function Zo(e) {
     this.data = e, this.depth = this.height = 0, this.parent = null;
 }
-Lc.prototype = k$.prototype = {
-    constructor: Lc,
-    count: qW,
-    each: YW,
-    eachAfter: GW,
-    eachBefore: WW,
-    find: XW,
-    sum: HW,
-    sort: JW,
-    path: KW,
-    ancestors: QW,
-    descendants: tG,
-    leaves: eG,
-    links: nG,
-    copy: rG,
-    [Symbol.iterator]: iG
+Zo.prototype = N3.prototype = {
+    constructor: Zo,
+    count: QU,
+    each: tz,
+    eachAfter: nz,
+    eachBefore: ez,
+    find: rz,
+    sum: iz,
+    sort: sz,
+    path: oz,
+    ancestors: cz,
+    descendants: uz,
+    leaves: lz,
+    links: fz,
+    copy: dz,
+    [Symbol.iterator]: hz
 };
 
-function Mm(e) {
-    return e == null ? null : cG(e);
+function _p(e) {
+    return e == null ? null : gz(e);
 }
 
-function cG(e) {
+function gz(e) {
     if (typeof e != "function")
         throw new Error();
     return e;
 }
-var lG = {
+var bz = {
         depth: -1
     },
-    yx = {},
-    $m = {};
+    Dw = {},
+    xp = {};
 
-function uG(e) {
+function wz(e) {
     return e.id;
 }
 
-function fG(e) {
+function vz(e) {
     return e.parentId;
 }
 
-function z$() {
-    var e = uG,
-        t = fG,
+function O3() {
+    var e = wz,
+        t = vz,
         n;
 
-    function i(r) {
-        var s = Array.from(r),
+    function r(i) {
+        var s = Array.from(i),
             o = e,
             a = t,
-            c, l, u, f, h, d, p, m, g = /* @__PURE__ */ new Map();
+            c, u, l, f, h, d, p, y, m = /* @__PURE__ */ new Map();
         if (n != null) {
-            const y = s.map((v, x) => hG(n(v, x, r))),
-                b = y.map(mx),
-                w = new Set(y).add("");
+            const g = s.map((v, x) => _z(n(v, x, i))),
+                b = g.map(Ow),
+                w = new Set(g).add("");
             for (const v of b)
-                w.has(v) || (w.add(v), y.push(v), b.push(mx(v)), s.push($m));
-            o = (v, x) => y[x], a = (v, x) => b[x];
+                w.has(v) || (w.add(v), g.push(v), b.push(Ow(v)), s.push(xp));
+            o = (v, x) => g[x], a = (v, x) => b[x];
         }
-        for (u = 0, c = s.length; u < c; ++u)
-            l = s[u], d = s[u] = new Lc(l), (p = o(l, u, r)) != null && (p += "") && (m = d.id = p, g.set(m, g.has(m) ? yx : d)), (p = a(l, u, r)) != null && (p += "") && (d.parent = p);
-        for (u = 0; u < c; ++u)
-            if (d = s[u], p = d.parent) {
-                if (h = g.get(p), !h)
+        for (l = 0, c = s.length; l < c; ++l)
+            u = s[l], d = s[l] = new Zo(u), (p = o(u, l, i)) != null && (p += "") && (y = d.id = p, m.set(y, m.has(y) ? Dw : d)), (p = a(u, l, i)) != null && (p += "") && (d.parent = p);
+        for (l = 0; l < c; ++l)
+            if (d = s[l], p = d.parent) {
+                if (h = m.get(p), !h)
                     throw new Error("missing: " + p);
-                if (h === yx)
+                if (h === Dw)
                     throw new Error("ambiguous: " + p);
                 h.children ? h.children.push(d) : h.children = [d], d.parent = h;
             } else {
                 if (f)
                     throw new Error("multiple roots");
                 f = d;
             }
         if (!f)
             throw new Error("no root");
         if (n != null) {
-            for (; f.data === $m && f.children.length === 1;)
+            for (; f.data === xp && f.children.length === 1;)
                 f = f.children[0], --c;
-            for (let y = s.length - 1; y >= 0 && (d = s[y], d.data === $m); --y)
+            for (let g = s.length - 1; g >= 0 && (d = s[g], d.data === xp); --g)
                 d.data = null;
         }
-        if (f.parent = lG, f.eachBefore(function(y) {
-                y.depth = y.parent.depth + 1, --c;
-            }).eachBefore(U$), f.parent = null, c > 0)
+        if (f.parent = bz, f.eachBefore(function(g) {
+                g.depth = g.parent.depth + 1, --c;
+            }).eachBefore(D3), f.parent = null, c > 0)
             throw new Error("cycle");
         return f;
     }
-    return i.id = function(r) {
-        return arguments.length ? (e = Mm(r), i) : e;
-    }, i.parentId = function(r) {
-        return arguments.length ? (t = Mm(r), i) : t;
-    }, i.path = function(r) {
-        return arguments.length ? (n = Mm(r), i) : n;
-    }, i;
+    return r.id = function(i) {
+        return arguments.length ? (e = _p(i), r) : e;
+    }, r.parentId = function(i) {
+        return arguments.length ? (t = _p(i), r) : t;
+    }, r.path = function(i) {
+        return arguments.length ? (n = _p(i), r) : n;
+    }, r;
 }
 
-function hG(e) {
+function _z(e) {
     e = `${e}`;
     let t = e.length;
-    return b1(e, t - 1) && !b1(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
+    return oy(e, t - 1) && !oy(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
 }
 
-function mx(e) {
+function Ow(e) {
     let t = e.length;
     if (t < 2)
         return "";
-    for (; --t > 1 && !b1(e, t);)
+    for (; --t > 1 && !oy(e, t);)
     ;
     return e.slice(0, t);
 }
 
-function b1(e, t) {
+function oy(e, t) {
     if (e[t] === "/") {
         let n = 0;
         for (; t > 0 && e[--t] === "\\";)
             ++n;
         if (!(n & 1))
             return !0;
     }
     return !1;
 }
 
-function dG(e, t) {
+function xz(e, t) {
     return e.parent === t.parent ? 1 : 2;
 }
 
-function Tm(e) {
+function Sp(e) {
     var t = e.children;
     return t ? t[0] : e.t;
 }
 
-function Dm(e) {
+function Mp(e) {
     var t = e.children;
     return t ? t[t.length - 1] : e.t;
 }
 
-function pG(e, t, n) {
-    var i = n / (t.i - e.i);
-    t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n;
+function Sz(e, t, n) {
+    var r = n / (t.i - e.i);
+    t.c -= r, t.s += n, e.c += r, t.z += n, t.m += n;
 }
 
-function yG(e) {
-    for (var t = 0, n = 0, i = e.children, r = i.length, s; --r >= 0;)
-        s = i[r], s.z += t, s.m += t, t += s.s + (n += s.c);
+function Mz(e) {
+    for (var t = 0, n = 0, r = e.children, i = r.length, s; --i >= 0;)
+        s = r[i], s.z += t, s.m += t, t += s.s + (n += s.c);
 }
 
-function mG(e, t, n) {
+function Az(e, t, n) {
     return e.a.parent === t.parent ? e.a : n;
 }
 
-function sd(e, t) {
+function Pl(e, t) {
     this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
 }
-sd.prototype = Object.create(Lc.prototype);
+Pl.prototype = Object.create(Zo.prototype);
 
-function gG(e) {
-    for (var t = new sd(e, 0), n, i = [t], r, s, o, a; n = i.pop();)
+function $z(e) {
+    for (var t = new Pl(e, 0), n, r = [t], i, s, o, a; n = r.pop();)
         if (s = n._.children)
             for (n.children = new Array(a = s.length), o = a - 1; o >= 0; --o)
-                i.push(r = n.children[o] = new sd(s[o], o)), r.parent = n;
-    return (t.parent = new sd(null, 0)).children = [t], t;
+                r.push(i = n.children[o] = new Pl(s[o], o)), i.parent = n;
+    return (t.parent = new Pl(null, 0)).children = [t], t;
 }
 
-function Tp() {
-    var e = dG,
+function eh() {
+    var e = xz,
         t = 1,
         n = 1,
-        i = null;
+        r = null;
 
-    function r(l) {
-        var u = gG(l);
-        if (u.eachAfter(s), u.parent.m = -u.z, u.eachBefore(o), i)
-            l.eachBefore(c);
+    function i(u) {
+        var l = $z(u);
+        if (l.eachAfter(s), l.parent.m = -l.z, l.eachBefore(o), r)
+            u.eachBefore(c);
         else {
-            var f = l,
-                h = l,
-                d = l;
-            l.eachBefore(function(b) {
+            var f = u,
+                h = u,
+                d = u;
+            u.eachBefore(function(b) {
                 b.x < f.x && (f = b), b.x > h.x && (h = b), b.depth > d.depth && (d = b);
             });
             var p = f === h ? 1 : e(f, h) / 2,
-                m = p - f.x,
-                g = t / (h.x + p + m),
-                y = n / (d.depth || 1);
-            l.eachBefore(function(b) {
-                b.x = (b.x + m) * g, b.y = b.depth * y;
+                y = p - f.x,
+                m = t / (h.x + p + y),
+                g = n / (d.depth || 1);
+            u.eachBefore(function(b) {
+                b.x = (b.x + y) * m, b.y = b.depth * g;
             });
         }
-        return l;
+        return u;
     }
 
-    function s(l) {
-        var u = l.children,
-            f = l.parent.children,
-            h = l.i ? f[l.i - 1] : null;
-        if (u) {
-            yG(l);
-            var d = (u[0].z + u[u.length - 1].z) / 2;
-            h ? (l.z = h.z + e(l._, h._), l.m = l.z - d) : l.z = d;
+    function s(u) {
+        var l = u.children,
+            f = u.parent.children,
+            h = u.i ? f[u.i - 1] : null;
+        if (l) {
+            Mz(u);
+            var d = (l[0].z + l[l.length - 1].z) / 2;
+            h ? (u.z = h.z + e(u._, h._), u.m = u.z - d) : u.z = d;
         } else
-            h && (l.z = h.z + e(l._, h._));
-        l.parent.A = a(l, h, l.parent.A || f[0]);
+            h && (u.z = h.z + e(u._, h._));
+        u.parent.A = a(u, h, u.parent.A || f[0]);
     }
 
-    function o(l) {
-        l._.x = l.z + l.parent.m, l.m += l.parent.m;
+    function o(u) {
+        u._.x = u.z + u.parent.m, u.m += u.parent.m;
     }
 
-    function a(l, u, f) {
-        if (u) {
-            for (var h = l, d = l, p = u, m = h.parent.children[0], g = h.m, y = d.m, b = p.m, w = m.m, v; p = Dm(p), h = Tm(h), p && h;)
-                m = Tm(m), d = Dm(d), d.a = l, v = p.z + b - h.z - g + e(p._, h._), v > 0 && (pG(mG(p, l, f), l, v), g += v, y += v), b += p.m, g += h.m, w += m.m, y += d.m;
-            p && !Dm(d) && (d.t = p, d.m += b - y), h && !Tm(m) && (m.t = h, m.m += g - w, f = l);
+    function a(u, l, f) {
+        if (l) {
+            for (var h = u, d = u, p = l, y = h.parent.children[0], m = h.m, g = d.m, b = p.m, w = y.m, v; p = Mp(p), h = Sp(h), p && h;)
+                y = Sp(y), d = Mp(d), d.a = u, v = p.z + b - h.z - m + e(p._, h._), v > 0 && (Sz(Az(p, u, f), u, v), m += v, g += v), b += p.m, m += h.m, w += y.m, g += d.m;
+            p && !Mp(d) && (d.t = p, d.m += b - g), h && !Sp(y) && (y.t = h, y.m += m - w, f = u);
         }
         return f;
     }
 
-    function c(l) {
-        l.x *= t, l.y = l.depth * n;
+    function c(u) {
+        u.x *= t, u.y = u.depth * n;
     }
-    return r.separation = function(l) {
-        return arguments.length ? (e = l, r) : e;
-    }, r.size = function(l) {
-        return arguments.length ? (i = !1, t = +l[0], n = +l[1], r) : i ? null : [t, n];
-    }, r.nodeSize = function(l) {
-        return arguments.length ? (i = !0, t = +l[0], n = +l[1], r) : i ? [t, n] : null;
-    }, r;
+    return i.separation = function(u) {
+        return arguments.length ? (e = u, i) : e;
+    }, i.size = function(u) {
+        return arguments.length ? (r = !1, t = +u[0], n = +u[1], i) : r ? null : [t, n];
+    }, i.nodeSize = function(u) {
+        return arguments.length ? (r = !0, t = +u[0], n = +u[1], i) : r ? [t, n] : null;
+    }, i;
 }
-const bG = 1664525,
-    wG = 1013904223,
-    gx = 1 / 4294967296;
+const Iz = 1664525,
+    Tz = 1013904223,
+    Lw = 1 / 4294967296;
 
-function Sf(e = Math.random()) {
-    let t = (0 <= e && e < 1 ? e / gx : Math.abs(e)) | 0;
-    return () => (t = bG * t + wG | 0, gx * (t >>> 0));
+function jm(e = Math.random()) {
+    let t = (0 <= e && e < 1 ? e / Lw : Math.abs(e)) | 0;
+    return () => (t = Iz * t + Tz | 0, Lw * (t >>> 0));
 }
 
-function br(e, t) {
+function Mr(e, t) {
     switch (arguments.length) {
         case 0:
             break;
         case 1:
             this.range(e);
             break;
         default:
             this.range(t).domain(e);
             break;
     }
     return this;
 }
 
-function s0(e, t) {
+function ed(e, t) {
     switch (arguments.length) {
         case 0:
             break;
         case 1: {
             typeof e == "function" ? this.interpolator(e) : this.range(e);
             break;
         }
         default: {
             this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
             break;
         }
     }
     return this;
 }
-const w1 = Symbol("implicit");
+const ay = Symbol("implicit");
 
-function uw() {
-    var e = new Jo(),
+function Vm() {
+    var e = new Ts(),
         t = [],
         n = [],
-        i = w1;
+        r = ay;
 
-    function r(s) {
+    function i(s) {
         let o = e.get(s);
         if (o === void 0) {
-            if (i !== w1)
-                return i;
+            if (r !== ay)
+                return r;
             e.set(s, o = t.push(s) - 1);
         }
         return n[o % n.length];
     }
-    return r.domain = function(s) {
+    return i.domain = function(s) {
         if (!arguments.length)
             return t.slice();
-        t = [], e = new Jo();
+        t = [], e = new Ts();
         for (const o of s)
             e.has(o) || e.set(o, t.push(o) - 1);
-        return r;
-    }, r.range = function(s) {
-        return arguments.length ? (n = Array.from(s), r) : n.slice();
-    }, r.unknown = function(s) {
-        return arguments.length ? (i = s, r) : i;
-    }, r.copy = function() {
-        return uw(t, n).unknown(i);
-    }, br.apply(r, arguments), r;
+        return i;
+    }, i.range = function(s) {
+        return arguments.length ? (n = Array.from(s), i) : n.slice();
+    }, i.unknown = function(s) {
+        return arguments.length ? (r = s, i) : r;
+    }, i.copy = function() {
+        return Vm(t, n).unknown(r);
+    }, Mr.apply(i, arguments), i;
 }
 
-function o0() {
-    var e = uw().unknown(void 0),
+function nd() {
+    var e = Vm().unknown(void 0),
         t = e.domain,
         n = e.range,
-        i = 0,
-        r = 1,
+        r = 0,
+        i = 1,
         s, o, a = !1,
         c = 0,
-        l = 0,
-        u = 0.5;
+        u = 0,
+        l = 0.5;
     delete e.unknown;
 
     function f() {
         var h = t().length,
-            d = r < i,
-            p = d ? r : i,
-            m = d ? i : r;
-        s = (m - p) / Math.max(1, h - c + l * 2), a && (s = Math.floor(s)), p += (m - p - s * (h - c)) * u, o = s * (1 - c), a && (p = Math.round(p), o = Math.round(o));
-        var g = Cn(h).map(function(y) {
-            return p + s * y;
+            d = i < r,
+            p = d ? i : r,
+            y = d ? r : i;
+        s = (y - p) / Math.max(1, h - c + u * 2), a && (s = Math.floor(s)), p += (y - p - s * (h - c)) * l, o = s * (1 - c), a && (p = Math.round(p), o = Math.round(o));
+        var m = sn(h).map(function(g) {
+            return p + s * g;
         });
-        return n(d ? g.reverse() : g);
+        return n(d ? m.reverse() : m);
     }
     return e.domain = function(h) {
         return arguments.length ? (t(h), f()) : t();
     }, e.range = function(h) {
-        return arguments.length ? ([i, r] = h, i = +i, r = +r, f()) : [i, r];
+        return arguments.length ? ([r, i] = h, r = +r, i = +i, f()) : [r, i];
     }, e.rangeRound = function(h) {
-        return [i, r] = h, i = +i, r = +r, a = !0, f();
+        return [r, i] = h, r = +r, i = +i, a = !0, f();
     }, e.bandwidth = function() {
         return o;
     }, e.step = function() {
         return s;
     }, e.round = function(h) {
         return arguments.length ? (a = !!h, f()) : a;
     }, e.padding = function(h) {
-        return arguments.length ? (c = Math.min(1, l = +h), f()) : c;
+        return arguments.length ? (c = Math.min(1, u = +h), f()) : c;
     }, e.paddingInner = function(h) {
         return arguments.length ? (c = Math.min(1, h), f()) : c;
     }, e.paddingOuter = function(h) {
-        return arguments.length ? (l = +h, f()) : l;
+        return arguments.length ? (u = +h, f()) : u;
     }, e.align = function(h) {
-        return arguments.length ? (u = Math.max(0, Math.min(1, h)), f()) : u;
+        return arguments.length ? (l = Math.max(0, Math.min(1, h)), f()) : l;
     }, e.copy = function() {
-        return o0(t(), [i, r]).round(a).paddingInner(c).paddingOuter(l).align(u);
-    }, br.apply(f(), arguments);
+        return nd(t(), [r, i]).round(a).paddingInner(c).paddingOuter(u).align(l);
+    }, Mr.apply(f(), arguments);
 }
 
-function P$(e) {
+function L3(e) {
     var t = e.copy;
     return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
-        return P$(t());
+        return L3(t());
     }, e;
 }
 
-function vG() {
-    return P$(o0.apply(null, arguments).paddingInner(1));
+function Ez() {
+    return L3(nd.apply(null, arguments).paddingInner(1));
 }
 
-function _G(e) {
+function Nz(e) {
     return function() {
         return e;
     };
 }
 
-function v1(e) {
+function cy(e) {
     return +e;
 }
-var bx = [0, 1];
+var kw = [0, 1];
 
-function ri(e) {
+function xn(e) {
     return e;
 }
 
-function _1(e, t) {
+function uy(e, t) {
     return (t -= e = +e) ? function(n) {
         return (n - e) / t;
-    } : _G(isNaN(t) ? NaN : 0.5);
+    } : Nz(isNaN(t) ? NaN : 0.5);
 }
 
-function xG(e, t) {
+function Dz(e, t) {
     var n;
     return e > t && (n = e, e = t, t = n),
-        function(i) {
-            return Math.max(e, Math.min(t, i));
+        function(r) {
+            return Math.max(e, Math.min(t, r));
         };
 }
 
-function SG(e, t, n) {
-    var i = e[0],
-        r = e[1],
+function Oz(e, t, n) {
+    var r = e[0],
+        i = e[1],
         s = t[0],
         o = t[1];
-    return r < i ? (i = _1(r, i), s = n(o, s)) : (i = _1(i, r), s = n(s, o)),
+    return i < r ? (r = uy(i, r), s = n(o, s)) : (r = uy(r, i), s = n(s, o)),
         function(a) {
-            return s(i(a));
+            return s(r(a));
         };
 }
 
-function IG(e, t, n) {
-    var i = Math.min(e.length, t.length) - 1,
-        r = new Array(i),
-        s = new Array(i),
+function Lz(e, t, n) {
+    var r = Math.min(e.length, t.length) - 1,
+        i = new Array(r),
+        s = new Array(r),
         o = -1;
-    for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++o < i;)
-        r[o] = _1(e[o], e[o + 1]), s[o] = n(t[o], t[o + 1]);
+    for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++o < r;)
+        i[o] = uy(e[o], e[o + 1]), s[o] = n(t[o], t[o + 1]);
     return function(a) {
-        var c = Wy(e, a, 1, i) - 1;
-        return s[c](r[c](a));
+        var c = qh(e, a, 1, r) - 1;
+        return s[c](i[c](a));
     };
 }
 
-function If(e, t) {
+function du(e, t) {
     return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
 }
 
-function a0() {
-    var e = bx,
-        t = bx,
-        n = il,
-        i, r, s, o = ri,
-        a, c, l;
+function rd() {
+    var e = kw,
+        t = kw,
+        n = ya,
+        r, i, s, o = xn,
+        a, c, u;
 
-    function u() {
+    function l() {
         var h = Math.min(e.length, t.length);
-        return o !== ri && (o = xG(e[0], e[h - 1])), a = h > 2 ? IG : SG, c = l = null, f;
+        return o !== xn && (o = Dz(e[0], e[h - 1])), a = h > 2 ? Lz : Oz, c = u = null, f;
     }
 
     function f(h) {
-        return h == null || isNaN(h = +h) ? s : (c || (c = a(e.map(i), t, n)))(i(o(h)));
+        return h == null || isNaN(h = +h) ? s : (c || (c = a(e.map(r), t, n)))(r(o(h)));
     }
     return f.invert = function(h) {
-            return o(r((l || (l = a(t, e.map(i), Qe)))(h)));
+            return o(i((u || (u = a(t, e.map(r), Te)))(h)));
         }, f.domain = function(h) {
-            return arguments.length ? (e = Array.from(h, v1), u()) : e.slice();
+            return arguments.length ? (e = Array.from(h, cy), l()) : e.slice();
         }, f.range = function(h) {
-            return arguments.length ? (t = Array.from(h), u()) : t.slice();
+            return arguments.length ? (t = Array.from(h), l()) : t.slice();
         }, f.rangeRound = function(h) {
-            return t = Array.from(h), n = Zb, u();
+            return t = Array.from(h), n = Dm, l();
         }, f.clamp = function(h) {
-            return arguments.length ? (o = h ? !0 : ri, u()) : o !== ri;
+            return arguments.length ? (o = h ? !0 : xn, l()) : o !== xn;
         }, f.interpolate = function(h) {
-            return arguments.length ? (n = h, u()) : n;
+            return arguments.length ? (n = h, l()) : n;
         }, f.unknown = function(h) {
             return arguments.length ? (s = h, f) : s;
         },
         function(h, d) {
-            return i = h, r = d, u();
+            return r = h, i = d, l();
         };
 }
 
-function V$() {
-    return a0()(ri, ri);
+function k3() {
+    return rd()(xn, xn);
 }
 
-function AG(e, t, n, i) {
-    var r = Rg(e, t, n),
+function kz(e, t, n, r) {
+    var i = M0(e, t, n),
         s;
-    switch (i = ku(i ?? ",f"), i.type) {
+    switch (r = Rc(r ?? ",f"), r.type) {
         case "s": {
             var o = Math.max(Math.abs(e), Math.abs(t));
-            return i.precision == null && !isNaN(s = LY(r, o)) && (i.precision = s), e$(i, o);
+            return r.precision == null && !isNaN(s = VP(i, o)) && (r.precision = s), XS(r, o);
         }
         case "":
         case "e":
         case "g":
         case "p":
         case "r": {
-            i.precision == null && !isNaN(s = RY(r, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = s - (i.type === "e"));
+            r.precision == null && !isNaN(s = YP(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = s - (r.type === "e"));
             break;
         }
         case "f":
         case "%": {
-            i.precision == null && !isNaN(s = EY(r)) && (i.precision = s - (i.type === "%") * 2);
+            r.precision == null && !isNaN(s = jP(i)) && (r.precision = s - (r.type === "%") * 2);
             break;
         }
     }
-    return rl(i);
+    return ma(r);
 }
 
-function Af(e) {
+function pu(e) {
     var t = e.domain;
     return e.ticks = function(n) {
-        var i = t();
-        return Ys(i[0], i[i.length - 1], n ?? 10);
-    }, e.tickFormat = function(n, i) {
         var r = t();
-        return AG(r[0], r[r.length - 1], n ?? 10, i);
+        return Ci(r[0], r[r.length - 1], n ?? 10);
+    }, e.tickFormat = function(n, r) {
+        var i = t();
+        return kz(i[0], i[i.length - 1], n ?? 10, r);
     }, e.nice = function(n) {
         n == null && (n = 10);
-        var i = t(),
-            r = 0,
-            s = i.length - 1,
-            o = i[r],
-            a = i[s],
-            c, l, u = 10;
-        for (a < o && (l = o, o = a, a = l, l = r, r = s, s = l); u-- > 0;) {
-            if (l = Ou(o, a, n), l === c)
-                return i[r] = o, i[s] = a, t(i);
-            if (l > 0)
-                o = Math.floor(o / l) * l, a = Math.ceil(a / l) * l;
-            else if (l < 0)
-                o = Math.ceil(o * l) / l, a = Math.floor(a * l) / l;
+        var r = t(),
+            i = 0,
+            s = r.length - 1,
+            o = r[i],
+            a = r[s],
+            c, u, l = 10;
+        for (a < o && (u = o, o = a, a = u, u = i, i = s, s = u); l-- > 0;) {
+            if (u = Ec(o, a, n), u === c)
+                return r[i] = o, r[s] = a, t(r);
+            if (u > 0)
+                o = Math.floor(o / u) * u, a = Math.ceil(a / u) * u;
+            else if (u < 0)
+                o = Math.ceil(o * u) / u, a = Math.floor(a * u) / u;
             else
                 break;
-            c = l;
+            c = u;
         }
         return e;
     }, e;
 }
 
-function c0() {
-    var e = V$();
+function id() {
+    var e = k3();
     return e.copy = function() {
-        return If(e, c0());
-    }, br.apply(e, arguments), Af(e);
+        return du(e, id());
+    }, Mr.apply(e, arguments), pu(e);
 }
 
-function j$(e) {
+function R3(e) {
     var t;
 
-    function n(i) {
-        return i == null || isNaN(i = +i) ? t : i;
+    function n(r) {
+        return r == null || isNaN(r = +r) ? t : r;
     }
-    return n.invert = n, n.domain = n.range = function(i) {
-        return arguments.length ? (e = Array.from(i, v1), n) : e.slice();
-    }, n.unknown = function(i) {
-        return arguments.length ? (t = i, n) : t;
+    return n.invert = n, n.domain = n.range = function(r) {
+        return arguments.length ? (e = Array.from(r, cy), n) : e.slice();
+    }, n.unknown = function(r) {
+        return arguments.length ? (t = r, n) : t;
     }, n.copy = function() {
-        return j$(e).unknown(t);
-    }, e = arguments.length ? Array.from(e, v1) : [0, 1], Af(n);
+        return R3(e).unknown(t);
+    }, e = arguments.length ? Array.from(e, cy) : [0, 1], pu(n);
 }
 
-function q$(e, t) {
+function F3(e, t) {
     e = e.slice();
     var n = 0,
-        i = e.length - 1,
-        r = e[n],
-        s = e[i],
+        r = e.length - 1,
+        i = e[n],
+        s = e[r],
         o;
-    return s < r && (o = n, n = i, i = o, o = r, r = s, s = o), e[n] = t.floor(r), e[i] = t.ceil(s), e;
+    return s < i && (o = n, n = r, r = o, o = i, i = s, s = o), e[n] = t.floor(i), e[r] = t.ceil(s), e;
 }
 
-function wx(e) {
+function Rw(e) {
     return Math.log(e);
 }
 
-function vx(e) {
+function Fw(e) {
     return Math.exp(e);
 }
 
-function MG(e) {
+function Rz(e) {
     return -Math.log(-e);
 }
 
-function $G(e) {
+function Fz(e) {
     return -Math.exp(-e);
 }
 
-function TG(e) {
+function Bz(e) {
     return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
 }
 
-function DG(e) {
-    return e === 10 ? TG : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
+function Cz(e) {
+    return e === 10 ? Bz : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
 }
 
-function NG(e) {
+function Pz(e) {
     return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
 }
 
-function _x(e) {
+function Bw(e) {
     return (t, n) => -e(-t, n);
 }
 
-function Y$(e) {
-    const t = e(wx, vx),
+function B3(e) {
+    const t = e(Rw, Fw),
         n = t.domain;
-    let i = 10,
-        r, s;
+    let r = 10,
+        i, s;
 
     function o() {
-        return r = NG(i), s = DG(i), n()[0] < 0 ? (r = _x(r), s = _x(s), e(MG, $G)) : e(wx, vx), t;
+        return i = Pz(r), s = Cz(r), n()[0] < 0 ? (i = Bw(i), s = Bw(s), e(Rz, Fz)) : e(Rw, Fw), t;
     }
     return t.base = function(a) {
-        return arguments.length ? (i = +a, o()) : i;
+        return arguments.length ? (r = +a, o()) : r;
     }, t.domain = function(a) {
         return arguments.length ? (n(a), o()) : n();
     }, t.ticks = (a) => {
         const c = n();
-        let l = c[0],
-            u = c[c.length - 1];
-        const f = u < l;
-        f && ([l, u] = [u, l]);
-        let h = r(l),
-            d = r(u),
-            p, m;
-        const g = a == null ? 10 : +a;
-        let y = [];
-        if (!(i % 1) && d - h < g) {
-            if (h = Math.floor(h), d = Math.ceil(d), l > 0) {
+        let u = c[0],
+            l = c[c.length - 1];
+        const f = l < u;
+        f && ([u, l] = [l, u]);
+        let h = i(u),
+            d = i(l),
+            p, y;
+        const m = a == null ? 10 : +a;
+        let g = [];
+        if (!(r % 1) && d - h < m) {
+            if (h = Math.floor(h), d = Math.ceil(d), u > 0) {
                 for (; h <= d; ++h)
-                    for (p = 1; p < i; ++p)
-                        if (m = h < 0 ? p / s(-h) : p * s(h), !(m < l)) {
-                            if (m > u)
+                    for (p = 1; p < r; ++p)
+                        if (y = h < 0 ? p / s(-h) : p * s(h), !(y < u)) {
+                            if (y > l)
                                 break;
-                            y.push(m);
+                            g.push(y);
                         }
             } else
                 for (; h <= d; ++h)
-                    for (p = i - 1; p >= 1; --p)
-                        if (m = h > 0 ? p / s(-h) : p * s(h), !(m < l)) {
-                            if (m > u)
+                    for (p = r - 1; p >= 1; --p)
+                        if (y = h > 0 ? p / s(-h) : p * s(h), !(y < u)) {
+                            if (y > l)
                                 break;
-                            y.push(m);
+                            g.push(y);
                         }
-            y.length * 2 < g && (y = Ys(l, u, g));
+            g.length * 2 < m && (g = Ci(u, l, m));
         } else
-            y = Ys(h, d, Math.min(d - h, g)).map(s);
-        return f ? y.reverse() : y;
+            g = Ci(h, d, Math.min(d - h, m)).map(s);
+        return f ? g.reverse() : g;
     }, t.tickFormat = (a, c) => {
-        if (a == null && (a = 10), c == null && (c = i === 10 ? "s" : ","), typeof c != "function" && (!(i % 1) && (c = ku(c)).precision == null && (c.trim = !0), c = rl(c)), a === 1 / 0)
+        if (a == null && (a = 10), c == null && (c = r === 10 ? "s" : ","), typeof c != "function" && (!(r % 1) && (c = Rc(c)).precision == null && (c.trim = !0), c = ma(c)), a === 1 / 0)
             return c;
-        const l = Math.max(1, i * a / t.ticks().length);
-        return (u) => {
-            let f = u / s(Math.round(r(u)));
-            return f * i < i - 0.5 && (f *= i), f <= l ? c(u) : "";
-        };
-    }, t.nice = () => n(q$(n(), {
-        floor: (a) => s(Math.floor(r(a))),
-        ceil: (a) => s(Math.ceil(r(a)))
+        const u = Math.max(1, r * a / t.ticks().length);
+        return (l) => {
+            let f = l / s(Math.round(i(l)));
+            return f * r < r - 0.5 && (f *= r), f <= u ? c(l) : "";
+        };
+    }, t.nice = () => n(F3(n(), {
+        floor: (a) => s(Math.floor(i(a))),
+        ceil: (a) => s(Math.ceil(i(a)))
     })), t;
 }
 
-function W$() {
-    const e = Y$(a0()).domain([1, 10]);
-    return e.copy = () => If(e, W$()).base(e.base()), br.apply(e, arguments), e;
+function C3() {
+    const e = B3(rd()).domain([1, 10]);
+    return e.copy = () => du(e, C3()).base(e.base()), Mr.apply(e, arguments), e;
 }
 
-function xx(e) {
+function Cw(e) {
     return function(t) {
         return Math.sign(t) * Math.log1p(Math.abs(t / e));
     };
 }
 
-function Sx(e) {
+function Pw(e) {
     return function(t) {
         return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
     };
 }
 
-function G$(e) {
+function P3(e) {
     var t = 1,
-        n = e(xx(t), Sx(t));
-    return n.constant = function(i) {
-        return arguments.length ? e(xx(t = +i), Sx(t)) : t;
-    }, Af(n);
+        n = e(Cw(t), Pw(t));
+    return n.constant = function(r) {
+        return arguments.length ? e(Cw(t = +r), Pw(t)) : t;
+    }, pu(n);
 }
 
-function X$() {
-    var e = G$(a0());
+function U3() {
+    var e = P3(rd());
     return e.copy = function() {
-        return If(e, X$()).constant(e.constant());
-    }, br.apply(e, arguments);
+        return du(e, U3()).constant(e.constant());
+    }, Mr.apply(e, arguments);
 }
 
-function Ix(e) {
+function Uw(e) {
     return function(t) {
         return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
     };
 }
 
-function BG(e) {
+function Uz(e) {
     return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
 }
 
-function OG(e) {
+function zz(e) {
     return e < 0 ? -e * e : e * e;
 }
 
-function H$(e) {
-    var t = e(ri, ri),
+function z3(e) {
+    var t = e(xn, xn),
         n = 1;
 
-    function i() {
-        return n === 1 ? e(ri, ri) : n === 0.5 ? e(BG, OG) : e(Ix(n), Ix(1 / n));
+    function r() {
+        return n === 1 ? e(xn, xn) : n === 0.5 ? e(Uz, zz) : e(Uw(n), Uw(1 / n));
     }
-    return t.exponent = function(r) {
-        return arguments.length ? (n = +r, i()) : n;
-    }, Af(t);
+    return t.exponent = function(i) {
+        return arguments.length ? (n = +i, r()) : n;
+    }, pu(t);
 }
 
-function J$() {
-    var e = H$(a0());
+function q3() {
+    var e = z3(rd());
     return e.copy = function() {
-        return If(e, J$()).exponent(e.exponent());
-    }, br.apply(e, arguments), e;
+        return du(e, q3()).exponent(e.exponent());
+    }, Mr.apply(e, arguments), e;
 }
 
-function K$() {
+function j3() {
     var e = [],
         t = [],
         n = [],
-        i;
+        r;
 
-    function r() {
+    function i() {
         var o = 0,
             a = Math.max(1, t.length);
         for (n = new Array(a - 1); ++o < a;)
-            n[o - 1] = zz(e, o / a);
+            n[o - 1] = Hk(e, o / a);
         return s;
     }
 
     function s(o) {
-        return o == null || isNaN(o = +o) ? i : t[Wy(n, o)];
+        return o == null || isNaN(o = +o) ? r : t[qh(n, o)];
     }
     return s.invertExtent = function(o) {
         var a = t.indexOf(o);
         return a < 0 ? [NaN, NaN] : [
             a > 0 ? n[a - 1] : e[0],
             a < n.length ? n[a] : e[e.length - 1]
         ];
     }, s.domain = function(o) {
         if (!arguments.length)
             return e.slice();
         e = [];
         for (let a of o)
             a != null && !isNaN(a = +a) && e.push(a);
-        return e.sort(me), r();
+        return e.sort(zt), i();
     }, s.range = function(o) {
-        return arguments.length ? (t = Array.from(o), r()) : t.slice();
+        return arguments.length ? (t = Array.from(o), i()) : t.slice();
     }, s.unknown = function(o) {
-        return arguments.length ? (i = o, s) : i;
+        return arguments.length ? (r = o, s) : r;
     }, s.quantiles = function() {
         return n.slice();
     }, s.copy = function() {
-        return K$().domain(e).range(t).unknown(i);
-    }, br.apply(s, arguments);
+        return j3().domain(e).range(t).unknown(r);
+    }, Mr.apply(s, arguments);
 }
 
-function Z$() {
+function V3() {
     var e = [0.5],
         t = [0, 1],
-        n, i = 1;
+        n, r = 1;
 
-    function r(s) {
-        return s != null && s <= s ? t[Wy(e, s, 0, i)] : n;
+    function i(s) {
+        return s != null && s <= s ? t[qh(e, s, 0, r)] : n;
     }
-    return r.domain = function(s) {
-        return arguments.length ? (e = Array.from(s), i = Math.min(e.length, t.length - 1), r) : e.slice();
-    }, r.range = function(s) {
-        return arguments.length ? (t = Array.from(s), i = Math.min(e.length, t.length - 1), r) : t.slice();
-    }, r.invertExtent = function(s) {
+    return i.domain = function(s) {
+        return arguments.length ? (e = Array.from(s), r = Math.min(e.length, t.length - 1), i) : e.slice();
+    }, i.range = function(s) {
+        return arguments.length ? (t = Array.from(s), r = Math.min(e.length, t.length - 1), i) : t.slice();
+    }, i.invertExtent = function(s) {
         var o = t.indexOf(s);
         return [e[o - 1], e[o]];
-    }, r.unknown = function(s) {
-        return arguments.length ? (n = s, r) : n;
-    }, r.copy = function() {
-        return Z$().domain(e).range(t).unknown(n);
-    }, br.apply(r, arguments);
+    }, i.unknown = function(s) {
+        return arguments.length ? (n = s, i) : n;
+    }, i.copy = function() {
+        return V3().domain(e).range(t).unknown(n);
+    }, Mr.apply(i, arguments);
 }
-const Nm = /* @__PURE__ */ new Date(),
-    Bm = /* @__PURE__ */ new Date();
+const Ap = /* @__PURE__ */ new Date(),
+    $p = /* @__PURE__ */ new Date();
 
-function Ue(e, t, n, i) {
-    function r(s) {
+function pe(e, t, n, r) {
+    function i(s) {
         return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
     }
-    return r.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), r.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), r.round = (s) => {
-        const o = r(s),
-            a = r.ceil(s);
+    return i.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), i.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), i.round = (s) => {
+        const o = i(s),
+            a = i.ceil(s);
         return s - o < a - s ? o : a;
-    }, r.offset = (s, o) => (t(s = /* @__PURE__ */ new Date(+s), o == null ? 1 : Math.floor(o)), s), r.range = (s, o, a) => {
+    }, i.offset = (s, o) => (t(s = /* @__PURE__ */ new Date(+s), o == null ? 1 : Math.floor(o)), s), i.range = (s, o, a) => {
         const c = [];
-        if (s = r.ceil(s), a = a == null ? 1 : Math.floor(a), !(s < o) || !(a > 0))
+        if (s = i.ceil(s), a = a == null ? 1 : Math.floor(a), !(s < o) || !(a > 0))
             return c;
-        let l;
+        let u;
         do
-            c.push(l = /* @__PURE__ */ new Date(+s)), t(s, a), e(s);
-        while (l < s && s < o);
+            c.push(u = /* @__PURE__ */ new Date(+s)), t(s, a), e(s);
+        while (u < s && s < o);
         return c;
-    }, r.filter = (s) => Ue((o) => {
+    }, i.filter = (s) => pe((o) => {
         if (o >= o)
             for (; e(o), !s(o);)
                 o.setTime(o - 1);
     }, (o, a) => {
         if (o >= o)
             if (a < 0)
                 for (; ++a <= 0;)
                     for (; t(o, -1), !s(o);)
             ;
             else
                 for (; --a >= 0;)
                     for (; t(o, 1), !s(o);)
         ;
-    }), n && (r.count = (s, o) => (Nm.setTime(+s), Bm.setTime(+o), e(Nm), e(Bm), Math.floor(n(Nm, Bm))), r.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? r.filter(i ? (o) => i(o) % s === 0 : (o) => r.count(0, o) % s === 0) : r)), r;
+    }), n && (i.count = (s, o) => (Ap.setTime(+s), $p.setTime(+o), e(Ap), e($p), Math.floor(n(Ap, $p))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(r ? (o) => r(o) % s === 0 : (o) => i.count(0, o) % s === 0) : i)), i;
 }
-const Dp = Ue(() => {}, (e, t) => {
+const nh = pe(() => {}, (e, t) => {
     e.setTime(+e + t);
 }, (e, t) => t - e);
-Dp.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Ue((t) => {
+nh.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? pe((t) => {
     t.setTime(Math.floor(t / e) * e);
 }, (t, n) => {
     t.setTime(+t + n * e);
-}, (t, n) => (n - t) / e) : Dp);
-Dp.range;
+}, (t, n) => (n - t) / e) : nh);
+nh.range;
 const Hr = 1e3,
-    si = Hr * 60,
-    Jr = si * 60,
-    ss = Jr * 24,
-    fw = ss * 7,
-    Ax = ss * 30,
-    Om = ss * 365,
-    xi = Ue((e) => {
+    Sn = Hr * 60,
+    Jr = Sn * 60,
+    ii = Jr * 24,
+    Ym = ii * 7,
+    zw = ii * 30,
+    Ip = ii * 365,
+    Bn = pe((e) => {
         e.setTime(e - e.getMilliseconds());
     }, (e, t) => {
         e.setTime(+e + t * Hr);
     }, (e, t) => (t - e) / Hr, (e) => e.getUTCSeconds());
-xi.range;
-const Mf = Ue((e) => {
+Bn.range;
+const yu = pe((e) => {
     e.setTime(e - e.getMilliseconds() - e.getSeconds() * Hr);
 }, (e, t) => {
-    e.setTime(+e + t * si);
-}, (e, t) => (t - e) / si, (e) => e.getMinutes());
-Mf.range;
-const $f = Ue((e) => {
+    e.setTime(+e + t * Sn);
+}, (e, t) => (t - e) / Sn, (e) => e.getMinutes());
+yu.range;
+const mu = pe((e) => {
     e.setUTCSeconds(0, 0);
 }, (e, t) => {
-    e.setTime(+e + t * si);
-}, (e, t) => (t - e) / si, (e) => e.getUTCMinutes());
-$f.range;
-const Tf = Ue((e) => {
-    e.setTime(e - e.getMilliseconds() - e.getSeconds() * Hr - e.getMinutes() * si);
+    e.setTime(+e + t * Sn);
+}, (e, t) => (t - e) / Sn, (e) => e.getUTCMinutes());
+mu.range;
+const gu = pe((e) => {
+    e.setTime(e - e.getMilliseconds() - e.getSeconds() * Hr - e.getMinutes() * Sn);
 }, (e, t) => {
     e.setTime(+e + t * Jr);
 }, (e, t) => (t - e) / Jr, (e) => e.getHours());
-Tf.range;
-const Df = Ue((e) => {
+gu.range;
+const bu = pe((e) => {
     e.setUTCMinutes(0, 0, 0);
 }, (e, t) => {
     e.setTime(+e + t * Jr);
 }, (e, t) => (t - e) / Jr, (e) => e.getUTCHours());
-Df.range;
-const aa = Ue(
+bu.range;
+const Ps = pe(
     (e) => e.setHours(0, 0, 0, 0),
     (e, t) => e.setDate(e.getDate() + t),
-    (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * si) / ss,
+    (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Sn) / ii,
     (e) => e.getDate() - 1
 );
-aa.range;
-const l0 = Ue((e) => {
+Ps.range;
+const sd = pe((e) => {
     e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCDate(e.getUTCDate() + t);
-}, (e, t) => (t - e) / ss, (e) => e.getUTCDate() - 1);
-l0.range;
-const u0 = Ue((e) => {
+}, (e, t) => (t - e) / ii, (e) => e.getUTCDate() - 1);
+sd.range;
+const od = pe((e) => {
     e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCDate(e.getUTCDate() + t);
-}, (e, t) => (t - e) / ss, (e) => Math.floor(e / ss));
-u0.range;
+}, (e, t) => (t - e) / ii, (e) => Math.floor(e / ii));
+od.range;
 
-function ca(e) {
-    return Ue((t) => {
+function Us(e) {
+    return pe((t) => {
         t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
     }, (t, n) => {
         t.setDate(t.getDate() + n * 7);
-    }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * si) / fw);
+    }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Sn) / Ym);
 }
-const Rc = ca(0),
-    Pu = ca(1),
-    Q$ = ca(2),
-    t6 = ca(3),
-    na = ca(4),
-    e6 = ca(5),
-    n6 = ca(6);
-Rc.range;
-Pu.range;
-Q$.range;
-t6.range;
-na.range;
-e6.range;
-n6.range;
+const Ko = Us(0),
+    Cc = Us(1),
+    Y3 = Us(2),
+    W3 = Us(3),
+    ks = Us(4),
+    X3 = Us(5),
+    G3 = Us(6);
+Ko.range;
+Cc.range;
+Y3.range;
+W3.range;
+ks.range;
+X3.range;
+G3.range;
 
-function la(e) {
-    return Ue((t) => {
+function zs(e) {
+    return pe((t) => {
         t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
     }, (t, n) => {
         t.setUTCDate(t.getUTCDate() + n * 7);
-    }, (t, n) => (n - t) / fw);
+    }, (t, n) => (n - t) / Ym);
 }
-const Cc = la(0),
-    Vu = la(1),
-    i6 = la(2),
-    r6 = la(3),
-    ia = la(4),
-    s6 = la(5),
-    o6 = la(6);
-Cc.range;
-Vu.range;
-i6.range;
-r6.range;
-ia.range;
-s6.range;
-o6.range;
-const Nf = Ue((e) => {
+const Qo = zs(0),
+    Pc = zs(1),
+    H3 = zs(2),
+    J3 = zs(3),
+    Rs = zs(4),
+    Z3 = zs(5),
+    K3 = zs(6);
+Qo.range;
+Pc.range;
+H3.range;
+J3.range;
+Rs.range;
+Z3.range;
+K3.range;
+const wu = pe((e) => {
     e.setDate(1), e.setHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setMonth(e.getMonth() + t);
 }, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
-Nf.range;
-const Bf = Ue((e) => {
+wu.range;
+const vu = pe((e) => {
     e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCMonth(e.getUTCMonth() + t);
 }, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
-Bf.range;
-const Di = Ue((e) => {
+vu.range;
+const Yn = pe((e) => {
     e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setFullYear(e.getFullYear() + t);
 }, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
-Di.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ue((t) => {
+Yn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : pe((t) => {
     t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
 }, (t, n) => {
     t.setFullYear(t.getFullYear() + n * e);
 });
-Di.range;
-const Ni = Ue((e) => {
+Yn.range;
+const Wn = pe((e) => {
     e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
 }, (e, t) => {
     e.setUTCFullYear(e.getUTCFullYear() + t);
 }, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
-Ni.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Ue((t) => {
+Wn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : pe((t) => {
     t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
 }, (t, n) => {
     t.setUTCFullYear(t.getUTCFullYear() + n * e);
 });
-Ni.range;
+Wn.range;
 
-function a6(e, t, n, i, r, s) {
+function Q3(e, t, n, r, i, s) {
     const o = [
-        [xi, 1, Hr],
-        [xi, 5, 5 * Hr],
-        [xi, 15, 15 * Hr],
-        [xi, 30, 30 * Hr],
-        [s, 1, si],
-        [s, 5, 5 * si],
-        [s, 15, 15 * si],
-        [s, 30, 30 * si],
-        [r, 1, Jr],
-        [r, 3, 3 * Jr],
-        [r, 6, 6 * Jr],
-        [r, 12, 12 * Jr],
-        [i, 1, ss],
-        [i, 2, 2 * ss],
-        [n, 1, fw],
-        [t, 1, Ax],
-        [t, 3, 3 * Ax],
-        [e, 1, Om]
+        [Bn, 1, Hr],
+        [Bn, 5, 5 * Hr],
+        [Bn, 15, 15 * Hr],
+        [Bn, 30, 30 * Hr],
+        [s, 1, Sn],
+        [s, 5, 5 * Sn],
+        [s, 15, 15 * Sn],
+        [s, 30, 30 * Sn],
+        [i, 1, Jr],
+        [i, 3, 3 * Jr],
+        [i, 6, 6 * Jr],
+        [i, 12, 12 * Jr],
+        [r, 1, ii],
+        [r, 2, 2 * ii],
+        [n, 1, Ym],
+        [t, 1, zw],
+        [t, 3, 3 * zw],
+        [e, 1, Ip]
     ];
 
-    function a(l, u, f) {
-        const h = u < l;
-        h && ([l, u] = [u, l]);
-        const d = f && typeof f.range == "function" ? f : c(l, u, f),
-            p = d ? d.range(l, +u + 1) : [];
+    function a(u, l, f) {
+        const h = l < u;
+        h && ([u, l] = [l, u]);
+        const d = f && typeof f.range == "function" ? f : c(u, l, f),
+            p = d ? d.range(u, +l + 1) : [];
         return h ? p.reverse() : p;
     }
 
-    function c(l, u, f) {
-        const h = Math.abs(u - l) / f,
-            d = Yy(([, , g]) => g).right(o, h);
+    function c(u, l, f) {
+        const h = Math.abs(l - u) / f,
+            d = zh(([, , m]) => m).right(o, h);
         if (d === o.length)
-            return e.every(Rg(l / Om, u / Om, f));
+            return e.every(M0(u / Ip, l / Ip, f));
         if (d === 0)
-            return Dp.every(Math.max(Rg(l, u, f), 1));
-        const [p, m] = o[h / o[d - 1][2] < o[d][2] / h ? d - 1 : d];
-        return p.every(m);
+            return nh.every(Math.max(M0(u, l, f), 1));
+        const [p, y] = o[h / o[d - 1][2] < o[d][2] / h ? d - 1 : d];
+        return p.every(y);
     }
     return [a, c];
 }
-const [FG, c6] = a6(Ni, Bf, Cc, u0, Df, $f), [EG, LG] = a6(Di, Nf, Rc, aa, Tf, Mf);
+const [qz, t6] = Q3(Wn, vu, Qo, od, bu, mu), [jz, Vz] = Q3(Yn, wu, Ko, Ps, gu, yu);
 
-function Fm(e) {
+function Tp(e) {
     if (0 <= e.y && e.y < 100) {
         var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
         return t.setFullYear(e.y), t;
     }
     return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
 }
 
-function Em(e) {
+function Ep(e) {
     if (0 <= e.y && e.y < 100) {
         var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
         return t.setUTCFullYear(e.y), t;
     }
     return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
 }
 
-function Sl(e, t, n) {
+function ka(e, t, n) {
     return {
         y: e,
         m: t,
         d: n,
         H: 0,
         M: 0,
         S: 0,
         L: 0
     };
 }
 
-function RG(e) {
+function Yz(e) {
     var t = e.dateTime,
         n = e.date,
-        i = e.time,
-        r = e.periods,
+        r = e.time,
+        i = e.periods,
         s = e.days,
         o = e.shortDays,
         a = e.months,
         c = e.shortMonths,
-        l = Il(r),
-        u = Al(r),
-        f = Il(s),
-        h = Al(s),
-        d = Il(o),
-        p = Al(o),
-        m = Il(a),
-        g = Al(a),
-        y = Il(c),
-        b = Al(c),
+        u = Ra(i),
+        l = Fa(i),
+        f = Ra(s),
+        h = Fa(s),
+        d = Ra(o),
+        p = Fa(o),
+        y = Ra(a),
+        m = Fa(a),
+        g = Ra(c),
+        b = Fa(c),
         w = {
-            a: L,
-            A: k,
-            b: U,
-            B: C,
+            a: k,
+            A: B,
+            b: C,
+            B: F,
             c: null,
-            d: Bx,
-            e: Bx,
-            f: sX,
-            g: yX,
-            G: gX,
-            H: nX,
-            I: iX,
-            j: rX,
-            L: l6,
-            m: oX,
-            M: aX,
-            p: z,
-            q: P,
-            Q: Ex,
-            s: Lx,
-            S: cX,
-            u: lX,
-            U: uX,
-            V: fX,
-            w: hX,
-            W: dX,
+            d: Xw,
+            e: Xw,
+            f: pq,
+            g: Mq,
+            G: $q,
+            H: fq,
+            I: hq,
+            j: dq,
+            L: e6,
+            m: yq,
+            M: mq,
+            p: P,
+            q: U,
+            Q: Jw,
+            s: Zw,
+            S: gq,
+            u: bq,
+            U: wq,
+            V: vq,
+            w: _q,
+            W: xq,
             x: null,
             X: null,
-            y: pX,
-            Y: mX,
-            Z: bX,
-            "%": Fx
+            y: Sq,
+            Y: Aq,
+            Z: Iq,
+            "%": Hw
         },
         v = {
-            a: G,
-            A: K,
-            b: et,
-            B: Z,
+            a: Y,
+            A: G,
+            b: K,
+            B: H,
             c: null,
-            d: Ox,
-            e: Ox,
-            f: xX,
-            g: OX,
-            G: EX,
-            H: wX,
-            I: vX,
-            j: _X,
-            L: f6,
-            m: SX,
-            M: IX,
-            p: Y,
-            q: X,
-            Q: Ex,
-            s: Lx,
-            S: AX,
-            u: MX,
-            U: $X,
-            V: TX,
-            w: DX,
-            W: NX,
+            d: Gw,
+            e: Gw,
+            f: Dq,
+            g: zq,
+            G: jq,
+            H: Tq,
+            I: Eq,
+            j: Nq,
+            L: r6,
+            m: Oq,
+            M: Lq,
+            p: V,
+            q: W,
+            Q: Jw,
+            s: Zw,
+            S: kq,
+            u: Rq,
+            U: Fq,
+            V: Bq,
+            w: Cq,
+            W: Pq,
             x: null,
             X: null,
-            y: BX,
-            Y: FX,
-            Z: LX,
-            "%": Fx
+            y: Uq,
+            Y: qq,
+            Z: Vq,
+            "%": Hw
         },
         x = {
             a: N,
-            A: $,
-            b: B,
+            A,
+            b: D,
             B: R,
             c: S,
-            d: Dx,
-            e: Dx,
-            f: ZG,
-            g: Tx,
-            G: $x,
-            H: Nx,
-            I: Nx,
-            j: XG,
-            L: KG,
-            m: GG,
-            M: HG,
-            p: M,
-            q: WG,
-            Q: tX,
-            s: eX,
-            S: JG,
-            u: PG,
-            U: VG,
-            V: jG,
-            w: zG,
-            W: qG,
-            x: T,
-            X: D,
-            y: Tx,
-            Y: $x,
-            Z: YG,
-            "%": QG
-        };
-    w.x = _(n, w), w.X = _(i, w), w.c = _(t, w), v.x = _(n, v), v.X = _(i, v), v.c = _(t, v);
-
-    function _(j, J) {
-        return function(tt) {
-            var V = [],
-                Ft = -1,
-                rt = 0,
-                Vt = j.length,
-                jt, Q, Zt;
-            for (tt instanceof Date || (tt = /* @__PURE__ */ new Date(+tt)); ++Ft < Vt;)
-                j.charCodeAt(Ft) === 37 && (V.push(j.slice(rt, Ft)), (Q = Mx[jt = j.charAt(++Ft)]) != null ? jt = j.charAt(++Ft) : Q = jt === "e" ? " " : "0", (Zt = J[jt]) && (jt = Zt(tt, Q)), V.push(jt), rt = Ft + 1);
-            return V.push(j.slice(rt, Ft)), V.join("");
+            d: Yw,
+            e: Yw,
+            f: aq,
+            g: Vw,
+            G: jw,
+            H: Ww,
+            I: Ww,
+            j: rq,
+            L: oq,
+            m: nq,
+            M: iq,
+            p: $,
+            q: eq,
+            Q: uq,
+            s: lq,
+            S: sq,
+            u: Jz,
+            U: Zz,
+            V: Kz,
+            w: Hz,
+            W: Qz,
+            x: I,
+            X: E,
+            y: Vw,
+            Y: jw,
+            Z: tq,
+            "%": cq
+        };
+    w.x = _(n, w), w.X = _(r, w), w.c = _(t, w), v.x = _(n, v), v.X = _(r, v), v.c = _(t, v);
+
+    function _(q, X) {
+        return function(Z) {
+            var z = [],
+                wt = -1,
+                tt = 0,
+                It = q.length,
+                Et, J, Bt;
+            for (Z instanceof Date || (Z = /* @__PURE__ */ new Date(+Z)); ++wt < It;)
+                q.charCodeAt(wt) === 37 && (z.push(q.slice(tt, wt)), (J = qw[Et = q.charAt(++wt)]) != null ? Et = q.charAt(++wt) : J = Et === "e" ? " " : "0", (Bt = X[Et]) && (Et = Bt(Z, J)), z.push(Et), tt = wt + 1);
+            return z.push(q.slice(tt, wt)), z.join("");
         };
     }
 
-    function I(j, J) {
-        return function(tt) {
-            var V = Sl(1900, void 0, 1),
-                Ft = A(V, j, tt += "", 0),
-                rt, Vt;
-            if (Ft != tt.length)
+    function M(q, X) {
+        return function(Z) {
+            var z = ka(1900, void 0, 1),
+                wt = T(z, q, Z += "", 0),
+                tt, It;
+            if (wt != Z.length)
                 return null;
-            if ("Q" in V)
-                return new Date(V.Q);
-            if ("s" in V)
-                return new Date(V.s * 1e3 + ("L" in V ? V.L : 0));
-            if (J && !("Z" in V) && (V.Z = 0), "p" in V && (V.H = V.H % 12 + V.p * 12), V.m === void 0 && (V.m = "q" in V ? V.q : 0), "V" in V) {
-                if (V.V < 1 || V.V > 53)
+            if ("Q" in z)
+                return new Date(z.Q);
+            if ("s" in z)
+                return new Date(z.s * 1e3 + ("L" in z ? z.L : 0));
+            if (X && !("Z" in z) && (z.Z = 0), "p" in z && (z.H = z.H % 12 + z.p * 12), z.m === void 0 && (z.m = "q" in z ? z.q : 0), "V" in z) {
+                if (z.V < 1 || z.V > 53)
                     return null;
-                "w" in V || (V.w = 1), "Z" in V ? (rt = Em(Sl(V.y, 0, 1)), Vt = rt.getUTCDay(), rt = Vt > 4 || Vt === 0 ? Vu.ceil(rt) : Vu(rt), rt = l0.offset(rt, (V.V - 1) * 7), V.y = rt.getUTCFullYear(), V.m = rt.getUTCMonth(), V.d = rt.getUTCDate() + (V.w + 6) % 7) : (rt = Fm(Sl(V.y, 0, 1)), Vt = rt.getDay(), rt = Vt > 4 || Vt === 0 ? Pu.ceil(rt) : Pu(rt), rt = aa.offset(rt, (V.V - 1) * 7), V.y = rt.getFullYear(), V.m = rt.getMonth(), V.d = rt.getDate() + (V.w + 6) % 7);
+                "w" in z || (z.w = 1), "Z" in z ? (tt = Ep(ka(z.y, 0, 1)), It = tt.getUTCDay(), tt = It > 4 || It === 0 ? Pc.ceil(tt) : Pc(tt), tt = sd.offset(tt, (z.V - 1) * 7), z.y = tt.getUTCFullYear(), z.m = tt.getUTCMonth(), z.d = tt.getUTCDate() + (z.w + 6) % 7) : (tt = Tp(ka(z.y, 0, 1)), It = tt.getDay(), tt = It > 4 || It === 0 ? Cc.ceil(tt) : Cc(tt), tt = Ps.offset(tt, (z.V - 1) * 7), z.y = tt.getFullYear(), z.m = tt.getMonth(), z.d = tt.getDate() + (z.w + 6) % 7);
             } else
-                ("W" in V || "U" in V) && ("w" in V || (V.w = "u" in V ? V.u % 7 : "W" in V ? 1 : 0), Vt = "Z" in V ? Em(Sl(V.y, 0, 1)).getUTCDay() : Fm(Sl(V.y, 0, 1)).getDay(), V.m = 0, V.d = "W" in V ? (V.w + 6) % 7 + V.W * 7 - (Vt + 5) % 7 : V.w + V.U * 7 - (Vt + 6) % 7);
-            return "Z" in V ? (V.H += V.Z / 100 | 0, V.M += V.Z % 100, Em(V)) : Fm(V);
+                ("W" in z || "U" in z) && ("w" in z || (z.w = "u" in z ? z.u % 7 : "W" in z ? 1 : 0), It = "Z" in z ? Ep(ka(z.y, 0, 1)).getUTCDay() : Tp(ka(z.y, 0, 1)).getDay(), z.m = 0, z.d = "W" in z ? (z.w + 6) % 7 + z.W * 7 - (It + 5) % 7 : z.w + z.U * 7 - (It + 6) % 7);
+            return "Z" in z ? (z.H += z.Z / 100 | 0, z.M += z.Z % 100, Ep(z)) : Tp(z);
         };
     }
 
-    function A(j, J, tt, V) {
-        for (var Ft = 0, rt = J.length, Vt = tt.length, jt, Q; Ft < rt;) {
-            if (V >= Vt)
+    function T(q, X, Z, z) {
+        for (var wt = 0, tt = X.length, It = Z.length, Et, J; wt < tt;) {
+            if (z >= It)
                 return -1;
-            if (jt = J.charCodeAt(Ft++), jt === 37) {
-                if (jt = J.charAt(Ft++), Q = x[jt in Mx ? J.charAt(Ft++) : jt], !Q || (V = Q(j, tt, V)) < 0)
+            if (Et = X.charCodeAt(wt++), Et === 37) {
+                if (Et = X.charAt(wt++), J = x[Et in qw ? X.charAt(wt++) : Et], !J || (z = J(q, Z, z)) < 0)
                     return -1;
-            } else if (jt != tt.charCodeAt(V++))
+            } else if (Et != Z.charCodeAt(z++))
                 return -1;
         }
-        return V;
+        return z;
     }
 
-    function M(j, J, tt) {
-        var V = l.exec(J.slice(tt));
-        return V ? (j.p = u.get(V[0].toLowerCase()), tt + V[0].length) : -1;
+    function $(q, X, Z) {
+        var z = u.exec(X.slice(Z));
+        return z ? (q.p = l.get(z[0].toLowerCase()), Z + z[0].length) : -1;
     }
 
-    function N(j, J, tt) {
-        var V = d.exec(J.slice(tt));
-        return V ? (j.w = p.get(V[0].toLowerCase()), tt + V[0].length) : -1;
+    function N(q, X, Z) {
+        var z = d.exec(X.slice(Z));
+        return z ? (q.w = p.get(z[0].toLowerCase()), Z + z[0].length) : -1;
     }
 
-    function $(j, J, tt) {
-        var V = f.exec(J.slice(tt));
-        return V ? (j.w = h.get(V[0].toLowerCase()), tt + V[0].length) : -1;
+    function A(q, X, Z) {
+        var z = f.exec(X.slice(Z));
+        return z ? (q.w = h.get(z[0].toLowerCase()), Z + z[0].length) : -1;
     }
 
-    function B(j, J, tt) {
-        var V = y.exec(J.slice(tt));
-        return V ? (j.m = b.get(V[0].toLowerCase()), tt + V[0].length) : -1;
+    function D(q, X, Z) {
+        var z = g.exec(X.slice(Z));
+        return z ? (q.m = b.get(z[0].toLowerCase()), Z + z[0].length) : -1;
     }
 
-    function R(j, J, tt) {
-        var V = m.exec(J.slice(tt));
-        return V ? (j.m = g.get(V[0].toLowerCase()), tt + V[0].length) : -1;
+    function R(q, X, Z) {
+        var z = y.exec(X.slice(Z));
+        return z ? (q.m = m.get(z[0].toLowerCase()), Z + z[0].length) : -1;
     }
 
-    function S(j, J, tt) {
-        return A(j, t, J, tt);
+    function S(q, X, Z) {
+        return T(q, t, X, Z);
     }
 
-    function T(j, J, tt) {
-        return A(j, n, J, tt);
+    function I(q, X, Z) {
+        return T(q, n, X, Z);
     }
 
-    function D(j, J, tt) {
-        return A(j, i, J, tt);
+    function E(q, X, Z) {
+        return T(q, r, X, Z);
     }
 
-    function L(j) {
-        return o[j.getDay()];
+    function k(q) {
+        return o[q.getDay()];
     }
 
-    function k(j) {
-        return s[j.getDay()];
+    function B(q) {
+        return s[q.getDay()];
     }
 
-    function U(j) {
-        return c[j.getMonth()];
+    function C(q) {
+        return c[q.getMonth()];
     }
 
-    function C(j) {
-        return a[j.getMonth()];
+    function F(q) {
+        return a[q.getMonth()];
     }
 
-    function z(j) {
-        return r[+(j.getHours() >= 12)];
+    function P(q) {
+        return i[+(q.getHours() >= 12)];
     }
 
-    function P(j) {
-        return 1 + ~~(j.getMonth() / 3);
+    function U(q) {
+        return 1 + ~~(q.getMonth() / 3);
     }
 
-    function G(j) {
-        return o[j.getUTCDay()];
+    function Y(q) {
+        return o[q.getUTCDay()];
     }
 
-    function K(j) {
-        return s[j.getUTCDay()];
+    function G(q) {
+        return s[q.getUTCDay()];
     }
 
-    function et(j) {
-        return c[j.getUTCMonth()];
+    function K(q) {
+        return c[q.getUTCMonth()];
     }
 
-    function Z(j) {
-        return a[j.getUTCMonth()];
+    function H(q) {
+        return a[q.getUTCMonth()];
     }
 
-    function Y(j) {
-        return r[+(j.getUTCHours() >= 12)];
+    function V(q) {
+        return i[+(q.getUTCHours() >= 12)];
     }
 
-    function X(j) {
-        return 1 + ~~(j.getUTCMonth() / 3);
+    function W(q) {
+        return 1 + ~~(q.getUTCMonth() / 3);
     }
     return {
-        format: function(j) {
-            var J = _(j += "", w);
-            return J.toString = function() {
-                return j;
-            }, J;
+        format: function(q) {
+            var X = _(q += "", w);
+            return X.toString = function() {
+                return q;
+            }, X;
         },
-        parse: function(j) {
-            var J = I(j += "", !1);
-            return J.toString = function() {
-                return j;
-            }, J;
+        parse: function(q) {
+            var X = M(q += "", !1);
+            return X.toString = function() {
+                return q;
+            }, X;
         },
-        utcFormat: function(j) {
-            var J = _(j += "", v);
-            return J.toString = function() {
-                return j;
-            }, J;
+        utcFormat: function(q) {
+            var X = _(q += "", v);
+            return X.toString = function() {
+                return q;
+            }, X;
         },
-        utcParse: function(j) {
-            var J = I(j += "", !0);
-            return J.toString = function() {
-                return j;
-            }, J;
+        utcParse: function(q) {
+            var X = M(q += "", !0);
+            return X.toString = function() {
+                return q;
+            }, X;
         }
     };
 }
-var Mx = {
+var qw = {
         "-": "",
         _: " ",
         0: "0"
     },
-    We = /^\s*\d+/,
-    CG = /^%/,
-    kG = /[\\^$*+?|[\]().{}]/g;
-
-function Ht(e, t, n) {
-    var i = e < 0 ? "-" : "",
-        r = (i ? -e : e) + "",
-        s = r.length;
-    return i + (s < n ? new Array(n - s + 1).join(t) + r : r);
+    _e = /^\s*\d+/,
+    Wz = /^%/,
+    Xz = /[\\^$*+?|[\]().{}]/g;
+
+function kt(e, t, n) {
+    var r = e < 0 ? "-" : "",
+        i = (r ? -e : e) + "",
+        s = i.length;
+    return r + (s < n ? new Array(n - s + 1).join(t) + i : i);
 }
 
-function UG(e) {
-    return e.replace(kG, "\\$&");
+function Gz(e) {
+    return e.replace(Xz, "\\$&");
 }
 
-function Il(e) {
-    return new RegExp("^(?:" + e.map(UG).join("|") + ")", "i");
+function Ra(e) {
+    return new RegExp("^(?:" + e.map(Gz).join("|") + ")", "i");
 }
 
-function Al(e) {
+function Fa(e) {
     return new Map(e.map((t, n) => [t.toLowerCase(), n]));
 }
 
-function zG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 1));
-    return i ? (e.w = +i[0], n + i[0].length) : -1;
+function Hz(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 1));
+    return r ? (e.w = +r[0], n + r[0].length) : -1;
 }
 
-function PG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 1));
-    return i ? (e.u = +i[0], n + i[0].length) : -1;
+function Jz(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 1));
+    return r ? (e.u = +r[0], n + r[0].length) : -1;
 }
 
-function VG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.U = +i[0], n + i[0].length) : -1;
+function Zz(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.U = +r[0], n + r[0].length) : -1;
 }
 
-function jG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.V = +i[0], n + i[0].length) : -1;
+function Kz(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.V = +r[0], n + r[0].length) : -1;
 }
 
-function qG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.W = +i[0], n + i[0].length) : -1;
+function Qz(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.W = +r[0], n + r[0].length) : -1;
 }
 
-function $x(e, t, n) {
-    var i = We.exec(t.slice(n, n + 4));
-    return i ? (e.y = +i[0], n + i[0].length) : -1;
+function jw(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 4));
+    return r ? (e.y = +r[0], n + r[0].length) : -1;
 }
 
-function Tx(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), n + i[0].length) : -1;
+function Vw(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
 }
 
-function YG(e, t, n) {
-    var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
-    return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), n + i[0].length) : -1;
+function tq(e, t, n) {
+    var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
+    return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
 }
 
-function WG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 1));
-    return i ? (e.q = i[0] * 3 - 3, n + i[0].length) : -1;
+function eq(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 1));
+    return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
 }
 
-function GG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.m = i[0] - 1, n + i[0].length) : -1;
+function nq(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
 }
 
-function Dx(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.d = +i[0], n + i[0].length) : -1;
+function Yw(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.d = +r[0], n + r[0].length) : -1;
 }
 
-function XG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 3));
-    return i ? (e.m = 0, e.d = +i[0], n + i[0].length) : -1;
+function rq(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 3));
+    return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
 }
 
-function Nx(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.H = +i[0], n + i[0].length) : -1;
+function Ww(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.H = +r[0], n + r[0].length) : -1;
 }
 
-function HG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.M = +i[0], n + i[0].length) : -1;
+function iq(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.M = +r[0], n + r[0].length) : -1;
 }
 
-function JG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 2));
-    return i ? (e.S = +i[0], n + i[0].length) : -1;
+function sq(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 2));
+    return r ? (e.S = +r[0], n + r[0].length) : -1;
 }
 
-function KG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 3));
-    return i ? (e.L = +i[0], n + i[0].length) : -1;
+function oq(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 3));
+    return r ? (e.L = +r[0], n + r[0].length) : -1;
 }
 
-function ZG(e, t, n) {
-    var i = We.exec(t.slice(n, n + 6));
-    return i ? (e.L = Math.floor(i[0] / 1e3), n + i[0].length) : -1;
+function aq(e, t, n) {
+    var r = _e.exec(t.slice(n, n + 6));
+    return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
 }
 
-function QG(e, t, n) {
-    var i = CG.exec(t.slice(n, n + 1));
-    return i ? n + i[0].length : -1;
+function cq(e, t, n) {
+    var r = Wz.exec(t.slice(n, n + 1));
+    return r ? n + r[0].length : -1;
 }
 
-function tX(e, t, n) {
-    var i = We.exec(t.slice(n));
-    return i ? (e.Q = +i[0], n + i[0].length) : -1;
+function uq(e, t, n) {
+    var r = _e.exec(t.slice(n));
+    return r ? (e.Q = +r[0], n + r[0].length) : -1;
 }
 
-function eX(e, t, n) {
-    var i = We.exec(t.slice(n));
-    return i ? (e.s = +i[0], n + i[0].length) : -1;
+function lq(e, t, n) {
+    var r = _e.exec(t.slice(n));
+    return r ? (e.s = +r[0], n + r[0].length) : -1;
 }
 
-function Bx(e, t) {
-    return Ht(e.getDate(), t, 2);
+function Xw(e, t) {
+    return kt(e.getDate(), t, 2);
 }
 
-function nX(e, t) {
-    return Ht(e.getHours(), t, 2);
+function fq(e, t) {
+    return kt(e.getHours(), t, 2);
 }
 
-function iX(e, t) {
-    return Ht(e.getHours() % 12 || 12, t, 2);
+function hq(e, t) {
+    return kt(e.getHours() % 12 || 12, t, 2);
 }
 
-function rX(e, t) {
-    return Ht(1 + aa.count(Di(e), e), t, 3);
+function dq(e, t) {
+    return kt(1 + Ps.count(Yn(e), e), t, 3);
 }
 
-function l6(e, t) {
-    return Ht(e.getMilliseconds(), t, 3);
+function e6(e, t) {
+    return kt(e.getMilliseconds(), t, 3);
 }
 
-function sX(e, t) {
-    return l6(e, t) + "000";
+function pq(e, t) {
+    return e6(e, t) + "000";
 }
 
-function oX(e, t) {
-    return Ht(e.getMonth() + 1, t, 2);
+function yq(e, t) {
+    return kt(e.getMonth() + 1, t, 2);
 }
 
-function aX(e, t) {
-    return Ht(e.getMinutes(), t, 2);
+function mq(e, t) {
+    return kt(e.getMinutes(), t, 2);
 }
 
-function cX(e, t) {
-    return Ht(e.getSeconds(), t, 2);
+function gq(e, t) {
+    return kt(e.getSeconds(), t, 2);
 }
 
-function lX(e) {
+function bq(e) {
     var t = e.getDay();
     return t === 0 ? 7 : t;
 }
 
-function uX(e, t) {
-    return Ht(Rc.count(Di(e) - 1, e), t, 2);
+function wq(e, t) {
+    return kt(Ko.count(Yn(e) - 1, e), t, 2);
 }
 
-function u6(e) {
+function n6(e) {
     var t = e.getDay();
-    return t >= 4 || t === 0 ? na(e) : na.ceil(e);
+    return t >= 4 || t === 0 ? ks(e) : ks.ceil(e);
 }
 
-function fX(e, t) {
-    return e = u6(e), Ht(na.count(Di(e), e) + (Di(e).getDay() === 4), t, 2);
+function vq(e, t) {
+    return e = n6(e), kt(ks.count(Yn(e), e) + (Yn(e).getDay() === 4), t, 2);
 }
 
-function hX(e) {
+function _q(e) {
     return e.getDay();
 }
 
-function dX(e, t) {
-    return Ht(Pu.count(Di(e) - 1, e), t, 2);
+function xq(e, t) {
+    return kt(Cc.count(Yn(e) - 1, e), t, 2);
 }
 
-function pX(e, t) {
-    return Ht(e.getFullYear() % 100, t, 2);
+function Sq(e, t) {
+    return kt(e.getFullYear() % 100, t, 2);
 }
 
-function yX(e, t) {
-    return e = u6(e), Ht(e.getFullYear() % 100, t, 2);
+function Mq(e, t) {
+    return e = n6(e), kt(e.getFullYear() % 100, t, 2);
 }
 
-function mX(e, t) {
-    return Ht(e.getFullYear() % 1e4, t, 4);
+function Aq(e, t) {
+    return kt(e.getFullYear() % 1e4, t, 4);
 }
 
-function gX(e, t) {
+function $q(e, t) {
     var n = e.getDay();
-    return e = n >= 4 || n === 0 ? na(e) : na.ceil(e), Ht(e.getFullYear() % 1e4, t, 4);
+    return e = n >= 4 || n === 0 ? ks(e) : ks.ceil(e), kt(e.getFullYear() % 1e4, t, 4);
 }
 
-function bX(e) {
+function Iq(e) {
     var t = e.getTimezoneOffset();
-    return (t > 0 ? "-" : (t *= -1, "+")) + Ht(t / 60 | 0, "0", 2) + Ht(t % 60, "0", 2);
+    return (t > 0 ? "-" : (t *= -1, "+")) + kt(t / 60 | 0, "0", 2) + kt(t % 60, "0", 2);
 }
 
-function Ox(e, t) {
-    return Ht(e.getUTCDate(), t, 2);
+function Gw(e, t) {
+    return kt(e.getUTCDate(), t, 2);
 }
 
-function wX(e, t) {
-    return Ht(e.getUTCHours(), t, 2);
+function Tq(e, t) {
+    return kt(e.getUTCHours(), t, 2);
 }
 
-function vX(e, t) {
-    return Ht(e.getUTCHours() % 12 || 12, t, 2);
+function Eq(e, t) {
+    return kt(e.getUTCHours() % 12 || 12, t, 2);
 }
 
-function _X(e, t) {
-    return Ht(1 + l0.count(Ni(e), e), t, 3);
+function Nq(e, t) {
+    return kt(1 + sd.count(Wn(e), e), t, 3);
 }
 
-function f6(e, t) {
-    return Ht(e.getUTCMilliseconds(), t, 3);
+function r6(e, t) {
+    return kt(e.getUTCMilliseconds(), t, 3);
 }
 
-function xX(e, t) {
-    return f6(e, t) + "000";
+function Dq(e, t) {
+    return r6(e, t) + "000";
 }
 
-function SX(e, t) {
-    return Ht(e.getUTCMonth() + 1, t, 2);
+function Oq(e, t) {
+    return kt(e.getUTCMonth() + 1, t, 2);
 }
 
-function IX(e, t) {
-    return Ht(e.getUTCMinutes(), t, 2);
+function Lq(e, t) {
+    return kt(e.getUTCMinutes(), t, 2);
 }
 
-function AX(e, t) {
-    return Ht(e.getUTCSeconds(), t, 2);
+function kq(e, t) {
+    return kt(e.getUTCSeconds(), t, 2);
 }
 
-function MX(e) {
+function Rq(e) {
     var t = e.getUTCDay();
     return t === 0 ? 7 : t;
 }
 
-function $X(e, t) {
-    return Ht(Cc.count(Ni(e) - 1, e), t, 2);
+function Fq(e, t) {
+    return kt(Qo.count(Wn(e) - 1, e), t, 2);
 }
 
-function h6(e) {
+function i6(e) {
     var t = e.getUTCDay();
-    return t >= 4 || t === 0 ? ia(e) : ia.ceil(e);
+    return t >= 4 || t === 0 ? Rs(e) : Rs.ceil(e);
 }
 
-function TX(e, t) {
-    return e = h6(e), Ht(ia.count(Ni(e), e) + (Ni(e).getUTCDay() === 4), t, 2);
+function Bq(e, t) {
+    return e = i6(e), kt(Rs.count(Wn(e), e) + (Wn(e).getUTCDay() === 4), t, 2);
 }
 
-function DX(e) {
+function Cq(e) {
     return e.getUTCDay();
 }
 
-function NX(e, t) {
-    return Ht(Vu.count(Ni(e) - 1, e), t, 2);
+function Pq(e, t) {
+    return kt(Pc.count(Wn(e) - 1, e), t, 2);
 }
 
-function BX(e, t) {
-    return Ht(e.getUTCFullYear() % 100, t, 2);
+function Uq(e, t) {
+    return kt(e.getUTCFullYear() % 100, t, 2);
 }
 
-function OX(e, t) {
-    return e = h6(e), Ht(e.getUTCFullYear() % 100, t, 2);
+function zq(e, t) {
+    return e = i6(e), kt(e.getUTCFullYear() % 100, t, 2);
 }
 
-function FX(e, t) {
-    return Ht(e.getUTCFullYear() % 1e4, t, 4);
+function qq(e, t) {
+    return kt(e.getUTCFullYear() % 1e4, t, 4);
 }
 
-function EX(e, t) {
+function jq(e, t) {
     var n = e.getUTCDay();
-    return e = n >= 4 || n === 0 ? ia(e) : ia.ceil(e), Ht(e.getUTCFullYear() % 1e4, t, 4);
+    return e = n >= 4 || n === 0 ? Rs(e) : Rs.ceil(e), kt(e.getUTCFullYear() % 1e4, t, 4);
 }
 
-function LX() {
+function Vq() {
     return "+0000";
 }
 
-function Fx() {
+function Hw() {
     return "%";
 }
 
-function Ex(e) {
+function Jw(e) {
     return +e;
 }
 
-function Lx(e) {
+function Zw(e) {
     return Math.floor(+e / 1e3);
 }
-var Sa, hw, Of;
-RX({
+var Qs, Wm, _u;
+Yq({
     dateTime: "%x, %X",
     date: "%-m/%-d/%Y",
     time: "%-I:%M:%S %p",
     periods: ["AM", "PM"],
     days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
     shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
     months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
     shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
 });
 
-function RX(e) {
-    return Sa = RG(e), hw = Sa.format, Sa.parse, Of = Sa.utcFormat, Sa.utcParse, Sa;
+function Yq(e) {
+    return Qs = Yz(e), Wm = Qs.format, Qs.parse, _u = Qs.utcFormat, Qs.utcParse, Qs;
 }
 
-function CX(e) {
+function Wq(e) {
     return new Date(e);
 }
 
-function kX(e) {
+function Xq(e) {
     return e instanceof Date ? +e : + /* @__PURE__ */ new Date(+e);
 }
 
-function dw(e, t, n, i, r, s, o, a, c, l) {
-    var u = V$(),
-        f = u.invert,
-        h = u.domain,
-        d = l(".%L"),
-        p = l(":%S"),
-        m = l("%I:%M"),
-        g = l("%I %p"),
-        y = l("%a %d"),
-        b = l("%b %d"),
-        w = l("%B"),
-        v = l("%Y");
+function Xm(e, t, n, r, i, s, o, a, c, u) {
+    var l = k3(),
+        f = l.invert,
+        h = l.domain,
+        d = u(".%L"),
+        p = u(":%S"),
+        y = u("%I:%M"),
+        m = u("%I %p"),
+        g = u("%a %d"),
+        b = u("%b %d"),
+        w = u("%B"),
+        v = u("%Y");
 
     function x(_) {
-        return (c(_) < _ ? d : a(_) < _ ? p : o(_) < _ ? m : s(_) < _ ? g : i(_) < _ ? r(_) < _ ? y : b : n(_) < _ ? w : v)(_);
+        return (c(_) < _ ? d : a(_) < _ ? p : o(_) < _ ? y : s(_) < _ ? m : r(_) < _ ? i(_) < _ ? g : b : n(_) < _ ? w : v)(_);
     }
-    return u.invert = function(_) {
+    return l.invert = function(_) {
         return new Date(f(_));
-    }, u.domain = function(_) {
-        return arguments.length ? h(Array.from(_, kX)) : h().map(CX);
-    }, u.ticks = function(_) {
-        var I = h();
-        return e(I[0], I[I.length - 1], _ ?? 10);
-    }, u.tickFormat = function(_, I) {
-        return I == null ? x : l(I);
-    }, u.nice = function(_) {
-        var I = h();
-        return (!_ || typeof _.range != "function") && (_ = t(I[0], I[I.length - 1], _ ?? 10)), _ ? h(q$(I, _)) : u;
-    }, u.copy = function() {
-        return If(u, dw(e, t, n, i, r, s, o, a, c, l));
-    }, u;
+    }, l.domain = function(_) {
+        return arguments.length ? h(Array.from(_, Xq)) : h().map(Wq);
+    }, l.ticks = function(_) {
+        var M = h();
+        return e(M[0], M[M.length - 1], _ ?? 10);
+    }, l.tickFormat = function(_, M) {
+        return M == null ? x : u(M);
+    }, l.nice = function(_) {
+        var M = h();
+        return (!_ || typeof _.range != "function") && (_ = t(M[0], M[M.length - 1], _ ?? 10)), _ ? h(F3(M, _)) : l;
+    }, l.copy = function() {
+        return du(l, Xm(e, t, n, r, i, s, o, a, c, u));
+    }, l;
 }
 
-function UX() {
-    return br.apply(dw(EG, LG, Di, Nf, Rc, aa, Tf, Mf, xi, hw).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
+function Gq() {
+    return Mr.apply(Xm(jz, Vz, Yn, wu, Ko, Ps, gu, yu, Bn, Wm).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
 }
 
-function zX() {
-    return br.apply(dw(FG, c6, Ni, Bf, Cc, l0, Df, $f, xi, Of).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
+function Hq() {
+    return Mr.apply(Xm(qz, t6, Wn, vu, Qo, sd, bu, mu, Bn, _u).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
 }
 
-function f0(e, t) {
+function ad(e, t) {
     return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
 }
 
-function h0() {
+function cd() {
     var e = 0,
         t = 0.5,
         n = 1,
-        i = 1,
-        r, s, o, a, c, l = ri,
-        u, f = !1,
+        r = 1,
+        i, s, o, a, c, u = xn,
+        l, f = !1,
         h;
 
-    function d(m) {
-        return isNaN(m = +m) ? h : (m = 0.5 + ((m = +u(m)) - s) * (i * m < i * s ? a : c), l(f ? Math.max(0, Math.min(1, m)) : m));
+    function d(y) {
+        return isNaN(y = +y) ? h : (y = 0.5 + ((y = +l(y)) - s) * (r * y < r * s ? a : c), u(f ? Math.max(0, Math.min(1, y)) : y));
     }
-    d.domain = function(m) {
-        return arguments.length ? ([e, t, n] = m, r = u(e = +e), s = u(t = +t), o = u(n = +n), a = r === s ? 0 : 0.5 / (s - r), c = s === o ? 0 : 0.5 / (o - s), i = s < r ? -1 : 1, d) : [e, t, n];
-    }, d.clamp = function(m) {
-        return arguments.length ? (f = !!m, d) : f;
-    }, d.interpolator = function(m) {
-        return arguments.length ? (l = m, d) : l;
+    d.domain = function(y) {
+        return arguments.length ? ([e, t, n] = y, i = l(e = +e), s = l(t = +t), o = l(n = +n), a = i === s ? 0 : 0.5 / (s - i), c = s === o ? 0 : 0.5 / (o - s), r = s < i ? -1 : 1, d) : [e, t, n];
+    }, d.clamp = function(y) {
+        return arguments.length ? (f = !!y, d) : f;
+    }, d.interpolator = function(y) {
+        return arguments.length ? (u = y, d) : u;
     };
 
-    function p(m) {
-        return function(g) {
-            var y, b, w;
-            return arguments.length ? ([y, b, w] = g, l = t0(m, [y, b, w]), d) : [l(0), l(0.5), l(1)];
+    function p(y) {
+        return function(m) {
+            var g, b, w;
+            return arguments.length ? ([g, b, w] = m, u = Jh(y, [g, b, w]), d) : [u(0), u(0.5), u(1)];
         };
     }
-    return d.range = p(il), d.rangeRound = p(Zb), d.unknown = function(m) {
-            return arguments.length ? (h = m, d) : h;
+    return d.range = p(ya), d.rangeRound = p(Dm), d.unknown = function(y) {
+            return arguments.length ? (h = y, d) : h;
         },
-        function(m) {
-            return u = m, r = m(e), s = m(t), o = m(n), a = r === s ? 0 : 0.5 / (s - r), c = s === o ? 0 : 0.5 / (o - s), i = s < r ? -1 : 1, d;
+        function(y) {
+            return l = y, i = y(e), s = y(t), o = y(n), a = i === s ? 0 : 0.5 / (s - i), c = s === o ? 0 : 0.5 / (o - s), r = s < i ? -1 : 1, d;
         };
 }
 
-function d6() {
-    var e = Af(h0()(ri));
+function s6() {
+    var e = pu(cd()(xn));
     return e.copy = function() {
-        return f0(e, d6());
-    }, s0.apply(e, arguments);
+        return ad(e, s6());
+    }, ed.apply(e, arguments);
 }
 
-function p6() {
-    var e = Y$(h0()).domain([0.1, 1, 10]);
+function o6() {
+    var e = B3(cd()).domain([0.1, 1, 10]);
     return e.copy = function() {
-        return f0(e, p6()).base(e.base());
-    }, s0.apply(e, arguments);
+        return ad(e, o6()).base(e.base());
+    }, ed.apply(e, arguments);
 }
 
-function y6() {
-    var e = G$(h0());
+function a6() {
+    var e = P3(cd());
     return e.copy = function() {
-        return f0(e, y6()).constant(e.constant());
-    }, s0.apply(e, arguments);
+        return ad(e, a6()).constant(e.constant());
+    }, ed.apply(e, arguments);
 }
 
-function m6() {
-    var e = H$(h0());
+function c6() {
+    var e = z3(cd());
     return e.copy = function() {
-        return f0(e, m6()).exponent(e.exponent());
-    }, s0.apply(e, arguments);
+        return ad(e, c6()).exponent(e.exponent());
+    }, ed.apply(e, arguments);
 }
 
-function Et(e) {
-    for (var t = e.length / 6 | 0, n = new Array(t), i = 0; i < t;)
-        n[i] = "#" + e.slice(i * 6, ++i * 6);
+function vt(e) {
+    for (var t = e.length / 6 | 0, n = new Array(t), r = 0; r < t;)
+        n[r] = "#" + e.slice(r * 6, ++r * 6);
     return n;
 }
-const PX = Et("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),
-    VX = Et("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),
-    jX = Et("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),
-    qX = Et("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"),
-    YX = Et("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),
-    WX = Et("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"),
-    GX = Et("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"),
-    XX = Et("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"),
-    HX = Et("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),
-    JX = Et("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"),
-    KX = Et("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"),
-    le = (e) => tj(e[e.length - 1]);
-var g6 = new Array(3).concat(
+const Jq = vt("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),
+    Zq = vt("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),
+    Kq = vt("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),
+    Qq = vt("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"),
+    tj = vt("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),
+    ej = vt("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"),
+    nj = vt("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"),
+    rj = vt("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"),
+    ij = vt("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),
+    sj = vt("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"),
+    oj = vt("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"),
+    Xt = (e) => uB(e[e.length - 1]);
+var u6 = new Array(3).concat(
     "d8b365f5f5f55ab4ac",
     "a6611adfc27d80cdc1018571",
     "a6611adfc27df5f5f580cdc1018571",
     "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
     "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
     "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
     "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
     "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
     "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
-).map(Et);
-const b6 = le(g6);
-var w6 = new Array(3).concat(
+).map(vt);
+const l6 = Xt(u6);
+var f6 = new Array(3).concat(
     "af8dc3f7f7f77fbf7b",
     "7b3294c2a5cfa6dba0008837",
     "7b3294c2a5cff7f7f7a6dba0008837",
     "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
     "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
     "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
     "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
     "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
     "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
-).map(Et);
-const v6 = le(w6);
-var _6 = new Array(3).concat(
+).map(vt);
+const h6 = Xt(f6);
+var d6 = new Array(3).concat(
     "e9a3c9f7f7f7a1d76a",
     "d01c8bf1b6dab8e1864dac26",
     "d01c8bf1b6daf7f7f7b8e1864dac26",
     "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
     "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
     "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
     "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
     "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
     "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
-).map(Et);
-const x6 = le(_6);
-var S6 = new Array(3).concat(
+).map(vt);
+const p6 = Xt(d6);
+var y6 = new Array(3).concat(
     "998ec3f7f7f7f1a340",
     "5e3c99b2abd2fdb863e66101",
     "5e3c99b2abd2f7f7f7fdb863e66101",
     "542788998ec3d8daebfee0b6f1a340b35806",
     "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
     "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
     "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
     "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
     "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
-).map(Et);
-const I6 = le(S6);
-var x1 = new Array(3).concat(
+).map(vt);
+const m6 = Xt(y6);
+var ly = new Array(3).concat(
     "ef8a62f7f7f767a9cf",
     "ca0020f4a58292c5de0571b0",
     "ca0020f4a582f7f7f792c5de0571b0",
     "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
     "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
     "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
     "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
     "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
     "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
-).map(Et);
-const Np = le(x1);
-var A6 = new Array(3).concat(
+).map(vt);
+const rh = Xt(ly);
+var g6 = new Array(3).concat(
     "ef8a62ffffff999999",
     "ca0020f4a582bababa404040",
     "ca0020f4a582ffffffbababa404040",
     "b2182bef8a62fddbc7e0e0e09999994d4d4d",
     "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
     "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
     "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
     "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
     "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
-).map(Et);
-const M6 = le(A6);
-var S1 = new Array(3).concat(
+).map(vt);
+const b6 = Xt(g6);
+var fy = new Array(3).concat(
     "fc8d59ffffbf91bfdb",
     "d7191cfdae61abd9e92c7bb6",
     "d7191cfdae61ffffbfabd9e92c7bb6",
     "d73027fc8d59fee090e0f3f891bfdb4575b4",
     "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
     "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
     "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
     "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
     "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
-).map(Et);
-const Bp = le(S1);
-var $6 = new Array(3).concat(
+).map(vt);
+const ih = Xt(fy);
+var w6 = new Array(3).concat(
     "fc8d59ffffbf91cf60",
     "d7191cfdae61a6d96a1a9641",
     "d7191cfdae61ffffbfa6d96a1a9641",
     "d73027fc8d59fee08bd9ef8b91cf601a9850",
     "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
     "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
     "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
     "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
     "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
-).map(Et);
-const T6 = le($6);
-var D6 = new Array(3).concat(
+).map(vt);
+const v6 = Xt(w6);
+var _6 = new Array(3).concat(
     "fc8d59ffffbf99d594",
     "d7191cfdae61abdda42b83ba",
     "d7191cfdae61ffffbfabdda42b83ba",
     "d53e4ffc8d59fee08be6f59899d5943288bd",
     "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
     "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
     "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
     "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
     "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
-).map(Et);
-const N6 = le(D6);
-var B6 = new Array(3).concat(
+).map(vt);
+const x6 = Xt(_6);
+var S6 = new Array(3).concat(
     "e5f5f999d8c92ca25f",
     "edf8fbb2e2e266c2a4238b45",
     "edf8fbb2e2e266c2a42ca25f006d2c",
     "edf8fbccece699d8c966c2a42ca25f006d2c",
     "edf8fbccece699d8c966c2a441ae76238b45005824",
     "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
     "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
-).map(Et);
-const O6 = le(B6);
-var F6 = new Array(3).concat(
+).map(vt);
+const M6 = Xt(S6);
+var A6 = new Array(3).concat(
     "e0ecf49ebcda8856a7",
     "edf8fbb3cde38c96c688419d",
     "edf8fbb3cde38c96c68856a7810f7c",
     "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
     "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
     "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
     "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
-).map(Et);
-const E6 = le(F6);
-var L6 = new Array(3).concat(
+).map(vt);
+const $6 = Xt(A6);
+var I6 = new Array(3).concat(
     "e0f3dba8ddb543a2ca",
     "f0f9e8bae4bc7bccc42b8cbe",
     "f0f9e8bae4bc7bccc443a2ca0868ac",
     "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
     "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
     "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
     "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
-).map(Et);
-const R6 = le(L6);
-var C6 = new Array(3).concat(
+).map(vt);
+const T6 = Xt(I6);
+var E6 = new Array(3).concat(
     "fee8c8fdbb84e34a33",
     "fef0d9fdcc8afc8d59d7301f",
     "fef0d9fdcc8afc8d59e34a33b30000",
     "fef0d9fdd49efdbb84fc8d59e34a33b30000",
     "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
     "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
     "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
-).map(Et);
-const k6 = le(C6);
-var U6 = new Array(3).concat(
+).map(vt);
+const N6 = Xt(E6);
+var D6 = new Array(3).concat(
     "ece2f0a6bddb1c9099",
     "f6eff7bdc9e167a9cf02818a",
     "f6eff7bdc9e167a9cf1c9099016c59",
     "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
     "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
     "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
     "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
-).map(Et);
-const z6 = le(U6);
-var P6 = new Array(3).concat(
+).map(vt);
+const O6 = Xt(D6);
+var L6 = new Array(3).concat(
     "ece7f2a6bddb2b8cbe",
     "f1eef6bdc9e174a9cf0570b0",
     "f1eef6bdc9e174a9cf2b8cbe045a8d",
     "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
     "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
     "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
     "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
-).map(Et);
-const V6 = le(P6);
-var j6 = new Array(3).concat(
+).map(vt);
+const k6 = Xt(L6);
+var R6 = new Array(3).concat(
     "e7e1efc994c7dd1c77",
     "f1eef6d7b5d8df65b0ce1256",
     "f1eef6d7b5d8df65b0dd1c77980043",
     "f1eef6d4b9dac994c7df65b0dd1c77980043",
     "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
     "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
     "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
-).map(Et);
-const q6 = le(j6);
-var Y6 = new Array(3).concat(
+).map(vt);
+const F6 = Xt(R6);
+var B6 = new Array(3).concat(
     "fde0ddfa9fb5c51b8a",
     "feebe2fbb4b9f768a1ae017e",
     "feebe2fbb4b9f768a1c51b8a7a0177",
     "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
     "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
     "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
     "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
-).map(Et);
-const W6 = le(Y6);
-var G6 = new Array(3).concat(
+).map(vt);
+const C6 = Xt(B6);
+var P6 = new Array(3).concat(
     "edf8b17fcdbb2c7fb8",
     "ffffcca1dab441b6c4225ea8",
     "ffffcca1dab441b6c42c7fb8253494",
     "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
     "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
     "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
     "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
-).map(Et);
-const X6 = le(G6);
-var H6 = new Array(3).concat(
+).map(vt);
+const U6 = Xt(P6);
+var z6 = new Array(3).concat(
     "f7fcb9addd8e31a354",
     "ffffccc2e69978c679238443",
     "ffffccc2e69978c67931a354006837",
     "ffffccd9f0a3addd8e78c67931a354006837",
     "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
     "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
     "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
-).map(Et);
-const J6 = le(H6);
-var K6 = new Array(3).concat(
+).map(vt);
+const q6 = Xt(z6);
+var j6 = new Array(3).concat(
     "fff7bcfec44fd95f0e",
     "ffffd4fed98efe9929cc4c02",
     "ffffd4fed98efe9929d95f0e993404",
     "ffffd4fee391fec44ffe9929d95f0e993404",
     "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
     "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
     "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
-).map(Et);
-const Z6 = le(K6);
-var Q6 = new Array(3).concat(
+).map(vt);
+const V6 = Xt(j6);
+var Y6 = new Array(3).concat(
     "ffeda0feb24cf03b20",
     "ffffb2fecc5cfd8d3ce31a1c",
     "ffffb2fecc5cfd8d3cf03b20bd0026",
     "ffffb2fed976feb24cfd8d3cf03b20bd0026",
     "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
     "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
     "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
-).map(Et);
-const tT = le(Q6);
-var eT = new Array(3).concat(
+).map(vt);
+const W6 = Xt(Y6);
+var X6 = new Array(3).concat(
     "deebf79ecae13182bd",
     "eff3ffbdd7e76baed62171b5",
     "eff3ffbdd7e76baed63182bd08519c",
     "eff3ffc6dbef9ecae16baed63182bd08519c",
     "eff3ffc6dbef9ecae16baed64292c62171b5084594",
     "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
     "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
-).map(Et);
-const nT = le(eT);
-var iT = new Array(3).concat(
+).map(vt);
+const G6 = Xt(X6);
+var H6 = new Array(3).concat(
     "e5f5e0a1d99b31a354",
     "edf8e9bae4b374c476238b45",
     "edf8e9bae4b374c47631a354006d2c",
     "edf8e9c7e9c0a1d99b74c47631a354006d2c",
     "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
     "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
     "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
-).map(Et);
-const rT = le(iT);
-var sT = new Array(3).concat(
+).map(vt);
+const J6 = Xt(H6);
+var Z6 = new Array(3).concat(
     "f0f0f0bdbdbd636363",
     "f7f7f7cccccc969696525252",
     "f7f7f7cccccc969696636363252525",
     "f7f7f7d9d9d9bdbdbd969696636363252525",
     "f7f7f7d9d9d9bdbdbd969696737373525252252525",
     "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
     "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
-).map(Et);
-const oT = le(sT);
-var aT = new Array(3).concat(
+).map(vt);
+const K6 = Xt(Z6);
+var Q6 = new Array(3).concat(
     "efedf5bcbddc756bb1",
     "f2f0f7cbc9e29e9ac86a51a3",
     "f2f0f7cbc9e29e9ac8756bb154278f",
     "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
     "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
     "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
     "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
-).map(Et);
-const cT = le(aT);
-var lT = new Array(3).concat(
+).map(vt);
+const tM = Xt(Q6);
+var eM = new Array(3).concat(
     "fee0d2fc9272de2d26",
     "fee5d9fcae91fb6a4acb181d",
     "fee5d9fcae91fb6a4ade2d26a50f15",
     "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
     "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
     "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
     "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
-).map(Et);
-const uT = le(lT);
-var fT = new Array(3).concat(
+).map(vt);
+const nM = Xt(eM);
+var rM = new Array(3).concat(
     "fee6cefdae6be6550d",
     "feeddefdbe85fd8d3cd94701",
     "feeddefdbe85fd8d3ce6550da63603",
     "feeddefdd0a2fdae6bfd8d3ce6550da63603",
     "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
     "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
     "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
-).map(Et);
-const hT = le(fT);
+).map(vt);
+const iM = Xt(rM);
 
-function dT(e) {
+function sM(e) {
     return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - e * (35.34 - e * (2381.73 - e * (6402.7 - e * (7024.72 - e * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + e * (170.73 + e * (52.82 - e * (131.46 - e * (176.58 - e * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + e * (442.36 - e * (2482.43 - e * (6167.24 - e * (6614.94 - e * 2475.67))))))) + ")";
 }
-const pT = Qb(hr(300, 0.5, 0), hr(-240, 0.5, 1));
-var yT = Qb(hr(-100, 0.75, 0.35), hr(80, 1.5, 0.8)),
-    mT = Qb(hr(260, 0.75, 0.35), hr(80, 1.5, 0.8)),
-    wh = hr();
+const oM = Om(vr(300, 0.5, 0), vr(-240, 0.5, 1));
+var aM = Om(vr(-100, 0.75, 0.35), vr(80, 1.5, 0.8)),
+    cM = Om(vr(260, 0.75, 0.35), vr(80, 1.5, 0.8)),
+    il = vr();
 
-function gT(e) {
+function uM(e) {
     (e < 0 || e > 1) && (e -= Math.floor(e));
     var t = Math.abs(e - 0.5);
-    return wh.h = 360 * e - 100, wh.s = 1.5 - 1.5 * t, wh.l = 0.8 - 0.9 * t, wh + "";
+    return il.h = 360 * e - 100, il.s = 1.5 - 1.5 * t, il.l = 0.8 - 0.9 * t, il + "";
 }
-var vh = Pn(),
-    ZX = Math.PI / 3,
-    QX = Math.PI * 2 / 3;
+var sl = un(),
+    aj = Math.PI / 3,
+    cj = Math.PI * 2 / 3;
 
-function bT(e) {
+function lM(e) {
     var t;
-    return e = (0.5 - e) * Math.PI, vh.r = 255 * (t = Math.sin(e)) * t, vh.g = 255 * (t = Math.sin(e + ZX)) * t, vh.b = 255 * (t = Math.sin(e + QX)) * t, vh + "";
+    return e = (0.5 - e) * Math.PI, sl.r = 255 * (t = Math.sin(e)) * t, sl.g = 255 * (t = Math.sin(e + aj)) * t, sl.b = 255 * (t = Math.sin(e + cj)) * t, sl + "";
 }
 
-function wT(e) {
+function fM(e) {
     return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + e * (1172.33 - e * (10793.56 - e * (33300.12 - e * (38394.49 - e * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + e * (557.33 + e * (1225.33 - e * (3574.96 - e * (1073.77 + e * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + e * (3211.1 - e * (15327.97 - e * (27814 - e * (22569.18 - e * 6838.66))))))) + ")";
 }
 
-function d0(e) {
+function ud(e) {
     var t = e.length;
     return function(n) {
         return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
     };
 }
-const vT = d0(Et("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
-var _T = d0(Et("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),
-    xT = d0(Et("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),
-    ST = d0(Et("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
+const hM = ud(vt("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
+var dM = ud(vt("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),
+    pM = ud(vt("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),
+    yM = ud(vt("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
 
-function je(e) {
+function be(e) {
     return function() {
         return e;
     };
 }
-const IT = Math.cos,
-    pw = Math.min,
-    Op = Math.sin,
-    ze = Math.sqrt,
-    Rx = 1e-12,
-    Fp = Math.PI,
-    p0 = 2 * Fp;
+const mM = Math.cos,
+    Gm = Math.min,
+    sh = Math.sin,
+    ye = Math.sqrt,
+    Kw = 1e-12,
+    oh = Math.PI,
+    ld = 2 * oh;
 
-function AT(e) {
+function gM(e) {
     let t = 3;
     return e.digits = function(n) {
         if (!arguments.length)
             return t;
         if (n == null)
             t = null;
         else {
-            const i = Math.floor(n);
-            if (!(i >= 0))
+            const r = Math.floor(n);
+            if (!(r >= 0))
                 throw new RangeError(`invalid digits: ${n}`);
-            t = i;
+            t = r;
         }
         return e;
-    }, () => new Z3(t);
+    }, () => new VS(t);
 }
 
-function MT(e) {
+function bM(e) {
     return typeof e == "object" && "length" in e ? e : Array.from(e);
 }
 
-function $T(e) {
+function wM(e) {
     this._context = e;
 }
-$T.prototype = {
+wM.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -21322,115 +21885,115 @@
             default:
                 this._context.lineTo(e, t);
                 break;
         }
     }
 };
 
-function Ff(e) {
-    return new $T(e);
+function xu(e) {
+    return new wM(e);
 }
 
-function TT(e) {
+function vM(e) {
     return e[0];
 }
 
-function DT(e) {
+function _M(e) {
     return e[1];
 }
 
-function NT(e, t) {
-    var n = je(!0),
-        i = null,
-        r = Ff,
+function xM(e, t) {
+    var n = be(!0),
+        r = null,
+        i = xu,
         s = null,
-        o = AT(a);
-    e = typeof e == "function" ? e : e === void 0 ? TT : je(e), t = typeof t == "function" ? t : t === void 0 ? DT : je(t);
+        o = gM(a);
+    e = typeof e == "function" ? e : e === void 0 ? vM : be(e), t = typeof t == "function" ? t : t === void 0 ? _M : be(t);
 
     function a(c) {
-        var l, u = (c = MT(c)).length,
+        var u, l = (c = bM(c)).length,
             f, h = !1,
             d;
-        for (i == null && (s = r(d = o())), l = 0; l <= u; ++l)
-            !(l < u && n(f = c[l], l, c)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(f, l, c), +t(f, l, c));
+        for (r == null && (s = i(d = o())), u = 0; u <= l; ++u)
+            !(u < l && n(f = c[u], u, c)) === h && ((h = !h) ? s.lineStart() : s.lineEnd()), h && s.point(+e(f, u, c), +t(f, u, c));
         if (d)
             return s = null, d + "" || null;
     }
     return a.x = function(c) {
-        return arguments.length ? (e = typeof c == "function" ? c : je(+c), a) : e;
+        return arguments.length ? (e = typeof c == "function" ? c : be(+c), a) : e;
     }, a.y = function(c) {
-        return arguments.length ? (t = typeof c == "function" ? c : je(+c), a) : t;
+        return arguments.length ? (t = typeof c == "function" ? c : be(+c), a) : t;
     }, a.defined = function(c) {
-        return arguments.length ? (n = typeof c == "function" ? c : je(!!c), a) : n;
+        return arguments.length ? (n = typeof c == "function" ? c : be(!!c), a) : n;
     }, a.curve = function(c) {
-        return arguments.length ? (r = c, i != null && (s = r(i)), a) : r;
+        return arguments.length ? (i = c, r != null && (s = i(r)), a) : i;
     }, a.context = function(c) {
-        return arguments.length ? (c == null ? i = s = null : s = r(i = c), a) : i;
+        return arguments.length ? (c == null ? r = s = null : s = i(r = c), a) : r;
     }, a;
 }
 
-function yw(e, t, n) {
-    var i = null,
-        r = je(!0),
+function Hm(e, t, n) {
+    var r = null,
+        i = be(!0),
         s = null,
-        o = Ff,
+        o = xu,
         a = null,
-        c = AT(l);
-    e = typeof e == "function" ? e : e === void 0 ? TT : je(+e), t = typeof t == "function" ? t : je(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? DT : je(+n);
+        c = gM(u);
+    e = typeof e == "function" ? e : e === void 0 ? vM : be(+e), t = typeof t == "function" ? t : be(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? _M : be(+n);
 
-    function l(f) {
-        var h, d, p, m = (f = MT(f)).length,
-            g, y = !1,
-            b, w = new Array(m),
-            v = new Array(m);
-        for (s == null && (a = o(b = c())), h = 0; h <= m; ++h) {
-            if (!(h < m && r(g = f[h], h, f)) === y)
-                if (y = !y)
+    function u(f) {
+        var h, d, p, y = (f = bM(f)).length,
+            m, g = !1,
+            b, w = new Array(y),
+            v = new Array(y);
+        for (s == null && (a = o(b = c())), h = 0; h <= y; ++h) {
+            if (!(h < y && i(m = f[h], h, f)) === g)
+                if (g = !g)
                     d = h, a.areaStart(), a.lineStart();
                 else {
                     for (a.lineEnd(), a.lineStart(), p = h - 1; p >= d; --p)
                         a.point(w[p], v[p]);
                     a.lineEnd(), a.areaEnd();
                 }
-            y && (w[h] = +e(g, h, f), v[h] = +t(g, h, f), a.point(i ? +i(g, h, f) : w[h], n ? +n(g, h, f) : v[h]));
+            g && (w[h] = +e(m, h, f), v[h] = +t(m, h, f), a.point(r ? +r(m, h, f) : w[h], n ? +n(m, h, f) : v[h]));
         }
         if (b)
             return a = null, b + "" || null;
     }
 
-    function u() {
-        return NT().defined(r).curve(o).context(s);
+    function l() {
+        return xM().defined(i).curve(o).context(s);
     }
-    return l.x = function(f) {
-        return arguments.length ? (e = typeof f == "function" ? f : je(+f), i = null, l) : e;
-    }, l.x0 = function(f) {
-        return arguments.length ? (e = typeof f == "function" ? f : je(+f), l) : e;
-    }, l.x1 = function(f) {
-        return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : je(+f), l) : i;
-    }, l.y = function(f) {
-        return arguments.length ? (t = typeof f == "function" ? f : je(+f), n = null, l) : t;
-    }, l.y0 = function(f) {
-        return arguments.length ? (t = typeof f == "function" ? f : je(+f), l) : t;
-    }, l.y1 = function(f) {
-        return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : je(+f), l) : n;
-    }, l.lineX0 = l.lineY0 = function() {
-        return u().x(e).y(t);
-    }, l.lineY1 = function() {
-        return u().x(e).y(n);
-    }, l.lineX1 = function() {
-        return u().x(i).y(t);
-    }, l.defined = function(f) {
-        return arguments.length ? (r = typeof f == "function" ? f : je(!!f), l) : r;
-    }, l.curve = function(f) {
-        return arguments.length ? (o = f, s != null && (a = o(s)), l) : o;
-    }, l.context = function(f) {
-        return arguments.length ? (f == null ? s = a = null : a = o(s = f), l) : s;
-    }, l;
+    return u.x = function(f) {
+        return arguments.length ? (e = typeof f == "function" ? f : be(+f), r = null, u) : e;
+    }, u.x0 = function(f) {
+        return arguments.length ? (e = typeof f == "function" ? f : be(+f), u) : e;
+    }, u.x1 = function(f) {
+        return arguments.length ? (r = f == null ? null : typeof f == "function" ? f : be(+f), u) : r;
+    }, u.y = function(f) {
+        return arguments.length ? (t = typeof f == "function" ? f : be(+f), n = null, u) : t;
+    }, u.y0 = function(f) {
+        return arguments.length ? (t = typeof f == "function" ? f : be(+f), u) : t;
+    }, u.y1 = function(f) {
+        return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : be(+f), u) : n;
+    }, u.lineX0 = u.lineY0 = function() {
+        return l().x(e).y(t);
+    }, u.lineY1 = function() {
+        return l().x(e).y(n);
+    }, u.lineX1 = function() {
+        return l().x(r).y(t);
+    }, u.defined = function(f) {
+        return arguments.length ? (i = typeof f == "function" ? f : be(!!f), u) : i;
+    }, u.curve = function(f) {
+        return arguments.length ? (o = f, s != null && (a = o(s)), u) : o;
+    }, u.context = function(f) {
+        return arguments.length ? (f == null ? s = a = null : a = o(s = f), u) : s;
+    }, u;
 }
-class BT {
+class SM {
     constructor(t, n) {
         this._context = t, this._x = n;
     }
     areaStart() {
         this._line = 0;
     }
     areaEnd() {
@@ -21455,182 +22018,182 @@
                 break;
             }
         }
         this._x0 = t, this._y0 = n;
     }
 }
 
-function tH(e) {
-    return new BT(e, !0);
+function uj(e) {
+    return new SM(e, !0);
 }
 
-function eH(e) {
-    return new BT(e, !1);
+function lj(e) {
+    return new SM(e, !1);
 }
-const nH = ze(3),
-    OT = {
+const fj = ye(3),
+    MM = {
         draw(e, t) {
-            const n = ze(t + pw(t / 28, 0.75)) * 0.59436,
-                i = n / 2,
-                r = i * nH;
-            e.moveTo(0, n), e.lineTo(0, -n), e.moveTo(-r, -i), e.lineTo(r, i), e.moveTo(-r, i), e.lineTo(r, -i);
+            const n = ye(t + Gm(t / 28, 0.75)) * 0.59436,
+                r = n / 2,
+                i = r * fj;
+            e.moveTo(0, n), e.lineTo(0, -n), e.moveTo(-i, -r), e.lineTo(i, r), e.moveTo(-i, r), e.lineTo(i, -r);
         }
     },
-    ju = {
+    Uc = {
         draw(e, t) {
-            const n = ze(t / Fp);
-            e.moveTo(n, 0), e.arc(0, 0, n, 0, p0);
+            const n = ye(t / oh);
+            e.moveTo(n, 0), e.arc(0, 0, n, 0, ld);
         }
     },
-    FT = {
+    AM = {
         draw(e, t) {
-            const n = ze(t / 5) / 2;
+            const n = ye(t / 5) / 2;
             e.moveTo(-3 * n, -n), e.lineTo(-n, -n), e.lineTo(-n, -3 * n), e.lineTo(n, -3 * n), e.lineTo(n, -n), e.lineTo(3 * n, -n), e.lineTo(3 * n, n), e.lineTo(n, n), e.lineTo(n, 3 * n), e.lineTo(-n, 3 * n), e.lineTo(-n, n), e.lineTo(-3 * n, n), e.closePath();
         }
     },
-    ET = ze(1 / 3),
-    iH = ET * 2,
-    LT = {
+    $M = ye(1 / 3),
+    hj = $M * 2,
+    IM = {
         draw(e, t) {
-            const n = ze(t / iH),
-                i = n * ET;
-            e.moveTo(0, -n), e.lineTo(i, 0), e.lineTo(0, n), e.lineTo(-i, 0), e.closePath();
+            const n = ye(t / hj),
+                r = n * $M;
+            e.moveTo(0, -n), e.lineTo(r, 0), e.lineTo(0, n), e.lineTo(-r, 0), e.closePath();
         }
     },
-    RT = {
+    TM = {
         draw(e, t) {
-            const n = ze(t) * 0.62625;
+            const n = ye(t) * 0.62625;
             e.moveTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.lineTo(-n, 0), e.closePath();
         }
     },
-    CT = {
+    EM = {
         draw(e, t) {
-            const n = ze(t - pw(t / 7, 2)) * 0.87559;
+            const n = ye(t - Gm(t / 7, 2)) * 0.87559;
             e.moveTo(-n, 0), e.lineTo(n, 0), e.moveTo(0, n), e.lineTo(0, -n);
         }
     },
-    kT = {
+    NM = {
         draw(e, t) {
-            const n = ze(t),
-                i = -n / 2;
-            e.rect(i, i, n, n);
+            const n = ye(t),
+                r = -n / 2;
+            e.rect(r, r, n, n);
         }
     },
-    UT = {
+    DM = {
         draw(e, t) {
-            const n = ze(t) * 0.4431;
+            const n = ye(t) * 0.4431;
             e.moveTo(n, n), e.lineTo(n, -n), e.lineTo(-n, -n), e.lineTo(-n, n), e.closePath();
         }
     },
-    rH = 0.8908130915292852,
-    zT = Op(Fp / 10) / Op(7 * Fp / 10),
-    sH = Op(p0 / 10) * zT,
-    oH = -IT(p0 / 10) * zT,
-    PT = {
+    dj = 0.8908130915292852,
+    OM = sh(oh / 10) / sh(7 * oh / 10),
+    pj = sh(ld / 10) * OM,
+    yj = -mM(ld / 10) * OM,
+    LM = {
         draw(e, t) {
-            const n = ze(t * rH),
-                i = sH * n,
-                r = oH * n;
-            e.moveTo(0, -n), e.lineTo(i, r);
+            const n = ye(t * dj),
+                r = pj * n,
+                i = yj * n;
+            e.moveTo(0, -n), e.lineTo(r, i);
             for (let s = 1; s < 5; ++s) {
-                const o = p0 * s / 5,
-                    a = IT(o),
-                    c = Op(o);
-                e.lineTo(c * n, -a * n), e.lineTo(a * i - c * r, c * i + a * r);
+                const o = ld * s / 5,
+                    a = mM(o),
+                    c = sh(o);
+                e.lineTo(c * n, -a * n), e.lineTo(a * r - c * i, c * r + a * i);
             }
             e.closePath();
         }
     },
-    Lm = ze(3),
-    VT = {
+    Np = ye(3),
+    kM = {
         draw(e, t) {
-            const n = -ze(t / (Lm * 3));
-            e.moveTo(0, n * 2), e.lineTo(-Lm * n, -n), e.lineTo(Lm * n, -n), e.closePath();
+            const n = -ye(t / (Np * 3));
+            e.moveTo(0, n * 2), e.lineTo(-Np * n, -n), e.lineTo(Np * n, -n), e.closePath();
         }
     },
-    aH = ze(3),
-    jT = {
+    mj = ye(3),
+    RM = {
         draw(e, t) {
-            const n = ze(t) * 0.6824,
-                i = n / 2,
-                r = n * aH / 2;
-            e.moveTo(0, -n), e.lineTo(r, i), e.lineTo(-r, i), e.closePath();
+            const n = ye(t) * 0.6824,
+                r = n / 2,
+                i = n * mj / 2;
+            e.moveTo(0, -n), e.lineTo(i, r), e.lineTo(-i, r), e.closePath();
         }
     },
-    Yn = -0.5,
-    Wn = ze(3) / 2,
-    I1 = 1 / ze(12),
-    cH = (I1 / 2 + 1) * 3,
-    qT = {
+    dn = -0.5,
+    pn = ye(3) / 2,
+    hy = 1 / ye(12),
+    gj = (hy / 2 + 1) * 3,
+    FM = {
         draw(e, t) {
-            const n = ze(t / cH),
-                i = n / 2,
-                r = n * I1,
-                s = i,
-                o = n * I1 + n,
+            const n = ye(t / gj),
+                r = n / 2,
+                i = n * hy,
+                s = r,
+                o = n * hy + n,
                 a = -s,
                 c = o;
-            e.moveTo(i, r), e.lineTo(s, o), e.lineTo(a, c), e.lineTo(Yn * i - Wn * r, Wn * i + Yn * r), e.lineTo(Yn * s - Wn * o, Wn * s + Yn * o), e.lineTo(Yn * a - Wn * c, Wn * a + Yn * c), e.lineTo(Yn * i + Wn * r, Yn * r - Wn * i), e.lineTo(Yn * s + Wn * o, Yn * o - Wn * s), e.lineTo(Yn * a + Wn * c, Yn * c - Wn * a), e.closePath();
+            e.moveTo(r, i), e.lineTo(s, o), e.lineTo(a, c), e.lineTo(dn * r - pn * i, pn * r + dn * i), e.lineTo(dn * s - pn * o, pn * s + dn * o), e.lineTo(dn * a - pn * c, pn * a + dn * c), e.lineTo(dn * r + pn * i, dn * i - pn * r), e.lineTo(dn * s + pn * o, dn * o - pn * s), e.lineTo(dn * a + pn * c, dn * c - pn * a), e.closePath();
         }
     },
-    YT = {
+    BM = {
         draw(e, t) {
-            const n = ze(t - pw(t / 6, 1.7)) * 0.6189;
+            const n = ye(t - Gm(t / 6, 1.7)) * 0.6189;
             e.moveTo(-n, -n), e.lineTo(n, n), e.moveTo(-n, n), e.lineTo(n, -n);
         }
     },
-    lH = [
-        ju,
-        FT,
-        LT,
-        kT,
-        PT,
-        VT,
-        qT
+    bj = [
+        Uc,
+        AM,
+        IM,
+        NM,
+        LM,
+        kM,
+        FM
     ],
-    uH = [
-        ju,
-        CT,
-        YT,
-        jT,
-        OT,
-        UT,
-        RT
+    wj = [
+        Uc,
+        EM,
+        BM,
+        RM,
+        MM,
+        DM,
+        TM
     ];
 
-function Xs() {}
+function zi() {}
 
-function Ep(e, t, n) {
+function ah(e, t, n) {
     e._context.bezierCurveTo(
         (2 * e._x0 + e._x1) / 3,
         (2 * e._y0 + e._y1) / 3,
         (e._x0 + 2 * e._x1) / 3,
         (e._y0 + 2 * e._y1) / 3,
         (e._x0 + 4 * e._x1 + t) / 6,
         (e._y0 + 4 * e._y1 + n) / 6
     );
 }
 
-function y0(e) {
+function fd(e) {
     this._context = e;
 }
-y0.prototype = {
+fd.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
         this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 3:
-                Ep(this, this._x1, this._y1);
+                ah(this, this._x1, this._y1);
             case 2:
                 this._context.lineTo(this._x1, this._y1);
                 break;
         }
         (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
     },
     point: function(e, t) {
@@ -21640,31 +22203,31 @@
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
             default:
-                Ep(this, e, t);
+                ah(this, e, t);
                 break;
         }
         this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
     }
 };
 
-function fH(e) {
-    return new y0(e);
+function vj(e) {
+    return new fd(e);
 }
 
-function WT(e) {
+function CM(e) {
     this._context = e;
 }
-WT.prototype = {
-    areaStart: Xs,
-    areaEnd: Xs,
+CM.prototype = {
+    areaStart: zi,
+    areaEnd: zi,
     lineStart: function() {
         this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 1: {
                 this._context.moveTo(this._x2, this._y2), this._context.closePath();
@@ -21688,29 +22251,29 @@
             case 1:
                 this._point = 2, this._x3 = e, this._y3 = t;
                 break;
             case 2:
                 this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
                 break;
             default:
-                Ep(this, e, t);
+                ah(this, e, t);
                 break;
         }
         this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
     }
 };
 
-function hH(e) {
-    return new WT(e);
+function _j(e) {
+    return new CM(e);
 }
 
-function GT(e) {
+function PM(e) {
     this._context = e;
 }
-GT.prototype = {
+PM.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -21726,78 +22289,78 @@
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3;
                 var n = (this._x0 + 4 * this._x1 + e) / 6,
-                    i = (this._y0 + 4 * this._y1 + t) / 6;
-                this._line ? this._context.lineTo(n, i) : this._context.moveTo(n, i);
+                    r = (this._y0 + 4 * this._y1 + t) / 6;
+                this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
                 break;
             case 3:
                 this._point = 4;
             default:
-                Ep(this, e, t);
+                ah(this, e, t);
                 break;
         }
         this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
     }
 };
 
-function dH(e) {
-    return new GT(e);
+function xj(e) {
+    return new PM(e);
 }
 
-function XT(e, t) {
-    this._basis = new y0(e), this._beta = t;
+function UM(e, t) {
+    this._basis = new fd(e), this._beta = t;
 }
-XT.prototype = {
+UM.prototype = {
     lineStart: function() {
         this._x = [], this._y = [], this._basis.lineStart();
     },
     lineEnd: function() {
         var e = this._x,
             t = this._y,
             n = e.length - 1;
         if (n > 0)
-            for (var i = e[0], r = t[0], s = e[n] - i, o = t[n] - r, a = -1, c; ++a <= n;)
+            for (var r = e[0], i = t[0], s = e[n] - r, o = t[n] - i, a = -1, c; ++a <= n;)
                 c = a / n, this._basis.point(
-                    this._beta * e[a] + (1 - this._beta) * (i + c * s),
-                    this._beta * t[a] + (1 - this._beta) * (r + c * o)
+                    this._beta * e[a] + (1 - this._beta) * (r + c * s),
+                    this._beta * t[a] + (1 - this._beta) * (i + c * o)
                 );
         this._x = this._y = null, this._basis.lineEnd();
     },
     point: function(e, t) {
         this._x.push(+e), this._y.push(+t);
     }
 };
-const pH = function e(t) {
-    function n(i) {
-        return t === 1 ? new y0(i) : new XT(i, t);
+const Sj = function e(t) {
+    function n(r) {
+        return t === 1 ? new fd(r) : new UM(r, t);
     }
-    return n.beta = function(i) {
-        return e(+i);
+    return n.beta = function(r) {
+        return e(+r);
     }, n;
 }(0.85);
 
-function Lp(e, t, n) {
+function ch(e, t, n) {
     e._context.bezierCurveTo(
         e._x1 + e._k * (e._x2 - e._x0),
         e._y1 + e._k * (e._y2 - e._y0),
         e._x2 + e._k * (e._x1 - t),
         e._y2 + e._k * (e._y1 - n),
         e._x2,
         e._y2
     );
 }
 
-function mw(e, t) {
+function Jm(e, t) {
     this._context = e, this._k = (1 - t) / 6;
 }
-mw.prototype = {
+Jm.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -21805,15 +22368,15 @@
     },
     lineEnd: function() {
         switch (this._point) {
             case 2:
                 this._context.lineTo(this._x2, this._y2);
                 break;
             case 3:
-                Lp(this, this._x1, this._y1);
+                ch(this, this._x1, this._y1);
                 break;
         }
         (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
     },
     point: function(e, t) {
         switch (e = +e, t = +t, this._point) {
             case 0:
@@ -21821,35 +22384,35 @@
                 break;
             case 1:
                 this._point = 2, this._x1 = e, this._y1 = t;
                 break;
             case 2:
                 this._point = 3;
             default:
-                Lp(this, e, t);
+                ch(this, e, t);
                 break;
         }
         this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
     }
 };
-const yH = function e(t) {
-    function n(i) {
-        return new mw(i, t);
+const Mj = function e(t) {
+    function n(r) {
+        return new Jm(r, t);
     }
-    return n.tension = function(i) {
-        return e(+i);
+    return n.tension = function(r) {
+        return e(+r);
     }, n;
 }(0);
 
-function gw(e, t) {
+function Zm(e, t) {
     this._context = e, this._k = (1 - t) / 6;
 }
-gw.prototype = {
-    areaStart: Xs,
-    areaEnd: Xs,
+Zm.prototype = {
+    areaStart: zi,
+    areaEnd: zi,
     lineStart: function() {
         this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 1: {
                 this._context.moveTo(this._x3, this._y3), this._context.closePath();
@@ -21873,33 +22436,33 @@
             case 1:
                 this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
                 break;
             case 2:
                 this._point = 3, this._x5 = e, this._y5 = t;
                 break;
             default:
-                Lp(this, e, t);
+                ch(this, e, t);
                 break;
         }
         this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
     }
 };
-const mH = function e(t) {
-    function n(i) {
-        return new gw(i, t);
+const Aj = function e(t) {
+    function n(r) {
+        return new Zm(r, t);
     }
-    return n.tension = function(i) {
-        return e(+i);
+    return n.tension = function(r) {
+        return e(+r);
     }, n;
 }(0);
 
-function bw(e, t) {
+function Km(e, t) {
     this._context = e, this._k = (1 - t) / 6;
 }
-bw.prototype = {
+Km.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -21918,51 +22481,51 @@
                 break;
             case 2:
                 this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                 break;
             case 3:
                 this._point = 4;
             default:
-                Lp(this, e, t);
+                ch(this, e, t);
                 break;
         }
         this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
     }
 };
-const gH = function e(t) {
-    function n(i) {
-        return new bw(i, t);
+const $j = function e(t) {
+    function n(r) {
+        return new Km(r, t);
     }
-    return n.tension = function(i) {
-        return e(+i);
+    return n.tension = function(r) {
+        return e(+r);
     }, n;
 }(0);
 
-function ww(e, t, n) {
-    var i = e._x1,
-        r = e._y1,
+function Qm(e, t, n) {
+    var r = e._x1,
+        i = e._y1,
         s = e._x2,
         o = e._y2;
-    if (e._l01_a > Rx) {
+    if (e._l01_a > Kw) {
         var a = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
             c = 3 * e._l01_a * (e._l01_a + e._l12_a);
-        i = (i * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / c, r = (r * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / c;
+        r = (r * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / c, i = (i * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / c;
     }
-    if (e._l23_a > Rx) {
-        var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
-            u = 3 * e._l23_a * (e._l23_a + e._l12_a);
-        s = (s * l + e._x1 * e._l23_2a - t * e._l12_2a) / u, o = (o * l + e._y1 * e._l23_2a - n * e._l12_2a) / u;
+    if (e._l23_a > Kw) {
+        var u = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
+            l = 3 * e._l23_a * (e._l23_a + e._l12_a);
+        s = (s * u + e._x1 * e._l23_2a - t * e._l12_2a) / l, o = (o * u + e._y1 * e._l23_2a - n * e._l12_2a) / l;
     }
-    e._context.bezierCurveTo(i, r, s, o, e._x2, e._y2);
+    e._context.bezierCurveTo(r, i, s, o, e._x2, e._y2);
 }
 
-function HT(e, t) {
+function zM(e, t) {
     this._context = e, this._alpha = t;
 }
-HT.prototype = {
+zM.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -21978,48 +22541,48 @@
                 break;
         }
         (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
     },
     point: function(e, t) {
         if (e = +e, t = +t, this._point) {
             var n = this._x2 - e,
-                i = this._y2 - t;
-            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
+                r = this._y2 - t;
+            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
         }
         switch (this._point) {
             case 0:
                 this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3;
             default:
-                ww(this, e, t);
+                Qm(this, e, t);
                 break;
         }
         this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
     }
 };
-const bH = function e(t) {
-    function n(i) {
-        return t ? new HT(i, t) : new mw(i, 0);
+const Ij = function e(t) {
+    function n(r) {
+        return t ? new zM(r, t) : new Jm(r, 0);
     }
-    return n.alpha = function(i) {
-        return e(+i);
+    return n.alpha = function(r) {
+        return e(+r);
     }, n;
 }(0.5);
 
-function JT(e, t) {
+function qM(e, t) {
     this._context = e, this._alpha = t;
 }
-JT.prototype = {
-    areaStart: Xs,
-    areaEnd: Xs,
+qM.prototype = {
+    areaStart: zi,
+    areaEnd: zi,
     lineStart: function() {
         this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
     },
     lineEnd: function() {
         switch (this._point) {
             case 1: {
                 this._context.moveTo(this._x3, this._y3), this._context.closePath();
@@ -22034,47 +22597,47 @@
                 break;
             }
         }
     },
     point: function(e, t) {
         if (e = +e, t = +t, this._point) {
             var n = this._x2 - e,
-                i = this._y2 - t;
-            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
+                r = this._y2 - t;
+            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
         }
         switch (this._point) {
             case 0:
                 this._point = 1, this._x3 = e, this._y3 = t;
                 break;
             case 1:
                 this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
                 break;
             case 2:
                 this._point = 3, this._x5 = e, this._y5 = t;
                 break;
             default:
-                ww(this, e, t);
+                Qm(this, e, t);
                 break;
         }
         this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
     }
 };
-const wH = function e(t) {
-    function n(i) {
-        return t ? new JT(i, t) : new gw(i, 0);
+const Tj = function e(t) {
+    function n(r) {
+        return t ? new qM(r, t) : new Zm(r, 0);
     }
-    return n.alpha = function(i) {
-        return e(+i);
+    return n.alpha = function(r) {
+        return e(+r);
     }, n;
 }(0.5);
 
-function KT(e, t) {
+function jM(e, t) {
     this._context = e, this._alpha = t;
 }
-KT.prototype = {
+jM.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -22082,97 +22645,97 @@
     },
     lineEnd: function() {
         (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
     },
     point: function(e, t) {
         if (e = +e, t = +t, this._point) {
             var n = this._x2 - e,
-                i = this._y2 - t;
-            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + i * i, this._alpha));
+                r = this._y2 - t;
+            this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
         }
         switch (this._point) {
             case 0:
                 this._point = 1;
                 break;
             case 1:
                 this._point = 2;
                 break;
             case 2:
                 this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                 break;
             case 3:
                 this._point = 4;
             default:
-                ww(this, e, t);
+                Qm(this, e, t);
                 break;
         }
         this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
     }
 };
-const vH = function e(t) {
-    function n(i) {
-        return t ? new KT(i, t) : new bw(i, 0);
+const Ej = function e(t) {
+    function n(r) {
+        return t ? new jM(r, t) : new Km(r, 0);
     }
-    return n.alpha = function(i) {
-        return e(+i);
+    return n.alpha = function(r) {
+        return e(+r);
     }, n;
 }(0.5);
 
-function ZT(e) {
+function VM(e) {
     this._context = e;
 }
-ZT.prototype = {
-    areaStart: Xs,
-    areaEnd: Xs,
+VM.prototype = {
+    areaStart: zi,
+    areaEnd: zi,
     lineStart: function() {
         this._point = 0;
     },
     lineEnd: function() {
         this._point && this._context.closePath();
     },
     point: function(e, t) {
         e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
     }
 };
 
-function _H(e) {
-    return new ZT(e);
+function Nj(e) {
+    return new VM(e);
 }
 
-function Cx(e) {
+function Qw(e) {
     return e < 0 ? -1 : 1;
 }
 
-function kx(e, t, n) {
-    var i = e._x1 - e._x0,
-        r = t - e._x1,
-        s = (e._y1 - e._y0) / (i || r < 0 && -0),
-        o = (n - e._y1) / (r || i < 0 && -0),
-        a = (s * r + o * i) / (i + r);
-    return (Cx(s) + Cx(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(a)) || 0;
+function t2(e, t, n) {
+    var r = e._x1 - e._x0,
+        i = t - e._x1,
+        s = (e._y1 - e._y0) / (r || i < 0 && -0),
+        o = (n - e._y1) / (i || r < 0 && -0),
+        a = (s * i + o * r) / (r + i);
+    return (Qw(s) + Qw(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(a)) || 0;
 }
 
-function Ux(e, t) {
+function e2(e, t) {
     var n = e._x1 - e._x0;
     return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
 }
 
-function Rm(e, t, n) {
-    var i = e._x0,
-        r = e._y0,
+function Dp(e, t, n) {
+    var r = e._x0,
+        i = e._y0,
         s = e._x1,
         o = e._y1,
-        a = (s - i) / 3;
-    e._context.bezierCurveTo(i + a, r + a * t, s - a, o - a * n, s, o);
+        a = (s - r) / 3;
+    e._context.bezierCurveTo(r + a, i + a * t, s - a, o - a * n, s, o);
 }
 
-function Rp(e) {
+function uh(e) {
     this._context = e;
 }
-Rp.prototype = {
+uh.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -22180,15 +22743,15 @@
     },
     lineEnd: function() {
         switch (this._point) {
             case 2:
                 this._context.lineTo(this._x1, this._y1);
                 break;
             case 3:
-                Rm(this, this._t0, Ux(this, this._t0));
+                Dp(this, this._t0, e2(this, this._t0));
                 break;
         }
         (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
     },
     point: function(e, t) {
         var n = NaN;
         if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
@@ -22196,62 +22759,62 @@
                 case 0:
                     this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
                     break;
                 case 1:
                     this._point = 2;
                     break;
                 case 2:
-                    this._point = 3, Rm(this, Ux(this, n = kx(this, e, t)), n);
+                    this._point = 3, Dp(this, e2(this, n = t2(this, e, t)), n);
                     break;
                 default:
-                    Rm(this, this._t0, n = kx(this, e, t));
+                    Dp(this, this._t0, n = t2(this, e, t));
                     break;
             }
             this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
         }
     }
 };
 
-function QT(e) {
-    this._context = new tD(e);
+function YM(e) {
+    this._context = new WM(e);
 }
-(QT.prototype = Object.create(Rp.prototype)).point = function(e, t) {
-    Rp.prototype.point.call(this, t, e);
+(YM.prototype = Object.create(uh.prototype)).point = function(e, t) {
+    uh.prototype.point.call(this, t, e);
 };
 
-function tD(e) {
+function WM(e) {
     this._context = e;
 }
-tD.prototype = {
+WM.prototype = {
     moveTo: function(e, t) {
         this._context.moveTo(t, e);
     },
     closePath: function() {
         this._context.closePath();
     },
     lineTo: function(e, t) {
         this._context.lineTo(t, e);
     },
-    bezierCurveTo: function(e, t, n, i, r, s) {
-        this._context.bezierCurveTo(t, e, i, n, s, r);
+    bezierCurveTo: function(e, t, n, r, i, s) {
+        this._context.bezierCurveTo(t, e, r, n, s, i);
     }
 };
 
-function xH(e) {
-    return new Rp(e);
+function Dj(e) {
+    return new uh(e);
 }
 
-function SH(e) {
-    return new QT(e);
+function Oj(e) {
+    return new YM(e);
 }
 
-function eD(e) {
+function XM(e) {
     this._context = e;
 }
-eD.prototype = {
+XM.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -22261,47 +22824,47 @@
         var e = this._x,
             t = this._y,
             n = e.length;
         if (n)
             if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
                 this._context.lineTo(e[1], t[1]);
             else
-                for (var i = zx(e), r = zx(t), s = 0, o = 1; o < n; ++s, ++o)
-                    this._context.bezierCurveTo(i[0][s], r[0][s], i[1][s], r[1][s], e[o], t[o]);
+                for (var r = n2(e), i = n2(t), s = 0, o = 1; o < n; ++s, ++o)
+                    this._context.bezierCurveTo(r[0][s], i[0][s], r[1][s], i[1][s], e[o], t[o]);
         (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
     },
     point: function(e, t) {
         this._x.push(+e), this._y.push(+t);
     }
 };
 
-function zx(e) {
+function n2(e) {
     var t, n = e.length - 1,
-        i, r = new Array(n),
+        r, i = new Array(n),
         s = new Array(n),
         o = new Array(n);
-    for (r[0] = 0, s[0] = 2, o[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
-        r[t] = 1, s[t] = 4, o[t] = 4 * e[t] + 2 * e[t + 1];
-    for (r[n - 1] = 2, s[n - 1] = 7, o[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
-        i = r[t] / s[t - 1], s[t] -= i, o[t] -= i * o[t - 1];
-    for (r[n - 1] = o[n - 1] / s[n - 1], t = n - 2; t >= 0; --t)
-        r[t] = (o[t] - r[t + 1]) / s[t];
-    for (s[n - 1] = (e[n] + r[n - 1]) / 2, t = 0; t < n - 1; ++t)
-        s[t] = 2 * e[t + 1] - r[t + 1];
-    return [r, s];
+    for (i[0] = 0, s[0] = 2, o[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
+        i[t] = 1, s[t] = 4, o[t] = 4 * e[t] + 2 * e[t + 1];
+    for (i[n - 1] = 2, s[n - 1] = 7, o[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
+        r = i[t] / s[t - 1], s[t] -= r, o[t] -= r * o[t - 1];
+    for (i[n - 1] = o[n - 1] / s[n - 1], t = n - 2; t >= 0; --t)
+        i[t] = (o[t] - i[t + 1]) / s[t];
+    for (s[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
+        s[t] = 2 * e[t + 1] - i[t + 1];
+    return [i, s];
 }
 
-function IH(e) {
-    return new eD(e);
+function Lj(e) {
+    return new XM(e);
 }
 
-function m0(e, t) {
+function hd(e, t) {
     this._context = e, this._t = t;
 }
-m0.prototype = {
+hd.prototype = {
     areaStart: function() {
         this._line = 0;
     },
     areaEnd: function() {
         this._line = NaN;
     },
     lineStart: function() {
@@ -22327,32 +22890,32 @@
                 break;
             }
         }
         this._x = e, this._y = t;
     }
 };
 
-function AH(e) {
-    return new m0(e, 0.5);
+function kj(e) {
+    return new hd(e, 0.5);
 }
 
-function MH(e) {
-    return new m0(e, 0);
+function Rj(e) {
+    return new hd(e, 0);
 }
 
-function $H(e) {
-    return new m0(e, 1);
+function Fj(e) {
+    return new hd(e, 1);
 }
-const _h = (e) => () => e;
+const ol = (e) => () => e;
 
-function TH(e, {
+function Bj(e, {
     sourceEvent: t,
     target: n,
-    transform: i,
-    dispatch: r
+    transform: r,
+    dispatch: i
 }) {
     Object.defineProperties(this, {
         type: {
             value: e,
             enumerable: !0,
             configurable: !0
         },
@@ -22363,34 +22926,34 @@
         },
         target: {
             value: n,
             enumerable: !0,
             configurable: !0
         },
         transform: {
-            value: i,
+            value: r,
             enumerable: !0,
             configurable: !0
         },
         _: {
-            value: r
+            value: i
         }
     });
 }
 
-function ir(e, t, n) {
+function fr(e, t, n) {
     this.k = e, this.x = t, this.y = n;
 }
-ir.prototype = {
-    constructor: ir,
+fr.prototype = {
+    constructor: fr,
     scale: function(e) {
-        return e === 1 ? this : new ir(this.k * e, this.x, this.y);
+        return e === 1 ? this : new fr(this.k * e, this.x, this.y);
     },
     translate: function(e, t) {
-        return e === 0 & t === 0 ? this : new ir(this.k, this.x + this.k * e, this.y + this.k * t);
+        return e === 0 & t === 0 ? this : new fr(this.k, this.x + this.k * e, this.y + this.k * t);
     },
     apply: function(e) {
         return [e[0] * this.k + this.x, e[1] * this.k + this.y];
     },
     applyX: function(e) {
         return e * this.k + this.x;
     },
@@ -22412,817 +22975,817 @@
     rescaleY: function(e) {
         return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
     },
     toString: function() {
         return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
     }
 };
-var nD = new ir(1, 0, 0);
-ir.prototype;
+var GM = new fr(1, 0, 0);
+fr.prototype;
 
-function Cm(e) {
+function Op(e) {
     e.stopImmediatePropagation();
 }
 
-function Ml(e) {
+function Ba(e) {
     e.preventDefault(), e.stopImmediatePropagation();
 }
 
-function DH(e) {
+function Cj(e) {
     return (!e.ctrlKey || e.type === "wheel") && !e.button;
 }
 
-function NH() {
+function Pj() {
     var e = this;
     return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [
         [e.x, e.y],
         [e.x + e.width, e.y + e.height]
     ]) : [
         [0, 0],
         [e.width.baseVal.value, e.height.baseVal.value]
     ]) : [
         [0, 0],
         [e.clientWidth, e.clientHeight]
     ];
 }
 
-function Px() {
-    return this.__zoom || nD;
+function r2() {
+    return this.__zoom || GM;
 }
 
-function BH(e) {
+function Uj(e) {
     return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
 }
 
-function OH() {
+function zj() {
     return navigator.maxTouchPoints || "ontouchstart" in this;
 }
 
-function FH(e, t, n) {
-    var i = e.invertX(t[0][0]) - n[0][0],
-        r = e.invertX(t[1][0]) - n[1][0],
+function qj(e, t, n) {
+    var r = e.invertX(t[0][0]) - n[0][0],
+        i = e.invertX(t[1][0]) - n[1][0],
         s = e.invertY(t[0][1]) - n[0][1],
         o = e.invertY(t[1][1]) - n[1][1];
     return e.translate(
-        r > i ? (i + r) / 2 : Math.min(0, i) || Math.max(0, r),
+        i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),
         o > s ? (s + o) / 2 : Math.min(0, s) || Math.max(0, o)
     );
 }
 
-function EH() {
-    var e = DH,
-        t = NH,
-        n = FH,
-        i = BH,
-        r = OH,
+function jj() {
+    var e = Cj,
+        t = Pj,
+        n = qj,
+        r = Uj,
+        i = zj,
         s = [0, 1 / 0],
         o = [
             [-1 / 0, -1 / 0],
             [1 / 0, 1 / 0]
         ],
         a = 250,
-        c = yj,
-        l = Hy("start", "zoom", "end"),
-        u, f, h, d = 500,
+        c = MB,
+        u = Yh("start", "zoom", "end"),
+        l, f, h, d = 500,
         p = 150,
-        m = 0,
-        g = 10;
+        y = 0,
+        m = 10;
 
-    function y(S) {
-        S.property("__zoom", Px).on("wheel.zoom", A, {
+    function g(S) {
+        S.property("__zoom", r2).on("wheel.zoom", T, {
             passive: !1
-        }).on("mousedown.zoom", M).on("dblclick.zoom", N).filter(r).on("touchstart.zoom", $).on("touchmove.zoom", B).on("touchend.zoom touchcancel.zoom", R).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
+        }).on("mousedown.zoom", $).on("dblclick.zoom", N).filter(i).on("touchstart.zoom", A).on("touchmove.zoom", D).on("touchend.zoom touchcancel.zoom", R).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
     }
-    y.transform = function(S, T, D, L) {
-        var k = S.selection ? S.selection() : S;
-        k.property("__zoom", Px), S !== k ? x(S, T, D, L) : k.interrupt().each(function() {
-            _(this, arguments).event(L).start().zoom(null, typeof T == "function" ? T.apply(this, arguments) : T).end();
-        });
-    }, y.scaleBy = function(S, T, D, L) {
-        y.scaleTo(S, function() {
-            var k = this.__zoom.k,
-                U = typeof T == "function" ? T.apply(this, arguments) : T;
-            return k * U;
-        }, D, L);
-    }, y.scaleTo = function(S, T, D, L) {
-        y.transform(S, function() {
-            var k = t.apply(this, arguments),
-                U = this.__zoom,
-                C = D == null ? v(k) : typeof D == "function" ? D.apply(this, arguments) : D,
-                z = U.invert(C),
-                P = typeof T == "function" ? T.apply(this, arguments) : T;
-            return n(w(b(U, P), C, z), k, o);
-        }, D, L);
-    }, y.translateBy = function(S, T, D, L) {
-        y.transform(S, function() {
+    g.transform = function(S, I, E, k) {
+        var B = S.selection ? S.selection() : S;
+        B.property("__zoom", r2), S !== B ? x(S, I, E, k) : B.interrupt().each(function() {
+            _(this, arguments).event(k).start().zoom(null, typeof I == "function" ? I.apply(this, arguments) : I).end();
+        });
+    }, g.scaleBy = function(S, I, E, k) {
+        g.scaleTo(S, function() {
+            var B = this.__zoom.k,
+                C = typeof I == "function" ? I.apply(this, arguments) : I;
+            return B * C;
+        }, E, k);
+    }, g.scaleTo = function(S, I, E, k) {
+        g.transform(S, function() {
+            var B = t.apply(this, arguments),
+                C = this.__zoom,
+                F = E == null ? v(B) : typeof E == "function" ? E.apply(this, arguments) : E,
+                P = C.invert(F),
+                U = typeof I == "function" ? I.apply(this, arguments) : I;
+            return n(w(b(C, U), F, P), B, o);
+        }, E, k);
+    }, g.translateBy = function(S, I, E, k) {
+        g.transform(S, function() {
             return n(this.__zoom.translate(
-                typeof T == "function" ? T.apply(this, arguments) : T,
-                typeof D == "function" ? D.apply(this, arguments) : D
+                typeof I == "function" ? I.apply(this, arguments) : I,
+                typeof E == "function" ? E.apply(this, arguments) : E
             ), t.apply(this, arguments), o);
-        }, null, L);
-    }, y.translateTo = function(S, T, D, L, k) {
-        y.transform(S, function() {
-            var U = t.apply(this, arguments),
-                C = this.__zoom,
-                z = L == null ? v(U) : typeof L == "function" ? L.apply(this, arguments) : L;
-            return n(nD.translate(z[0], z[1]).scale(C.k).translate(
-                typeof T == "function" ? -T.apply(this, arguments) : -T,
-                typeof D == "function" ? -D.apply(this, arguments) : -D
-            ), U, o);
-        }, L, k);
-    };
-
-    function b(S, T) {
-        return T = Math.max(s[0], Math.min(s[1], T)), T === S.k ? S : new ir(T, S.x, S.y);
-    }
-
-    function w(S, T, D) {
-        var L = T[0] - D[0] * S.k,
-            k = T[1] - D[1] * S.k;
-        return L === S.x && k === S.y ? S : new ir(S.k, L, k);
+        }, null, k);
+    }, g.translateTo = function(S, I, E, k, B) {
+        g.transform(S, function() {
+            var C = t.apply(this, arguments),
+                F = this.__zoom,
+                P = k == null ? v(C) : typeof k == "function" ? k.apply(this, arguments) : k;
+            return n(GM.translate(P[0], P[1]).scale(F.k).translate(
+                typeof I == "function" ? -I.apply(this, arguments) : -I,
+                typeof E == "function" ? -E.apply(this, arguments) : -E
+            ), C, o);
+        }, k, B);
+    };
+
+    function b(S, I) {
+        return I = Math.max(s[0], Math.min(s[1], I)), I === S.k ? S : new fr(I, S.x, S.y);
+    }
+
+    function w(S, I, E) {
+        var k = I[0] - E[0] * S.k,
+            B = I[1] - E[1] * S.k;
+        return k === S.x && B === S.y ? S : new fr(S.k, k, B);
     }
 
     function v(S) {
         return [(+S[0][0] + +S[1][0]) / 2, (+S[0][1] + +S[1][1]) / 2];
     }
 
-    function x(S, T, D, L) {
+    function x(S, I, E, k) {
         S.on("start.zoom", function() {
-            _(this, arguments).event(L).start();
+            _(this, arguments).event(k).start();
         }).on("interrupt.zoom end.zoom", function() {
-            _(this, arguments).event(L).end();
+            _(this, arguments).event(k).end();
         }).tween("zoom", function() {
-            var k = this,
-                U = arguments,
-                C = _(k, U).event(L),
-                z = t.apply(k, U),
-                P = D == null ? v(z) : typeof D == "function" ? D.apply(k, U) : D,
-                G = Math.max(z[1][0] - z[0][0], z[1][1] - z[0][1]),
-                K = k.__zoom,
-                et = typeof T == "function" ? T.apply(k, U) : T,
-                Z = c(K.invert(P).concat(G / K.k), et.invert(P).concat(G / et.k));
-            return function(Y) {
-                if (Y === 1)
-                    Y = et;
+            var B = this,
+                C = arguments,
+                F = _(B, C).event(k),
+                P = t.apply(B, C),
+                U = E == null ? v(P) : typeof E == "function" ? E.apply(B, C) : E,
+                Y = Math.max(P[1][0] - P[0][0], P[1][1] - P[0][1]),
+                G = B.__zoom,
+                K = typeof I == "function" ? I.apply(B, C) : I,
+                H = c(G.invert(U).concat(Y / G.k), K.invert(U).concat(Y / K.k));
+            return function(V) {
+                if (V === 1)
+                    V = K;
                 else {
-                    var X = Z(Y),
-                        j = G / X[2];
-                    Y = new ir(j, P[0] - X[0] * j, P[1] - X[1] * j);
+                    var W = H(V),
+                        q = Y / W[2];
+                    V = new fr(q, U[0] - W[0] * q, U[1] - W[1] * q);
                 }
-                C.zoom(null, Y);
+                F.zoom(null, V);
             };
         });
     }
 
-    function _(S, T, D) {
-        return !D && S.__zooming || new I(S, T);
+    function _(S, I, E) {
+        return !E && S.__zooming || new M(S, I);
     }
 
-    function I(S, T) {
-        this.that = S, this.args = T, this.active = 0, this.sourceEvent = null, this.extent = t.apply(S, T), this.taps = 0;
+    function M(S, I) {
+        this.that = S, this.args = I, this.active = 0, this.sourceEvent = null, this.extent = t.apply(S, I), this.taps = 0;
     }
-    I.prototype = {
+    M.prototype = {
         event: function(S) {
             return S && (this.sourceEvent = S), this;
         },
         start: function() {
             return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
         },
-        zoom: function(S, T) {
-            return this.mouse && S !== "mouse" && (this.mouse[1] = T.invert(this.mouse[0])), this.touch0 && S !== "touch" && (this.touch0[1] = T.invert(this.touch0[0])), this.touch1 && S !== "touch" && (this.touch1[1] = T.invert(this.touch1[0])), this.that.__zoom = T, this.emit("zoom"), this;
+        zoom: function(S, I) {
+            return this.mouse && S !== "mouse" && (this.mouse[1] = I.invert(this.mouse[0])), this.touch0 && S !== "touch" && (this.touch0[1] = I.invert(this.touch0[0])), this.touch1 && S !== "touch" && (this.touch1[1] = I.invert(this.touch1[0])), this.that.__zoom = I, this.emit("zoom"), this;
         },
         end: function() {
             return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
         },
         emit: function(S) {
-            var T = ce(this.that).datum();
-            l.call(
+            var I = Wt(this.that).datum();
+            u.call(
                 S,
                 this.that,
-                new TH(S, {
+                new Bj(S, {
                     sourceEvent: this.sourceEvent,
-                    target: y,
+                    target: g,
                     type: S,
                     transform: this.that.__zoom,
-                    dispatch: l
+                    dispatch: u
                 }),
-                T
+                I
             );
         }
     };
 
-    function A(S, ...T) {
+    function T(S, ...I) {
         if (!e.apply(this, arguments))
             return;
-        var D = _(this, T).event(S),
-            L = this.__zoom,
-            k = Math.max(s[0], Math.min(s[1], L.k * Math.pow(2, i.apply(this, arguments)))),
-            U = yi(S);
-        if (D.wheel)
-            (D.mouse[0][0] !== U[0] || D.mouse[0][1] !== U[1]) && (D.mouse[1] = L.invert(D.mouse[0] = U)), clearTimeout(D.wheel);
+        var E = _(this, I).event(S),
+            k = this.__zoom,
+            B = Math.max(s[0], Math.min(s[1], k.k * Math.pow(2, r.apply(this, arguments)))),
+            C = On(S);
+        if (E.wheel)
+            (E.mouse[0][0] !== C[0] || E.mouse[0][1] !== C[1]) && (E.mouse[1] = k.invert(E.mouse[0] = C)), clearTimeout(E.wheel);
         else {
-            if (L.k === k)
+            if (k.k === B)
                 return;
-            D.mouse = [U, L.invert(U)], dc(this), D.start();
+            E.mouse = [C, k.invert(C)], No(this), E.start();
         }
-        Ml(S), D.wheel = setTimeout(C, p), D.zoom("mouse", n(w(b(L, k), D.mouse[0], D.mouse[1]), D.extent, o));
+        Ba(S), E.wheel = setTimeout(F, p), E.zoom("mouse", n(w(b(k, B), E.mouse[0], E.mouse[1]), E.extent, o));
 
-        function C() {
-            D.wheel = null, D.end();
+        function F() {
+            E.wheel = null, E.end();
         }
     }
 
-    function M(S, ...T) {
+    function $(S, ...I) {
         if (h || !e.apply(this, arguments))
             return;
-        var D = S.currentTarget,
-            L = _(this, T, !0).event(S),
-            k = ce(S.view).on("mousemove.zoom", P, !0).on("mouseup.zoom", G, !0),
-            U = yi(S, D),
-            C = S.clientX,
-            z = S.clientY;
-        M3(S.view), Cm(S), L.mouse = [U, this.__zoom.invert(U)], dc(this), L.start();
+        var E = S.currentTarget,
+            k = _(this, I, !0).event(S),
+            B = Wt(S.view).on("mousemove.zoom", U, !0).on("mouseup.zoom", Y, !0),
+            C = On(S, E),
+            F = S.clientX,
+            P = S.clientY;
+        bS(S.view), Op(S), k.mouse = [C, this.__zoom.invert(C)], No(this), k.start();
 
-        function P(K) {
-            if (Ml(K), !L.moved) {
-                var et = K.clientX - C,
-                    Z = K.clientY - z;
-                L.moved = et * et + Z * Z > m;
+        function U(G) {
+            if (Ba(G), !k.moved) {
+                var K = G.clientX - F,
+                    H = G.clientY - P;
+                k.moved = K * K + H * H > y;
             }
-            L.event(K).zoom("mouse", n(w(L.that.__zoom, L.mouse[0] = yi(K, D), L.mouse[1]), L.extent, o));
+            k.event(G).zoom("mouse", n(w(k.that.__zoom, k.mouse[0] = On(G, E), k.mouse[1]), k.extent, o));
         }
 
-        function G(K) {
-            k.on("mousemove.zoom mouseup.zoom", null), $3(K.view, L.moved), Ml(K), L.event(K).end();
+        function Y(G) {
+            B.on("mousemove.zoom mouseup.zoom", null), wS(G.view, k.moved), Ba(G), k.event(G).end();
         }
     }
 
-    function N(S, ...T) {
+    function N(S, ...I) {
         if (e.apply(this, arguments)) {
-            var D = this.__zoom,
-                L = yi(S.changedTouches ? S.changedTouches[0] : S, this),
-                k = D.invert(L),
-                U = D.k * (S.shiftKey ? 0.5 : 2),
-                C = n(w(b(D, U), L, k), t.apply(this, T), o);
-            Ml(S), a > 0 ? ce(this).transition().duration(a).call(x, C, L, S) : ce(this).call(y.transform, C, L, S);
+            var E = this.__zoom,
+                k = On(S.changedTouches ? S.changedTouches[0] : S, this),
+                B = E.invert(k),
+                C = E.k * (S.shiftKey ? 0.5 : 2),
+                F = n(w(b(E, C), k, B), t.apply(this, I), o);
+            Ba(S), a > 0 ? Wt(this).transition().duration(a).call(x, F, k, S) : Wt(this).call(g.transform, F, k, S);
         }
     }
 
-    function $(S, ...T) {
+    function A(S, ...I) {
         if (e.apply(this, arguments)) {
-            var D = S.touches,
-                L = D.length,
-                k = _(this, T, S.changedTouches.length === L).event(S),
-                U, C, z, P;
-            for (Cm(S), C = 0; C < L; ++C)
-                z = D[C], P = yi(z, this), P = [P, this.__zoom.invert(P), z.identifier], k.touch0 ? !k.touch1 && k.touch0[2] !== P[2] && (k.touch1 = P, k.taps = 0) : (k.touch0 = P, U = !0, k.taps = 1 + !!u);
-            u && (u = clearTimeout(u)), U && (k.taps < 2 && (f = P[0], u = setTimeout(function() {
-                u = null;
-            }, d)), dc(this), k.start());
+            var E = S.touches,
+                k = E.length,
+                B = _(this, I, S.changedTouches.length === k).event(S),
+                C, F, P, U;
+            for (Op(S), F = 0; F < k; ++F)
+                P = E[F], U = On(P, this), U = [U, this.__zoom.invert(U), P.identifier], B.touch0 ? !B.touch1 && B.touch0[2] !== U[2] && (B.touch1 = U, B.taps = 0) : (B.touch0 = U, C = !0, B.taps = 1 + !!l);
+            l && (l = clearTimeout(l)), C && (B.taps < 2 && (f = U[0], l = setTimeout(function() {
+                l = null;
+            }, d)), No(this), B.start());
         }
     }
 
-    function B(S, ...T) {
+    function D(S, ...I) {
         if (this.__zooming) {
-            var D = _(this, T).event(S),
-                L = S.changedTouches,
-                k = L.length,
-                U, C, z, P;
-            for (Ml(S), U = 0; U < k; ++U)
-                C = L[U], z = yi(C, this), D.touch0 && D.touch0[2] === C.identifier ? D.touch0[0] = z : D.touch1 && D.touch1[2] === C.identifier && (D.touch1[0] = z);
-            if (C = D.that.__zoom, D.touch1) {
-                var G = D.touch0[0],
-                    K = D.touch0[1],
-                    et = D.touch1[0],
-                    Z = D.touch1[1],
-                    Y = (Y = et[0] - G[0]) * Y + (Y = et[1] - G[1]) * Y,
-                    X = (X = Z[0] - K[0]) * X + (X = Z[1] - K[1]) * X;
-                C = b(C, Math.sqrt(Y / X)), z = [(G[0] + et[0]) / 2, (G[1] + et[1]) / 2], P = [(K[0] + Z[0]) / 2, (K[1] + Z[1]) / 2];
-            } else if (D.touch0)
-                z = D.touch0[0], P = D.touch0[1];
+            var E = _(this, I).event(S),
+                k = S.changedTouches,
+                B = k.length,
+                C, F, P, U;
+            for (Ba(S), C = 0; C < B; ++C)
+                F = k[C], P = On(F, this), E.touch0 && E.touch0[2] === F.identifier ? E.touch0[0] = P : E.touch1 && E.touch1[2] === F.identifier && (E.touch1[0] = P);
+            if (F = E.that.__zoom, E.touch1) {
+                var Y = E.touch0[0],
+                    G = E.touch0[1],
+                    K = E.touch1[0],
+                    H = E.touch1[1],
+                    V = (V = K[0] - Y[0]) * V + (V = K[1] - Y[1]) * V,
+                    W = (W = H[0] - G[0]) * W + (W = H[1] - G[1]) * W;
+                F = b(F, Math.sqrt(V / W)), P = [(Y[0] + K[0]) / 2, (Y[1] + K[1]) / 2], U = [(G[0] + H[0]) / 2, (G[1] + H[1]) / 2];
+            } else if (E.touch0)
+                P = E.touch0[0], U = E.touch0[1];
             else
                 return;
-            D.zoom("touch", n(w(C, z, P), D.extent, o));
+            E.zoom("touch", n(w(F, P, U), E.extent, o));
         }
     }
 
-    function R(S, ...T) {
+    function R(S, ...I) {
         if (this.__zooming) {
-            var D = _(this, T).event(S),
-                L = S.changedTouches,
-                k = L.length,
-                U, C;
-            for (Cm(S), h && clearTimeout(h), h = setTimeout(function() {
+            var E = _(this, I).event(S),
+                k = S.changedTouches,
+                B = k.length,
+                C, F;
+            for (Op(S), h && clearTimeout(h), h = setTimeout(function() {
                     h = null;
-                }, d), U = 0; U < k; ++U)
-                C = L[U], D.touch0 && D.touch0[2] === C.identifier ? delete D.touch0 : D.touch1 && D.touch1[2] === C.identifier && delete D.touch1;
-            if (D.touch1 && !D.touch0 && (D.touch0 = D.touch1, delete D.touch1), D.touch0)
-                D.touch0[1] = this.__zoom.invert(D.touch0[0]);
-            else if (D.end(), D.taps === 2 && (C = yi(C, this), Math.hypot(f[0] - C[0], f[1] - C[1]) < g)) {
-                var z = ce(this).on("dblclick.zoom");
-                z && z.apply(this, arguments);
+                }, d), C = 0; C < B; ++C)
+                F = k[C], E.touch0 && E.touch0[2] === F.identifier ? delete E.touch0 : E.touch1 && E.touch1[2] === F.identifier && delete E.touch1;
+            if (E.touch1 && !E.touch0 && (E.touch0 = E.touch1, delete E.touch1), E.touch0)
+                E.touch0[1] = this.__zoom.invert(E.touch0[0]);
+            else if (E.end(), E.taps === 2 && (F = On(F, this), Math.hypot(f[0] - F[0], f[1] - F[1]) < m)) {
+                var P = Wt(this).on("dblclick.zoom");
+                P && P.apply(this, arguments);
             }
         }
     }
-    return y.wheelDelta = function(S) {
-        return arguments.length ? (i = typeof S == "function" ? S : _h(+S), y) : i;
-    }, y.filter = function(S) {
-        return arguments.length ? (e = typeof S == "function" ? S : _h(!!S), y) : e;
-    }, y.touchable = function(S) {
-        return arguments.length ? (r = typeof S == "function" ? S : _h(!!S), y) : r;
-    }, y.extent = function(S) {
-        return arguments.length ? (t = typeof S == "function" ? S : _h([
+    return g.wheelDelta = function(S) {
+        return arguments.length ? (r = typeof S == "function" ? S : ol(+S), g) : r;
+    }, g.filter = function(S) {
+        return arguments.length ? (e = typeof S == "function" ? S : ol(!!S), g) : e;
+    }, g.touchable = function(S) {
+        return arguments.length ? (i = typeof S == "function" ? S : ol(!!S), g) : i;
+    }, g.extent = function(S) {
+        return arguments.length ? (t = typeof S == "function" ? S : ol([
             [+S[0][0], +S[0][1]],
             [+S[1][0], +S[1][1]]
-        ]), y) : t;
-    }, y.scaleExtent = function(S) {
-        return arguments.length ? (s[0] = +S[0], s[1] = +S[1], y) : [s[0], s[1]];
-    }, y.translateExtent = function(S) {
-        return arguments.length ? (o[0][0] = +S[0][0], o[1][0] = +S[1][0], o[0][1] = +S[0][1], o[1][1] = +S[1][1], y) : [
+        ]), g) : t;
+    }, g.scaleExtent = function(S) {
+        return arguments.length ? (s[0] = +S[0], s[1] = +S[1], g) : [s[0], s[1]];
+    }, g.translateExtent = function(S) {
+        return arguments.length ? (o[0][0] = +S[0][0], o[1][0] = +S[1][0], o[0][1] = +S[0][1], o[1][1] = +S[1][1], g) : [
             [o[0][0], o[0][1]],
             [o[1][0], o[1][1]]
         ];
-    }, y.constrain = function(S) {
-        return arguments.length ? (n = S, y) : n;
-    }, y.duration = function(S) {
-        return arguments.length ? (a = +S, y) : a;
-    }, y.interpolate = function(S) {
-        return arguments.length ? (c = S, y) : c;
-    }, y.on = function() {
-        var S = l.on.apply(l, arguments);
-        return S === l ? y : S;
-    }, y.clickDistance = function(S) {
-        return arguments.length ? (m = (S = +S) * S, y) : Math.sqrt(m);
-    }, y.tapDistance = function(S) {
-        return arguments.length ? (g = +S, y) : g;
-    }, y;
+    }, g.constrain = function(S) {
+        return arguments.length ? (n = S, g) : n;
+    }, g.duration = function(S) {
+        return arguments.length ? (a = +S, g) : a;
+    }, g.interpolate = function(S) {
+        return arguments.length ? (c = S, g) : c;
+    }, g.on = function() {
+        var S = u.on.apply(u, arguments);
+        return S === u ? g : S;
+    }, g.clickDistance = function(S) {
+        return arguments.length ? (y = (S = +S) * S, g) : Math.sqrt(y);
+    }, g.tapDistance = function(S) {
+        return arguments.length ? (m = +S, g) : m;
+    }, g;
 }
 
-function dn(e) {
+function Ce(e) {
     return e != null && !Number.isNaN(e);
 }
 
-function li(e, t) {
-    return +dn(t) - +dn(e) || me(e, t);
+function In(e, t) {
+    return +Ce(t) - +Ce(e) || zt(e, t);
 }
 
-function Cp(e, t) {
-    return +dn(t) - +dn(e) || Ho(e, t);
+function lh(e, t) {
+    return +Ce(t) - +Ce(e) || Is(e, t);
 }
 
-function vw(e) {
+function tg(e) {
     return e != null && `${e}` != "";
 }
 
-function kp(e) {
+function fh(e) {
     return isFinite(e) ? e : NaN;
 }
 
 function Qr(e) {
     return e > 0 && isFinite(e) ? e : NaN;
 }
 
-function g0(e) {
+function dd(e) {
     return e < 0 && isFinite(e) ? e : NaN;
 }
 
-function iD(e, t) {
+function HM(e, t) {
     if (e instanceof Date || (e = /* @__PURE__ */ new Date(+e)), isNaN(e))
         return typeof t == "function" ? t(e) : t;
     const n = e.getUTCHours(),
-        i = e.getUTCMinutes(),
-        r = e.getUTCSeconds(),
+        r = e.getUTCMinutes(),
+        i = e.getUTCSeconds(),
         s = e.getUTCMilliseconds();
-    return `${LH(e.getUTCFullYear())}-${Pr(e.getUTCMonth() + 1, 2)}-${Pr(e.getUTCDate(), 2)}${n || i || r || s ? `T${Pr(n, 2)}:${Pr(i, 2)}${r || s ? `:${Pr(r, 2)}${s ? `.${Pr(s, 3)}` : ""}` : ""}Z` : ""}`;
+    return `${Vj(e.getUTCFullYear())}-${zr(e.getUTCMonth() + 1, 2)}-${zr(e.getUTCDate(), 2)}${n || r || i || s ? `T${zr(n, 2)}:${zr(r, 2)}${i || s ? `:${zr(i, 2)}${s ? `.${zr(s, 3)}` : ""}` : ""}Z` : ""}`;
 }
 
-function LH(e) {
-    return e < 0 ? `-${Pr(-e, 6)}` : e > 9999 ? `+${Pr(e, 6)}` : Pr(e, 4);
+function Vj(e) {
+    return e < 0 ? `-${zr(-e, 6)}` : e > 9999 ? `+${zr(e, 6)}` : zr(e, 4);
 }
 
-function Pr(e, t) {
+function zr(e, t) {
     return `${e}`.padStart(t, "0");
 }
-const RH = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
+const Yj = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
 
-function _w(e, t) {
-    return RH.test(e += "") ? new Date(e) : typeof t == "function" ? t(e) : t;
+function JM(e, t) {
+    return Yj.test(e += "") ? new Date(e) : typeof t == "function" ? t(e) : t;
 }
 
-function kc(e) {
+function ta(e) {
     if (e == null)
         return;
     const t = e[0],
         n = e[e.length - 1];
-    return Ho(t, n);
+    return Is(t, n);
 }
-const tc = 1e3,
-    Es = tc * 60,
-    Ls = Es * 60,
-    dr = Ls * 24,
-    Wi = dr * 7,
-    Vo = dr * 30,
-    xs = dr * 365,
-    km = [
+const go = 1e3,
+    Ti = go * 60,
+    Ei = Ti * 60,
+    _r = Ei * 24,
+    nr = _r * 7,
+    _s = _r * 30,
+    gi = _r * 365,
+    Lp = [
         ["millisecond", 1],
         ["2 milliseconds", 2],
         ["5 milliseconds", 5],
         ["10 milliseconds", 10],
         ["20 milliseconds", 20],
         ["50 milliseconds", 50],
         ["100 milliseconds", 100],
         ["200 milliseconds", 200],
         ["500 milliseconds", 500],
-        ["second", tc],
-        ["5 seconds", 5 * tc],
-        ["15 seconds", 15 * tc],
-        ["30 seconds", 30 * tc],
-        ["minute", Es],
-        ["5 minutes", 5 * Es],
-        ["15 minutes", 15 * Es],
-        ["30 minutes", 30 * Es],
-        ["hour", Ls],
-        ["3 hours", 3 * Ls],
-        ["6 hours", 6 * Ls],
-        ["12 hours", 12 * Ls],
-        ["day", dr],
-        ["2 days", 2 * dr],
-        ["week", Wi],
-        ["2 weeks", 2 * Wi],
+        ["second", go],
+        ["5 seconds", 5 * go],
+        ["15 seconds", 15 * go],
+        ["30 seconds", 30 * go],
+        ["minute", Ti],
+        ["5 minutes", 5 * Ti],
+        ["15 minutes", 15 * Ti],
+        ["30 minutes", 30 * Ti],
+        ["hour", Ei],
+        ["3 hours", 3 * Ei],
+        ["6 hours", 6 * Ei],
+        ["12 hours", 12 * Ei],
+        ["day", _r],
+        ["2 days", 2 * _r],
+        ["week", nr],
+        ["2 weeks", 2 * nr],
         // https://github.com/d3/d3-time/issues/46
-        ["month", Vo],
-        ["3 months", 3 * Vo],
-        ["6 months", 6 * Vo],
+        ["month", _s],
+        ["3 months", 3 * _s],
+        ["6 months", 6 * _s],
         // https://github.com/d3/d3-time/issues/46
-        ["year", xs],
-        ["2 years", 2 * xs],
-        ["5 years", 5 * xs],
-        ["10 years", 10 * xs],
-        ["20 years", 20 * xs],
-        ["50 years", 50 * xs],
-        ["100 years", 100 * xs]
+        ["year", gi],
+        ["2 years", 2 * gi],
+        ["5 years", 5 * gi],
+        ["10 years", 10 * gi],
+        ["20 years", 20 * gi],
+        ["50 years", 50 * gi],
+        ["100 years", 100 * gi]
         // TODO generalize to longer time scales
     ],
-    xw = /* @__PURE__ */ new Map([
-        ["second", tc],
-        ["minute", Es],
-        ["hour", Ls],
-        ["day", dr],
-        ["monday", Wi],
-        ["tuesday", Wi],
-        ["wednesday", Wi],
-        ["thursday", Wi],
-        ["friday", Wi],
-        ["saturday", Wi],
-        ["sunday", Wi],
-        ["week", Wi],
-        ["month", Vo],
-        ["year", xs]
+    eg = /* @__PURE__ */ new Map([
+        ["second", go],
+        ["minute", Ti],
+        ["hour", Ei],
+        ["day", _r],
+        ["monday", nr],
+        ["tuesday", nr],
+        ["wednesday", nr],
+        ["thursday", nr],
+        ["friday", nr],
+        ["saturday", nr],
+        ["sunday", nr],
+        ["week", nr],
+        ["month", _s],
+        ["year", gi]
     ]),
-    rD = /* @__PURE__ */ new Map([
-        ["second", xi],
-        ["minute", Mf],
-        ["hour", Tf],
-        ["day", aa],
+    ZM = /* @__PURE__ */ new Map([
+        ["second", Bn],
+        ["minute", yu],
+        ["hour", gu],
+        ["day", Ps],
         // https://github.com/d3/d3-time/issues/62
-        ["monday", Pu],
-        ["tuesday", Q$],
-        ["wednesday", t6],
-        ["thursday", na],
-        ["friday", e6],
-        ["saturday", n6],
-        ["sunday", Rc],
-        ["week", Rc],
-        ["month", Nf],
-        ["year", Di]
+        ["monday", Cc],
+        ["tuesday", Y3],
+        ["wednesday", W3],
+        ["thursday", ks],
+        ["friday", X3],
+        ["saturday", G3],
+        ["sunday", Ko],
+        ["week", Ko],
+        ["month", wu],
+        ["year", Yn]
     ]),
-    Sw = /* @__PURE__ */ new Map([
-        ["second", xi],
-        ["minute", $f],
-        ["hour", Df],
-        ["day", u0],
-        ["monday", Vu],
-        ["tuesday", i6],
-        ["wednesday", r6],
-        ["thursday", ia],
-        ["friday", s6],
-        ["saturday", o6],
-        ["sunday", Cc],
-        ["week", Cc],
-        ["month", Bf],
-        ["year", Ni]
+    ng = /* @__PURE__ */ new Map([
+        ["second", Bn],
+        ["minute", mu],
+        ["hour", bu],
+        ["day", od],
+        ["monday", Pc],
+        ["tuesday", H3],
+        ["wednesday", J3],
+        ["thursday", Rs],
+        ["friday", Z3],
+        ["saturday", K3],
+        ["sunday", Qo],
+        ["week", Qo],
+        ["month", vu],
+        ["year", Wn]
     ]),
-    Ef = Symbol("intervalDuration"),
-    b0 = Symbol("intervalType");
-for (const [e, t] of rD)
-    t[Ef] = xw.get(e), t[b0] = "time";
-for (const [e, t] of Sw)
-    t[Ef] = xw.get(e), t[b0] = "utc";
-const Ql = [
-        ["year", Ni, "utc"],
-        ["month", Bf, "utc"],
-        ["day", u0, "utc", 6 * Vo],
-        ["hour", Df, "utc", 3 * dr],
-        ["minute", $f, "utc", 6 * Ls],
-        ["second", xi, "utc", 30 * Es]
+    Su = Symbol("intervalDuration"),
+    pd = Symbol("intervalType");
+for (const [e, t] of ZM)
+    t[Su] = eg.get(e), t[pd] = "time";
+for (const [e, t] of ng)
+    t[Su] = eg.get(e), t[pd] = "utc";
+const sc = [
+        ["year", Wn, "utc"],
+        ["month", vu, "utc"],
+        ["day", od, "utc", 6 * _s],
+        ["hour", bu, "utc", 3 * _r],
+        ["minute", mu, "utc", 6 * Ei],
+        ["second", Bn, "utc", 30 * Ti]
     ],
-    od = [
-        ["year", Di, "time"],
-        ["month", Nf, "time"],
-        ["day", aa, "time", 6 * Vo],
-        ["hour", Tf, "time", 3 * dr],
-        ["minute", Mf, "time", 6 * Ls],
-        ["second", xi, "time", 30 * Es]
+    Ul = [
+        ["year", Yn, "time"],
+        ["month", wu, "time"],
+        ["day", Ps, "time", 6 * _s],
+        ["hour", gu, "time", 3 * _r],
+        ["minute", yu, "time", 6 * Ei],
+        ["second", Bn, "time", 30 * Ti]
     ],
-    CH = [
-        Ql[0],
-        od[0],
-        Ql[1],
-        od[1],
-        Ql[2],
-        od[2],
+    Wj = [
+        sc[0],
+        Ul[0],
+        sc[1],
+        Ul[1],
+        sc[2],
+        Ul[2],
         // Below day, local time typically has an hourly offset from UTC and hence the
         // two are aligned and indistinguishable; therefore, we only consider UTC, and
         // we dont consider these if the domain only has a single value.
-        ...Ql.slice(3)
+        ...sc.slice(3)
     ];
 
-function Iw(e) {
+function rg(e) {
     let t = `${e}`.toLowerCase();
     t.endsWith("s") && (t = t.slice(0, -1));
     let n = 1;
-    const i = /^(?:(\d+)\s+)/.exec(t);
-    switch (i && (t = t.slice(i[0].length), n = +i[1]), t) {
+    const r = /^(?:(\d+)\s+)/.exec(t);
+    switch (r && (t = t.slice(r[0].length), n = +r[1]), t) {
         case "quarter":
             t = "month", n *= 3;
             break;
         case "half":
             t = "month", n *= 6;
             break;
     }
-    let r = Sw.get(t);
-    if (!r)
+    let i = ng.get(t);
+    if (!i)
         throw new Error(`unknown interval: ${e}`);
-    if (n > 1 && !r.every)
+    if (n > 1 && !i.every)
         throw new Error(`non-periodic interval: ${t}`);
     return [t, n];
 }
 
-function sD(e) {
-    return oD(Iw(e), "time");
+function KM(e) {
+    return QM(rg(e), "time");
 }
 
-function Aw(e) {
-    return oD(Iw(e), "utc");
+function ig(e) {
+    return QM(rg(e), "utc");
 }
 
-function oD([e, t], n) {
-    let i = (n === "time" ? rD : Sw).get(e);
-    return t > 1 && (i = i.every(t), i[Ef] = xw.get(e) * t, i[b0] = n), i;
+function QM([e, t], n) {
+    let r = (n === "time" ? ZM : ng).get(e);
+    return t > 1 && (r = r.every(t), r[Su] = eg.get(e) * t, r[pd] = n), r;
 }
 
-function Vx(e, t) {
+function i2(e, t) {
     if (!(t > 1))
         return;
-    const n = e[Ef];
-    if (!km.some(([, r]) => r === n) || n % dr === 0 && dr < n && n < Vo)
+    const n = e[Su];
+    if (!Lp.some(([, i]) => i === n) || n % _r === 0 && _r < n && n < _s)
         return;
-    const [i] = km[Yy(([, r]) => Math.log(r)).center(km, Math.log(n * t))];
-    return (e[b0] === "time" ? sD : Aw)(i);
+    const [r] = Lp[zh(([, i]) => Math.log(i)).center(Lp, Math.log(n * t))];
+    return (e[pd] === "time" ? KM : ig)(r);
 }
 
-function jx(e, t, n) {
-    const i = t === "time" ? hw : Of;
+function s2(e, t, n) {
+    const r = t === "time" ? Wm : _u;
     if (n == null)
-        return i(
+        return r(
             e === "year" ? "%Y" : e === "month" ? "%Y-%m" : e === "day" ? "%Y-%m-%d" : e === "hour" || e === "minute" ? "%Y-%m-%dT%H:%M" : e === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
         );
-    const r = kH(n);
+    const i = Xj(n);
     switch (e) {
         case "millisecond":
-            return Ia(i(".%L"), i(":%M:%S"), r);
+            return to(r(".%L"), r(":%M:%S"), i);
         case "second":
-            return Ia(i(":%S"), i("%-I:%M"), r);
+            return to(r(":%S"), r("%-I:%M"), i);
         case "minute":
-            return Ia(i("%-I:%M"), i("%p"), r);
+            return to(r("%-I:%M"), r("%p"), i);
         case "hour":
-            return Ia(i("%-I %p"), i("%b %-d"), r);
+            return to(r("%-I %p"), r("%b %-d"), i);
         case "day":
-            return Ia(i("%-d"), i("%b"), r);
+            return to(r("%-d"), r("%b"), i);
         case "month":
-            return Ia(i("%b"), i("%Y"), r);
+            return to(r("%b"), r("%Y"), i);
         case "year":
-            return i("%Y");
+            return r("%Y");
     }
     throw new Error("unable to format time ticks");
 }
 
-function kH(e) {
+function Xj(e) {
     return e === "left" || e === "right" ? (t, n) => `
 ${t}
 ${n}` : e === "top" ? (t, n) => `${n}
 ${t}` : (t, n) => `${t}
 ${n}`;
 }
 
-function UH(e) {
-    return e === "time" ? od : e === "utc" ? Ql : CH;
+function Gj(e) {
+    return e === "time" ? Ul : e === "utc" ? sc : Wj;
 }
 
-function zH(e, t, n) {
-    const i = De(jz(t, (r, s) => Math.abs(s - r)));
-    if (i < 1e3)
-        return jx("millisecond", "utc", n);
-    for (const [r, s, o, a] of UH(e)) {
-        if (i > a || r === "hour" && !i)
+function Hj(e, t, n) {
+    const r = ae(Kk(t, (i, s) => Math.abs(s - i)));
+    if (r < 1e3)
+        return s2("millisecond", "utc", n);
+    for (const [i, s, o, a] of Gj(e)) {
+        if (r > a || i === "hour" && !r)
             break;
         if (t.every((c) => s.floor(c) >= c))
-            return jx(r, o, n);
+            return s2(i, o, n);
     }
 }
 
-function Ia(e, t, n) {
-    return (i, r, s) => {
-        const o = e(i, r),
-            a = t(i, r),
-            c = r - kc(s);
-        return r !== c && s[c] !== void 0 && a === t(s[c], c) ? o : n(o, a);
+function to(e, t, n) {
+    return (r, i, s) => {
+        const o = e(r, i),
+            a = t(r, i),
+            c = i - ta(s);
+        return i !== c && s[c] !== void 0 && a === t(s[c], c) ? o : n(o, a);
     };
 }
-const Uc = Object.getPrototypeOf(Uint8Array),
-    PH = Object.prototype.toString,
-    aD = Symbol("reindex");
+const ea = Object.getPrototypeOf(Uint8Array),
+    Jj = Object.prototype.toString,
+    tA = Symbol("reindex");
 
-function Pt(e, t, n) {
-    const i = typeof t;
-    return i === "string" ? qx(e, cD(t), n) : i === "function" ? qx(e, t, n) : i === "number" || t instanceof Date || i === "boolean" ? ye(e, jn(t), n) : typeof(t == null ? void 0 : t.transform) == "function" ? Yx(t.transform(e), n) : VH(Yx(t, n), e == null ? void 0 : e[aD]);
+function $t(e, t, n) {
+    const r = typeof t;
+    return r === "string" ? o2(e, eA(t), n) : r === "function" ? o2(e, t, n) : r === "number" || t instanceof Date || r === "boolean" ? Zt(e, fn(t), n) : typeof(t == null ? void 0 : t.transform) == "function" ? a2(t.transform(e), n) : Zj(a2(t, n), e == null ? void 0 : e[tA]);
 }
 
-function VH(e, t) {
-    return t ? _0(e, t) : e;
+function Zj(e, t) {
+    return t ? gd(e, t) : e;
 }
 
-function qx(e, t, n) {
-    return ye(e, (n == null ? void 0 : n.prototype) instanceof Uc ? jH(t) : t, n);
+function o2(e, t, n) {
+    return Zt(e, (n == null ? void 0 : n.prototype) instanceof ea ? Kj(t) : t, n);
 }
 
-function Yx(e, t) {
-    return t === void 0 ? Nn(e) : e instanceof t ? e : t.prototype instanceof Uc && !(e instanceof Uc) ? t.from(e, Tw) : t.from(e);
+function a2(e, t) {
+    return t === void 0 ? Qe(e) : e instanceof t ? e : t.prototype instanceof ea && !(e instanceof ea) ? t.from(e, ag) : t.from(e);
 }
 
-function jH(e) {
-    return (t, n) => Tw(e(t, n));
+function Kj(e) {
+    return (t, n) => ag(e(t, n));
 }
-const yu = [null],
-    cD = (e) => (t) => t[e],
-    vn = {
-        transform: fs
+const hc = [null],
+    eA = (e) => (t) => t[e],
+    Ve = {
+        transform: ui
     },
-    Tt = {
+    yt = {
         transform: (e) => e
     },
-    Mw = () => 1,
-    qH = () => !0,
-    tn = (e) => e == null ? e : `${e}`,
-    qt = (e) => e == null ? e : +e,
-    w0 = (e) => e ? e[0] : void 0,
-    qu = (e) => e ? e[1] : void 0,
-    YH = (e) => e ? e[2] : void 0,
-    jn = (e) => () => e;
+    sg = () => 1,
+    Qj = () => !0,
+    Ee = (e) => e == null ? e : `${e}`,
+    Nt = (e) => e == null ? e : +e,
+    yd = (e) => e ? e[0] : void 0,
+    zc = (e) => e ? e[1] : void 0,
+    tV = (e) => e ? e[2] : void 0,
+    fn = (e) => () => e;
 
-function $w(e) {
+function og(e) {
     const t = +`${e}`.slice(1) / 100;
-    return (n, i) => Ws(n, t, i);
+    return (n, r) => Pi(n, t, r);
 }
 
-function An(e) {
-    return e instanceof Uc ? e : ye(e, Tw, Float64Array);
+function He(e) {
+    return e instanceof ea ? e : Zt(e, ag, Float64Array);
 }
 
-function Tw(e) {
+function ag(e) {
     return e == null ? NaN : Number(e);
 }
 
-function WH(e) {
-    return ye(e, lD);
+function eV(e) {
+    return Zt(e, nA);
 }
 
-function lD(e) {
-    return e instanceof Date && !isNaN(e) ? e : typeof e == "string" ? _w(e) : e == null || isNaN(e = +e) ? void 0 : new Date(e);
+function nA(e) {
+    return e instanceof Date && !isNaN(e) ? e : typeof e == "string" ? JM(e) : e == null || isNaN(e = +e) ? void 0 : new Date(e);
 }
 
-function mn(e, t) {
-    return e === void 0 && (e = t), e === null ? [void 0, "none"] : Lf(e) ? [void 0, e] : [e, void 0];
+function ze(e, t) {
+    return e === void 0 && (e = t), e === null ? [void 0, "none"] : Mu(e) ? [void 0, e] : [e, void 0];
 }
 
-function Be(e, t) {
+function ue(e, t) {
     return e === void 0 && (e = t), e === null || typeof e == "number" ? [void 0, e] : [e, void 0];
 }
 
-function uD(e, t, n) {
+function rA(e, t, n) {
     if (e != null)
-        return qn(e, t, n);
+        return hn(e, t, n);
 }
 
-function qn(e, t, n) {
-    const i = `${e}`.toLowerCase();
-    if (!n.includes(i))
+function hn(e, t, n) {
+    const r = `${e}`.toLowerCase();
+    if (!n.includes(r))
         throw new Error(`invalid ${t}: ${e}`);
-    return i;
+    return r;
 }
 
-function Nn(e) {
-    return e == null || e instanceof Array || e instanceof Uc ? e : Array.from(e);
+function Qe(e) {
+    return e == null || e instanceof Array || e instanceof ea ? e : Array.from(e);
 }
 
-function ye(e, t, n = Array) {
+function Zt(e, t, n = Array) {
     return e == null ? e : e instanceof n ? e.map(t) : n.from(e, t);
 }
 
-function Yu(e, t = Array) {
+function qc(e, t = Array) {
     return e instanceof t ? e.slice() : t.from(e);
 }
 
-function fD({
+function iA({
     x: e,
     x1: t,
     x2: n
 }) {
     return e !== void 0 || t !== void 0 || n !== void 0;
 }
 
-function hD({
+function sA({
     y: e,
     y1: t,
     y2: n
 }) {
     return e !== void 0 || t !== void 0 || n !== void 0;
 }
 
-function v0(e) {
-    return fD(e) || hD(e) || e.interval !== void 0;
+function md(e) {
+    return iA(e) || sA(e) || e.interval !== void 0;
 }
 
-function hi(e) {
-    return (e == null ? void 0 : e.toString) === PH;
+function En(e) {
+    return (e == null ? void 0 : e.toString) === Jj;
 }
 
-function jo(e) {
-    return hi(e) && (e.type !== void 0 || e.domain !== void 0);
+function xs(e) {
+    return En(e) && (e.type !== void 0 || e.domain !== void 0);
 }
 
-function Hi(e) {
-    return hi(e) && typeof e.transform != "function";
+function rr(e) {
+    return En(e) && typeof e.transform != "function";
 }
 
-function Hs(e) {
-    return Hi(e) && e.value === void 0 && e.channel === void 0;
+function qi(e) {
+    return rr(e) && e.value === void 0 && e.channel === void 0;
 }
 
-function dD(e, t, n, i = Tt) {
-    return t === void 0 && n === void 0 ? (t = 0, n = e === void 0 ? i : e) : t === void 0 ? t = e === void 0 ? 0 : e : n === void 0 && (n = e === void 0 ? 0 : e), [t, n];
+function oA(e, t, n, r = yt) {
+    return t === void 0 && n === void 0 ? (t = 0, n = e === void 0 ? r : e) : t === void 0 ? t = e === void 0 ? 0 : e : n === void 0 && (n = e === void 0 ? 0 : e), [t, n];
 }
 
-function ki(e, t) {
-    return e === void 0 && t === void 0 ? [w0, qu] : [e, t];
+function Jn(e, t) {
+    return e === void 0 && t === void 0 ? [yd, zc] : [e, t];
 }
 
-function co({
+function Qi({
     z: e,
     fill: t,
     stroke: n
 } = {}) {
-    return e === void 0 && ([e] = mn(t)), e === void 0 && ([e] = mn(n)), e;
+    return e === void 0 && ([e] = ze(t)), e === void 0 && ([e] = ze(n)), e;
 }
 
-function fs(e) {
+function ui(e) {
     const t = e.length,
         n = new Uint32Array(t);
-    for (let i = 0; i < t; ++i)
-        n[i] = i;
+    for (let r = 0; r < t; ++r)
+        n[r] = r;
     return n;
 }
 
-function _0(e, t) {
-    return ye(t, (n) => e[n], e.constructor);
+function gd(e, t) {
+    return Zt(t, (n) => e[n], e.constructor);
 }
 
-function Dw(e) {
-    return e.length === 1 ? (t, n) => e(_0(n, t)) : e;
+function cg(e) {
+    return e.length === 1 ? (t, n) => e(gd(n, t)) : e;
 }
 
-function qo(e, t, n) {
+function Ss(e, t, n) {
     return e.subarray ? e.subarray(t, n) : e.slice(t, n);
 }
 
-function Eo(e) {
+function ys(e) {
     return e !== null && typeof e == "object" ? e.valueOf() : e;
 }
 
-function pD(e, t) {
+function aA(e, t) {
     if (t[e] !== void 0)
         return t[e];
     switch (e) {
         case "x1":
         case "x2":
             e = "x";
             break;
@@ -23230,2646 +23793,2646 @@
         case "y2":
             e = "y";
             break;
     }
     return t[e];
 }
 
-function Un(e) {
+function an(e) {
     let t;
     return [{
             transform: () => t,
-            label: wr(e)
+            label: Ar(e)
         },
         (n) => t = n
     ];
 }
 
-function xn(e) {
-    return e == null ? [e] : Un(e);
+function We(e) {
+    return e == null ? [e] : an(e);
 }
 
-function wr(e, t) {
+function Ar(e, t) {
     return typeof e == "string" ? e : e && e.label !== void 0 ? e.label : t;
 }
 
-function Up(e, t) {
+function hh(e, t) {
     return {
         transform(n) {
-            const i = e.transform(n),
-                r = t.transform(n);
-            return gn(i) || gn(r) ? ye(i, (s, o) => new Date((+i[o] + +r[o]) / 2)) : ye(i, (s, o) => (+i[o] + +r[o]) / 2, Float64Array);
+            const r = e.transform(n),
+                i = t.transform(n);
+            return qe(r) || qe(i) ? Zt(r, (s, o) => new Date((+r[o] + +i[o]) / 2)) : Zt(r, (s, o) => (+r[o] + +i[o]) / 2, Float64Array);
         },
         label: e.label
     };
 }
 
-function zp(e, t) {
-    const n = yD(t == null ? void 0 : t.interval, t == null ? void 0 : t.type);
-    return n ? ye(e, n) : e;
+function dh(e, t) {
+    const n = cA(t == null ? void 0 : t.interval, t == null ? void 0 : t.type);
+    return n ? Zt(e, n) : e;
 }
 
-function yD(e, t) {
-    const n = x0(e, t);
-    return n && ((i) => dn(i) ? n.floor(i) : i);
+function cA(e, t) {
+    const n = bd(e, t);
+    return n && ((r) => Ce(r) ? n.floor(r) : r);
 }
 
-function x0(e, t) {
+function bd(e, t) {
     if (e != null) {
         if (typeof e == "number") {
             0 < e && e < 1 && Number.isInteger(1 / e) && (e = -1 / e);
             const n = Math.abs(e);
             return e < 0 ? {
-                floor: (i) => Math.floor(i * n) / n,
-                offset: (i) => (i * n + 1) / n,
+                floor: (r) => Math.floor(r * n) / n,
+                offset: (r) => (r * n + 1) / n,
                 // note: no optional step for simplicity
-                range: (i, r) => Cn(Math.ceil(i * n), r * n).map((s) => s / n)
+                range: (r, i) => sn(Math.ceil(r * n), i * n).map((s) => s / n)
             } : {
-                floor: (i) => Math.floor(i / n) * n,
-                offset: (i) => i + n,
+                floor: (r) => Math.floor(r / n) * n,
+                offset: (r) => r + n,
                 // note: no optional step for simplicity
-                range: (i, r) => Cn(Math.ceil(i / n), r / n).map((s) => s * n)
+                range: (r, i) => sn(Math.ceil(r / n), i / n).map((s) => s * n)
             };
         }
         if (typeof e == "string")
-            return (t === "time" ? sD : Aw)(e);
+            return (t === "time" ? KM : ig)(e);
         if (typeof e.floor != "function")
             throw new Error("invalid interval; missing floor method");
         if (typeof e.offset != "function")
             throw new Error("invalid interval; missing offset method");
         return e;
     }
 }
 
-function ol(e, t) {
-    if (e = x0(e, t), e && typeof e.range != "function")
+function ba(e, t) {
+    if (e = bd(e, t), e && typeof e.range != "function")
         throw new Error("invalid interval: missing range method");
     return e;
 }
 
-function GH(e, t) {
-    if (e = ol(e, t), e && typeof e.ceil != "function")
+function nV(e, t) {
+    if (e = ba(e, t), e && typeof e.ceil != "function")
         throw new Error("invalid interval: missing ceil method");
     return e;
 }
 
-function XH(e) {
-    return ec(e) && typeof(e == null ? void 0 : e.floor) == "function" && e.floor() instanceof Date;
+function rV(e) {
+    return bo(e) && typeof(e == null ? void 0 : e.floor) == "function" && e.floor() instanceof Date;
 }
 
-function ec(e) {
+function bo(e) {
     return typeof(e == null ? void 0 : e.range) == "function";
 }
 
-function al(e) {
-    return e === void 0 || Hi(e) ? e : {
+function wa(e) {
+    return e === void 0 || rr(e) ? e : {
         value: e
     };
 }
 
-function HH(e) {
+function iV(e) {
     return e == null ? null : {
-        transform: (t) => Pt(t, e, Float64Array),
-        label: wr(e)
+        transform: (t) => $t(t, e, Float64Array),
+        label: Ar(e)
     };
 }
 
-function JH(e) {
-    if (!hs(e))
+function sV(e) {
+    if (!li(e))
         return !1;
     for (const t of e)
         if (t != null)
             return typeof t == "object" && "0" in t && "1" in t;
 }
 
-function hs(e) {
+function li(e) {
     return e && typeof e[Symbol.iterator] == "function";
 }
 
-function mD(e) {
+function uA(e) {
     for (const t of e)
         if (t != null)
             return typeof t != "object" || t instanceof Date;
 }
 
-function Ae(e) {
+function ie(e) {
     for (const t of e) {
         if (t == null)
             continue;
         const n = typeof t;
         return n === "string" || n === "boolean";
     }
 }
 
-function gn(e) {
+function qe(e) {
     for (const t of e)
         if (t != null)
             return t instanceof Date;
 }
 
-function KH(e) {
+function oV(e) {
     for (const t of e)
         if (t != null)
-            return typeof t == "string" && isNaN(t) && _w(t);
+            return typeof t == "string" && isNaN(t) && JM(t);
 }
 
-function ZH(e) {
+function aV(e) {
     for (const t of e)
         if (t != null) {
             if (typeof t != "string")
                 return !1;
             if (t.trim())
                 return !isNaN(t);
         }
 }
 
-function nc(e) {
+function wo(e) {
     for (const t of e)
         if (t != null)
             return typeof t == "number";
 }
 
-function Um(e, t) {
+function kp(e, t) {
     let n;
-    for (const i of e)
-        if (i != null) {
-            if (!t(i))
+    for (const r of e)
+        if (r != null) {
+            if (!t(r))
                 return !1;
             n = !0;
         }
     return n;
 }
-const QH = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
+const cV = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
 
-function Lf(e) {
+function Mu(e) {
     return typeof e != "string" ? !1 : (e = e.toLowerCase().trim(), /^#[0-9a-f]{3,8}$/.test(e) || // hex rgb, rgba, rrggbb, rrggbbaa
         /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\(.*\)$/.test(e) || // <funciri>, CSS variable, color, etc.
-        QH.has(e));
+        cV.has(e));
 }
 
-function tJ(e) {
+function uV(e) {
     return typeof e == "number" && (0 <= e && e <= 1 || isNaN(e));
 }
 
-function we(e) {
-    return e == null || zc(e);
+function te(e) {
+    return e == null || na(e);
 }
 
-function zc(e) {
+function na(e) {
     return /^\s*none\s*$/i.test(e);
 }
 
-function eJ(e) {
+function lV(e) {
     return /^\s*round\s*$/i.test(e);
 }
 
-function A1(e, t) {
-    return uD(e, t, [
+function dy(e, t) {
+    return rA(e, t, [
         "middle",
         "top-left",
         "top",
         "top-right",
         "right",
         "bottom-right",
         "bottom",
         "bottom-left",
         "left"
     ]);
 }
 
-function Rf(e = "middle") {
-    return A1(e, "frameAnchor");
+function Au(e = "middle") {
+    return dy(e, "frameAnchor");
 }
 
-function nJ(e = {}, ...t) {
+function fV(e = {}, ...t) {
     let n = e;
-    for (const i of t)
-        for (const r in i)
-            if (n[r] === void 0) {
-                const s = i[r];
+    for (const r of t)
+        for (const i in r)
+            if (n[i] === void 0) {
+                const s = r[i];
                 n === e ? n = {
                     ...n,
-                    [r]: s
-                } : n[r] = s;
+                    [i]: s
+                } : n[i] = s;
             }
     return n;
 }
 
-function iJ(e) {
+function hV(e) {
     console.warn("named iterables are deprecated; please use an object instead");
     const t = /* @__PURE__ */ new Set();
     return Object.fromEntries(
         Array.from(e, (n) => {
             const {
-                name: i
+                name: r
             } = n;
-            if (i == null)
+            if (r == null)
                 throw new Error("missing name");
-            const r = `${i}`;
-            if (r === "__proto__")
-                throw new Error(`illegal name: ${r}`);
-            if (t.has(r))
-                throw new Error(`duplicate name: ${r}`);
-            return t.add(r), [i, n];
+            const i = `${r}`;
+            if (i === "__proto__")
+                throw new Error(`illegal name: ${i}`);
+            if (t.has(i))
+                throw new Error(`duplicate name: ${i}`);
+            return t.add(i), [r, n];
         })
     );
 }
 
-function Nw(e) {
-    return hs(e) ? iJ(e) : e;
+function ug(e) {
+    return li(e) ? hV(e) : e;
 }
 
-function gD(e) {
-    return e === !0 ? e = "frame" : e === !1 ? e = null : e != null && (e = qn(e, "clip", ["frame", "sphere"])), e;
+function lA(e) {
+    return e === !0 ? e = "frame" : e === !1 ? e = null : e != null && (e = hn(e, "clip", ["frame", "sphere"])), e;
 }
-const rr = Symbol("position"),
-    ds = Symbol("color"),
-    Cf = Symbol("radius"),
-    kf = Symbol("length"),
-    Uf = Symbol("opacity"),
-    S0 = Symbol("symbol"),
-    bD = Symbol("projection"),
-    Se = /* @__PURE__ */ new Map([
-        ["x", rr],
-        ["y", rr],
-        ["fx", rr],
-        ["fy", rr],
-        ["r", Cf],
-        ["color", ds],
-        ["opacity", Uf],
-        ["symbol", S0],
-        ["length", kf],
-        ["projection", bD]
+const hr = Symbol("position"),
+    fi = Symbol("color"),
+    $u = Symbol("radius"),
+    Iu = Symbol("length"),
+    Tu = Symbol("opacity"),
+    wd = Symbol("symbol"),
+    fA = Symbol("projection"),
+    re = /* @__PURE__ */ new Map([
+        ["x", hr],
+        ["y", hr],
+        ["fx", hr],
+        ["fy", hr],
+        ["r", $u],
+        ["color", fi],
+        ["opacity", Tu],
+        ["symbol", wd],
+        ["length", Iu],
+        ["projection", fA]
     ]);
 
-function rJ(e) {
-    return e === rr || e === bD;
+function dV(e) {
+    return e === hr || e === fA;
 }
 
-function sJ(e) {
-    return e === rr || e === Cf || e === kf || e === Uf;
+function pV(e) {
+    return e === hr || e === $u || e === Iu || e === Tu;
 }
-const wD = Math.sqrt(3),
-    vD = 2 / wD,
-    oJ = {
+const hA = Math.sqrt(3),
+    dA = 2 / hA,
+    yV = {
         draw(e, t) {
             const n = Math.sqrt(t / Math.PI),
-                i = n * vD,
-                r = i / 2;
-            e.moveTo(0, i), e.lineTo(n, r), e.lineTo(n, -r), e.lineTo(0, -i), e.lineTo(-n, -r), e.lineTo(-n, r), e.closePath();
-        }
-    },
-    Bw = /* @__PURE__ */ new Map([
-        ["asterisk", OT],
-        ["circle", ju],
-        ["cross", FT],
-        ["diamond", LT],
-        ["diamond2", RT],
-        ["hexagon", oJ],
-        ["plus", CT],
-        ["square", kT],
-        ["square2", UT],
-        ["star", PT],
-        ["times", YT],
-        ["triangle", VT],
-        ["triangle2", jT],
-        ["wye", qT]
+                r = n * dA,
+                i = r / 2;
+            e.moveTo(0, r), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(0, -r), e.lineTo(-n, -i), e.lineTo(-n, i), e.closePath();
+        }
+    },
+    lg = /* @__PURE__ */ new Map([
+        ["asterisk", MM],
+        ["circle", Uc],
+        ["cross", AM],
+        ["diamond", IM],
+        ["diamond2", TM],
+        ["hexagon", yV],
+        ["plus", EM],
+        ["square", NM],
+        ["square2", DM],
+        ["star", LM],
+        ["times", BM],
+        ["triangle", kM],
+        ["triangle2", RM],
+        ["wye", FM]
     ]);
 
-function Ow(e) {
+function fg(e) {
     return e && typeof e.draw == "function";
 }
 
-function aJ(e) {
-    return Ow(e) ? !0 : typeof e != "string" ? !1 : Bw.has(e.toLowerCase());
+function mV(e) {
+    return fg(e) ? !0 : typeof e != "string" ? !1 : lg.has(e.toLowerCase());
 }
 
-function Fw(e) {
-    if (e == null || Ow(e))
+function hg(e) {
+    if (e == null || fg(e))
         return e;
-    const t = Bw.get(`${e}`.toLowerCase());
+    const t = lg.get(`${e}`.toLowerCase());
     if (t)
         return t;
     throw new Error(`invalid symbol: ${e}`);
 }
 
-function cJ(e) {
-    if (e == null || Ow(e))
+function gV(e) {
+    if (e == null || fg(e))
         return [void 0, e];
     if (typeof e == "string") {
-        const t = Bw.get(`${e}`.toLowerCase());
+        const t = lg.get(`${e}`.toLowerCase());
         if (t)
             return [void 0, t];
     }
     return [e, void 0];
 }
 
-function vr({
+function $r({
     filter: e,
     sort: t,
     reverse: n,
-    transform: i,
-    initializer: r,
+    transform: r,
+    initializer: i,
     ...s
 } = {}, o) {
-    if (i === void 0 && (e != null && (i = Ew(e)), t != null && !Hs(t) && (i = zm(i, Rw(t))), n && (i = zm(i, Lw))), o != null && r != null)
+    if (r === void 0 && (e != null && (r = dg(e)), t != null && !qi(t) && (r = Rp(r, yg(t))), n && (r = Rp(r, pg))), o != null && i != null)
         throw new Error("transforms cannot be applied after initializers");
     return {
         ...s,
-        ...(t === null || Hs(t)) && {
+        ...(t === null || qi(t)) && {
             sort: t
         },
-        transform: zm(i, o)
+        transform: Rp(r, o)
     };
 }
 
-function Bn({
+function tn({
     filter: e,
     sort: t,
     reverse: n,
-    initializer: i,
-    ...r
+    initializer: r,
+    ...i
 } = {}, s) {
-    return i === void 0 && (e != null && (i = Ew(e)), t != null && !Hs(t) && (i = Pm(i, Rw(t))), n && (i = Pm(i, Lw))), {
-        ...r,
-        ...(t === null || Hs(t)) && {
+    return r === void 0 && (e != null && (r = dg(e)), t != null && !qi(t) && (r = Fp(r, yg(t))), n && (r = Fp(r, pg))), {
+        ...i,
+        ...(t === null || qi(t)) && {
             sort: t
         },
-        initializer: Pm(i, s)
+        initializer: Fp(r, s)
     };
 }
 
-function zm(e, t) {
-    return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, i, r) {
+function Rp(e, t) {
+    return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, r, i) {
         return {
             data: n,
-            facets: i
-        } = e.call(this, n, i, r), t.call(this, Nn(n), i, r);
+            facets: r
+        } = e.call(this, n, r, i), t.call(this, Qe(n), r, i);
     };
 }
 
-function Pm(e, t) {
-    return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, i, r, ...s) {
-        let o, a, c, l, u, f;
+function Fp(e, t) {
+    return e == null ? t === null ? void 0 : t : t == null ? e === null ? void 0 : e : function(n, r, i, ...s) {
+        let o, a, c, u, l, f;
         return {
             data: a = n,
-            facets: c = i,
+            facets: c = r,
             channels: o
-        } = e.call(this, n, i, r, ...s), {
-            data: u = a,
+        } = e.call(this, n, r, i, ...s), {
+            data: l = a,
             facets: f = c,
-            channels: l
+            channels: u
         } = t.call(this, a, c, {
-            ...r,
+            ...i,
             ...o
         }, ...s), {
-            data: u,
+            data: l,
             facets: f,
             channels: {
                 ...o,
-                ...l
+                ...u
             }
         };
     };
 }
 
-function I0(e, t) {
-    return (e.initializer != null ? Bn : vr)(e, t);
+function vd(e, t) {
+    return (e.initializer != null ? tn : $r)(e, t);
 }
 
-function lJ(e, t) {
-    return I0(t, Ew(e));
+function bV(e, t) {
+    return vd(t, dg(e));
 }
 
-function Ew(e) {
+function dg(e) {
     return (t, n) => {
-        const i = Pt(t, e);
+        const r = $t(t, e);
         return {
             data: t,
-            facets: n.map((r) => r.filter((s) => i[s]))
+            facets: n.map((i) => i.filter((s) => r[s]))
         };
     };
 }
 
-function uJ({
+function wV({
     sort: e,
     ...t
 } = {}) {
     return {
-        ...I0(t, Lw),
-        sort: Hs(e) ? e : null
+        ...vd(t, pg),
+        sort: qi(e) ? e : null
     };
 }
 
-function Lw(e, t) {
+function pg(e, t) {
     return {
         data: e,
         facets: t.map((n) => n.slice().reverse())
     };
 }
 
-function fJ({
+function vV({
     seed: e,
     sort: t,
     ...n
 } = {}) {
     return {
-        ...I0(n, xD(e == null ? Math.random : Sf(e))),
-        sort: Hs(t) ? t : null
+        ...vd(n, yA(e == null ? Math.random : jm(e))),
+        sort: qi(t) ? t : null
     };
 }
 
-function _D(e, {
+function pA(e, {
     sort: t,
     ...n
 } = {}) {
     return {
-        ...(Hi(e) && e.channel !== void 0 ? Bn : I0)(n, Rw(e)),
-        sort: Hs(t) ? t : null
+        ...(rr(e) && e.channel !== void 0 ? tn : vd)(n, yg(e)),
+        sort: qi(t) ? t : null
     };
 }
 
-function Rw(e) {
-    return (typeof e == "function" && e.length !== 1 ? hJ : xD)(e);
+function yg(e) {
+    return (typeof e == "function" && e.length !== 1 ? _V : yA)(e);
 }
 
-function hJ(e) {
+function _V(e) {
     return (t, n) => {
-        const i = (r, s) => e(t[r], t[s]);
+        const r = (i, s) => e(t[i], t[s]);
         return {
             data: t,
-            facets: n.map((r) => r.slice().sort(i))
+            facets: n.map((i) => i.slice().sort(r))
         };
     };
 }
 
-function xD(e) {
+function yA(e) {
     let t, n;
     ({
         channel: t,
         value: e,
         order: n
     } = {
-        ...al(e)
+        ...wa(e)
     });
-    const i = t == null ? void 0 : t.startsWith("-");
-    if (i && (t = t.slice(1)), n === void 0 && (n = i ? Cp : li), typeof n != "function")
+    const r = t == null ? void 0 : t.startsWith("-");
+    if (r && (t = t.slice(1)), n === void 0 && (n = r ? lh : In), typeof n != "function")
         switch (`${n}`.toLowerCase()) {
             case "ascending":
-                n = li;
+                n = In;
                 break;
             case "descending":
-                n = Cp;
+                n = lh;
                 break;
             default:
                 throw new Error(`invalid order: ${n}`);
         }
-    return (r, s, o) => {
+    return (i, s, o) => {
         let a;
         if (t === void 0)
-            a = Pt(r, e);
+            a = $t(i, e);
         else {
             if (o === void 0)
                 throw new Error("channel sort requires an initializer");
             if (a = o[t], !a)
                 return {};
             a = a.value;
         }
-        const c = (l, u) => n(a[l], a[u]);
+        const c = (u, l) => n(a[u], a[l]);
         return {
-            data: r,
-            facets: s.map((l) => l.slice().sort(c))
+            data: i,
+            facets: s.map((u) => u.slice().sort(c))
         };
     };
 }
 
-function Cw(e, t) {
-    return A0(null, null, e, t);
+function mg(e, t) {
+    return _d(null, null, e, t);
 }
 
-function Wu(e = {
+function jc(e = {
     y: "count"
 }, t = {}) {
     const {
-        x: n = Tt
+        x: n = yt
     } = t;
     if (n == null)
         throw new Error("missing channel: x");
-    return A0(n, null, e, t);
+    return _d(n, null, e, t);
 }
 
-function Gu(e = {
+function Vc(e = {
     x: "count"
 }, t = {}) {
     const {
-        y: n = Tt
+        y: n = yt
     } = t;
     if (n == null)
         throw new Error("missing channel: y");
-    return A0(null, n, e, t);
+    return _d(null, n, e, t);
 }
 
-function kw(e = {
+function gg(e = {
     fill: "count"
 }, t = {}) {
     let {
         x: n,
-        y: i
+        y: r
     } = t;
-    if ([n, i] = ki(n, i), n == null)
+    if ([n, r] = Jn(n, r), n == null)
         throw new Error("missing channel: x");
-    if (i == null)
+    if (r == null)
         throw new Error("missing channel: y");
-    return A0(n, i, e, t);
+    return _d(n, r, e, t);
 }
 
-function A0(e, t, {
-    data: n = Vw,
-    filter: i,
-    sort: r,
+function _d(e, t, {
+    data: n = _g,
+    filter: r,
+    sort: i,
     reverse: s,
     ...o
     // output channel definitions
 } = {}, a = {}) {
-    o = ID(o, a), n = $D(n, Tt), r = r == null ? void 0 : AD("sort", r, a), i = i == null ? void 0 : MD("filter", i, a);
-    const [c, l] = xn(e), [u, f] = xn(t), {
+    o = gA(o, a), n = vA(n, yt), i = i == null ? void 0 : bA("sort", i, a), r = r == null ? void 0 : wA("filter", r, a);
+    const [c, u] = We(e), [l, f] = We(t), {
         z: h,
         fill: d,
         stroke: p,
-        x1: m,
-        x2: g,
+        x1: y,
+        x2: m,
         // consumed if x is an output
-        y1: y,
+        y1: g,
         y2: b,
         // consumed if y is an output
         ...w
-    } = a, [v, x] = xn(h), [_] = mn(d), [I] = mn(p), [A, M] = xn(_), [N, $] = xn(I);
+    } = a, [v, x] = We(h), [_] = ze(d), [M] = ze(p), [T, $] = We(_), [N, A] = We(M);
     return {
         ..."z" in a && {
             z: v || h
         },
         ..."fill" in a && {
-            fill: A || d
+            fill: T || d
         },
         ..."stroke" in a && {
             stroke: N || p
         },
-        ...vr(w, (B, R, S) => {
-            const T = zp(Pt(B, e), S == null ? void 0 : S.x),
-                D = zp(Pt(B, t), S == null ? void 0 : S.y),
-                L = Pt(B, h),
-                k = Pt(B, _),
-                U = Pt(B, I),
-                C = Pw(o, {
-                    z: L,
-                    fill: k,
-                    stroke: U
+        ...$r(w, (D, R, S) => {
+            const I = dh($t(D, e), S == null ? void 0 : S.x),
+                E = dh($t(D, t), S == null ? void 0 : S.y),
+                k = $t(D, h),
+                B = $t(D, _),
+                C = $t(D, M),
+                F = vg(o, {
+                    z: k,
+                    fill: B,
+                    stroke: C
                 }),
-                z = [],
                 P = [],
-                G = T && l([]),
-                K = D && f([]),
-                et = L && x([]),
-                Z = k && M([]),
-                Y = U && $([]);
-            let X = 0;
-            for (const j of o)
-                j.initialize(B);
-            r && r.initialize(B), i && i.initialize(B);
-            for (const j of R) {
-                const J = [];
-                for (const tt of o)
-                    tt.scope("facet", j);
-                r && r.scope("facet", j), i && i.scope("facet", j);
-                for (const [tt, V] of pc(j, C))
-                    for (const [Ft, rt] of pc(V, D))
-                        for (const [Vt, jt] of pc(rt, T)) {
-                            const Q = {
-                                data: B
+                U = [],
+                Y = I && u([]),
+                G = E && f([]),
+                K = k && x([]),
+                H = B && $([]),
+                V = C && A([]);
+            let W = 0;
+            for (const q of o)
+                q.initialize(D);
+            i && i.initialize(D), r && r.initialize(D);
+            for (const q of R) {
+                const X = [];
+                for (const Z of o)
+                    Z.scope("facet", q);
+                i && i.scope("facet", q), r && r.scope("facet", q);
+                for (const [Z, z] of Do(q, F))
+                    for (const [wt, tt] of Do(z, E))
+                        for (const [It, Et] of Do(tt, I)) {
+                            const J = {
+                                data: D
                             };
-                            if (T && (Q.x = Vt), D && (Q.y = Ft), C && (Q.z = tt), !(i && !i.reduce(jt, Q))) {
-                                J.push(X++), P.push(n.reduceIndex(jt, B, Q)), T && G.push(Vt), D && K.push(Ft), L && et.push(C === L ? tt : L[jt[0]]), k && Z.push(C === k ? tt : k[jt[0]]), U && Y.push(C === U ? tt : U[jt[0]]);
-                                for (const Zt of o)
-                                    Zt.reduce(jt, Q);
-                                r && r.reduce(jt, Q);
+                            if (I && (J.x = It), E && (J.y = wt), F && (J.z = Z), !(r && !r.reduce(Et, J))) {
+                                X.push(W++), U.push(n.reduceIndex(Et, D, J)), I && Y.push(It), E && G.push(wt), k && K.push(F === k ? Z : k[Et[0]]), B && H.push(F === B ? Z : B[Et[0]]), C && V.push(F === C ? Z : C[Et[0]]);
+                                for (const Bt of o)
+                                    Bt.reduce(Et, J);
+                                i && i.reduce(Et, J);
                             }
                         }
-                z.push(J);
+                P.push(X);
             }
-            return TD(z, r, s), {
-                data: P,
-                facets: z
+            return _A(P, i, s), {
+                data: U,
+                facets: P
             };
         }),
-        ...!Rs(o, "x") && (c ? {
+        ...!Ni(o, "x") && (c ? {
             x: c
         } : {
-            x1: m,
-            x2: g
+            x1: y,
+            x2: m
         }),
-        ...!Rs(o, "y") && (u ? {
-            y: u
+        ...!Ni(o, "y") && (l ? {
+            y: l
         } : {
-            y1: y,
+            y1: g,
             y2: b
         }),
         ...Object.fromEntries(o.map(({
-            name: B,
+            name: D,
             output: R
-        }) => [B, R]))
+        }) => [D, R]))
     };
 }
 
-function Rs(e, ...t) {
+function Ni(e, ...t) {
     for (const {
             name: n
         }
         of e)
         if (t.includes(n))
             return !0;
     return !1;
 }
 
-function SD(e, t, n = Uw) {
-    const i = Object.entries(e);
-    return t.title != null && e.title === void 0 && i.push(["title", bJ]), t.href != null && e.href === void 0 && i.push(["href", jw]), i.filter(([, r]) => r !== void 0).map(([r, s]) => s === null ? dJ(r) : n(r, s, t));
+function mA(e, t, n = bg) {
+    const r = Object.entries(e);
+    return t.title != null && e.title === void 0 && r.push(["title", IV]), t.href != null && e.href === void 0 && r.push(["href", xg]), r.filter(([, i]) => i !== void 0).map(([i, s]) => s === null ? xV(i) : n(i, s, t));
 }
 
-function Uw(e, t, n, i = zw) {
-    let r;
-    hi(t) && "reduce" in t && (r = t.scale, t = t.reduce);
-    const s = i(e, t, n),
-        [o, a] = Un(s.label);
+function bg(e, t, n, r = wg) {
+    let i;
+    En(t) && "reduce" in t && (i = t.scale, t = t.reduce);
+    const s = r(e, t, n),
+        [o, a] = an(s.label);
     let c;
     return {
         name: e,
-        output: r === void 0 ? o : {
+        output: i === void 0 ? o : {
             value: o,
-            scale: r
+            scale: i
         },
-        initialize(l) {
-            s.initialize(l), c = a([]);
+        initialize(u) {
+            s.initialize(u), c = a([]);
         },
-        scope(l, u) {
-            s.scope(l, u);
+        scope(u, l) {
+            s.scope(u, l);
         },
-        reduce(l, u) {
-            c.push(s.reduce(l, u));
+        reduce(u, l) {
+            c.push(s.reduce(u, l));
         }
     };
 }
 
-function dJ(e) {
+function xV(e) {
     return {
         name: e,
         initialize() {},
         scope() {},
         reduce() {}
     };
 }
 
-function zw(e, t, n, i = M0) {
-    const r = pD(e, n),
-        s = i(t, r);
+function wg(e, t, n, r = xd) {
+    const i = aA(e, n),
+        s = r(t, i);
     let o, a;
     return {
-        label: wr(s === Pp ? null : r, s.label),
+        label: Ar(s === ph ? null : i, s.label),
         initialize(c) {
-            o = r === void 0 ? c : Pt(c, r), s.scope === "data" && (a = s.reduceIndex(fs(c), o));
+            o = i === void 0 ? c : $t(c, i), s.scope === "data" && (a = s.reduceIndex(ui(c), o));
         },
-        scope(c, l) {
-            s.scope === c && (a = s.reduceIndex(l, o));
+        scope(c, u) {
+            s.scope === c && (a = s.reduceIndex(u, o));
         },
-        reduce(c, l) {
-            return s.scope == null ? s.reduceIndex(c, o, l) : s.reduceIndex(c, o, a, l);
+        reduce(c, u) {
+            return s.scope == null ? s.reduceIndex(c, o, u) : s.reduceIndex(c, o, a, u);
         }
     };
 }
 
-function pc(e, t) {
-    return t ? us(e, (n) => t[n]) : [
+function Do(e, t) {
+    return t ? ci(e, (n) => t[n]) : [
         [, e]
     ];
 }
 
-function M0(e, t, n = pJ) {
+function xd(e, t, n = SV) {
     if (e == null)
         return n(e);
     if (typeof e.reduceIndex == "function")
         return e;
-    if (typeof e.reduce == "function" && hi(e))
-        return mJ(e);
+    if (typeof e.reduce == "function" && En(e))
+        return AV(e);
     if (typeof e == "function")
-        return gJ(e);
+        return $V(e);
     if (/^p\d{2}$/i.test(e))
-        return Fr($w(e));
+        return Br(og(e));
     switch (`${e}`.toLowerCase()) {
         case "first":
-            return jw;
+            return xg;
         case "last":
-            return wJ;
+            return TV;
         case "identity":
-            return Vw;
+            return _g;
         case "count":
-            return Pp;
+            return ph;
         case "distinct":
-            return vJ;
+            return EV;
         case "sum":
-            return t == null ? Pp : _J;
+            return t == null ? ph : NV;
         case "proportion":
-            return Gx(t, "data");
+            return u2(t, "data");
         case "proportion-facet":
-            return Gx(t, "facet");
+            return u2(t, "facet");
         case "deviation":
-            return Fr(gf);
+            return Br(au);
         case "min":
-            return Fr(Ye);
+            return Br(ve);
         case "min-index":
-            return Fr(Uz);
+            return Br(Gk);
         case "max":
-            return Fr(De);
+            return Br(ae);
         case "max-index":
-            return Fr(kz);
+            return Br(Xk);
         case "mean":
-            return Wx(Xy);
+            return c2(Vh);
         case "median":
-            return Wx(Fu);
+            return c2(Nc);
         case "variance":
-            return Fr(zb);
+            return Br(wm);
         case "mode":
-            return Fr(d3);
+            return Br(sS);
     }
     return n(e);
 }
 
-function pJ(e) {
+function SV(e) {
     throw new Error(`invalid reduce: ${e}`);
 }
 
-function ID(e, t) {
-    return SD(e, t, AD);
+function gA(e, t) {
+    return mA(e, t, bA);
 }
 
-function AD(e, t, n) {
-    return Uw(e, t, n, MD);
+function bA(e, t, n) {
+    return bg(e, t, n, wA);
 }
 
-function MD(e, t, n) {
-    return zw(e, t, n, $D);
+function wA(e, t, n) {
+    return wg(e, t, n, vA);
 }
 
-function $D(e, t) {
-    return M0(e, t, yJ);
+function vA(e, t) {
+    return xd(e, t, MV);
 }
 
-function yJ(e) {
+function MV(e) {
     switch (`${e}`.toLowerCase()) {
         case "x":
-            return xJ;
+            return DV;
         case "y":
-            return SJ;
+            return OV;
         case "z":
-            return DD;
+            return xA;
     }
     throw new Error(`invalid group reduce: ${e}`);
 }
 
-function Pw(e, t) {
+function vg(e, t) {
     for (const n in t) {
-        const i = t[n];
-        if (i !== void 0 && !e.some((r) => r.name === n))
-            return i;
+        const r = t[n];
+        if (r !== void 0 && !e.some((i) => i.name === n))
+            return r;
     }
 }
 
-function TD(e, t, n) {
+function _A(e, t, n) {
     if (t) {
-        const i = t.output.transform(),
-            r = (s, o) => li(i[s], i[o]);
-        e.forEach((s) => s.sort(r));
+        const r = t.output.transform(),
+            i = (s, o) => In(r[s], r[o]);
+        e.forEach((s) => s.sort(i));
     }
-    n && e.forEach((i) => i.reverse());
+    n && e.forEach((r) => r.reverse());
 }
 
-function mJ(e) {
+function AV(e) {
     return console.warn("deprecated reduce interface; implement reduceIndex instead."), {
         ...e,
         reduceIndex: e.reduce.bind(e)
     };
 }
 
-function gJ(e) {
+function $V(e) {
     return {
-        reduceIndex(t, n, i) {
-            return e(_0(n, t), i);
+        reduceIndex(t, n, r) {
+            return e(gd(n, t), r);
         }
     };
 }
 
-function Fr(e) {
+function Br(e) {
     return {
         reduceIndex(t, n) {
-            return e(t, (i) => n[i]);
+            return e(t, (r) => n[r]);
         }
     };
 }
 
-function Wx(e) {
+function c2(e) {
     return {
         reduceIndex(t, n) {
-            const i = e(t, (r) => n[r]);
-            return gn(n) ? new Date(i) : i;
+            const r = e(t, (i) => n[i]);
+            return qe(n) ? new Date(r) : r;
         }
     };
 }
-const Vw = {
+const _g = {
         reduceIndex(e, t) {
-            return _0(t, e);
+            return gd(t, e);
         }
     },
-    jw = {
+    xg = {
         reduceIndex(e, t) {
             return t[e[0]];
         }
     },
-    bJ = {
+    IV = {
         reduceIndex(e, t) {
-            const i = Hd(
-                    uc(
+            const r = xf(
+                    Io(
                         e,
                         (s) => s.length,
                         (s) => t[s]
                     ),
-                    qu
+                    zc
                 ),
-                r = i.slice(-5).reverse();
-            if (r.length < i.length) {
-                const s = i.slice(0, -4);
-                r[4] = [` ${s.length.toLocaleString("en-US")} more`, fr(s, qu)];
+                i = r.slice(-5).reverse();
+            if (i.length < r.length) {
+                const s = r.slice(0, -4);
+                i[4] = [` ${s.length.toLocaleString("en-US")} more`, wr(s, zc)];
             }
-            return r.map(([s, o]) => `${s} (${o.toLocaleString("en-US")})`).join(`
+            return i.map(([s, o]) => `${s} (${o.toLocaleString("en-US")})`).join(`
 `);
         }
     },
-    wJ = {
+    TV = {
         reduceIndex(e, t) {
             return t[e[e.length - 1]];
         }
     },
-    Pp = {
+    ph = {
         label: "Frequency",
         reduceIndex(e) {
             return e.length;
         }
     },
-    vJ = {
+    EV = {
         label: "Distinct",
         reduceIndex(e, t) {
-            const n = new el();
-            for (const i of e)
-                n.add(t[i]);
+            const n = new da();
+            for (const r of e)
+                n.add(t[r]);
             return n.size;
         }
     },
-    _J = Fr(fr);
+    NV = Br(wr);
 
-function Gx(e, t) {
+function u2(e, t) {
     return e == null ? {
         scope: t,
         label: "Frequency",
-        reduceIndex: (n, i, r = 1) => n.length / r
+        reduceIndex: (n, r, i = 1) => n.length / i
     } : {
         scope: t,
-        reduceIndex: (n, i, r = 1) => fr(n, (s) => i[s]) / r
+        reduceIndex: (n, r, i = 1) => wr(n, (s) => r[s]) / i
     };
 }
-const xJ = {
+const DV = {
         reduceIndex(e, t, {
             x: n
         }) {
             return n;
         }
     },
-    SJ = {
+    OV = {
         reduceIndex(e, t, {
             y: n
         }) {
             return n;
         }
     },
-    DD = {
+    xA = {
         reduceIndex(e, t, {
             z: n
         }) {
             return n;
         }
     };
 
-function IJ(e) {
+function LV(e) {
     if (typeof e != "function")
         throw new Error(`invalid test function: ${e}`);
     return {
         reduceIndex(t, n, {
-            data: i
+            data: r
         }) {
-            return n[t.find((r) => e(i[r], r, i))];
+            return n[t.find((i) => e(r[i], i, r))];
         }
     };
 }
 
-function Xu(e, {
+function Yc(e, {
     scale: t,
     type: n,
-    value: i,
-    filter: r,
+    value: r,
+    filter: i,
     hint: s,
-    label: o = wr(i)
+    label: o = Ar(r)
 }, a) {
-    return s === void 0 && typeof(i == null ? void 0 : i.transform) == "function" && (s = i.hint), BD(a, {
+    return s === void 0 && typeof(r == null ? void 0 : r.transform) == "function" && (s = r.hint), MA(a, {
         scale: t,
         type: n,
-        value: Pt(e, i),
+        value: $t(e, r),
         label: o,
-        filter: r,
+        filter: i,
         hint: s
     });
 }
 
-function ND(e, t) {
+function SA(e, t) {
     return Object.fromEntries(
-        Object.entries(e).map(([n, i]) => [n, Xu(t, i, n)])
+        Object.entries(e).map(([n, r]) => [n, Yc(t, r, n)])
     );
 }
 
-function qw(e, t) {
+function Sg(e, t) {
     const n = Object.fromEntries(
-        Object.entries(e).map(([i, {
-            scale: r,
+        Object.entries(e).map(([r, {
+            scale: i,
             value: s
         }]) => {
-            const o = r == null ? null : t[r];
-            return [i, o == null ? s : ye(s, o)];
+            const o = i == null ? null : t[i];
+            return [r, o == null ? s : Zt(s, o)];
         })
     );
     return n.channels = e, n;
 }
 
-function BD(e, t) {
+function MA(e, t) {
     const {
         scale: n,
-        value: i
+        value: r
     } = t;
     if (n === !0 || n === "auto")
         switch (e) {
             case "fill":
             case "stroke":
             case "color":
-                t.scale = n !== !0 && Um(i, Lf) ? null : "color";
+                t.scale = n !== !0 && kp(r, Mu) ? null : "color";
                 break;
             case "fillOpacity":
             case "strokeOpacity":
             case "opacity":
-                t.scale = n !== !0 && Um(i, tJ) ? null : "opacity";
+                t.scale = n !== !0 && kp(r, uV) ? null : "opacity";
                 break;
             case "symbol":
-                n !== !0 && Um(i, aJ) ? (t.scale = null, t.value = ye(i, Fw)) : t.scale = "symbol";
+                n !== !0 && kp(r, mV) ? (t.scale = null, t.value = Zt(r, hg)) : t.scale = "symbol";
                 break;
             default:
-                t.scale = Se.has(e) ? e : null;
+                t.scale = re.has(e) ? e : null;
                 break;
         }
     else if (n === !1)
         t.scale = null;
-    else if (n != null && !Se.has(n))
+    else if (n != null && !re.has(n))
         throw new Error(`unknown scale: ${n}`);
     return t;
 }
 
-function AJ(e, t, n, i, r) {
+function kV(e, t, n, r, i) {
     const {
         order: s,
         reverse: o,
         reduce: a = !0,
         limit: c
-    } = r;
-    for (const l in r) {
-        if (!Se.has(l))
+    } = i;
+    for (const u in i) {
+        if (!re.has(u))
             continue;
         let {
-            value: u,
+            value: l,
             order: f = s,
             reverse: h = o,
             reduce: d = a,
             limit: p = c
-        } = al(r[l]);
-        const m = u == null ? void 0 : u.startsWith("-");
-        if (m && (u = u.slice(1)), f = f === void 0 ? m !== (u === "width" || u === "height") ? FD : OD : TJ(f), d == null || d === !1)
+        } = wa(i[u]);
+        const y = l == null ? void 0 : l.startsWith("-");
+        if (y && (l = l.slice(1)), f = f === void 0 ? y !== (l === "width" || l === "height") ? $A : AA : BV(f), d == null || d === !1)
             continue;
-        const g = l === "fx" || l === "fy" ? $J(t, i[l]) : MJ(n, l);
-        if (!g)
-            throw new Error(`missing channel for scale: ${l}`);
-        const y = g.value,
-            [b = 0, w = 1 / 0] = hs(p) ? p : p < 0 ? [p] : [0, p];
-        if (u == null)
-            g.domain = () => {
-                let v = Array.from(new el(y));
+        const m = u === "fx" || u === "fy" ? FV(t, r[u]) : RV(n, u);
+        if (!m)
+            throw new Error(`missing channel for scale: ${u}`);
+        const g = m.value,
+            [b = 0, w = 1 / 0] = li(p) ? p : p < 0 ? [p] : [0, p];
+        if (l == null)
+            m.domain = () => {
+                let v = Array.from(new da(g));
                 return h && (v = v.reverse()), (b !== 0 || w !== 1 / 0) && (v = v.slice(b, w)), v;
             };
         else {
-            const v = u === "data" ? e : u === "height" ? Xx(n, "y1", "y2") : u === "width" ? Xx(n, "x1", "x2") : M1(n, u, u === "y" ? "y2" : u === "x" ? "x2" : void 0),
-                x = M0(d === !0 ? "max" : d, v);
-            g.domain = () => {
-                let _ = Fz(
-                    fs(y),
-                    (I) => x.reduceIndex(I, v),
-                    (I) => y[I]
+            const v = l === "data" ? e : l === "height" ? l2(n, "y1", "y2") : l === "width" ? l2(n, "x1", "x2") : py(n, l, l === "y" ? "y2" : l === "x" ? "x2" : void 0),
+                x = xd(d === !0 ? "max" : d, v);
+            m.domain = () => {
+                let _ = qk(
+                    ui(g),
+                    (M) => x.reduceIndex(M, v),
+                    (M) => g[M]
                 );
-                return f && _.sort(f), h && _.reverse(), (b !== 0 || w !== 1 / 0) && (_ = _.slice(b, w)), _.map(w0);
+                return f && _.sort(f), h && _.reverse(), (b !== 0 || w !== 1 / 0) && (_ = _.slice(b, w)), _.map(yd);
             };
         }
     }
 }
 
-function MJ(e, t) {
+function RV(e, t) {
     for (const n in e) {
-        const i = e[n];
-        if (i.scale === t)
-            return i;
+        const r = e[n];
+        if (r.scale === t)
+            return r;
     }
 }
 
-function $J(e, t) {
+function FV(e, t) {
     const n = e.original;
     if (n === e)
         return t;
-    const i = t.value,
-        r = t.value = [];
+    const r = t.value,
+        i = t.value = [];
     for (let s = 0; s < n.length; ++s) {
-        const o = i[n[s][0]];
+        const o = r[n[s][0]];
         for (const a of e[s])
-            r[a] = o;
+            i[a] = o;
     }
     return t;
 }
 
-function Xx(e, t, n) {
-    const i = M1(e, t),
-        r = M1(e, n);
-    return ye(r, (s, o) => Math.abs(s - i[o]), Float64Array);
+function l2(e, t, n) {
+    const r = py(e, t),
+        i = py(e, n);
+    return Zt(i, (s, o) => Math.abs(s - r[o]), Float64Array);
 }
 
-function M1(e, t, n) {
-    let i = e[t];
-    if (!i && n !== void 0 && (i = e[n]), i)
-        return i.value;
+function py(e, t, n) {
+    let r = e[t];
+    if (!r && n !== void 0 && (r = e[n]), r)
+        return r.value;
     throw new Error(`missing channel: ${t}`);
 }
 
-function TJ(e) {
+function BV(e) {
     if (e == null || typeof e == "function")
         return e;
     switch (`${e}`.toLowerCase()) {
         case "ascending":
-            return OD;
+            return AA;
         case "descending":
-            return FD;
+            return $A;
     }
     throw new Error(`invalid order: ${e}`);
 }
 
-function OD([e, t], [n, i]) {
-    return li(t, i) || li(e, n);
+function AA([e, t], [n, r]) {
+    return In(t, r) || In(e, n);
 }
 
-function FD([e, t], [n, i]) {
-    return Cp(t, i) || li(e, n);
+function $A([e, t], [n, r]) {
+    return lh(t, r) || In(e, n);
 }
 
-function $1(e, t) {
+function yy(e, t) {
     let n = e[t];
     if (n) {
         for (; n.source;)
             n = n.source;
         return n.source === null ? null : n;
     }
 }
 
-function $0(e = {}) {
+function Sd(e = {}) {
     const {
         document: t = typeof window < "u" ? window.document : void 0,
         clip: n
     } = e;
     return {
         document: t,
-        clip: gD(n)
+        clip: lA(n)
     };
 }
 
-function Gt(e, {
+function Ot(e, {
     document: t
 }) {
-    return ce(Ky(e).call(t.documentElement));
+    return Wt(Xh(e).call(t.documentElement));
 }
-let T1 = 0,
-    D1;
+let my = 0,
+    gy;
 
-function DJ() {
-    const e = T1;
-    return T1 = 0, D1 = void 0, e;
+function CV() {
+    const e = my;
+    return my = 0, gy = void 0, e;
 }
 
-function ts(e) {
-    e !== D1 && (D1 = e, console.warn(e), ++T1);
+function ti(e) {
+    e !== gy && (gy = e, console.warn(e), ++my);
 }
-const ED = Math.PI,
-    Mr = 2 * ED,
-    Hx = 0.618;
+const IA = Math.PI,
+    Lr = 2 * IA,
+    f2 = 0.618;
 
-function NJ({
+function PV({
     projection: e,
     inset: t = 0,
     insetTop: n = t,
-    insetRight: i = t,
-    insetBottom: r = t,
+    insetRight: r = t,
+    insetBottom: i = t,
     insetLeft: s = t
 } = {}, o) {
     if (e == null)
         return;
     if (typeof e.stream == "function")
         return e;
-    let a, c, l = "frame";
-    if (hi(e)) {
+    let a, c, u = "frame";
+    if (En(e)) {
         let x;
         if ({
                 type: e,
                 domain: c,
                 inset: x,
                 insetTop: n = x !== void 0 ? x : n,
-                insetRight: i = x !== void 0 ? x : i,
-                insetBottom: r = x !== void 0 ? x : r,
+                insetRight: r = x !== void 0 ? x : r,
+                insetBottom: i = x !== void 0 ? x : i,
                 insetLeft: s = x !== void 0 ? x : s,
-                clip: l = l,
+                clip: u = u,
                 ...a
             } = e, e == null)
             return;
     }
     typeof e != "function" && ({
         type: e
-    } = LD(e));
+    } = TA(e));
     const {
-        width: u,
+        width: l,
         height: f,
         marginLeft: h,
         marginRight: d,
         marginTop: p,
-        marginBottom: m
-    } = o, g = u - h - d - s - i, y = f - p - m - n - r;
+        marginBottom: y
+    } = o, m = l - h - d - s - r, g = f - p - y - n - i;
     if (e = e == null ? void 0 : e({
-            width: g,
-            height: y,
-            clip: l,
+            width: m,
+            height: g,
+            clip: u,
             ...a
         }), e == null)
         return;
-    l = BJ(l, h, p, u - d, f - m);
+    u = UV(u, h, p, l - d, f - y);
     let b = h + s,
         w = p + n,
         v;
     if (c != null) {
         const [
             [x, _],
-            [I, A]
-        ] = oo(e).bounds(c), M = Math.min(g / (I - x), y / (A - _));
-        M > 0 ? (b -= (M * (x + I) - g) / 2, w -= (M * (_ + A) - y) / 2, v = Ip({
-            point(N, $) {
-                this.stream.point(N * M + b, $ * M + w);
+            [M, T]
+        ] = Zi(e).bounds(c), $ = Math.min(m / (M - x), g / (T - _));
+        $ > 0 ? (b -= ($ * (x + M) - m) / 2, w -= ($ * (_ + T) - g) / 2, v = Zf({
+            point(N, A) {
+                this.stream.point(N * $ + b, A * $ + w);
             }
-        })) : ts("Warning: the projection could not be fit to the specified domain; using the default scale.");
+        })) : ti("Warning: the projection could not be fit to the specified domain; using the default scale.");
     }
-    return v ?? (v = b === 0 && w === 0 ? RD() : Ip({
+    return v ?? (v = b === 0 && w === 0 ? EA() : Zf({
         point(x, _) {
             this.stream.point(x + b, _ + w);
         }
     })), {
-        stream: (x) => e.stream(v.stream(l(x)))
+        stream: (x) => e.stream(v.stream(u(x)))
     };
 }
 
-function LD(e) {
+function TA(e) {
     switch (`${e}`.toLowerCase()) {
         case "albers-usa":
-            return di(_W, 0.7463, 0.4673);
+            return Nn(NU, 0.7463, 0.4673);
         case "albers":
-            return xh($$, 0.7463, 0.4673);
+            return al(w3, 0.7463, 0.4673);
         case "azimuthal-equal-area":
-            return di(xW, 4, 4);
+            return Nn(DU, 4, 4);
         case "azimuthal-equidistant":
-            return di(SW, Mr, Mr);
+            return Nn(OU, Lr, Lr);
         case "conic-conformal":
-            return xh(MW, Mr, Mr);
+            return al(RU, Lr, Lr);
         case "conic-equal-area":
-            return xh(Ap, 6.1702, 2.9781);
+            return al(Kf, 6.1702, 2.9781);
         case "conic-equidistant":
-            return xh(DW, 7.312, 3.6282);
+            return al(CU, 7.312, 3.6282);
         case "equal-earth":
-            return di(BW, 5.4133, 2.6347);
+            return Nn(UU, 5.4133, 2.6347);
         case "equirectangular":
-            return di($W, Mr, ED);
+            return Nn(FU, Lr, IA);
         case "gnomonic":
-            return di(OW, 3.4641, 3.4641);
+            return Nn(zU, 3.4641, 3.4641);
         case "identity":
             return {
-                type: RD
+                type: EA
             };
         case "reflect-y":
             return {
-                type: OJ
+                type: zV
             };
         case "mercator":
-            return di(IW, Mr, Mr);
+            return Nn(LU, Lr, Lr);
         case "orthographic":
-            return di(FW, 2, 2);
+            return Nn(qU, 2, 2);
         case "stereographic":
-            return di(EW, 2, 2);
+            return Nn(jU, 2, 2);
         case "transverse-mercator":
-            return di(LW, Mr, Mr);
+            return Nn(VU, Lr, Lr);
         default:
             throw new Error(`unknown projection type: ${e}`);
     }
 }
 
-function BJ(e, t, n, i, r) {
+function UV(e, t, n, r, i) {
     if (e === !1 || e == null || typeof e == "number")
         return (s) => s;
     switch (e === !0 && (e = "frame"), `${e}`.toLowerCase()) {
         case "frame":
-            return f$(t, n, i, r);
+            return r3(t, n, r, i);
         default:
             throw new Error(`unknown projection clip type: ${e}`);
     }
 }
 
-function di(e, t, n) {
+function Nn(e, t, n) {
     return {
         type: ({
-            width: i,
-            height: r,
+            width: r,
+            height: i,
             rotate: s,
             precision: o = 0.15,
             clip: a
         }) => {
-            var l, u, f;
+            var u, l, f;
             const c = e();
-            return o != null && ((l = c.precision) == null || l.call(c, o)), s != null && ((u = c.rotate) == null || u.call(c, s)), typeof a == "number" && ((f = c.clipAngle) == null || f.call(c, a)), c.scale(Math.min(i / t, r / n)), c.translate([i / 2, r / 2]), c;
+            return o != null && ((u = c.precision) == null || u.call(c, o)), s != null && ((l = c.rotate) == null || l.call(c, s)), typeof a == "number" && ((f = c.clipAngle) == null || f.call(c, a)), c.scale(Math.min(r / t, i / n)), c.translate([r / 2, i / 2]), c;
         },
         aspectRatio: n / t
     };
 }
 
-function xh(e, t, n) {
+function al(e, t, n) {
     const {
-        type: i,
-        aspectRatio: r
-    } = di(e, t, n);
+        type: r,
+        aspectRatio: i
+    } = Nn(e, t, n);
     return {
         type: (s) => {
             const {
                 parallels: o,
                 domain: a,
                 width: c,
-                height: l
-            } = s, u = i(s);
-            return o != null && (u.parallels(o), a === void 0 && u.fitSize([c, l], {
+                height: u
+            } = s, l = r(s);
+            return o != null && (l.parallels(o), a === void 0 && l.fitSize([c, u], {
                 type: "Sphere"
-            })), u;
+            })), l;
         },
-        aspectRatio: r
+        aspectRatio: i
     };
 }
-const RD = jn({
+const EA = fn({
         stream: (e) => e
     }),
-    OJ = jn(
-        Ip({
+    zV = fn(
+        Zf({
             point(e, t) {
                 this.stream.point(e, -t);
             }
         })
     );
 
-function CD(e, t, n, i) {
-    const r = n[e],
+function NA(e, t, n, r) {
+    const i = n[e],
         s = n[t],
-        o = r.length,
+        o = i.length,
         a = n[e] = new Float64Array(o).fill(NaN),
         c = n[t] = new Float64Array(o).fill(NaN);
-    let l;
-    const u = i.stream({
+    let u;
+    const l = r.stream({
         point(f, h) {
-            a[l] = f, c[l] = h;
+            a[u] = f, c[u] = h;
         }
     });
-    for (l = 0; l < o; ++l)
-        u.point(r[l], s[l]);
+    for (u = 0; u < o; ++u)
+        l.point(i[u], s[u]);
 }
 
-function FJ({
+function qV({
     projection: e
 } = {}) {
-    return e == null ? !1 : typeof e.stream == "function" ? !0 : (hi(e) && (e = e.type), e != null);
+    return e == null ? !1 : typeof e.stream == "function" ? !0 : (En(e) && (e = e.type), e != null);
 }
 
-function EJ(e) {
+function jV(e) {
     if (typeof(e == null ? void 0 : e.stream) == "function")
-        return Hx;
-    if (hi(e) && (e = e.type), e != null) {
+        return f2;
+    if (En(e) && (e = e.type), e != null) {
         if (typeof e != "function") {
             const {
                 aspectRatio: t
-            } = LD(e);
+            } = TA(e);
             if (t)
                 return t;
         }
-        return Hx;
+        return f2;
     }
 }
 
-function T0(e, t, {
+function Md(e, t, {
     projection: n
 }) {
     const {
-        x: i,
-        y: r
+        x: r,
+        y: i
     } = e;
     let s = {};
-    return i && (s.x = i), r && (s.y = r), s = qw(s, t), n && (i == null ? void 0 : i.scale) === "x" && (r == null ? void 0 : r.scale) === "y" && CD("x", "y", s, n), i && (s.x = An(s.x)), r && (s.y = An(s.y)), s;
+    return r && (s.x = r), i && (s.y = i), s = Sg(s, t), n && (r == null ? void 0 : r.scale) === "x" && (i == null ? void 0 : i.scale) === "y" && NA("x", "y", s, n), r && (s.x = He(s.x)), i && (s.y = He(s.y)), s;
 }
 
-function LJ(e) {
+function VV(e) {
     const t = [],
         n = [],
-        i = {
+        r = {
             scale: "x",
             value: t
         },
-        r = {
+        i = {
             scale: "y",
             value: n
         },
         s = {
             point(o, a) {
                 t.push(o), n.push(a);
             },
             lineStart() {},
             lineEnd() {},
             polygonStart() {},
             polygonEnd() {},
             sphere() {}
         };
     for (const o of e.value)
-        Ns(o, s);
-    return [i, r];
+        Mi(o, s);
+    return [r, i];
 }
-const kD = /* @__PURE__ */ new Map([
-    ["accent", VX],
-    ["category10", PX],
-    ["dark2", jX],
-    ["observable10", qX],
-    ["paired", YX],
-    ["pastel1", WX],
-    ["pastel2", GX],
-    ["set1", XX],
-    ["set2", HX],
-    ["set3", JX],
-    ["tableau10", KX]
+const DA = /* @__PURE__ */ new Map([
+    ["accent", Zq],
+    ["category10", Jq],
+    ["dark2", Kq],
+    ["observable10", Qq],
+    ["paired", tj],
+    ["pastel1", ej],
+    ["pastel2", nj],
+    ["set1", rj],
+    ["set2", ij],
+    ["set3", sj],
+    ["tableau10", oj]
 ]);
 
-function RJ(e) {
-    return e != null && kD.has(`${e}`.toLowerCase());
+function YV(e) {
+    return e != null && DA.has(`${e}`.toLowerCase());
 }
-const Jx = new Map([
-    ...kD,
+const h2 = new Map([
+    ...DA,
     // diverging
-    ["brbg", $r(g6, b6)],
-    ["prgn", $r(w6, v6)],
-    ["piyg", $r(_6, x6)],
-    ["puor", $r(S6, I6)],
-    ["rdbu", $r(x1, Np)],
-    ["rdgy", $r(A6, M6)],
-    ["rdylbu", $r(S1, Bp)],
-    ["rdylgn", $r($6, T6)],
-    ["spectral", $r(D6, N6)],
+    ["brbg", kr(u6, l6)],
+    ["prgn", kr(f6, h6)],
+    ["piyg", kr(d6, p6)],
+    ["puor", kr(y6, m6)],
+    ["rdbu", kr(ly, rh)],
+    ["rdgy", kr(g6, b6)],
+    ["rdylbu", kr(fy, ih)],
+    ["rdylgn", kr(w6, v6)],
+    ["spectral", kr(_6, x6)],
     // reversed diverging (for temperature data)
-    ["burd", Kx(x1, Np)],
-    ["buylrd", Kx(S1, Bp)],
+    ["burd", d2(ly, rh)],
+    ["buylrd", d2(fy, ih)],
     // sequential (single-hue)
-    ["blues", Ve(eT, nT)],
-    ["greens", Ve(iT, rT)],
-    ["greys", Ve(sT, oT)],
-    ["oranges", Ve(fT, hT)],
-    ["purples", Ve(aT, cT)],
-    ["reds", Ve(lT, uT)],
+    ["blues", ge(X6, G6)],
+    ["greens", ge(H6, J6)],
+    ["greys", ge(Z6, K6)],
+    ["oranges", ge(rM, iM)],
+    ["purples", ge(Q6, tM)],
+    ["reds", ge(eM, nM)],
     // sequential (multi-hue)
-    ["turbo", Tr(wT)],
-    ["viridis", Tr(vT)],
-    ["magma", Tr(_T)],
-    ["inferno", Tr(xT)],
-    ["plasma", Tr(ST)],
-    ["cividis", Tr(dT)],
-    ["cubehelix", Tr(pT)],
-    ["warm", Tr(yT)],
-    ["cool", Tr(mT)],
-    ["bugn", Ve(B6, O6)],
-    ["bupu", Ve(F6, E6)],
-    ["gnbu", Ve(L6, R6)],
-    ["orrd", Ve(C6, k6)],
-    ["pubu", Ve(P6, V6)],
-    ["pubugn", Ve(U6, z6)],
-    ["purd", Ve(j6, q6)],
-    ["rdpu", Ve(Y6, W6)],
-    ["ylgn", Ve(H6, J6)],
-    ["ylgnbu", Ve(G6, X6)],
-    ["ylorbr", Ve(K6, Z6)],
-    ["ylorrd", Ve(Q6, tT)],
+    ["turbo", Rr(fM)],
+    ["viridis", Rr(hM)],
+    ["magma", Rr(dM)],
+    ["inferno", Rr(pM)],
+    ["plasma", Rr(yM)],
+    ["cividis", Rr(sM)],
+    ["cubehelix", Rr(oM)],
+    ["warm", Rr(aM)],
+    ["cool", Rr(cM)],
+    ["bugn", ge(S6, M6)],
+    ["bupu", ge(A6, $6)],
+    ["gnbu", ge(I6, T6)],
+    ["orrd", ge(E6, N6)],
+    ["pubu", ge(L6, k6)],
+    ["pubugn", ge(D6, O6)],
+    ["purd", ge(R6, F6)],
+    ["rdpu", ge(B6, C6)],
+    ["ylgn", ge(z6, q6)],
+    ["ylgnbu", ge(P6, U6)],
+    ["ylorbr", ge(j6, V6)],
+    ["ylorrd", ge(Y6, W6)],
     // cyclical
-    ["rainbow", Zx(gT)],
-    ["sinebow", Zx(bT)]
+    ["rainbow", p2(uM)],
+    ["sinebow", p2(lM)]
 ]);
 
-function Ve(e, t) {
+function ge(e, t) {
     return ({
         length: n
-    }) => n === 1 ? [e[3][1]] : n === 2 ? [e[3][1], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 9 ? $i(t, n) : e[n]);
+    }) => n === 1 ? [e[3][1]] : n === 2 ? [e[3][1], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 9 ? jn(t, n) : e[n]);
 }
 
-function $r(e, t) {
+function kr(e, t) {
     return ({
         length: n
-    }) => n === 2 ? [e[3][0], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 11 ? $i(t, n) : e[n]);
+    }) => n === 2 ? [e[3][0], e[3][2]] : (n = Math.max(3, Math.floor(n)), n > 11 ? jn(t, n) : e[n]);
 }
 
-function Kx(e, t) {
+function d2(e, t) {
     return ({
         length: n
-    }) => n === 2 ? [e[3][2], e[3][0]] : (n = Math.max(3, Math.floor(n)), n > 11 ? $i((i) => t(1 - i), n) : e[n].slice().reverse());
+    }) => n === 2 ? [e[3][2], e[3][0]] : (n = Math.max(3, Math.floor(n)), n > 11 ? jn((r) => t(1 - r), n) : e[n].slice().reverse());
 }
 
-function Tr(e) {
+function Rr(e) {
     return ({
         length: t
-    }) => $i(e, Math.max(2, Math.floor(t)));
+    }) => jn(e, Math.max(2, Math.floor(t)));
 }
 
-function Zx(e) {
+function p2(e) {
     return ({
         length: t
-    }) => $i(e, Math.floor(t) + 1).slice(0, -1);
+    }) => jn(e, Math.floor(t) + 1).slice(0, -1);
 }
 
-function UD(e) {
+function OA(e) {
     const t = `${e}`.toLowerCase();
-    if (!Jx.has(t))
+    if (!h2.has(t))
         throw new Error(`unknown ordinal scheme: ${t}`);
-    return Jx.get(t);
+    return h2.get(t);
 }
 
-function D0(e, t) {
-    const n = UD(e),
-        i = typeof n == "function" ? n({
+function Ad(e, t) {
+    const n = OA(e),
+        r = typeof n == "function" ? n({
             length: t
         }) : n;
-    return i.length !== t ? i.slice(0, t) : i;
+    return r.length !== t ? r.slice(0, t) : r;
 }
 
-function CJ(e, t = "greys") {
+function WV(e, t = "greys") {
     const n = /* @__PURE__ */ new Set(),
-        [i, r] = D0(t, 2);
+        [r, i] = Ad(t, 2);
     for (const s of e)
         if (s != null)
             if (s === !0)
-                n.add(r);
+                n.add(i);
             else if (s === !1)
-        n.add(i);
+        n.add(r);
     else
         return;
     return [...n];
 }
-const Qx = /* @__PURE__ */ new Map([
+const y2 = /* @__PURE__ */ new Map([
     // diverging
-    ["brbg", b6],
-    ["prgn", v6],
-    ["piyg", x6],
-    ["puor", I6],
-    ["rdbu", Np],
-    ["rdgy", M6],
-    ["rdylbu", Bp],
-    ["rdylgn", T6],
-    ["spectral", N6],
+    ["brbg", l6],
+    ["prgn", h6],
+    ["piyg", p6],
+    ["puor", m6],
+    ["rdbu", rh],
+    ["rdgy", b6],
+    ["rdylbu", ih],
+    ["rdylgn", v6],
+    ["spectral", x6],
     // reversed diverging (for temperature data)
-    ["burd", (e) => Np(1 - e)],
-    ["buylrd", (e) => Bp(1 - e)],
+    ["burd", (e) => rh(1 - e)],
+    ["buylrd", (e) => ih(1 - e)],
     // sequential (single-hue)
-    ["blues", nT],
-    ["greens", rT],
-    ["greys", oT],
-    ["purples", cT],
-    ["reds", uT],
-    ["oranges", hT],
+    ["blues", G6],
+    ["greens", J6],
+    ["greys", K6],
+    ["purples", tM],
+    ["reds", nM],
+    ["oranges", iM],
     // sequential (multi-hue)
-    ["turbo", wT],
-    ["viridis", vT],
-    ["magma", _T],
-    ["inferno", xT],
-    ["plasma", ST],
-    ["cividis", dT],
-    ["cubehelix", pT],
-    ["warm", yT],
-    ["cool", mT],
-    ["bugn", O6],
-    ["bupu", E6],
-    ["gnbu", R6],
-    ["orrd", k6],
-    ["pubugn", z6],
-    ["pubu", V6],
-    ["purd", q6],
-    ["rdpu", W6],
-    ["ylgnbu", X6],
-    ["ylgn", J6],
-    ["ylorbr", Z6],
-    ["ylorrd", tT],
+    ["turbo", fM],
+    ["viridis", hM],
+    ["magma", dM],
+    ["inferno", pM],
+    ["plasma", yM],
+    ["cividis", sM],
+    ["cubehelix", oM],
+    ["warm", aM],
+    ["cool", cM],
+    ["bugn", M6],
+    ["bupu", $6],
+    ["gnbu", T6],
+    ["orrd", N6],
+    ["pubugn", O6],
+    ["pubu", k6],
+    ["purd", F6],
+    ["rdpu", C6],
+    ["ylgnbu", U6],
+    ["ylgn", q6],
+    ["ylorbr", V6],
+    ["ylorrd", W6],
     // cyclical
-    ["rainbow", gT],
-    ["sinebow", bT]
+    ["rainbow", uM],
+    ["sinebow", lM]
 ]);
 
-function Yw(e) {
+function Mg(e) {
     const t = `${e}`.toLowerCase();
-    if (!Qx.has(t))
+    if (!y2.has(t))
         throw new Error(`unknown quantitative scheme: ${t}`);
-    return Qx.get(t);
+    return y2.get(t);
 }
-const kJ = /* @__PURE__ */ new Set([
+const XV = /* @__PURE__ */ new Set([
     "brbg",
     "prgn",
     "piyg",
     "puor",
     "rdbu",
     "rdgy",
     "rdylbu",
     "rdylgn",
     "spectral",
     "burd",
     "buylrd"
 ]);
 
-function UJ(e) {
-    return e != null && kJ.has(`${e}`.toLowerCase());
+function GV(e) {
+    return e != null && XV.has(`${e}`.toLowerCase());
 }
-const zD = (e) => (t) => e(1 - t),
-    Vm = [0, 1],
-    tS = /* @__PURE__ */ new Map([
+const LA = (e) => (t) => e(1 - t),
+    Bp = [0, 1],
+    m2 = /* @__PURE__ */ new Map([
         // numbers
-        ["number", Qe],
+        ["number", Te],
         // color spaces
-        ["rgb", Qo],
-        ["hsl", gj],
-        ["hcl", vj],
-        ["lab", bj]
+        ["rgb", Ds],
+        ["hsl", $B],
+        ["hcl", EB],
+        ["lab", IB]
     ]);
 
-function PD(e) {
+function kA(e) {
     const t = `${e}`.toLowerCase();
-    if (!tS.has(t))
+    if (!m2.has(t))
         throw new Error(`unknown interpolator: ${t}`);
-    return tS.get(t);
+    return m2.get(t);
 }
 
-function zf(e, t, n, {
-    type: i,
-    nice: r,
+function Eu(e, t, n, {
+    type: r,
+    nice: i,
     clamp: s,
     zero: o,
-    domain: a = jD(e, n),
+    domain: a = FA(e, n),
     unknown: c,
-    round: l,
-    scheme: u,
+    round: u,
+    scheme: l,
     interval: f,
-    range: h = Se.get(e) === Cf ? JJ(n, a) : Se.get(e) === kf ? KJ(n, a) : Se.get(e) === Uf ? Vm : void 0,
-    interpolate: d = Se.get(e) === ds ? u == null && h !== void 0 ? Qo : Yw(u !== void 0 ? u : i === "cyclical" ? "rainbow" : "turbo") : l ? Zb : Qe,
+    range: h = re.get(e) === $u ? sY(n, a) : re.get(e) === Iu ? oY(n, a) : re.get(e) === Tu ? Bp : void 0,
+    interpolate: d = re.get(e) === fi ? l == null && h !== void 0 ? Ds : Mg(l !== void 0 ? l : r === "cyclical" ? "rainbow" : "turbo") : u ? Dm : Te,
     reverse: p
 }) {
-    if (f = ol(f, i), (i === "cyclical" || i === "sequential") && (i = "linear"), typeof d != "function" && (d = PD(d)), p = !!p, h !== void 0) {
-        const m = (a = Nn(a)).length,
-            g = (h = Nn(h)).length;
-        if (m !== g) {
+    if (f = ba(f, r), (r === "cyclical" || r === "sequential") && (r = "linear"), typeof d != "function" && (d = kA(d)), p = !!p, h !== void 0) {
+        const y = (a = Qe(a)).length,
+            m = (h = Qe(h)).length;
+        if (y !== m) {
             if (d.length === 1)
                 throw new Error("invalid piecewise interpolator");
-            d = t0(d, h), h = void 0;
+            d = Jh(d, h), h = void 0;
         }
     }
-    if (d.length === 1 ? (p && (d = zD(d), p = !1), h === void 0 && (h = Float64Array.from(a, (m, g) => g / (a.length - 1)), h.length === 2 && (h = Vm)), t.interpolate((h === Vm ? jn : Gw)(d))) : t.interpolate(d), o) {
-        const [m, g] = ke(a);
-        (m > 0 || g < 0) && (a = Yu(a), kc(a) !== Math.sign(m) ? a[a.length - 1] = 0 : a[0] = 0);
+    if (d.length === 1 ? (p && (d = LA(d), p = !1), h === void 0 && (h = Float64Array.from(a, (y, m) => m / (a.length - 1)), h.length === 2 && (h = Bp)), t.interpolate((h === Bp ? fn : $g)(d))) : t.interpolate(d), o) {
+        const [y, m] = de(a);
+        (y > 0 || m < 0) && (a = qc(a), ta(a) !== Math.sign(y) ? a[a.length - 1] = 0 : a[0] = 0);
     }
-    return p && (a = Kd(a)), t.domain(a).unknown(c), r && (t.nice(zJ(r, i)), a = t.domain()), h !== void 0 && t.range(h), s && t.clamp(s), {
-        type: i,
+    return p && (a = Mf(a)), t.domain(a).unknown(c), i && (t.nice(HV(i, r)), a = t.domain()), h !== void 0 && t.range(h), s && t.clamp(s), {
+        type: r,
         domain: a,
         range: h,
         scale: t,
         interpolate: d,
         interval: f
     };
 }
 
-function zJ(e, t) {
-    return e === !0 ? void 0 : typeof e == "number" ? e : GH(e, t);
+function HV(e, t) {
+    return e === !0 ? void 0 : typeof e == "number" ? e : nV(e, t);
 }
 
-function PJ(e, t, n) {
-    return zf(e, c0(), t, n);
+function JV(e, t, n) {
+    return Eu(e, id(), t, n);
 }
 
-function VJ(e, t, n) {
-    return VD(e, t, {
+function ZV(e, t, n) {
+    return RA(e, t, {
         ...n,
         exponent: 0.5
     });
 }
 
-function VD(e, t, {
+function RA(e, t, {
     exponent: n = 1,
-    ...i
+    ...r
 }) {
-    return zf(e, J$().exponent(n), t, {
-        ...i,
+    return Eu(e, q3().exponent(n), t, {
+        ...r,
         type: "pow"
     });
 }
 
-function jJ(e, t, {
+function KV(e, t, {
     base: n = 10,
-    domain: i = ZJ(t),
-    ...r
+    domain: r = aY(t),
+    ...i
 }) {
-    return zf(e, W$().base(n), t, {
-        ...r,
-        domain: i
+    return Eu(e, C3().base(n), t, {
+        ...i,
+        domain: r
     });
 }
 
-function qJ(e, t, {
+function QV(e, t, {
     constant: n = 1,
-    ...i
+    ...r
 }) {
-    return zf(e, X$().constant(n), t, i);
+    return Eu(e, U3().constant(n), t, r);
 }
 
-function YJ(e, t, {
+function tY(e, t, {
     range: n,
-    quantiles: i = n === void 0 ? 5 : (n = [...n]).length,
+    quantiles: r = n === void 0 ? 5 : (n = [...n]).length,
     // deprecated; use n instead
-    n: r = i,
+    n: i = r,
     scheme: s = "rdylbu",
-    domain: o = QJ(t),
+    domain: o = cY(t),
     unknown: a,
     interpolate: c,
-    reverse: l
+    reverse: u
 }) {
-    return n === void 0 && (n = c !== void 0 ? $i(c, r) : Se.get(e) === ds ? D0(s, r) : void 0), o.length > 0 && (o = K$(o, n === void 0 ? {
-        length: r
-    } : n).quantiles()), Ww(e, t, {
+    return n === void 0 && (n = c !== void 0 ? jn(c, i) : re.get(e) === fi ? Ad(s, i) : void 0), o.length > 0 && (o = j3(o, n === void 0 ? {
+        length: i
+    } : n).quantiles()), Ag(e, t, {
         domain: o,
         range: n,
-        reverse: l,
+        reverse: u,
         unknown: a
     });
 }
 
-function WJ(e, t, {
+function eY(e, t, {
     range: n,
-    n: i = n === void 0 ? 5 : (n = [...n]).length,
-    scheme: r = "rdylbu",
-    domain: s = jD(e, t),
+    n: r = n === void 0 ? 5 : (n = [...n]).length,
+    scheme: i = "rdylbu",
+    domain: s = FA(e, t),
     unknown: o,
     interpolate: a,
     reverse: c
 }) {
-    const [l, u] = ke(s);
+    const [u, l] = de(s);
     let f;
-    return n === void 0 ? (f = Ys(l, u, i), f[0] <= l && f.splice(0, 1), f[f.length - 1] >= u && f.pop(), i = f.length + 1, n = a !== void 0 ? $i(a, i) : Se.get(e) === ds ? D0(r, i) : void 0) : (f = $i(Qe(l, u), i + 1).slice(1, -1), l instanceof Date && (f = f.map((h) => new Date(h)))), kc(Nn(s)) < 0 && f.reverse(), Ww(e, t, {
+    return n === void 0 ? (f = Ci(u, l, r), f[0] <= u && f.splice(0, 1), f[f.length - 1] >= l && f.pop(), r = f.length + 1, n = a !== void 0 ? jn(a, r) : re.get(e) === fi ? Ad(i, r) : void 0) : (f = jn(Te(u, l), r + 1).slice(1, -1), u instanceof Date && (f = f.map((h) => new Date(h)))), ta(Qe(s)) < 0 && f.reverse(), Ag(e, t, {
         domain: f,
         range: n,
         reverse: c,
         unknown: o
     });
 }
 
-function Ww(e, t, {
+function Ag(e, t, {
     domain: n = [0],
     // explicit thresholds in ascending order
-    unknown: i,
-    scheme: r = "rdylbu",
+    unknown: r,
+    scheme: i = "rdylbu",
     interpolate: s,
-    range: o = s !== void 0 ? $i(s, n.length + 1) : Se.get(e) === ds ? D0(r, n.length + 1) : void 0,
+    range: o = s !== void 0 ? jn(s, n.length + 1) : re.get(e) === fi ? Ad(i, n.length + 1) : void 0,
     reverse: a
 }) {
-    n = Nn(n);
-    const c = kc(n);
-    if (!isNaN(c) && !GJ(n, c))
+    n = Qe(n);
+    const c = ta(n);
+    if (!isNaN(c) && !nY(n, c))
         throw new Error(`the ${e} scale has a non-monotonic domain`);
-    return a && (o = Kd(o)), {
+    return a && (o = Mf(o)), {
         type: "threshold",
-        scale: Z$(c < 0 ? Kd(n) : n, o === void 0 ? [] : o).unknown(i),
+        scale: V3(c < 0 ? Mf(n) : n, o === void 0 ? [] : o).unknown(r),
         domain: n,
         range: o
     };
 }
 
-function GJ(e, t) {
-    for (let n = 1, i = e.length, r = e[0]; n < i; ++n) {
-        const s = Ho(r, r = e[n]);
+function nY(e, t) {
+    for (let n = 1, r = e.length, i = e[0]; n < r; ++n) {
+        const s = Is(i, i = e[n]);
         if (s !== 0 && s !== t)
             return !1;
     }
     return !0;
 }
 
-function XJ(e) {
+function rY(e) {
     return {
         type: "identity",
-        scale: sJ(Se.get(e)) ? j$() : (t) => t
+        scale: pV(re.get(e)) ? R3() : (t) => t
     };
 }
 
-function Hu(e, t = kp) {
+function Wc(e, t = fh) {
     return e.length ? [
-        Ye(e, ({
+        ve(e, ({
             value: n
-        }) => n === void 0 ? n : Ye(n, t)),
-        De(e, ({
+        }) => n === void 0 ? n : ve(n, t)),
+        ae(e, ({
             value: n
-        }) => n === void 0 ? n : De(n, t))
+        }) => n === void 0 ? n : ae(n, t))
     ] : [0, 1];
 }
 
-function jD(e, t) {
-    const n = Se.get(e);
-    return (n === Cf || n === Uf || n === kf ? HJ : Hu)(t);
+function FA(e, t) {
+    const n = re.get(e);
+    return (n === $u || n === Tu || n === Iu ? iY : Wc)(t);
 }
 
-function HJ(e) {
-    return [0, e.length ? De(e, ({
+function iY(e) {
+    return [0, e.length ? ae(e, ({
         value: t
-    }) => t === void 0 ? t : De(t, kp)) : 1];
+    }) => t === void 0 ? t : ae(t, fh)) : 1];
 }
 
-function JJ(e, t) {
+function sY(e, t) {
     const n = e.find(({
         radius: o
     }) => o !== void 0);
     if (n !== void 0)
         return [0, n.radius];
-    const i = Ws(e, 0.5, ({
+    const r = Pi(e, 0.5, ({
             value: o
-        }) => o === void 0 ? NaN : Ws(o, 0.25, Qr)),
-        r = t.map((o) => 3 * Math.sqrt(o / i)),
-        s = 30 / De(r);
-    return s < 1 ? r.map((o) => o * s) : r;
+        }) => o === void 0 ? NaN : Pi(o, 0.25, Qr)),
+        i = t.map((o) => 3 * Math.sqrt(o / r)),
+        s = 30 / ae(i);
+    return s < 1 ? i.map((o) => o * s) : i;
 }
 
-function KJ(e, t) {
-    const n = Fu(e, ({
+function oY(e, t) {
+    const n = Nc(e, ({
             value: s
-        }) => s === void 0 ? NaN : Fu(s, Math.abs)),
-        i = t.map((s) => 12 * s / n),
-        r = 60 / De(i);
-    return r < 1 ? i.map((s) => s * r) : i;
+        }) => s === void 0 ? NaN : Nc(s, Math.abs)),
+        r = t.map((s) => 12 * s / n),
+        i = 60 / ae(r);
+    return i < 1 ? r.map((s) => s * i) : r;
 }
 
-function ZJ(e) {
+function aY(e) {
     for (const {
             value: t
         }
         of e)
         if (t !== void 0)
             for (let n of t) {
                 if (n > 0)
-                    return Hu(e, Qr);
+                    return Wc(e, Qr);
                 if (n < 0)
-                    return Hu(e, g0);
+                    return Wc(e, dd);
             }
     return [1, 10];
 }
 
-function QJ(e) {
+function cY(e) {
     const t = [];
     for (const {
             value: n
         }
         of e)
         if (n !== void 0)
-            for (const i of n)
-                t.push(i);
+            for (const r of n)
+                t.push(r);
     return t;
 }
 
-function Gw(e) {
-    return (t, n) => (i) => e(t + i * (n - t));
+function $g(e) {
+    return (t, n) => (r) => e(t + r * (n - t));
 }
 
-function N0(e, t, n, i, {
-    type: r,
+function $d(e, t, n, r, {
+    type: i,
     nice: s,
     clamp: o,
-    domain: a = Hu(i),
+    domain: a = Wc(r),
     unknown: c,
-    pivot: l = 0,
-    scheme: u,
+    pivot: u = 0,
+    scheme: l,
     range: f,
     symmetric: h = !0,
-    interpolate: d = Se.get(e) === ds ? u == null && f !== void 0 ? Qo : Yw(u !== void 0 ? u : "rdbu") : Qe,
+    interpolate: d = re.get(e) === fi ? l == null && f !== void 0 ? Ds : Mg(l !== void 0 ? l : "rdbu") : Te,
     reverse: p
 }) {
-    l = +l, a = Nn(a);
-    let [m, g] = a;
-    if (a.length > 2 && ts(`Warning: the diverging ${e} scale domain contains extra elements.`), Ho(m, g) < 0 && ([m, g] = [g, m], p = !p), m = Math.min(m, l), g = Math.max(g, l), typeof d != "function" && (d = PD(d)), f !== void 0 && (d = d.length === 1 ? Gw(d)(...f) : t0(d, f)), p && (d = zD(d)), h) {
-        const y = n.apply(l),
-            b = y - n.apply(m),
-            w = n.apply(g) - y;
-        b < w ? m = n.invert(y - w) : b > w && (g = n.invert(y + b));
+    u = +u, a = Qe(a);
+    let [y, m] = a;
+    if (a.length > 2 && ti(`Warning: the diverging ${e} scale domain contains extra elements.`), Is(y, m) < 0 && ([y, m] = [m, y], p = !p), y = Math.min(y, u), m = Math.max(m, u), typeof d != "function" && (d = kA(d)), f !== void 0 && (d = d.length === 1 ? $g(d)(...f) : Jh(d, f)), p && (d = LA(d)), h) {
+        const g = n.apply(u),
+            b = g - n.apply(y),
+            w = n.apply(m) - g;
+        b < w ? y = n.invert(g - w) : b > w && (m = n.invert(g + b));
     }
-    return t.domain([m, l, g]).unknown(c).interpolator(d), o && t.clamp(o), s && t.nice(s), {
-        type: r,
-        domain: [m, g],
-        pivot: l,
+    return t.domain([y, u, m]).unknown(c).interpolator(d), o && t.clamp(o), s && t.nice(s), {
+        type: i,
+        domain: [y, m],
+        pivot: u,
         interpolate: d,
         scale: t
     };
 }
 
-function tK(e, t, n) {
-    return N0(e, d6(), rK, t, n);
+function uY(e, t, n) {
+    return $d(e, s6(), dY, t, n);
 }
 
-function eK(e, t, n) {
-    return qD(e, t, {
+function lY(e, t, n) {
+    return BA(e, t, {
         ...n,
         exponent: 0.5
     });
 }
 
-function qD(e, t, {
+function BA(e, t, {
     exponent: n = 1,
-    ...i
+    ...r
 }) {
-    return N0(e, m6().exponent(n = +n), aK(n), t, {
-        ...i,
+    return $d(e, c6().exponent(n = +n), mY(n), t, {
+        ...r,
         type: "diverging-pow"
     });
 }
 
-function nK(e, t, {
+function fY(e, t, {
     base: n = 10,
-    pivot: i = 1,
-    domain: r = Hu(t, i < 0 ? g0 : Qr),
+    pivot: r = 1,
+    domain: i = Wc(t, r < 0 ? dd : Qr),
     ...s
 }) {
-    return N0(e, p6().base(n = +n), sK, t, {
-        domain: r,
-        pivot: i,
+    return $d(e, o6().base(n = +n), pY, t, {
+        domain: i,
+        pivot: r,
         ...s
     });
 }
 
-function iK(e, t, {
+function hY(e, t, {
     constant: n = 1,
-    ...i
+    ...r
 }) {
-    return N0(
+    return $d(
         e,
-        y6().constant(n = +n),
-        cK(n),
+        a6().constant(n = +n),
+        gY(n),
         t,
-        i
+        r
     );
 }
-const rK = {
+const dY = {
         apply(e) {
             return e;
         },
         invert(e) {
             return e;
         }
     },
-    sK = {
+    pY = {
         apply: Math.log,
         invert: Math.exp
     },
-    oK = {
+    yY = {
         apply(e) {
             return Math.sign(e) * Math.sqrt(Math.abs(e));
         },
         invert(e) {
             return Math.sign(e) * (e * e);
         }
     };
 
-function aK(e) {
-    return e === 0.5 ? oK : {
+function mY(e) {
+    return e === 0.5 ? yY : {
         apply(t) {
             return Math.sign(t) * Math.pow(Math.abs(t), e);
         },
         invert(t) {
             return Math.sign(t) * Math.pow(Math.abs(t), 1 / e);
         }
     };
 }
 
-function cK(e) {
+function gY(e) {
     return {
         apply(t) {
             return Math.sign(t) * Math.log1p(Math.abs(t / e));
         },
         invert(t) {
             return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
         }
     };
 }
 
-function YD(e, t, n, i) {
-    return zf(e, t, n, i);
+function CA(e, t, n, r) {
+    return Eu(e, t, n, r);
 }
 
-function lK(e, t, n) {
-    return YD(e, UX(), t, n);
+function bY(e, t, n) {
+    return CA(e, Gq(), t, n);
 }
 
-function uK(e, t, n) {
-    return YD(e, zX(), t, n);
+function wY(e, t, n) {
+    return CA(e, Hq(), t, n);
 }
-const Pf = Symbol("ordinal");
+const Nu = Symbol("ordinal");
 
-function WD(e, t, n, {
-    type: i,
-    interval: r,
+function PA(e, t, n, {
+    type: r,
+    interval: i,
     domain: s,
     range: o,
     reverse: a,
     hint: c
 }) {
-    return r = ol(r, i), s === void 0 && (s = XD(n, r, e)), (i === "categorical" || i === Pf) && (i = "ordinal"), a && (s = Kd(s)), s = t.domain(s).domain(), o !== void 0 && (typeof o == "function" && (o = o(s)), t.range(o)), {
-        type: i,
+    return i = ba(i, r), s === void 0 && (s = zA(n, i, e)), (r === "categorical" || r === Nu) && (r = "ordinal"), a && (s = Mf(s)), s = t.domain(s).domain(), o !== void 0 && (typeof o == "function" && (o = o(s)), t.range(o)), {
+        type: r,
         domain: s,
         range: o,
         scale: t,
         hint: c,
-        interval: r
+        interval: i
     };
 }
 
-function fK(e, t, {
+function vY(e, t, {
     type: n,
-    interval: i,
-    domain: r,
+    interval: r,
+    domain: i,
     range: s,
     scheme: o,
     unknown: a,
     ...c
 }) {
-    i = ol(i, n), r === void 0 && (r = XD(t, i, e));
-    let l;
-    if (Se.get(e) === S0)
-        l = pK(t), s = s === void 0 ? yK(l) : ye(s, Fw);
-    else if (Se.get(e) === ds && (s === void 0 && (n === "ordinal" || n === Pf) && (s = CJ(r, o), s !== void 0 && (o = void 0)), o === void 0 && s === void 0 && (o = n === "ordinal" ? "turbo" : "observable10"), o !== void 0))
+    r = ba(r, n), i === void 0 && (i = zA(t, r, e));
+    let u;
+    if (re.get(e) === wd)
+        u = SY(t), s = s === void 0 ? MY(u) : Zt(s, hg);
+    else if (re.get(e) === fi && (s === void 0 && (n === "ordinal" || n === Nu) && (s = WV(i, o), s !== void 0 && (o = void 0)), o === void 0 && s === void 0 && (o = n === "ordinal" ? "turbo" : "observable10"), o !== void 0))
         if (s !== void 0) {
-            const u = Yw(o),
+            const l = Mg(o),
                 f = s[0],
                 h = s[1] - s[0];
             s = ({
                 length: d
-            }) => $i((p) => u(f + h * p), d);
+            }) => jn((p) => l(f + h * p), d);
         } else
-            s = UD(o);
-    if (a === w1)
+            s = OA(o);
+    if (a === ay)
         throw new Error(`implicit unknown on ${e} scale is not supported`);
-    return WD(e, uw().unknown(a), t, {
+    return PA(e, Vm().unknown(a), t, {
         ...c,
         type: n,
-        domain: r,
+        domain: i,
         range: s,
-        hint: l
+        hint: u
     });
 }
 
-function hK(e, t, {
+function _Y(e, t, {
     align: n = 0.5,
-    padding: i = 0.5,
-    ...r
+    padding: r = 0.5,
+    ...i
 }) {
-    return GD(vG().align(n).padding(i), t, r, e);
+    return UA(Ez().align(n).padding(r), t, i, e);
 }
 
-function dK(e, t, {
+function xY(e, t, {
     align: n = 0.5,
-    padding: i = 0.1,
-    paddingInner: r = i,
-    paddingOuter: s = e === "fx" || e === "fy" ? 0 : i,
+    padding: r = 0.1,
+    paddingInner: i = r,
+    paddingOuter: s = e === "fx" || e === "fy" ? 0 : r,
     ...o
 }) {
-    return GD(
-        o0().align(n).paddingInner(r).paddingOuter(s),
+    return UA(
+        nd().align(n).paddingInner(i).paddingOuter(s),
         t,
         o,
         e
     );
 }
 
-function GD(e, t, n, i) {
+function UA(e, t, n, r) {
     let {
-        round: r
+        round: i
     } = n;
-    return r !== void 0 && e.round(r = !!r), e = WD(i, e, t, n), e.round = r, e;
+    return i !== void 0 && e.round(i = !!i), e = PA(r, e, t, n), e.round = i, e;
 }
 
-function XD(e, t, n) {
-    const i = new el();
+function zA(e, t, n) {
+    const r = new da();
     for (const {
-            value: r,
+            value: i,
             domain: s
         }
         of e) {
         if (s !== void 0)
             return s();
-        if (r !== void 0)
-            for (const o of r)
-                i.add(o);
+        if (i !== void 0)
+            for (const o of i)
+                r.add(o);
     }
     if (t !== void 0) {
-        const [r, s] = ke(i).map(t.floor, t);
-        return t.range(r, t.offset(s));
+        const [i, s] = de(r).map(t.floor, t);
+        return t.range(i, t.offset(s));
     }
-    if (i.size > 1e4 && Se.get(n) === rr)
+    if (r.size > 1e4 && re.get(n) === hr)
         throw new Error(`implicit ordinal domain of ${n} scale has more than 10,000 values`);
-    return Hd(i, li);
+    return xf(r, In);
 }
 
-function eS(e, t) {
+function g2(e, t) {
     let n;
     for (const {
-            hint: i
+            hint: r
         }
         of e) {
-        const r = i == null ? void 0 : i[t];
-        if (r !== void 0) {
+        const i = r == null ? void 0 : r[t];
+        if (i !== void 0) {
             if (n === void 0)
-                n = r;
-            else if (n !== r)
+                n = i;
+            else if (n !== i)
                 return;
         }
     }
     return n;
 }
 
-function pK(e) {
+function SY(e) {
     return {
-        fill: eS(e, "fill"),
-        stroke: eS(e, "stroke")
+        fill: g2(e, "fill"),
+        stroke: g2(e, "stroke")
     };
 }
 
-function yK(e) {
-    return we(e.fill) ? uH : lH;
+function MY(e) {
+    return te(e.fill) ? wj : bj;
 }
 
-function N1(e, {
+function by(e, {
     label: t,
     inset: n = 0,
-    insetTop: i = n,
-    insetRight: r = n,
+    insetTop: r = n,
+    insetRight: i = n,
     insetBottom: s = n,
     insetLeft: o = n,
     round: a,
     nice: c,
-    clamp: l,
-    zero: u,
+    clamp: u,
+    zero: l,
     align: f,
     padding: h,
     projection: d,
     facet: {
         label: p = t
     } = {},
-    ...m
+    ...y
 } = {}) {
-    const g = {};
-    for (const [y, b] of e) {
-        const w = m[y],
-            v = QD(y, b, {
-                round: Se.get(y) === rr ? a : void 0,
+    const m = {};
+    for (const [g, b] of e) {
+        const w = y[g],
+            v = WA(g, b, {
+                round: re.get(g) === hr ? a : void 0,
                 // only for position
                 nice: c,
-                clamp: l,
-                zero: u,
+                clamp: u,
+                zero: l,
                 align: f,
                 padding: h,
                 projection: d,
                 ...w
             });
         if (v) {
             let {
-                label: x = y === "fx" || y === "fy" ? p : t,
+                label: x = g === "fx" || g === "fy" ? p : t,
                 percent: _,
-                transform: I,
-                inset: A,
-                insetTop: M = A !== void 0 ? A : y === "y" ? i : 0,
+                transform: M,
+                inset: T,
+                insetTop: $ = T !== void 0 ? T : g === "y" ? r : 0,
                 // not fy
-                insetRight: N = A !== void 0 ? A : y === "x" ? r : 0,
+                insetRight: N = T !== void 0 ? T : g === "x" ? i : 0,
                 // not fx
-                insetBottom: $ = A !== void 0 ? A : y === "y" ? s : 0,
+                insetBottom: A = T !== void 0 ? T : g === "y" ? s : 0,
                 // not fy
-                insetLeft: B = A !== void 0 ? A : y === "x" ? o : 0
+                insetLeft: D = T !== void 0 ? T : g === "x" ? o : 0
                 // not fx
             } = w || {};
-            if (I == null)
-                I = void 0;
-            else if (typeof I != "function")
+            if (M == null)
+                M = void 0;
+            else if (typeof M != "function")
                 throw new Error("invalid scale transform; not a function");
-            v.percent = !!_, v.label = x === void 0 ? gK(b, v) : x, v.transform = I, y === "x" || y === "fx" ? (v.insetLeft = +B, v.insetRight = +N) : (y === "y" || y === "fy") && (v.insetTop = +M, v.insetBottom = +$), g[y] = v;
+            v.percent = !!_, v.label = x === void 0 ? $Y(b, v) : x, v.transform = M, g === "x" || g === "fx" ? (v.insetLeft = +D, v.insetRight = +N) : (g === "y" || g === "fy") && (v.insetTop = +$, v.insetBottom = +A), m[g] = v;
         }
     }
-    return g;
+    return m;
 }
 
-function nS(e) {
+function b2(e) {
     const t = {},
         n = {
             scales: t
         };
-    for (const [i, r] of Object.entries(e)) {
+    for (const [r, i] of Object.entries(e)) {
         const {
             scale: s,
             type: o,
             interval: a,
             label: c
-        } = r;
-        t[i] = e8(r), n[i] = s, s.type = o, a != null && (s.interval = a), c != null && (s.label = c);
+        } = i;
+        t[r] = GA(i), n[r] = s, s.type = o, a != null && (s.interval = a), c != null && (s.label = c);
     }
     return n;
 }
 
-function mK(e, t) {
+function AY(e, t) {
     const {
         x: n,
-        y: i,
-        fx: r,
+        y: r,
+        fx: i,
         fy: s
-    } = e, o = r || s ? Xw(t) : t;
-    r && iS(r, o), s && rS(s, o);
-    const a = r || s ? JD(e, t) : t;
-    n && iS(n, a), i && rS(i, a);
+    } = e, o = i || s ? Ig(t) : t;
+    i && w2(i, o), s && v2(s, o);
+    const a = i || s ? jA(e, t) : t;
+    n && w2(n, a), r && v2(r, a);
 }
 
-function gK(e = [], t) {
+function $Y(e = [], t) {
     let n;
     for (const {
-            label: i
+            label: r
         }
         of e)
-        if (i !== void 0) {
+        if (r !== void 0) {
             if (n === void 0)
-                n = i;
-            else if (n !== i)
+                n = r;
+            else if (n !== r)
                 return;
         }
     if (n !== void 0)
-        return !ua(t) && t.percent && (n = `${n} (%)`), {
+        return !qs(t) && t.percent && (n = `${n} (%)`), {
             inferred: !0,
             toString: () => n
         };
 }
 
-function HD(e) {
-    return Math.sign(kc(e.domain())) * Math.sign(kc(e.range()));
+function qA(e) {
+    return Math.sign(ta(e.domain())) * Math.sign(ta(e.range()));
 }
 
-function Xw(e) {
+function Ig(e) {
     const {
         marginTop: t,
         marginRight: n,
-        marginBottom: i,
-        marginLeft: r,
+        marginBottom: r,
+        marginLeft: i,
         width: s,
         height: o,
         facet: {
             marginTop: a,
             marginRight: c,
-            marginBottom: l,
-            marginLeft: u
+            marginBottom: u,
+            marginLeft: l
         }
     } = e;
     return {
         marginTop: Math.max(t, a),
         marginRight: Math.max(n, c),
-        marginBottom: Math.max(i, l),
-        marginLeft: Math.max(r, u),
+        marginBottom: Math.max(r, u),
+        marginLeft: Math.max(i, l),
         width: s,
         height: o
     };
 }
 
-function JD({
+function jA({
     fx: e,
     fy: t
 }, n) {
     const {
-        marginTop: i,
-        marginRight: r,
+        marginTop: r,
+        marginRight: i,
         marginBottom: s,
         marginLeft: o,
         width: a,
         height: c
-    } = Xw(n);
+    } = Ig(n);
     return {
-        marginTop: i,
-        marginRight: r,
+        marginTop: r,
+        marginRight: i,
         marginBottom: s,
         marginLeft: o,
-        width: e ? e.scale.bandwidth() + o + r : a,
-        height: t ? t.scale.bandwidth() + i + s : c,
+        width: e ? e.scale.bandwidth() + o + i : a,
+        height: t ? t.scale.bandwidth() + r + s : c,
         facet: {
             width: a,
             height: c
         }
     };
 }
 
-function iS(e, t) {
+function w2(e, t) {
     if (e.range === void 0) {
         const {
             insetLeft: n,
-            insetRight: i
+            insetRight: r
         } = e, {
-            width: r,
+            width: i,
             marginLeft: s = 0,
             marginRight: o = 0
-        } = t, a = s + n, c = r - o - i;
-        e.range = [a, Math.max(a, c)], ua(e) || (e.range = ZD(e)), e.scale.range(e.range);
+        } = t, a = s + n, c = i - o - r;
+        e.range = [a, Math.max(a, c)], qs(e) || (e.range = YA(e)), e.scale.range(e.range);
     }
-    KD(e);
+    VA(e);
 }
 
-function rS(e, t) {
+function v2(e, t) {
     if (e.range === void 0) {
         const {
             insetTop: n,
-            insetBottom: i
+            insetBottom: r
         } = e, {
-            height: r,
+            height: i,
             marginTop: s = 0,
             marginBottom: o = 0
-        } = t, a = s + n, c = r - o - i;
-        e.range = [Math.max(a, c), a], ua(e) ? e.range.reverse() : e.range = ZD(e), e.scale.range(e.range);
+        } = t, a = s + n, c = i - o - r;
+        e.range = [Math.max(a, c), a], qs(e) ? e.range.reverse() : e.range = YA(e), e.scale.range(e.range);
     }
-    KD(e);
+    VA(e);
 }
 
-function KD(e) {
-    e.round === void 0 && vK(e) && bK(e) <= 30 && e.scale.round(!0);
+function VA(e) {
+    e.round === void 0 && EY(e) && IY(e) <= 30 && e.scale.round(!0);
 }
 
-function bK({
+function IY({
     scale: e
 }) {
     const t = e.domain().length,
-        [n, i] = e.range(),
-        r = e.paddingInner ? e.paddingInner() : 1,
+        [n, r] = e.range(),
+        i = e.paddingInner ? e.paddingInner() : 1,
         s = e.paddingOuter ? e.paddingOuter() : e.padding(),
-        o = t - r,
-        a = Math.abs(i - n) / Math.max(1, o + s * 2);
+        o = t - i,
+        a = Math.abs(r - n) / Math.max(1, o + s * 2);
     return (a - Math.floor(a)) * o;
 }
 
-function ZD(e) {
-    const t = e.scale.domain().length + t8(e);
+function YA(e) {
+    const t = e.scale.domain().length + XA(e);
     if (!(t > 2))
         return e.range;
-    const [n, i] = e.range;
+    const [n, r] = e.range;
     return Array.from({
         length: t
-    }, (r, s) => n + s / (t - 1) * (i - n));
+    }, (i, s) => n + s / (t - 1) * (r - n));
 }
 
-function B1(e, t, n) {
-    return QD(e, n === void 0 ? void 0 : [{
+function wy(e, t, n) {
+    return WA(e, n === void 0 ? void 0 : [{
         hint: n
     }], {
         ...t
     });
 }
 
-function QD(e, t = [], n = {}) {
-    const i = wK(e, t, n);
-    if (n.type === void 0 && n.domain === void 0 && n.range === void 0 && n.interval == null && e !== "fx" && e !== "fy" && ua({
-            type: i
+function WA(e, t = [], n = {}) {
+    const r = TY(e, t, n);
+    if (n.type === void 0 && n.domain === void 0 && n.range === void 0 && n.interval == null && e !== "fx" && e !== "fy" && qs({
+            type: r
         })) {
-        const r = t.map(({
+        const i = t.map(({
             value: s
         }) => s).filter((s) => s !== void 0);
-        r.some(gn) ? ts(
-            `Warning: some data associated with the ${e} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${Aa(
-        i
-      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${e} scale to "${Aa(
-        i
+        i.some(qe) ? ti(
+            `Warning: some data associated with the ${e} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${eo(
+        r
+      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${e} scale to "${eo(
+        r
       )}".`
-        ) : r.some(KH) ? ts(
-            `Warning: some data associated with the ${e} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${Aa(
-        i
-      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${e} scale to "${Aa(
-        i
+        ) : i.some(oV) ? ti(
+            `Warning: some data associated with the ${e} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${eo(
+        r
+      )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${e} scale to "${eo(
+        r
       )}".`
-        ) : r.some(ZH) && ts(
-            `Warning: some data associated with the ${e} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${Aa(
-        i
-      )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${e} scale to "${Aa(
-        i
+        ) : i.some(aV) && ti(
+            `Warning: some data associated with the ${e} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${eo(
+        r
+      )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${e} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${e} scale to "${eo(
+        r
       )}".`
         );
     }
-    switch (n.type = i, i) {
+    switch (n.type = r, r) {
         case "diverging":
         case "diverging-sqrt":
         case "diverging-pow":
         case "diverging-log":
         case "diverging-symlog":
         case "cyclical":
         case "sequential":
         case "linear":
         case "sqrt":
         case "threshold":
         case "quantile":
         case "pow":
         case "log":
         case "symlog":
-            n = Sh(t, n, An);
+            n = cl(t, n, He);
             break;
         case "identity":
-            switch (Se.get(e)) {
-                case rr:
-                    n = Sh(t, n, An);
+            switch (re.get(e)) {
+                case hr:
+                    n = cl(t, n, He);
                     break;
-                case S0:
-                    n = Sh(t, n, _K);
+                case wd:
+                    n = cl(t, n, NY);
                     break;
             }
             break;
         case "utc":
         case "time":
-            n = Sh(t, n, WH);
+            n = cl(t, n, eV);
             break;
     }
-    switch (i) {
+    switch (r) {
         case "diverging":
-            return tK(e, t, n);
+            return uY(e, t, n);
         case "diverging-sqrt":
-            return eK(e, t, n);
+            return lY(e, t, n);
         case "diverging-pow":
-            return qD(e, t, n);
+            return BA(e, t, n);
         case "diverging-log":
-            return nK(e, t, n);
+            return fY(e, t, n);
         case "diverging-symlog":
-            return iK(e, t, n);
+            return hY(e, t, n);
         case "categorical":
         case "ordinal":
-        case Pf:
-            return fK(e, t, n);
+        case Nu:
+            return vY(e, t, n);
         case "cyclical":
         case "sequential":
         case "linear":
-            return PJ(e, t, n);
+            return JV(e, t, n);
         case "sqrt":
-            return VJ(e, t, n);
+            return ZV(e, t, n);
         case "threshold":
-            return Ww(e, t, n);
+            return Ag(e, t, n);
         case "quantile":
-            return YJ(e, t, n);
+            return tY(e, t, n);
         case "quantize":
-            return WJ(e, t, n);
+            return eY(e, t, n);
         case "pow":
-            return VD(e, t, n);
+            return RA(e, t, n);
         case "log":
-            return jJ(e, t, n);
+            return KV(e, t, n);
         case "symlog":
-            return qJ(e, t, n);
+            return QV(e, t, n);
         case "utc":
-            return uK(e, t, n);
+            return wY(e, t, n);
         case "time":
-            return lK(e, t, n);
+            return bY(e, t, n);
         case "point":
-            return hK(e, t, n);
+            return _Y(e, t, n);
         case "band":
-            return dK(e, t, n);
+            return xY(e, t, n);
         case "identity":
-            return XJ(e);
+            return rY(e);
         case void 0:
             return;
         default:
-            throw new Error(`unknown scale type: ${i}`);
+            throw new Error(`unknown scale type: ${r}`);
     }
 }
 
-function Aa(e) {
+function eo(e) {
     return typeof e == "symbol" ? e.description : e;
 }
 
-function sS(e) {
+function _2(e) {
     return typeof e == "string" ? `${e}`.toLowerCase() : e;
 }
-const oS = {
+const x2 = {
     toString: () => "projection"
 };
 
-function wK(e, t, {
+function TY(e, t, {
     type: n,
-    domain: i,
-    range: r,
+    domain: r,
+    range: i,
     scheme: s,
     pivot: o,
     projection: a
 }) {
-    if (n = sS(n), e === "fx" || e === "fy")
+    if (n = _2(n), e === "fx" || e === "fy")
         return "band";
-    (e === "x" || e === "y") && a != null && (n = oS);
-    for (const l of t) {
-        const u = sS(l.type);
-        if (u !== void 0) {
+    (e === "x" || e === "y") && a != null && (n = x2);
+    for (const u of t) {
+        const l = _2(u.type);
+        if (l !== void 0) {
             if (n === void 0)
-                n = u;
-            else if (n !== u)
-                throw new Error(`scale incompatible with channel: ${n} !== ${u}`);
+                n = l;
+            else if (n !== l)
+                throw new Error(`scale incompatible with channel: ${n} !== ${l}`);
         }
     }
-    if (n === oS)
+    if (n === x2)
         return;
     if (n !== void 0)
         return n;
-    if (i === void 0 && !t.some(({
-            value: l
-        }) => l !== void 0))
+    if (r === void 0 && !t.some(({
+            value: u
+        }) => u !== void 0))
         return;
-    const c = Se.get(e);
-    if (c === Cf)
+    const c = re.get(e);
+    if (c === $u)
         return "sqrt";
-    if (c === Uf || c === kf)
+    if (c === Tu || c === Iu)
         return "linear";
-    if (c === S0)
+    if (c === wd)
         return "ordinal";
-    if ((i || r || []).length > 2)
-        return jm(c);
-    if (i !== void 0) {
-        if (Ae(i))
-            return jm(c);
-        if (gn(i))
+    if ((r || i || []).length > 2)
+        return Cp(c);
+    if (r !== void 0) {
+        if (ie(r))
+            return Cp(c);
+        if (qe(r))
             return "utc";
     } else {
-        const l = t.map(({
-            value: u
-        }) => u).filter((u) => u !== void 0);
-        if (l.some(Ae))
-            return jm(c);
-        if (l.some(gn))
+        const u = t.map(({
+            value: l
+        }) => l).filter((l) => l !== void 0);
+        if (u.some(ie))
+            return Cp(c);
+        if (u.some(qe))
             return "utc";
     }
-    if (c === ds) {
-        if (o != null || UJ(s))
+    if (c === fi) {
+        if (o != null || GV(s))
             return "diverging";
-        if (RJ(s))
+        if (YV(s))
             return "categorical";
     }
     return "linear";
 }
 
-function jm(e) {
+function Cp(e) {
     switch (e) {
-        case rr:
+        case hr:
             return "point";
-        case ds:
-            return Pf;
+        case fi:
+            return Nu;
         default:
             return "ordinal";
     }
 }
 
-function ua({
+function qs({
     type: e
 }) {
-    return e === "ordinal" || e === "point" || e === "band" || e === Pf;
+    return e === "ordinal" || e === "point" || e === "band" || e === Nu;
 }
 
-function t8({
+function XA({
     type: e
 }) {
     return e === "threshold";
 }
 
-function vK({
+function EY({
     type: e
 }) {
     return e === "point" || e === "band";
 }
 
-function oi(e) {
+function Mn(e) {
     if (e === void 0)
         return !0;
     const t = e.domain(),
         n = e(t[0]);
-    for (let i = 1, r = t.length; i < r; ++i)
-        if (e(t[i]) - n)
+    for (let r = 1, i = t.length; r < i; ++r)
+        if (e(t[r]) - n)
             return !1;
     return !0;
 }
 
-function Sh(e, {
+function cl(e, {
     domain: t,
     ...n
-}, i) {
-    var r;
+}, r) {
+    var i;
     for (const s of e)
-        s.value !== void 0 && (t === void 0 && (t = (r = s.value) == null ? void 0 : r.domain), s.value = i(s.value));
+        s.value !== void 0 && (t === void 0 && (t = (i = s.value) == null ? void 0 : i.domain), s.value = r(s.value));
     return {
-        domain: t === void 0 ? t : i(t),
+        domain: t === void 0 ? t : r(t),
         ...n
     };
 }
 
-function _K(e) {
-    return ye(e, Fw);
+function NY(e) {
+    return Zt(e, hg);
 }
 
-function Vp(e = {}) {
+function Xc(e = {}) {
     let t;
     for (const n in e)
-        if (Se.has(n) && jo(e[n])) {
+        if (re.has(n) && xs(e[n])) {
             if (t !== void 0)
                 throw new Error("ambiguous scale definition; multiple scales found");
-            t = e8(B1(n, e[n]));
+            t = GA(wy(n, e[n]));
         }
     if (t === void 0)
         throw new Error("invalid scale definition; no scale found");
     return t;
 }
 
-function xK(e) {
+function DY(e) {
     return (t) => {
-        if (!Se.has(t = `${t}`))
+        if (!re.has(t = `${t}`))
             throw new Error(`unknown scale: ${t}`);
         return e[t];
     };
 }
 
-function e8({
+function GA({
     scale: e,
     type: t,
     domain: n,
-    range: i,
-    interpolate: r,
+    range: r,
+    interpolate: i,
     interval: s,
     transform: o,
     percent: a,
     pivot: c
 }) {
     if (t === "identity")
         return {
             type: "identity",
-            apply: (u) => u,
-            invert: (u) => u
+            apply: (l) => l,
+            invert: (l) => l
         };
-    const l = e.unknown ? e.unknown() : void 0;
+    const u = e.unknown ? e.unknown() : void 0;
     return {
         type: t,
-        domain: Yu(n),
+        domain: qc(n),
         // defensive copy
-        ...i !== void 0 && {
-            range: Yu(i)
+        ...r !== void 0 && {
+            range: qc(r)
         },
         // defensive copy
         ...o !== void 0 && {
             transform: o
         },
         ...a && {
             percent: a
         },
         // only exposed if truthy
-        ...l !== void 0 && {
-            unknown: l
+        ...u !== void 0 && {
+            unknown: u
         },
         ...s !== void 0 && {
             interval: s
         },
         // quantitative
-        ...r !== void 0 && {
-            interpolate: r
+        ...i !== void 0 && {
+            interpolate: i
         },
         ...e.clamp && {
             clamp: e.clamp()
         },
         // diverging (always asymmetric; we never want to apply the symmetric transform twice)
         ...c !== void 0 && {
             pivot: c,
@@ -25899,1556 +26462,1556 @@
             padding: e.padding()
         }),
         ...e.bandwidth && {
             bandwidth: e.bandwidth(),
             step: e.step()
         },
         // utilities
-        apply: (u) => e(u),
+        apply: (l) => e(l),
         ...e.invert && {
-            invert: (u) => e.invert(u)
+            invert: (l) => e.invert(l)
         }
     };
 }
 
-function Hw(e) {
+function Tg(e) {
     let t, n;
-    return (...i) => (((n == null ? void 0 : n.length) !== i.length || n.some((r, s) => r !== i[s])) && (n = i, t = e(...i)), t);
+    return (...r) => (((n == null ? void 0 : n.length) !== r.length || n.some((i, s) => i !== r[s])) && (n = r, t = e(...r)), t);
 }
-const SK = Hw((e) => new Intl.NumberFormat(e)),
-    IK = Hw((e, t) => new Intl.DateTimeFormat(e, {
+const OY = Tg((e) => new Intl.NumberFormat(e)),
+    LY = Tg((e, t) => new Intl.DateTimeFormat(e, {
         timeZone: "UTC",
         ...t && {
             month: t
         }
     })),
-    AK = Hw((e, t) => new Intl.DateTimeFormat(e, {
+    kY = Tg((e, t) => new Intl.DateTimeFormat(e, {
         timeZone: "UTC",
         ...t && {
             weekday: t
         }
     }));
 
-function MK(e = "en-US") {
-    const t = SK(e);
+function RY(e = "en-US") {
+    const t = OY(e);
     return (n) => n != null && !isNaN(n) ? t.format(n) : void 0;
 }
 
-function $K(e = "en-US", t = "short") {
-    const n = IK(e, t);
-    return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2e3, +i))) ? n.format(i) : void 0;
+function FY(e = "en-US", t = "short") {
+    const n = LY(e, t);
+    return (r) => r != null && !isNaN(r = +new Date(Date.UTC(2e3, +r))) ? n.format(r) : void 0;
 }
 
-function TK(e = "en-US", t = "short") {
-    const n = AK(e, t);
-    return (i) => i != null && !isNaN(i = +new Date(Date.UTC(2001, 0, +i))) ? n.format(i) : void 0;
+function BY(e = "en-US", t = "short") {
+    const n = kY(e, t);
+    return (r) => r != null && !isNaN(r = +new Date(Date.UTC(2001, 0, +r))) ? n.format(r) : void 0;
 }
 
-function n8(e) {
-    return iD(e, "Invalid Date");
+function HA(e) {
+    return HM(e, "Invalid Date");
 }
 
-function DK(e = "en-US") {
-    const t = MK(e);
-    return (n) => (n instanceof Date ? n8 : typeof n == "number" ? t : tn)(n);
+function CY(e = "en-US") {
+    const t = RY(e);
+    return (n) => (n instanceof Date ? HA : typeof n == "number" ? t : Ee)(n);
 }
-const ra = DK(),
-    He = (typeof window < "u" ? window.devicePixelRatio > 1 : typeof it > "u") ? 0 : 0.5;
-let NK = 0;
+const Fs = CY(),
+    Me = (typeof window < "u" ? window.devicePixelRatio > 1 : typeof it > "u") ? 0 : 0.5;
+let PY = 0;
 
-function O1() {
-    return `plot-clip-${++NK}`;
+function vy() {
+    return `plot-clip-${++PY}`;
 }
 
-function i8(e, {
+function JA(e, {
     title: t,
     href: n,
-    ariaLabel: i,
-    ariaDescription: r,
+    ariaLabel: r,
+    ariaDescription: i,
     ariaHidden: s,
     target: o,
     fill: a,
     fillOpacity: c,
-    stroke: l,
-    strokeWidth: u,
+    stroke: u,
+    strokeWidth: l,
     strokeOpacity: f,
     strokeLinejoin: h,
     strokeLinecap: d,
     strokeMiterlimit: p,
-    strokeDasharray: m,
-    strokeDashoffset: g,
-    opacity: y,
+    strokeDasharray: y,
+    strokeDashoffset: m,
+    opacity: g,
     mixBlendMode: b,
     imageFilter: w,
     paintOrder: v,
     pointerEvents: x,
     shapeRendering: _,
-    channels: I
+    channels: M
 }, {
-    ariaLabel: A,
-    fill: M = "currentColor",
+    ariaLabel: T,
+    fill: $ = "currentColor",
     fillOpacity: N,
-    stroke: $ = "none",
-    strokeOpacity: B,
+    stroke: A = "none",
+    strokeOpacity: D,
     strokeWidth: R,
     strokeLinecap: S,
-    strokeLinejoin: T,
-    strokeMiterlimit: D,
-    paintOrder: L
-}) {
-    M === null && (a = null, c = null), $ === null && (l = null, f = null), we(M) ? !we($) && (!we(a) || I != null && I.fill) && ($ = "none") : we($) && (!we(l) || I != null && I.stroke) && (M = "none");
-    const [k, U] = mn(a, M), [C, z] = Be(c, N), [P, G] = mn(l, $), [K, et] = Be(f, B), [Z, Y] = Be(y);
-    zc(G) || (u === void 0 && (u = R), d === void 0 && (d = S), h === void 0 && (h = T), p === void 0 && !eJ(h) && (p = D), !zc(U) && v === void 0 && (v = L));
-    const [X, j] = Be(u);
-    return M !== null && (e.fill = Me(U, "currentColor"), e.fillOpacity = $l(z, 1)), $ !== null && (e.stroke = Me(G, "none"), e.strokeWidth = $l(j, 1), e.strokeOpacity = $l(et, 1), e.strokeLinejoin = Me(h, "miter"), e.strokeLinecap = Me(d, "butt"), e.strokeMiterlimit = $l(p, 4), e.strokeDasharray = Me(m, "none"), e.strokeDashoffset = Me(g, "0")), e.target = tn(o), e.ariaLabel = tn(A), e.ariaDescription = tn(r), e.ariaHidden = tn(s), e.opacity = $l(Y, 1), e.mixBlendMode = Me(b, "normal"), e.imageFilter = Me(w, "none"), e.paintOrder = Me(v, "normal"), e.pointerEvents = Me(x, "auto"), e.shapeRendering = Me(_, "auto"), {
+    strokeLinejoin: I,
+    strokeMiterlimit: E,
+    paintOrder: k
+}) {
+    $ === null && (a = null, c = null), A === null && (u = null, f = null), te($) ? !te(A) && (!te(a) || M != null && M.fill) && (A = "none") : te(A) && (!te(u) || M != null && M.stroke) && ($ = "none");
+    const [B, C] = ze(a, $), [F, P] = ue(c, N), [U, Y] = ze(u, A), [G, K] = ue(f, D), [H, V] = ue(g);
+    na(Y) || (l === void 0 && (l = R), d === void 0 && (d = S), h === void 0 && (h = I), p === void 0 && !lV(h) && (p = E), !na(C) && v === void 0 && (v = k));
+    const [W, q] = ue(l);
+    return $ !== null && (e.fill = se(C, "currentColor"), e.fillOpacity = Ca(P, 1)), A !== null && (e.stroke = se(Y, "none"), e.strokeWidth = Ca(q, 1), e.strokeOpacity = Ca(K, 1), e.strokeLinejoin = se(h, "miter"), e.strokeLinecap = se(d, "butt"), e.strokeMiterlimit = Ca(p, 4), e.strokeDasharray = se(y, "none"), e.strokeDashoffset = se(m, "0")), e.target = Ee(o), e.ariaLabel = Ee(T), e.ariaDescription = Ee(i), e.ariaHidden = Ee(s), e.opacity = Ca(V, 1), e.mixBlendMode = se(b, "normal"), e.imageFilter = se(w, "none"), e.paintOrder = se(v, "normal"), e.pointerEvents = se(x, "auto"), e.shapeRendering = se(_, "auto"), {
         title: {
             value: t,
             optional: !0,
             filter: null
         },
         href: {
             value: n,
             optional: !0,
             filter: null
         },
         ariaLabel: {
-            value: i,
+            value: r,
             optional: !0,
             filter: null
         },
         fill: {
-            value: k,
+            value: B,
             scale: "auto",
             optional: !0
         },
         fillOpacity: {
-            value: C,
+            value: F,
             scale: "auto",
             optional: !0
         },
         stroke: {
-            value: P,
+            value: U,
             scale: "auto",
             optional: !0
         },
         strokeOpacity: {
-            value: K,
+            value: G,
             scale: "auto",
             optional: !0
         },
         strokeWidth: {
-            value: X,
+            value: W,
             optional: !0
         },
         opacity: {
-            value: Z,
+            value: H,
             scale: "auto",
             optional: !0
         }
     };
 }
 
-function BK(e, t) {
-    t && e.filter((n) => vw(t[n])).append("title").call(FK, t);
+function UY(e, t) {
+    t && e.filter((n) => tg(t[n])).append("title").call(qY, t);
 }
 
-function OK(e, t) {
-    t && e.filter(([n]) => vw(t[n])).append("title").call(EK, t);
+function zY(e, t) {
+    t && e.filter(([n]) => tg(t[n])).append("title").call(jY, t);
 }
 
-function FK(e, t) {
-    t && e.text((n) => ra(t[n]));
+function qY(e, t) {
+    t && e.text((n) => Fs(t[n]));
 }
 
-function EK(e, t) {
-    t && e.text(([n]) => ra(t[n]));
+function jY(e, t) {
+    t && e.text(([n]) => Fs(t[n]));
 }
 
-function Pe(e, {
+function me(e, {
     target: t,
     tip: n
 }, {
-    ariaLabel: i,
-    title: r,
+    ariaLabel: r,
+    title: i,
     fill: s,
     fillOpacity: o,
     stroke: a,
     strokeOpacity: c,
-    strokeWidth: l,
-    opacity: u,
+    strokeWidth: u,
+    opacity: l,
     href: f
 }) {
-    i && yt(e, "aria-label", (h) => i[h]), s && yt(e, "fill", (h) => s[h]), o && yt(e, "fill-opacity", (h) => o[h]), a && yt(e, "stroke", (h) => a[h]), c && yt(e, "stroke-opacity", (h) => c[h]), l && yt(e, "stroke-width", (h) => l[h]), u && yt(e, "opacity", (h) => u[h]), f && s8(e, (h) => f[h], t), n || BK(e, r);
+    r && at(e, "aria-label", (h) => r[h]), s && at(e, "fill", (h) => s[h]), o && at(e, "fill-opacity", (h) => o[h]), a && at(e, "stroke", (h) => a[h]), c && at(e, "stroke-opacity", (h) => c[h]), u && at(e, "stroke-width", (h) => u[h]), l && at(e, "opacity", (h) => l[h]), f && KA(e, (h) => f[h], t), n || UY(e, i);
 }
 
-function jp(e, {
+function yh(e, {
     target: t,
     tip: n
 }, {
-    ariaLabel: i,
-    title: r,
+    ariaLabel: r,
+    title: i,
     fill: s,
     fillOpacity: o,
     stroke: a,
     strokeOpacity: c,
-    strokeWidth: l,
-    opacity: u,
+    strokeWidth: u,
+    opacity: l,
     href: f
 }) {
-    i && yt(e, "aria-label", ([h]) => i[h]), s && yt(e, "fill", ([h]) => s[h]), o && yt(e, "fill-opacity", ([h]) => o[h]), a && yt(e, "stroke", ([h]) => a[h]), c && yt(e, "stroke-opacity", ([h]) => c[h]), l && yt(e, "stroke-width", ([h]) => l[h]), u && yt(e, "opacity", ([h]) => u[h]), f && s8(e, ([h]) => f[h], t), n || OK(e, r);
+    r && at(e, "aria-label", ([h]) => r[h]), s && at(e, "fill", ([h]) => s[h]), o && at(e, "fill-opacity", ([h]) => o[h]), a && at(e, "stroke", ([h]) => a[h]), c && at(e, "stroke-opacity", ([h]) => c[h]), u && at(e, "stroke-width", ([h]) => u[h]), l && at(e, "opacity", ([h]) => l[h]), f && KA(e, ([h]) => f[h], t), n || zY(e, i);
 }
 
-function LK({
+function VY({
     ariaLabel: e,
     title: t,
     fill: n,
-    fillOpacity: i,
-    stroke: r,
+    fillOpacity: r,
+    stroke: i,
     strokeOpacity: s,
     strokeWidth: o,
     opacity: a,
     href: c
 }, {
-    tip: l
+    tip: u
 }) {
-    return [e, l ? void 0 : t, n, i, r, s, o, a, c].filter((u) => u !== void 0);
+    return [e, u ? void 0 : t, n, r, i, s, o, a, c].filter((l) => l !== void 0);
 }
 
-function Jw(e, t, n) {
-    const i = us(e, (r) => t[r]);
-    return n === void 0 && i.size > 1 + e.length >> 1 && ts(
+function Eg(e, t, n) {
+    const r = ci(e, (i) => t[i]);
+    return n === void 0 && r.size > 1 + e.length >> 1 && ti(
         "Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null."
-    ), i.values();
+    ), r.values();
 }
 
-function* r8(e, t, n, i) {
+function* ZA(e, t, n, r) {
     const {
-        z: r
+        z: i
     } = n, {
         z: s
-    } = i, o = LK(i, n), a = [...t, ...o];
-    for (const c of s ? Jw(e, s, r) : [e]) {
-        let l, u;
+    } = r, o = VY(r, n), a = [...t, ...o];
+    for (const c of s ? Eg(e, s, i) : [e]) {
+        let u, l;
         t:
             for (const f of c) {
                 for (const h of a)
-                    if (!dn(h[f])) {
-                        u && u.push(-1);
+                    if (!Ce(h[f])) {
+                        l && l.push(-1);
                         continue t;
                     }
-                if (l === void 0) {
-                    u && (yield u), l = o.map((h) => Eo(h[f])), u = [f];
+                if (u === void 0) {
+                    l && (yield l), u = o.map((h) => ys(h[f])), l = [f];
                     continue;
                 }
-                u.push(f);
+                l.push(f);
                 for (let h = 0; h < o.length; ++h)
-                    if (Eo(o[h][f]) !== l[h]) {
-                        yield u, l = o.map((p) => Eo(p[f])), u = [f];
+                    if (ys(o[h][f]) !== u[h]) {
+                        yield l, u = o.map((p) => ys(p[f])), l = [f];
                         continue t;
                     }
             }
-        u && (yield u);
+        l && (yield l);
     }
 }
 
-function RK(e, t, n, i) {
-    let r;
+function YY(e, t, n, r) {
+    let i;
     const {
-        clip: s = i.clip
+        clip: s = r.clip
     } = t;
     switch (s) {
         case "frame": {
             const {
                 width: o,
                 height: a,
                 marginLeft: c,
-                marginRight: l,
-                marginTop: u,
+                marginRight: u,
+                marginTop: l,
                 marginBottom: f
-            } = n, h = O1();
-            r = `url(#${h})`, e = Gt("svg:g", i).call(
-                (d) => d.append("svg:clipPath").attr("id", h).append("rect").attr("x", c).attr("y", u).attr("width", o - l - c).attr("height", a - u - f)
+            } = n, h = vy();
+            i = `url(#${h})`, e = Ot("svg:g", r).call(
+                (d) => d.append("svg:clipPath").attr("id", h).append("rect").attr("x", c).attr("y", l).attr("width", o - u - c).attr("height", a - l - f)
             ).each(function() {
                 this.appendChild(e.node()), e.node = () => this;
             });
             break;
         }
         case "sphere": {
             const {
                 projection: o
-            } = i;
+            } = r;
             if (!o)
                 throw new Error('the "sphere" clip option requires a projection');
-            const a = O1();
-            r = `url(#${a})`, e.append("clipPath").attr("id", a).append("path").attr("d", oo(o)({
+            const a = vy();
+            i = `url(#${a})`, e.append("clipPath").attr("id", a).append("path").attr("d", Zi(o)({
                 type: "Sphere"
             }));
             break;
         }
     }
-    yt(e, "aria-label", t.ariaLabel), yt(e, "aria-description", t.ariaDescription), yt(e, "aria-hidden", t.ariaHidden), yt(e, "clip-path", r);
+    at(e, "aria-label", t.ariaLabel), at(e, "aria-description", t.ariaDescription), at(e, "aria-hidden", t.ariaHidden), at(e, "clip-path", i);
 }
 
-function ve(e, t, n, i) {
-    RK(e, t, n, i), yt(e, "fill", t.fill), yt(e, "fill-opacity", t.fillOpacity), yt(e, "stroke", t.stroke), yt(e, "stroke-width", t.strokeWidth), yt(e, "stroke-opacity", t.strokeOpacity), yt(e, "stroke-linejoin", t.strokeLinejoin), yt(e, "stroke-linecap", t.strokeLinecap), yt(e, "stroke-miterlimit", t.strokeMiterlimit), yt(e, "stroke-dasharray", t.strokeDasharray), yt(e, "stroke-dashoffset", t.strokeDashoffset), yt(e, "shape-rendering", t.shapeRendering), yt(e, "filter", t.imageFilter), yt(e, "paint-order", t.paintOrder);
+function ee(e, t, n, r) {
+    YY(e, t, n, r), at(e, "fill", t.fill), at(e, "fill-opacity", t.fillOpacity), at(e, "stroke", t.stroke), at(e, "stroke-width", t.strokeWidth), at(e, "stroke-opacity", t.strokeOpacity), at(e, "stroke-linejoin", t.strokeLinejoin), at(e, "stroke-linecap", t.strokeLinecap), at(e, "stroke-miterlimit", t.strokeMiterlimit), at(e, "stroke-dasharray", t.strokeDasharray), at(e, "stroke-dashoffset", t.strokeDashoffset), at(e, "shape-rendering", t.shapeRendering), at(e, "filter", t.imageFilter), at(e, "paint-order", t.paintOrder);
     const {
-        pointerEvents: r = i.pointerSticky === !1 ? "none" : void 0
+        pointerEvents: i = r.pointerSticky === !1 ? "none" : void 0
     } = t;
-    yt(e, "pointer-events", r);
+    at(e, "pointer-events", i);
 }
 
-function be(e, t) {
-    CK(e, "mix-blend-mode", t.mixBlendMode), yt(e, "opacity", t.opacity);
+function Qt(e, t) {
+    WY(e, "mix-blend-mode", t.mixBlendMode), at(e, "opacity", t.opacity);
 }
 
-function s8(e, t, n) {
-    e.each(function(i) {
-        const r = t(i);
-        if (r != null) {
-            const s = this.ownerDocument.createElementNS(Ko.svg, "a");
-            s.setAttribute("fill", "inherit"), s.setAttributeNS(Ko.xlink, "href", r), n != null && s.setAttribute("target", n), this.parentNode.insertBefore(s, this).appendChild(this);
+function KA(e, t, n) {
+    e.each(function(r) {
+        const i = t(r);
+        if (i != null) {
+            const s = this.ownerDocument.createElementNS(Es.svg, "a");
+            s.setAttribute("fill", "inherit"), s.setAttributeNS(Es.xlink, "href", i), n != null && s.setAttribute("target", n), this.parentNode.insertBefore(s, this).appendChild(this);
         }
     });
 }
 
-function yt(e, t, n) {
+function at(e, t, n) {
     n != null && e.attr(t, n);
 }
 
-function CK(e, t, n) {
+function WY(e, t, n) {
     n != null && e.style(t, n);
 }
 
-function ue(e, t, {
+function Gt(e, t, {
     x: n,
-    y: i
-}, r = He, s = He) {
-    r += t.dx, s += t.dy, n != null && n.bandwidth && (r += n.bandwidth() / 2), i != null && i.bandwidth && (s += i.bandwidth() / 2), (r || s) && e.attr("transform", `translate(${r},${s})`);
+    y: r
+}, i = Me, s = Me) {
+    i += t.dx, s += t.dy, n != null && n.bandwidth && (i += n.bandwidth() / 2), r != null && r.bandwidth && (s += r.bandwidth() / 2), (i || s) && e.attr("transform", `translate(${i},${s})`);
 }
 
-function Me(e, t) {
-    if ((e = tn(e)) !== t)
+function se(e, t) {
+    if ((e = Ee(e)) !== t)
         return e;
 }
 
-function $l(e, t) {
-    if ((e = qt(e)) !== t)
+function Ca(e, t) {
+    if ((e = Nt(e)) !== t)
         return e;
 }
-const kK = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
+const XY = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
 
-function Kw(e) {
+function Ng(e) {
     if (e === void 0)
         return "plot-d6a7b5";
-    if (e = `${e}`, !kK.test(e))
+    if (e = `${e}`, !XY.test(e))
         throw new Error(`invalid class name: ${e}`);
     return e;
 }
 
-function Zw(e, t) {
+function Dg(e, t) {
     if (typeof t == "string")
         e.property("style", t);
     else if (t != null)
         for (const n of e)
             Object.assign(n.style, t);
 }
 
-function _r({
+function Ir({
     frameAnchor: e
 }, {
     width: t,
     height: n,
-    marginTop: i,
-    marginRight: r,
+    marginTop: r,
+    marginRight: i,
     marginBottom: s,
     marginLeft: o
 }) {
     return [
-        /left$/.test(e) ? o : /right$/.test(e) ? t - r : (o + t - r) / 2,
-        /^top/.test(e) ? i : /^bottom/.test(e) ? n - s : (i + n - s) / 2
+        /left$/.test(e) ? o : /right$/.test(e) ? t - i : (o + t - i) / 2,
+        /^top/.test(e) ? r : /^bottom/.test(e) ? n - s : (r + n - s) / 2
     ];
 }
 
-function UK(e, t, n = {}) {
-    let i = 0.5 - He,
-        r = 0.5 + He,
-        s = 0.5 + He,
-        o = 0.5 - He;
+function GY(e, t, n = {}) {
+    let r = 0.5 - Me,
+        i = 0.5 + Me,
+        s = 0.5 + Me,
+        o = 0.5 - Me;
     for (const {
-            marginTop: m,
-            marginRight: g,
-            marginBottom: y,
+            marginTop: y,
+            marginRight: m,
+            marginBottom: g,
             marginLeft: b
         }
         of t)
-        m > i && (i = m), g > r && (r = g), y > s && (s = y), b > o && (o = b);
+        y > r && (r = y), m > i && (i = m), g > s && (s = g), b > o && (o = b);
     let {
         margin: a,
-        marginTop: c = a !== void 0 ? a : i,
-        marginRight: l = a !== void 0 ? a : r,
-        marginBottom: u = a !== void 0 ? a : s,
+        marginTop: c = a !== void 0 ? a : r,
+        marginRight: u = a !== void 0 ? a : i,
+        marginBottom: l = a !== void 0 ? a : s,
         marginLeft: f = a !== void 0 ? a : o
     } = n;
-    c = +c, l = +l, u = +u, f = +f;
+    c = +c, u = +u, l = +l, f = +f;
     let {
         width: h = 640,
-        height: d = zK(e, n, {
+        height: d = HY(e, n, {
             width: h,
-            marginTopDefault: i,
-            marginRightDefault: r,
+            marginTopDefault: r,
+            marginRightDefault: i,
             marginBottomDefault: s,
             marginLeftDefault: o
-        }) + Math.max(0, c - i + u - s)
+        }) + Math.max(0, c - r + l - s)
     } = n;
     h = +h, d = +d;
     const p = {
         width: h,
         height: d,
         marginTop: c,
-        marginRight: l,
-        marginBottom: u,
+        marginRight: u,
+        marginBottom: l,
         marginLeft: f
     };
     if (e.fx || e.fy) {
         let {
-            margin: m,
-            marginTop: g = m !== void 0 ? m : c,
-            marginRight: y = m !== void 0 ? m : l,
-            marginBottom: b = m !== void 0 ? m : u,
-            marginLeft: w = m !== void 0 ? m : f
+            margin: y,
+            marginTop: m = y !== void 0 ? y : c,
+            marginRight: g = y !== void 0 ? y : u,
+            marginBottom: b = y !== void 0 ? y : l,
+            marginLeft: w = y !== void 0 ? y : f
         } = n.facet ?? {};
-        g = +g, y = +y, b = +b, w = +w, p.facet = {
-            marginTop: g,
-            marginRight: y,
+        m = +m, g = +g, b = +b, w = +w, p.facet = {
+            marginTop: m,
+            marginRight: g,
             marginBottom: b,
             marginLeft: w
         };
     }
     return p;
 }
 
-function zK({
+function HY({
     x: e,
     y: t,
     fy: n,
-    fx: i
+    fx: r
 }, {
-    projection: r,
+    projection: i,
     aspectRatio: s
 }, {
     width: o,
     marginTopDefault: a,
     marginRightDefault: c,
-    marginBottomDefault: l,
-    marginLeftDefault: u
+    marginBottomDefault: u,
+    marginLeftDefault: l
 }) {
     const f = n ? n.scale.domain().length : 1,
-        h = EJ(r);
+        h = jV(i);
     if (h) {
-        const p = i ? i.scale.domain().length : 1,
-            m = (1.1 * f - 0.1) / (1.1 * p - 0.1) * h,
-            g = Math.max(0.1, Math.min(10, m));
-        return Math.round((o - u - c) * g + a + l);
+        const p = r ? r.scale.domain().length : 1,
+            y = (1.1 * f - 0.1) / (1.1 * p - 0.1) * h,
+            m = Math.max(0.1, Math.min(10, y));
+        return Math.round((o - l - c) * m + a + u);
     }
-    const d = t ? ua(t) ? t.scale.domain().length : Math.max(7, 17 / f) : 1;
+    const d = t ? qs(t) ? t.scale.domain().length : Math.max(7, 17 / f) : 1;
     if (s != null) {
         if (s = +s, !(isFinite(s) && s > 0))
             throw new Error(`invalid aspectRatio: ${s}`);
-        const p = aS("y", t) / (aS("x", e) * s),
-            m = i ? i.scale.bandwidth() : 1,
-            g = n ? n.scale.bandwidth() : 1,
-            y = m * (o - u - c) - e.insetLeft - e.insetRight;
-        return (p * y + t.insetTop + t.insetBottom) / g + a + l;
+        const p = S2("y", t) / (S2("x", e) * s),
+            y = r ? r.scale.bandwidth() : 1,
+            m = n ? n.scale.bandwidth() : 1,
+            g = y * (o - l - c) - e.insetLeft - e.insetRight;
+        return (p * g + t.insetTop + t.insetBottom) / m + a + u;
     }
-    return !!(t || n) * Math.max(1, Math.min(60, d * f)) * 20 + !!i * 30 + 60;
+    return !!(t || n) * Math.max(1, Math.min(60, d * f)) * 20 + !!r * 30 + 60;
 }
 
-function aS(e, t) {
+function S2(e, t) {
     if (!t)
         throw new Error(`aspectRatio requires ${e} scale`);
     const {
         type: n,
-        domain: i
+        domain: r
     } = t;
-    let r;
+    let i;
     switch (n) {
         case "linear":
         case "utc":
         case "time":
-            r = Number;
+            i = Number;
             break;
         case "pow": {
             const a = t.scale.exponent();
-            r = (c) => Math.pow(c, a);
+            i = (c) => Math.pow(c, a);
             break;
         }
         case "log":
-            r = Math.log;
+            i = Math.log;
             break;
         case "point":
         case "band":
-            return i.length;
+            return r.length;
         default:
             throw new Error(`unsupported ${e} scale for aspectRatio: ${n}`);
     }
-    const [s, o] = ke(i);
-    return Math.abs(r(o) - r(s));
+    const [s, o] = de(r);
+    return Math.abs(i(o) - i(s));
 }
 
-function PK(e, t) {
+function JY(e, t) {
     const {
         fx: n,
-        fy: i
-    } = N1(e, t), r = n == null ? void 0 : n.scale.domain(), s = i == null ? void 0 : i.scale.domain();
-    return r && s ? Bz(r, s).map(([o, a], c) => ({
+        fy: r
+    } = by(e, t), i = n == null ? void 0 : n.scale.domain(), s = r == null ? void 0 : r.scale.domain();
+    return i && s ? Uk(i, s).map(([o, a], c) => ({
         x: o,
         y: a,
         i: c
-    })) : r ? r.map((o, a) => ({
+    })) : i ? i.map((o, a) => ({
         x: o,
         i: a
     })) : s ? s.map((o, a) => ({
         y: o,
         i: a
     })) : void 0;
 }
 
-function VK(e, {
+function ZY(e, {
     x: t,
     y: n
 }) {
-    return t && (t = F1(t)), n && (n = F1(n)), e.filter(
-        t && n ? (i) => t.has(i.x) && n.has(i.y) : t ? (i) => t.has(i.x) : (i) => n.has(i.y)
+    return t && (t = _y(t)), n && (n = _y(n)), e.filter(
+        t && n ? (r) => t.has(r.x) && n.has(r.y) : t ? (r) => t.has(r.x) : (r) => n.has(r.y)
     ).sort(
-        t && n ? (i, r) => t.get(i.x) - t.get(r.x) || n.get(i.y) - n.get(r.y) : t ? (i, r) => t.get(i.x) - t.get(r.x) : (i, r) => n.get(i.y) - n.get(r.y)
+        t && n ? (r, i) => t.get(r.x) - t.get(i.x) || n.get(r.y) - n.get(i.y) : t ? (r, i) => t.get(r.x) - t.get(i.x) : (r, i) => n.get(r.y) - n.get(i.y)
     );
 }
 
-function Qw(e, {
+function Og(e, {
     fx: t,
     fy: n
 }) {
-    const i = fs(e),
-        r = t == null ? void 0 : t.value,
+    const r = ui(e),
+        i = t == null ? void 0 : t.value,
         s = n == null ? void 0 : n.value;
-    return t && n ? uc(
-        i,
-        (o) => (o.fx = r[o[0]], o.fy = s[o[0]], o),
-        (o) => r[o],
+    return t && n ? Io(
+        r,
+        (o) => (o.fx = i[o[0]], o.fy = s[o[0]], o),
+        (o) => i[o],
         (o) => s[o]
-    ) : t ? uc(
-        i,
-        (o) => (o.fx = r[o[0]], o),
-        (o) => r[o]
-    ) : uc(
-        i,
+    ) : t ? Io(
+        r,
+        (o) => (o.fx = i[o[0]], o),
+        (o) => i[o]
+    ) : Io(
+        r,
         (o) => (o.fy = s[o[0]], o),
         (o) => s[o]
     );
 }
 
-function jK(e, t, {
+function KY(e, t, {
     marginTop: n,
-    marginLeft: i
+    marginLeft: r
 }) {
     return e && t ? ({
-        x: r,
+        x: i,
         y: s
-    }) => `translate(${e(r) - i},${t(s) - n})` : e ? ({
-        x: r
-    }) => `translate(${e(r) - i},0)` : ({
-        y: r
-    }) => `translate(0,${t(r) - n})`;
+    }) => `translate(${e(i) - r},${t(s) - n})` : e ? ({
+        x: i
+    }) => `translate(${e(i) - r},0)` : ({
+        y: i
+    }) => `translate(0,${t(i) - n})`;
 }
 
-function qK(e) {
+function QY(e) {
     const t = [],
-        n = new Uint32Array(fr(e, (i) => i.length));
-    for (const i of e) {
-        let r = 0;
+        n = new Uint32Array(wr(e, (r) => r.length));
+    for (const r of e) {
+        let i = 0;
         for (const s of e)
-            i !== s && (n.set(s, r), r += s.length);
-        t.push(n.slice(0, r));
+            r !== s && (n.set(s, i), i += s.length);
+        t.push(n.slice(0, i));
     }
     return t;
 }
-const YK = /* @__PURE__ */ new Map([
-    ["top", qm],
-    ["right", Gm],
-    ["bottom", Ym],
-    ["left", Wm],
-    ["top-left", Ih(qm, Wm)],
-    ["top-right", Ih(qm, Gm)],
-    ["bottom-left", Ih(Ym, Wm)],
-    ["bottom-right", Ih(Ym, Gm)],
-    ["top-empty", XK],
-    ["right-empty", KK],
-    ["bottom-empty", HK],
-    ["left-empty", JK],
-    ["empty", ZK]
+const tW = /* @__PURE__ */ new Map([
+    ["top", Pp],
+    ["right", qp],
+    ["bottom", Up],
+    ["left", zp],
+    ["top-left", ul(Pp, zp)],
+    ["top-right", ul(Pp, qp)],
+    ["bottom-left", ul(Up, zp)],
+    ["bottom-right", ul(Up, qp)],
+    ["top-empty", rW],
+    ["right-empty", oW],
+    ["bottom-empty", iW],
+    ["left-empty", sW],
+    ["empty", aW]
 ]);
 
-function WK(e) {
+function eW(e) {
     if (e == null)
         return null;
-    const t = YK.get(`${e}`.toLowerCase());
+    const t = tW.get(`${e}`.toLowerCase());
     if (t)
         return t;
     throw new Error(`invalid facet anchor: ${e}`);
 }
-const cS = /* @__PURE__ */ new WeakMap();
+const M2 = /* @__PURE__ */ new WeakMap();
 
-function F1(e) {
-    let t = cS.get(e);
-    return t || cS.set(e, t = new Jo(ye(e, (n, i) => [n, i]))), t;
+function _y(e) {
+    let t = M2.get(e);
+    return t || M2.set(e, t = new Ts(Zt(e, (n, r) => [n, r]))), t;
 }
 
-function lo(e, t) {
-    return F1(e).get(t);
+function ts(e, t) {
+    return _y(e).get(t);
 }
 
-function GK(e, t, n) {
-    return t = Eo(t), n = Eo(n), e.find((i) => Object.is(Eo(i.x), t) && Object.is(Eo(i.y), n));
+function nW(e, t, n) {
+    return t = ys(t), n = ys(n), e.find((r) => Object.is(ys(r.x), t) && Object.is(ys(r.y), n));
 }
 
-function B0(e, t, n) {
-    var i;
-    return (i = GK(e, t, n)) == null ? void 0 : i.empty;
+function Id(e, t, n) {
+    var r;
+    return (r = nW(e, t, n)) == null ? void 0 : r.empty;
 }
 
-function qm(e, {
+function Pp(e, {
     y: t
 }, {
     y: n
 }) {
-    return t ? lo(t, n) === 0 : !0;
+    return t ? ts(t, n) === 0 : !0;
 }
 
-function Ym(e, {
+function Up(e, {
     y: t
 }, {
     y: n
 }) {
-    return t ? lo(t, n) === t.length - 1 : !0;
+    return t ? ts(t, n) === t.length - 1 : !0;
 }
 
-function Wm(e, {
+function zp(e, {
     x: t
 }, {
     x: n
 }) {
-    return t ? lo(t, n) === 0 : !0;
+    return t ? ts(t, n) === 0 : !0;
 }
 
-function Gm(e, {
+function qp(e, {
     x: t
 }, {
     x: n
 }) {
-    return t ? lo(t, n) === t.length - 1 : !0;
+    return t ? ts(t, n) === t.length - 1 : !0;
 }
 
-function XK(e, {
+function rW(e, {
     y: t
 }, {
     x: n,
-    y: i,
-    empty: r
+    y: r,
+    empty: i
 }) {
-    if (r)
+    if (i)
         return !1;
     if (!t)
         return;
-    const s = lo(t, i);
+    const s = ts(t, r);
     if (s > 0)
-        return B0(e, n, t[s - 1]);
+        return Id(e, n, t[s - 1]);
 }
 
-function HK(e, {
+function iW(e, {
     y: t
 }, {
     x: n,
-    y: i,
-    empty: r
+    y: r,
+    empty: i
 }) {
-    if (r)
+    if (i)
         return !1;
     if (!t)
         return;
-    const s = lo(t, i);
+    const s = ts(t, r);
     if (s < t.length - 1)
-        return B0(e, n, t[s + 1]);
+        return Id(e, n, t[s + 1]);
 }
 
-function JK(e, {
+function sW(e, {
     x: t
 }, {
     x: n,
-    y: i,
-    empty: r
+    y: r,
+    empty: i
 }) {
-    if (r)
+    if (i)
         return !1;
     if (!t)
         return;
-    const s = lo(t, n);
+    const s = ts(t, n);
     if (s > 0)
-        return B0(e, t[s - 1], i);
+        return Id(e, t[s - 1], r);
 }
 
-function KK(e, {
+function oW(e, {
     x: t
 }, {
     x: n,
-    y: i,
-    empty: r
+    y: r,
+    empty: i
 }) {
-    if (r)
+    if (i)
         return !1;
     if (!t)
         return;
-    const s = lo(t, n);
+    const s = ts(t, n);
     if (s < t.length - 1)
-        return B0(e, t[s + 1], i);
+        return Id(e, t[s + 1], r);
 }
 
-function ZK(e, t, {
+function aW(e, t, {
     empty: n
 }) {
     return n;
 }
 
-function Ih(e, t) {
+function ul(e, t) {
     return function() {
         return e.apply(null, arguments) && t.apply(null, arguments);
     };
 }
 
-function Xm(e, {
+function jp(e, {
     channels: {
         fx: t,
         fy: n
     },
-    groups: i
+    groups: r
 }) {
     return t && n ? e.map(({
-        x: r,
+        x: i,
         y: s
     }) => {
         var o;
-        return ((o = i.get(r)) == null ? void 0 : o.get(s)) ?? [];
+        return ((o = r.get(i)) == null ? void 0 : o.get(s)) ?? [];
     }) : t ? e.map(({
-        x: r
-    }) => i.get(r) ?? []) : e.map(({
-        y: r
-    }) => i.get(r) ?? []);
+        x: i
+    }) => r.get(i) ?? []) : e.map(({
+        y: i
+    }) => r.get(i) ?? []);
 }
-let fe = class {
-    constructor(t, n = {}, i = {}, r) {
+let Ht = class {
+    constructor(t, n = {}, r = {}, i) {
         const {
             facet: s = "auto",
             facetAnchor: o,
             fx: a,
             fy: c,
-            sort: l,
-            dx: u = 0,
+            sort: u,
+            dx: l = 0,
             dy: f = 0,
             margin: h = 0,
             marginTop: d = h,
             marginRight: p = h,
-            marginBottom: m = h,
-            marginLeft: g = h,
-            clip: y = r == null ? void 0 : r.clip,
+            marginBottom: y = h,
+            marginLeft: m = h,
+            clip: g = i == null ? void 0 : i.clip,
             channels: b,
             tip: w,
             render: v
-        } = i;
-        if (this.data = t, this.sort = Hs(l) ? l : null, this.initializer = Bn(i).initializer, this.transform = this.initializer ? i.transform : vr(i).transform, s === null || s === !1 ? this.facet = null : (this.facet = qn(s === !0 ? "include" : s, "facet", ["auto", "include", "exclude", "super"]), this.fx = t === yu && typeof a == "string" ? [a] : a, this.fy = t === yu && typeof c == "string" ? [c] : c), this.facetAnchor = WK(o), n = Nw(n), b !== void 0 && (n = {
-                ...QK(b),
+        } = r;
+        if (this.data = t, this.sort = qi(u) ? u : null, this.initializer = tn(r).initializer, this.transform = this.initializer ? r.transform : $r(r).transform, s === null || s === !1 ? this.facet = null : (this.facet = hn(s === !0 ? "include" : s, "facet", ["auto", "include", "exclude", "super"]), this.fx = t === hc && typeof a == "string" ? [a] : a, this.fy = t === hc && typeof c == "string" ? [c] : c), this.facetAnchor = eW(o), n = ug(n), b !== void 0 && (n = {
+                ...cW(b),
                 ...n
-            }), r !== void 0 && (n = {
-                ...i8(this, i, r),
+            }), i !== void 0 && (n = {
+                ...JA(this, r, i),
                 ...n
             }), this.channels = Object.fromEntries(
                 Object.entries(n).map(([x, _]) => {
-                    if (Hi(_.value)) {
+                    if (rr(_.value)) {
                         const {
-                            value: I,
-                            label: A = _.label,
-                            scale: M = _.scale
+                            value: M,
+                            label: T = _.label,
+                            scale: $ = _.scale
                         } = _.value;
                         _ = {
                             ..._,
-                            label: A,
-                            scale: M,
-                            value: I
+                            label: T,
+                            scale: $,
+                            value: M
                         };
                     }
-                    if (t === yu && typeof _.value == "string") {
+                    if (t === hc && typeof _.value == "string") {
                         const {
-                            value: I
+                            value: M
                         } = _;
                         _ = {
                             ..._,
-                            value: [I]
+                            value: [M]
                         };
                     }
                     return [x, _];
                 }).filter(([x, {
                     value: _,
-                    optional: I
+                    optional: M
                 }]) => {
                     if (_ != null)
                         return !0;
-                    if (I)
+                    if (M)
                         return !1;
                     throw new Error(`missing channel value: ${x}`);
                 })
-            ), this.dx = +u, this.dy = +f, this.marginTop = +d, this.marginRight = +p, this.marginBottom = +m, this.marginLeft = +g, this.clip = gD(y), this.tip = tZ(w), this.facet === "super") {
+            ), this.dx = +l, this.dy = +f, this.marginTop = +d, this.marginRight = +p, this.marginBottom = +y, this.marginLeft = +m, this.clip = lA(g), this.tip = uW(w), this.facet === "super") {
             if (a || c)
                 throw new Error("super-faceting cannot use fx or fy");
             for (const x in this.channels) {
                 const {
                     scale: _
                 } = n[x];
                 if (!(_ !== "x" && _ !== "y"))
                     throw new Error("super-faceting cannot use x or y");
             }
         }
-        v != null && (this.render = qp(v, this.render));
+        v != null && (this.render = mh(v, this.render));
     }
-    initialize(t, n, i) {
-        let r = Nn(this.data);
-        t === void 0 && r != null && (t = [fs(r)]);
+    initialize(t, n, r) {
+        let i = Qe(this.data);
+        t === void 0 && i != null && (t = [ui(i)]);
         const s = t;
         this.transform != null && ({
             facets: t,
-            data: r
-        } = this.transform(r, t, i), r = Nn(r)), t !== void 0 && (t.original = s);
-        const o = ND(this.channels, r);
-        return this.sort != null && AJ(r, t, o, n, this.sort), {
-            data: r,
+            data: i
+        } = this.transform(i, t, r), i = Qe(i)), t !== void 0 && (t.original = s);
+        const o = SA(this.channels, i);
+        return this.sort != null && kV(i, t, o, n, this.sort), {
+            data: i,
             facets: t,
             channels: o
         };
     }
-    filter(t, n, i) {
-        for (const r in n) {
+    filter(t, n, r) {
+        for (const i in n) {
             const {
-                filter: s = dn
-            } = n[r];
+                filter: s = Ce
+            } = n[i];
             if (s !== null) {
-                const o = i[r];
+                const o = r[i];
                 t = t.filter((a) => s(o[a]));
             }
         }
         return t;
     }
     // If there is a projection, and there are paired x and y channels associated
     // with the x and y scale respectively (and not already in screen coordinates
     // as with an initializer), then apply the projection, replacing the x and y
     // values. Note that the x and y scales themselves dont exist if there is a
     // projection, but whether the channels are associated with scales still
     // determines whether the projection should apply; think of the projection as
     // a combination xy-scale.
-    project(t, n, i) {
-        for (const r in t)
-            if (t[r].scale === "x" && /^x|x$/.test(r)) {
-                const s = r.replace(/^x|x$/, "y");
-                s in t && t[s].scale === "y" && CD(r, s, n, i.projection);
+    project(t, n, r) {
+        for (const i in t)
+            if (t[i].scale === "x" && /^x|x$/.test(i)) {
+                const s = i.replace(/^x|x$/, "y");
+                s in t && t[s].scale === "y" && NA(i, s, n, r.projection);
             }
     }
-    scale(t, n, i) {
-        const r = qw(t, n);
-        return i.projection && this.project(t, r, i), r;
+    scale(t, n, r) {
+        const i = Sg(t, n);
+        return r.projection && this.project(t, i, r), i;
     }
 };
 
-function ui(...e) {
-    return e.plot = fe.prototype.plot, e;
+function Tn(...e) {
+    return e.plot = Ht.prototype.plot, e;
 }
 
-function qp(e, t) {
+function mh(e, t) {
     if (e == null)
         return t === null ? void 0 : t;
     if (t == null)
         return e === null ? void 0 : e;
     if (typeof e != "function")
         throw new TypeError(`invalid render transform: ${e}`);
     if (typeof t != "function")
         throw new TypeError(`invalid render transform: ${t}`);
-    return function(n, i, r, s, o, a) {
-        return e.call(this, n, i, r, s, o, (c, l, u, f, h) => t.call(this, c, l, u, f, h, a));
+    return function(n, r, i, s, o, a) {
+        return e.call(this, n, r, i, s, o, (c, u, l, f, h) => t.call(this, c, u, l, f, h, a));
     };
 }
 
-function QK(e) {
+function cW(e) {
     return Object.fromEntries(
-        Object.entries(Nw(e)).map(([t, n]) => (n = typeof n == "string" ? {
+        Object.entries(ug(e)).map(([t, n]) => (n = typeof n == "string" ? {
             value: n,
             label: t
-        } : al(n), n.filter === void 0 && n.scale == null && (n = {
+        } : wa(n), n.filter === void 0 && n.scale == null && (n = {
             ...n,
             filter: null
         }), [t, n]))
     );
 }
 
-function tZ(e) {
-    return e === !0 ? "xy" : e === !1 || e == null ? null : typeof e == "string" ? qn(e, "tip", ["x", "y", "xy"]) : e;
+function uW(e) {
+    return e === !0 ? "xy" : e === !1 || e == null ? null : typeof e == "string" ? hn(e, "tip", ["x", "y", "xy"]) : e;
 }
 
-function fa(e, t) {
+function js(e, t) {
     return (e == null ? void 0 : e.tip) === !0 ? {
         ...e,
         tip: t
-    } : hi(e == null ? void 0 : e.tip) && e.tip.pointer === void 0 ? {
+    } : En(e == null ? void 0 : e.tip) && e.tip.pointer === void 0 ? {
         ...e,
         tip: {
             ...e.tip,
             pointer: t
         }
     } : e;
 }
-const lS = /* @__PURE__ */ new WeakMap();
+const A2 = /* @__PURE__ */ new WeakMap();
 
-function tv(e, t, {
+function Lg(e, t, {
     x: n,
-    y: i,
-    px: r,
+    y: r,
+    px: i,
     py: s,
     maxRadius: o = 40,
     channels: a,
     render: c,
-    ...l
+    ...u
 } = {}) {
-    return o = +o, r != null && (n ?? (n = null), a = {
+    return o = +o, i != null && (n ?? (n = null), a = {
         ...a,
         px: {
-            value: r,
+            value: i,
             scale: "x"
         }
-    }), s != null && (i ?? (i = null), a = {
+    }), s != null && (r ?? (r = null), a = {
         ...a,
         py: {
             value: s,
             scale: "y"
         }
     }), {
         x: n,
-        y: i,
+        y: r,
         channels: a,
-        ...l,
+        ...u,
         // Unlike other composed transforms, the render transform must be the
         // outermost render function because it will re-render dynamically in
         // response to pointer events.
-        render: qp(function(u, f, h, d, p, m) {
+        render: mh(function(l, f, h, d, p, y) {
             p = {
                 ...p,
                 pointerSticky: !1
             };
-            const g = p.ownerSVGElement,
+            const m = p.ownerSVGElement,
                 {
-                    data: y
+                    data: g
                 } = p.getMarkState(this);
-            let b = lS.get(g);
-            b || lS.set(g, b = {
+            let b = A2.get(m);
+            b || A2.set(m, b = {
                 sticky: !1,
                 roots: [],
                 renders: []
             });
-            let w = b.renders.push(G) - 1;
+            let w = b.renders.push(Y) - 1;
             const {
                 x: v,
                 y: x,
                 fx: _,
-                fy: I
+                fy: M
             } = f;
-            let A = _ ? _(u.fx) - d.marginLeft : 0,
-                M = I ? I(u.fy) - d.marginTop : 0;
-            v != null && v.bandwidth && (A += v.bandwidth() / 2), x != null && x.bandwidth && (M += x.bandwidth() / 2);
-            const N = u.fi != null;
-            let $;
+            let T = _ ? _(l.fx) - d.marginLeft : 0,
+                $ = M ? M(l.fy) - d.marginTop : 0;
+            v != null && v.bandwidth && (T += v.bandwidth() / 2), x != null && x.bandwidth && ($ += x.bandwidth() / 2);
+            const N = l.fi != null;
+            let A;
             if (N) {
-                let Y = b.facetStates;
-                Y || (b.facetStates = Y = /* @__PURE__ */ new Map()), $ = Y.get(this), $ || Y.set(this, $ = /* @__PURE__ */ new Map());
+                let V = b.facetStates;
+                V || (b.facetStates = V = /* @__PURE__ */ new Map()), A = V.get(this), A || V.set(this, A = /* @__PURE__ */ new Map());
             }
-            const [B, R] = _r(this, d), {
+            const [D, R] = Ir(this, d), {
                 px: S,
-                py: T
-            } = h, D = S ? (Y) => S[Y] : o8(h, B), L = T ? (Y) => T[Y] : a8(h, R);
-            let k, U, C, z;
+                py: I
+            } = h, E = S ? (V) => S[V] : QA(h, D), k = I ? (V) => I[V] : t$(h, R);
+            let B, C, F, P;
 
-            function P(Y, X) {
+            function U(V, W) {
                 if (N)
-                    if (z && (z = cancelAnimationFrame(z)), Y == null)
-                        $.delete(u.fi);
+                    if (P && (P = cancelAnimationFrame(P)), V == null)
+                        A.delete(l.fi);
                     else {
-                        $.set(u.fi, X), z = requestAnimationFrame(() => {
-                            z = null;
-                            for (const [j, J] of $)
-                                if (J < X || J === X && j < u.fi) {
-                                    Y = null;
+                        A.set(l.fi, W), P = requestAnimationFrame(() => {
+                            P = null;
+                            for (const [q, X] of A)
+                                if (X < W || X === W && q < l.fi) {
+                                    V = null;
                                     break;
                                 }
-                            G(Y);
+                            Y(V);
                         });
                         return;
                     }
-                G(Y);
+                Y(V);
             }
 
-            function G(Y) {
-                if (k === Y && C === b.sticky)
+            function Y(V) {
+                if (B === V && F === b.sticky)
                     return;
-                k = Y, C = p.pointerSticky = b.sticky;
-                const X = k == null ? [] : [k];
-                N && (X.fx = u.fx, X.fy = u.fy, X.fi = u.fi);
-                const j = m(X, f, h, d, p);
-                if (U) {
+                B = V, F = p.pointerSticky = b.sticky;
+                const W = B == null ? [] : [B];
+                N && (W.fx = l.fx, W.fy = l.fy, W.fi = l.fi);
+                const q = y(W, f, h, d, p);
+                if (C) {
                     if (N) {
-                        const J = U.parentNode,
-                            tt = U.getAttribute("transform"),
-                            V = j.getAttribute("transform");
-                        tt ? j.setAttribute("transform", tt) : j.removeAttribute("transform"), V ? J.setAttribute("transform", V) : J.removeAttribute("transform"), j.removeAttribute("aria-label"), j.removeAttribute("aria-description"), j.removeAttribute("aria-hidden");
+                        const X = C.parentNode,
+                            Z = C.getAttribute("transform"),
+                            z = q.getAttribute("transform");
+                        Z ? q.setAttribute("transform", Z) : q.removeAttribute("transform"), z ? X.setAttribute("transform", z) : X.removeAttribute("transform"), q.removeAttribute("aria-label"), q.removeAttribute("aria-description"), q.removeAttribute("aria-hidden");
                     }
-                    U.replaceWith(j);
+                    C.replaceWith(q);
                 }
-                return b.roots[w] = U = j, k == null && ($ == null ? void 0 : $.size) > 1 || p.dispatchValue(k == null ? null : y[k]), j;
+                return b.roots[w] = C = q, B == null && (A == null ? void 0 : A.size) > 1 || p.dispatchValue(B == null ? null : g[B]), q;
             }
 
-            function K(Y) {
-                if (b.sticky || Y.pointerType === "mouse" && Y.buttons === 1)
+            function G(V) {
+                if (b.sticky || V.pointerType === "mouse" && V.buttons === 1)
                     return;
-                let [X, j] = yi(Y);
-                X -= A, j -= M;
-                const J = X < d.marginLeft || X > d.width - d.marginRight ? 1 : e,
-                    tt = j < d.marginTop || j > d.height - d.marginBottom ? 1 : t;
-                let V = null,
-                    Ft = o * o;
-                for (const rt of u) {
-                    const Vt = J * (D(rt) - X),
-                        jt = tt * (L(rt) - j),
-                        Q = Vt * Vt + jt * jt;
-                    Q <= Ft && (V = rt, Ft = Q);
-                }
-                if (V != null && (e !== 1 || t !== 1)) {
-                    const rt = D(V) - X,
-                        Vt = L(V) - j;
-                    Ft = rt * rt + Vt * Vt;
-                }
-                P(V, Ft);
+                let [W, q] = On(V);
+                W -= T, q -= $;
+                const X = W < d.marginLeft || W > d.width - d.marginRight ? 1 : e,
+                    Z = q < d.marginTop || q > d.height - d.marginBottom ? 1 : t;
+                let z = null,
+                    wt = o * o;
+                for (const tt of l) {
+                    const It = X * (E(tt) - W),
+                        Et = Z * (k(tt) - q),
+                        J = It * It + Et * Et;
+                    J <= wt && (z = tt, wt = J);
+                }
+                if (z != null && (e !== 1 || t !== 1)) {
+                    const tt = E(z) - W,
+                        It = k(z) - q;
+                    wt = tt * tt + It * It;
+                }
+                U(z, wt);
             }
 
-            function et(Y) {
-                Y.pointerType === "mouse" && k != null && (b.sticky && b.roots.some((X) => X == null ? void 0 : X.contains(Y.target)) || (b.sticky ? (b.sticky = !1, b.renders.forEach((X) => X(null))) : (b.sticky = !0, G(k)), Y.stopImmediatePropagation()));
+            function K(V) {
+                V.pointerType === "mouse" && B != null && (b.sticky && b.roots.some((W) => W == null ? void 0 : W.contains(V.target)) || (b.sticky ? (b.sticky = !1, b.renders.forEach((W) => W(null))) : (b.sticky = !0, Y(B)), V.stopImmediatePropagation()));
             }
 
-            function Z(Y) {
-                Y.pointerType === "mouse" && (b.sticky || P(null));
+            function H(V) {
+                V.pointerType === "mouse" && (b.sticky || U(null));
             }
-            return g.addEventListener("pointerenter", K), g.addEventListener("pointermove", K), g.addEventListener("pointerdown", et), g.addEventListener("pointerleave", Z), G(null);
+            return m.addEventListener("pointerenter", G), m.addEventListener("pointermove", G), m.addEventListener("pointerdown", K), m.addEventListener("pointerleave", H), Y(null);
         }, c)
     };
 }
 
-function ev(e) {
-    return tv(1, 1, e);
+function Td(e) {
+    return Lg(1, 1, e);
 }
 
-function nv(e) {
-    return tv(1, 0.01, e);
+function Ed(e) {
+    return Lg(1, 0.01, e);
 }
 
-function Yp(e) {
-    return tv(0.01, 1, e);
+function Gc(e) {
+    return Lg(0.01, 1, e);
 }
 
-function o8({
+function QA({
     x1: e,
     x2: t,
     x: n = e
-}, i) {
-    return e && t ? (r) => (e[r] + t[r]) / 2 : n ? (r) => n[r] : () => i;
+}, r) {
+    return e && t ? (i) => (e[i] + t[i]) / 2 : n ? (i) => n[i] : () => r;
 }
 
-function a8({
+function t$({
     y1: e,
     y2: t,
     y: n = e
-}, i) {
-    return e && t ? (r) => (e[r] + t[r]) / 2 : n ? (r) => n[r] : () => i;
+}, r) {
+    return e && t ? (i) => (e[i] + t[i]) / 2 : n ? (i) => n[i] : () => r;
 }
 
-function c8(e) {
-    return ua(e) && e.interval === void 0 ? void 0 : "tabular-nums";
+function e$(e) {
+    return qs(e) && e.interval === void 0 ? void 0 : "tabular-nums";
 }
 
-function eZ(e, t) {
+function lW(e, t) {
     let {
         label: n = e.label,
-        tickSize: i = 6,
-        width: r = 240,
-        height: s = 44 + i,
+        tickSize: r = 6,
+        width: i = 240,
+        height: s = 44 + r,
         marginTop: o = 18,
         marginRight: a = 0,
-        marginBottom: c = 16 + i,
-        marginLeft: l = 0,
-        style: u,
-        ticks: f = (r - l - a) / 64,
+        marginBottom: c = 16 + r,
+        marginLeft: u = 0,
+        style: l,
+        ticks: f = (i - u - a) / 64,
         tickFormat: h,
-        fontVariant: d = c8(e),
+        fontVariant: d = e$(e),
         round: p = !0,
-        opacity: m,
-        className: g
+        opacity: y,
+        className: m
     } = t;
-    const y = $0(t);
-    g = Kw(g), m = Be(m)[1], h === null && (h = () => null);
-    const b = Gt("svg", y).attr("class", `${g}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", r).attr("height", s).attr("viewBox", `0 0 ${r} ${s}`).call(
-        (B) => (
+    const g = Sd(t);
+    m = Ng(m), y = ue(y)[1], h === null && (h = () => null);
+    const b = Ot("svg", g).attr("class", `${m}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", i).attr("height", s).attr("viewBox", `0 0 ${i} ${s}`).call(
+        (D) => (
             // Warning: if you edit this, change defaultClassName.
-            B.append("style").text(
-                `:where(.${g}-ramp) {
+            D.append("style").text(
+                `:where(.${m}-ramp) {
   display: block;
   height: auto;
   height: intrinsic;
   max-width: 100%;
   overflow: visible;
 }
-:where(.${g}-ramp text) {
+:where(.${m}-ramp text) {
   white-space: pre;
 }`
             )
         )
-    ).call(Zw, u);
-    let w = (B) => B.selectAll(".tick line").attr("y1", o + c - s),
+    ).call(Dg, l);
+    let w = (D) => D.selectAll(".tick line").attr("y1", o + c - s),
         v;
-    const x = p ? (B, R) => B.rangeRound(R) : (B, R) => B.range(R),
+    const x = p ? (D, R) => D.rangeRound(R) : (D, R) => D.range(R),
         {
             type: _,
-            domain: I,
-            range: A,
-            interpolate: M,
+            domain: M,
+            range: T,
+            interpolate: $,
             scale: N,
-            pivot: $
+            pivot: A
         } = e;
-    if (M) {
-        const B = A === void 0 ? M : t0(M.length === 1 ? Gw(M) : M, A);
+    if ($) {
+        const D = T === void 0 ? $ : Jh($.length === 1 ? $g($) : $, T);
         v = x(
             N.copy(),
-            $i(
-                Qe(l, r - a),
-                Math.min(I.length + ($ !== void 0), A === void 0 ? 1 / 0 : A.length)
+            jn(
+                Te(u, i - a),
+                Math.min(M.length + (A !== void 0), T === void 0 ? 1 / 0 : T.length)
             )
         );
         const R = 256,
-            S = y.document.createElement("canvas");
+            S = g.document.createElement("canvas");
         S.width = R, S.height = 1;
-        const T = S.getContext("2d");
-        for (let D = 0, L = R - 1; D < R; ++D)
-            T.fillStyle = B(D / L), T.fillRect(D, 0, 1, 1);
-        b.append("image").attr("opacity", m).attr("x", l).attr("y", o).attr("width", r - l - a).attr("height", s - o - c).attr("preserveAspectRatio", "none").attr("xlink:href", S.toDataURL());
+        const I = S.getContext("2d");
+        for (let E = 0, k = R - 1; E < R; ++E)
+            I.fillStyle = D(E / k), I.fillRect(E, 0, 1, 1);
+        b.append("image").attr("opacity", y).attr("x", u).attr("y", o).attr("width", i - u - a).attr("height", s - o - c).attr("preserveAspectRatio", "none").attr("xlink:href", S.toDataURL());
     } else if (_ === "threshold") {
-        const B = I,
-            R = h === void 0 ? (S) => S : typeof h == "string" ? rl(h) : h;
-        v = x(c0().domain([-1, A.length - 1]), [l, r - a]), b.append("g").attr("fill-opacity", m).selectAll().data(A).enter().append("rect").attr("x", (S, T) => v(T - 1)).attr("y", o).attr("width", (S, T) => v(T) - v(T - 1)).attr("height", s - o - c).attr("fill", (S) => S), f = ye(B, (S, T) => T), h = (S) => R(B[S], S);
+        const D = M,
+            R = h === void 0 ? (S) => S : typeof h == "string" ? ma(h) : h;
+        v = x(id().domain([-1, T.length - 1]), [u, i - a]), b.append("g").attr("fill-opacity", y).selectAll().data(T).enter().append("rect").attr("x", (S, I) => v(I - 1)).attr("y", o).attr("width", (S, I) => v(I) - v(I - 1)).attr("height", s - o - c).attr("fill", (S) => S), f = Zt(D, (S, I) => I), h = (S) => R(D[S], S);
     } else
-        v = x(o0().domain(I), [l, r - a]), b.append("g").attr("fill-opacity", m).selectAll().data(I).enter().append("rect").attr("x", v).attr("y", o).attr("width", Math.max(0, v.bandwidth() - 1)).attr("height", s - o - c).attr("fill", N), w = () => {};
+        v = x(nd().domain(M), [u, i - a]), b.append("g").attr("fill-opacity", y).selectAll().data(M).enter().append("rect").attr("x", v).attr("y", o).attr("width", Math.max(0, v.bandwidth() - 1)).attr("height", s - o - c).attr("fill", N), w = () => {};
     return b.append("g").attr("transform", `translate(0,${s - c})`).call(
-        Qz(v).ticks(Array.isArray(f) ? null : f, typeof h == "string" ? h : void 0).tickFormat(typeof h == "function" ? h : void 0).tickSize(i).tickValues(Array.isArray(f) ? f : null)
-    ).attr("font-size", null).attr("font-family", null).attr("font-variant", Me(d, "normal")).call(w).call((B) => B.select(".domain").remove()), n !== void 0 && b.append("text").attr("x", l).attr("y", o - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(n), b.node();
+        cR(v).ticks(Array.isArray(f) ? null : f, typeof h == "string" ? h : void 0).tickFormat(typeof h == "function" ? h : void 0).tickSize(r).tickValues(Array.isArray(f) ? f : null)
+    ).attr("font-size", null).attr("font-family", null).attr("font-variant", se(d, "normal")).call(w).call((D) => D.select(".domain").remove()), n !== void 0 && b.append("text").attr("x", u).attr("y", o - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(n), b.node();
 }
-const Wp = Math.PI / 180;
+const gh = Math.PI / 180;
 
-function cl(e, {
+function va(e, {
     marker: t,
     markerStart: n = t,
-    markerMid: i = t,
-    markerEnd: r = t
+    markerMid: r = t,
+    markerEnd: i = t
 } = {}) {
-    e.markerStart = Hm(n), e.markerMid = Hm(i), e.markerEnd = Hm(r);
+    e.markerStart = Vp(n), e.markerMid = Vp(r), e.markerEnd = Vp(i);
 }
 
-function Hm(e) {
+function Vp(e) {
     if (e == null || e === !1)
         return null;
     if (e === !0)
-        return fS;
+        return I2;
     if (typeof e == "function")
         return e;
     switch (`${e}`.toLowerCase()) {
         case "none":
             return null;
         case "arrow":
-            return uS("auto");
+            return $2("auto");
         case "arrow-reverse":
-            return uS("auto-start-reverse");
+            return $2("auto-start-reverse");
         case "dot":
-            return nZ;
+            return fW;
         case "circle":
         case "circle-fill":
-            return fS;
+            return I2;
         case "circle-stroke":
-            return iZ;
+            return hW;
         case "tick":
-            return Jm("auto");
+            return Yp("auto");
         case "tick-x":
-            return Jm(90);
+            return Yp(90);
         case "tick-y":
-            return Jm(0);
+            return Yp(0);
     }
     throw new Error(`invalid marker: ${e}`);
 }
 
-function uS(e) {
-    return (t, n) => Gt("svg:marker", n).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", e).attr("fill", "none").attr("stroke", t).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((i) => i.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
+function $2(e) {
+    return (t, n) => Ot("svg:marker", n).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", e).attr("fill", "none").attr("stroke", t).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((r) => r.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
 }
 
-function nZ(e, t) {
-    return Gt("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "none").call((n) => n.append("circle").attr("r", 2.5)).node();
+function fW(e, t) {
+    return Ot("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "none").call((n) => n.append("circle").attr("r", 2.5)).node();
 }
 
-function fS(e, t) {
-    return Gt("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
+function I2(e, t) {
+    return Ot("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", e).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
 }
 
-function iZ(e, t) {
-    return Gt("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", e).attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
+function hW(e, t) {
+    return Ot("svg:marker", t).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", e).attr("stroke-width", 1.5).call((n) => n.append("circle").attr("r", 3)).node();
 }
 
-function Jm(e) {
-    return (t, n) => Gt("svg:marker", n).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", e).attr("stroke", t).call((i) => i.append("path").attr("d", "M0,-3v6")).node();
+function Yp(e) {
+    return (t, n) => Ot("svg:marker", n).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", e).attr("stroke", t).call((r) => r.append("path").attr("d", "M0,-3v6")).node();
 }
-let rZ = 0;
+let dW = 0;
 
-function Vf(e, t, {
+function Du(e, t, {
     stroke: n
-}, i) {
-    return l8(e, t, n && ((r) => n[r]), i);
+}, r) {
+    return n$(e, t, n && ((i) => n[i]), r);
 }
 
-function sZ(e, t, {
+function pW(e, t, {
     stroke: n
-}, i) {
-    return l8(e, t, n && (([r]) => n[r]), i);
+}, r) {
+    return n$(e, t, n && (([i]) => n[i]), r);
 }
 
-function l8(e, {
+function n$(e, {
     markerStart: t,
     markerMid: n,
-    markerEnd: i,
-    stroke: r
-}, s = () => r, o) {
+    markerEnd: r,
+    stroke: i
+}, s = () => i, o) {
     const a = /* @__PURE__ */ new Map();
 
-    function c(l) {
-        return function(u) {
-            const f = s(u);
-            let h = a.get(l);
-            h || a.set(l, h = /* @__PURE__ */ new Map());
+    function c(u) {
+        return function(l) {
+            const f = s(l);
+            let h = a.get(u);
+            h || a.set(u, h = /* @__PURE__ */ new Map());
             let d = h.get(f);
             if (!d) {
-                const p = this.parentNode.insertBefore(l(f, o), this),
-                    m = `plot-marker-${++rZ}`;
-                p.setAttribute("id", m), h.set(f, d = `url(#${m})`);
+                const p = this.parentNode.insertBefore(u(f, o), this),
+                    y = `plot-marker-${++dW}`;
+                p.setAttribute("id", y), h.set(f, d = `url(#${y})`);
             }
             return d;
         };
     }
-    t && e.attr("marker-start", c(t)), n && e.attr("marker-mid", c(n)), i && e.attr("marker-end", c(i));
+    t && e.attr("marker-start", c(t)), n && e.attr("marker-mid", c(n)), r && e.attr("marker-end", c(r));
 }
 
-function jf({
+function Ou({
     inset: e,
     insetLeft: t,
     insetRight: n,
-    ...i
+    ...r
 } = {}) {
-    return [t, n] = u8(e, t, n), {
+    return [t, n] = r$(e, t, n), {
         inset: e,
         insetLeft: t,
         insetRight: n,
-        ...i
+        ...r
     };
 }
 
-function qf({
+function Lu({
     inset: e,
     insetTop: t,
     insetBottom: n,
-    ...i
+    ...r
 } = {}) {
-    return [t, n] = u8(e, t, n), {
+    return [t, n] = r$(e, t, n), {
         inset: e,
         insetTop: t,
         insetBottom: n,
-        ...i
+        ...r
     };
 }
 
-function u8(e, t, n) {
-    return e === void 0 && t === void 0 && n === void 0 ? He ? [1, 0] : [0.5, 0.5] : [t, n];
+function r$(e, t, n) {
+    return e === void 0 && t === void 0 && n === void 0 ? Me ? [1, 0] : [0.5, 0.5] : [t, n];
 }
 
-function f8(e, {
+function i$(e, {
     interval: t
 }) {
     return e = {
-        ...al(e)
-    }, e.interval = x0(e.interval === void 0 ? t : e.interval), e;
+        ...wa(e)
+    }, e.interval = bd(e.interval === void 0 ? t : e.interval), e;
 }
 
-function O0(e, t, n, i) {
+function Nd(e, t, n, r) {
     const {
-        [e]: r, [`${e}1`]: s, [`${e}2`]: o
+        [e]: i, [`${e}1`]: s, [`${e}2`]: o
     } = n, {
         value: a,
         interval: c
-    } = f8(r, n);
-    if (a == null || c == null && !i)
+    } = i$(i, n);
+    if (a == null || c == null && !r)
         return n;
-    const l = wr(r);
+    const u = Ar(i);
     if (c == null) {
         let d;
         const p = {
-            transform: (m) => d || (d = Pt(m, a)),
-            label: l
+            transform: (y) => d || (d = $t(y, a)),
+            label: u
         };
         return {
             ...n,
             [e]: void 0,
             [`${e}1`]: s === void 0 ? p : s,
-            [`${e}2`]: o === void 0 && !(s === o && i) ? p : o
+            [`${e}2`]: o === void 0 && !(s === o && r) ? p : o
         };
     }
-    let u, f;
+    let l, f;
 
     function h(d) {
-        return f !== void 0 && d === u ? f : f = ye(Pt(u = d, a), (p) => c.floor(p));
+        return f !== void 0 && d === l ? f : f = Zt($t(l = d, a), (p) => c.floor(p));
     }
     return t({
         ...n,
         [e]: void 0,
         [`${e}1`]: s === void 0 ? {
             transform: h,
-            label: l
+            label: u
         } : s,
         [`${e}2`]: o === void 0 ? {
             transform: (d) => h(d).map((p) => c.offset(p)),
-            label: l
+            label: u
         } : o
     });
 }
 
-function h8(e, t, n) {
+function s$(e, t, n) {
     const {
-        [e]: i
+        [e]: r
     } = n, {
-        value: r,
+        value: i,
         interval: s
-    } = f8(i, n);
-    return r == null || s == null ? n : t({
+    } = i$(r, n);
+    return i == null || s == null ? n : t({
         ...n,
         [e]: {
-            label: wr(i),
+            label: Ar(r),
             transform: (o) => {
-                const a = ye(Pt(o, r), (l) => s.floor(l)),
-                    c = a.map((l) => s.offset(l));
+                const a = Zt($t(o, i), (u) => s.floor(u)),
+                    c = a.map((u) => s.offset(u));
                 return a.map(
-                    gn(a) ? (l, u) => l == null || isNaN(l = +l) || (u = c[u], u == null) || isNaN(u = +u) ? void 0 : new Date((l + u) / 2) : (l, u) => l == null || (u = c[u], u == null) ? NaN : (+l + +u) / 2
+                    qe(a) ? (u, l) => u == null || isNaN(u = +u) || (l = c[l], l == null) || isNaN(l = +l) ? void 0 : new Date((u + l) / 2) : (u, l) => u == null || (l = c[l], l == null) ? NaN : (+u + +l) / 2
                 );
             }
         }
     });
 }
 
-function d8(e = {}) {
-    return O0("x", jf, e, !0);
+function o$(e = {}) {
+    return Nd("x", Ou, e, !0);
 }
 
-function p8(e = {}) {
-    return O0("y", qf, e, !0);
+function a$(e = {}) {
+    return Nd("y", Lu, e, !0);
 }
 
-function y8(e = {}) {
-    return O0("x", jf, e);
+function c$(e = {}) {
+    return Nd("x", Ou, e);
 }
 
-function m8(e = {}) {
-    return O0("y", qf, e);
+function u$(e = {}) {
+    return Nd("y", Lu, e);
 }
 
-function g8(e = {}) {
-    return h8("x", jf, e);
+function l$(e = {}) {
+    return s$("x", Ou, e);
 }
 
-function b8(e = {}) {
-    return h8("y", qf, e);
+function f$(e = {}) {
+    return s$("y", Lu, e);
 }
-const w8 = {
+const h$ = {
     ariaLabel: "rule",
     fill: null,
     stroke: "currentColor"
 };
-class v8 extends fe {
+class d$ extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y1: r,
+            x: r,
+            y1: i,
             y2: s,
             inset: o = 0,
             insetTop: a = o,
             insetBottom: c = o
         } = n;
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     optional: !0
                 },
                 y1: {
-                    value: r,
+                    value: i,
                     scale: "y",
                     optional: !0
                 },
                 y2: {
                     value: s,
                     scale: "y",
                     optional: !0
                 }
             },
-            fa(n, "x"),
-            w8
-        ), this.insetTop = qt(a), this.insetBottom = qt(c), cl(this, n);
+            js(n, "x"),
+            h$
+        ), this.insetTop = Nt(a), this.insetBottom = Nt(c), va(this, n);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y1: l,
-            y2: u
-        } = i, {
+            y1: u,
+            y2: l
+        } = r, {
             width: f,
             height: h,
             marginTop: d,
             marginRight: p,
-            marginLeft: m,
-            marginBottom: g
-        } = r, {
-            insetTop: y,
+            marginLeft: y,
+            marginBottom: m
+        } = i, {
+            insetTop: g,
             insetBottom: b
         } = this;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             x: c && o
-        }, He, 0).call(
-            (w) => w.selectAll().data(t).enter().append("line").call(be, this).attr("x1", c ? (v) => c[v] : (m + f - p) / 2).attr("x2", c ? (v) => c[v] : (m + f - p) / 2).attr("y1", l && !oi(a) ? (v) => l[v] + y : d + y).attr(
+        }, Me, 0).call(
+            (w) => w.selectAll().data(t).enter().append("line").call(Qt, this).attr("x1", c ? (v) => c[v] : (y + f - p) / 2).attr("x2", c ? (v) => c[v] : (y + f - p) / 2).attr("y1", u && !Mn(a) ? (v) => u[v] + g : d + g).attr(
                 "y2",
-                u && !oi(a) ? a.bandwidth ? (v) => u[v] + a.bandwidth() - b : (v) => u[v] - b : h - g - b
-            ).call(Pe, this, i).call(Vf, this, i, s)
+                l && !Mn(a) ? a.bandwidth ? (v) => l[v] + a.bandwidth() - b : (v) => l[v] - b : h - m - b
+            ).call(me, this, r).call(Du, this, r, s)
         ).node();
     }
 }
-class _8 extends fe {
+class p$ extends Ht {
     constructor(t, n = {}) {
         const {
-            x1: i,
-            x2: r,
+            x1: r,
+            x2: i,
             y: s,
             inset: o = 0,
             insetRight: a = o,
             insetLeft: c = o
         } = n;
         super(
             t, {
                 y: {
                     value: s,
                     scale: "y",
                     optional: !0
                 },
                 x1: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     optional: !0
                 },
                 x2: {
-                    value: r,
+                    value: i,
                     scale: "x",
                     optional: !0
                 }
             },
-            fa(n, "y"),
-            w8
-        ), this.insetRight = qt(a), this.insetLeft = qt(c), cl(this, n);
+            js(n, "y"),
+            h$
+        ), this.insetRight = Nt(a), this.insetLeft = Nt(c), va(this, n);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             y: c,
-            x1: l,
-            x2: u
-        } = i, {
+            x1: u,
+            x2: l
+        } = r, {
             width: f,
             height: h,
             marginTop: d,
             marginRight: p,
-            marginLeft: m,
-            marginBottom: g
-        } = r, {
-            insetLeft: y,
+            marginLeft: y,
+            marginBottom: m
+        } = i, {
+            insetLeft: g,
             insetRight: b
         } = this;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             y: c && a
-        }, 0, He).call(
-            (w) => w.selectAll().data(t).enter().append("line").call(be, this).attr("x1", l && !oi(o) ? (v) => l[v] + y : m + y).attr(
+        }, 0, Me).call(
+            (w) => w.selectAll().data(t).enter().append("line").call(Qt, this).attr("x1", u && !Mn(o) ? (v) => u[v] + g : y + g).attr(
                 "x2",
-                u && !oi(o) ? o.bandwidth ? (v) => u[v] + o.bandwidth() - b : (v) => u[v] - b : f - p - b
-            ).attr("y1", c ? (v) => c[v] : (d + h - g) / 2).attr("y2", c ? (v) => c[v] : (d + h - g) / 2).call(Pe, this, i).call(Vf, this, i, s)
+                l && !Mn(o) ? o.bandwidth ? (v) => l[v] + o.bandwidth() - b : (v) => l[v] - b : f - p - b
+            ).attr("y1", c ? (v) => c[v] : (d + h - m) / 2).attr("y2", c ? (v) => c[v] : (d + h - m) / 2).call(me, this, r).call(Du, this, r, s)
         ).node();
     }
 }
 
-function Js(e, t) {
+function ji(e, t) {
     let {
-        x: n = Tt,
-        y: i,
-        y1: r,
+        x: n = yt,
+        y: r,
+        y1: i,
         y2: s,
         ...o
-    } = m8(t);
-    return [r, s] = x8(i, r, s), new v8(e, {
+    } = u$(t);
+    return [i, s] = y$(r, i, s), new d$(e, {
         ...o,
         x: n,
-        y1: r,
+        y1: i,
         y2: s
     });
 }
 
-function Ks(e, t) {
+function Vi(e, t) {
     let {
-        y: n = Tt,
-        x: i,
-        x1: r,
+        y: n = yt,
+        x: r,
+        x1: i,
         x2: s,
         ...o
-    } = y8(t);
-    return [r, s] = x8(i, r, s), new _8(e, {
+    } = c$(t);
+    return [i, s] = y$(r, i, s), new p$(e, {
         ...o,
         y: n,
-        x1: r,
+        x1: i,
         x2: s
     });
 }
 
-function x8(e, t, n) {
+function y$(e, t, n) {
     if (e == null) {
         if (t === void 0) {
             if (n !== void 0)
                 return [0, n];
         } else if (n === void 0)
             return [0, t];
     } else {
@@ -27456,195 +28019,195 @@
             return n === void 0 ? [0, e] : [e, n];
         if (n === void 0)
             return [e, t];
     }
     return [t, n];
 }
 
-function F0(e, ...t) {
+function Dd(e, ...t) {
     let n = t.length;
-    for (let i = 0, r = !0; i < n; ++i)
-        typeof t[i] != "function" && (r && (e = e.slice(), r = !1), e.splice(i, 2, e[i] + t[i] + e[i + 1]), t.splice(i, 1), --i, --n);
-    return (i) => {
-        let r = e[0];
+    for (let r = 0, i = !0; r < n; ++r)
+        typeof t[r] != "function" && (i && (e = e.slice(), i = !1), e.splice(r, 2, e[r] + t[r] + e[r + 1]), t.splice(r, 1), --r, --n);
+    return (r) => {
+        let i = e[0];
         for (let s = 0; s < n; ++s)
-            r += t[s](i) + e[s + 1];
-        return r;
+            i += t[s](r) + e[s + 1];
+        return i;
     };
 }
-const oZ = {
+const yW = {
         ariaLabel: "text",
         strokeLinejoin: "round",
         strokeWidth: 3,
         paintOrder: "stroke"
     },
-    S8 = "";
-class E0 extends fe {
+    m$ = "";
+class Od extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
-            text: s = hs(t) && mD(t) ? Tt : vn,
+            x: r,
+            y: i,
+            text: s = li(t) && uA(t) ? yt : Ve,
             frameAnchor: o,
             textAnchor: a = /right$/i.test(o) ? "end" : /left$/i.test(o) ? "start" : "middle",
             lineAnchor: c = /^top/i.test(o) ? "top" : /^bottom/i.test(o) ? "bottom" : "middle",
-            lineHeight: l = 1,
-            lineWidth: u = 1 / 0,
+            lineHeight: u = 1,
+            lineWidth: l = 1 / 0,
             textOverflow: f,
             monospace: h,
             fontFamily: d = h ? "ui-monospace, monospace" : void 0,
             fontSize: p,
-            fontStyle: m,
-            fontVariant: g,
-            fontWeight: y,
+            fontStyle: y,
+            fontVariant: m,
+            fontWeight: g,
             rotate: b
-        } = n, [w, v] = Be(b, 0), [x, _] = uZ(p);
+        } = n, [w, v] = ue(b, 0), [x, _] = wW(p);
         if (super(
                 t, {
                     x: {
-                        value: i,
+                        value: r,
                         scale: "x",
                         optional: !0
                     },
                     y: {
-                        value: r,
+                        value: i,
                         scale: "y",
                         optional: !0
                     },
                     fontSize: {
                         value: x,
                         optional: !0
                     },
                     rotate: {
-                        value: HH(w),
+                        value: iV(w),
                         optional: !0
                     },
                     text: {
                         value: s,
-                        filter: vw,
+                        filter: tg,
                         optional: !0
                     }
                 },
                 n,
-                oZ
-            ), this.rotate = v, this.textAnchor = Me(a, "middle"), this.lineAnchor = qn(c, "lineAnchor", ["top", "middle", "bottom"]), this.lineHeight = +l, this.lineWidth = +u, this.textOverflow = I8(f), this.monospace = !!h, this.fontFamily = tn(d), this.fontSize = _, this.fontStyle = tn(m), this.fontVariant = tn(g), this.fontWeight = tn(y), this.frameAnchor = Rf(o), !(this.lineWidth >= 0))
-            throw new Error(`invalid lineWidth: ${u}`);
-        this.splitLines = T8(this), this.clipLine = D8(this);
+                yW
+            ), this.rotate = v, this.textAnchor = se(a, "middle"), this.lineAnchor = hn(c, "lineAnchor", ["top", "middle", "bottom"]), this.lineHeight = +u, this.lineWidth = +l, this.textOverflow = g$(f), this.monospace = !!h, this.fontFamily = Ee(d), this.fontSize = _, this.fontStyle = Ee(y), this.fontVariant = Ee(m), this.fontWeight = Ee(g), this.frameAnchor = Au(o), !(this.lineWidth >= 0))
+            throw new Error(`invalid lineWidth: ${l}`);
+        this.splitLines = _$(this), this.clipLine = x$(this);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y: l,
-            rotate: u,
+            y: u,
+            rotate: l,
             text: f,
             title: h,
             fontSize: d
-        } = i, {
+        } = r, {
             rotate: p
-        } = this, [m, g] = _r(this, r);
-        return Gt("svg:g", s).call(ve, this, r, s).call($8, this, f, r).call(ue, this, {
+        } = this, [y, m] = Ir(this, i);
+        return Ot("svg:g", s).call(ee, this, i, s).call(v$, this, f, i).call(Gt, this, {
             x: c && o,
-            y: l && a
+            y: u && a
         }).call(
-            (y) => y.selectAll().data(t).enter().append("text").call(be, this).call(aZ, this, f, h).attr(
+            (g) => g.selectAll().data(t).enter().append("text").call(Qt, this).call(mW, this, f, h).attr(
                 "transform",
-                F0`translate(${c ? (b) => c[b] : m},${l ? (b) => l[b] : g})${u ? (b) => ` rotate(${u[b]})` : p ? ` rotate(${p})` : ""}`
-            ).call(yt, "font-size", d && ((b) => d[b])).call(Pe, this, i)
+                Dd`translate(${c ? (b) => c[b] : y},${u ? (b) => u[b] : m})${l ? (b) => ` rotate(${l[b]})` : p ? ` rotate(${p})` : ""}`
+            ).call(at, "font-size", d && ((b) => d[b])).call(me, this, r)
         ).node();
     }
 }
 
-function I8(e) {
-    return e == null ? null : qn(e, "textOverflow", [
+function g$(e) {
+    return e == null ? null : hn(e, "textOverflow", [
         "clip",
         // shorthand for clip-end
         "ellipsis",
         //  ellipsis-end
         "clip-start",
         "clip-end",
         "ellipsis-start",
         "ellipsis-middle",
         "ellipsis-end"
     ]).replace(/^(clip|ellipsis)$/, "$1-end");
 }
 
-function aZ(e, t, n, i) {
+function mW(e, t, n, r) {
     if (!n)
         return;
     const {
-        lineAnchor: r,
+        lineAnchor: i,
         lineHeight: s,
         textOverflow: o,
         splitLines: a,
         clipLine: c
     } = t;
-    e.each(function(l) {
-        const u = a(ra(n[l]) ?? "").map(c),
-            f = u.length,
-            h = r === "top" ? 0.71 : r === "bottom" ? 1 - f : (164 - f * 100) / 200;
+    e.each(function(u) {
+        const l = a(Fs(n[u]) ?? "").map(c),
+            f = l.length,
+            h = i === "top" ? 0.71 : i === "bottom" ? 1 - f : (164 - f * 100) / 200;
         if (f > 1) {
             let d = 0;
             for (let p = 0; p < f; ++p) {
-                if (++d, !u[p])
+                if (++d, !l[p])
                     continue;
-                const m = this.ownerDocument.createElementNS(Ko.svg, "tspan");
-                m.setAttribute("x", 0), p === d - 1 ? m.setAttribute("y", `${(h + p) * s}em`) : m.setAttribute("dy", `${d * s}em`), m.textContent = u[p], this.appendChild(m), d = 0;
+                const y = this.ownerDocument.createElementNS(Es.svg, "tspan");
+                y.setAttribute("x", 0), p === d - 1 ? y.setAttribute("y", `${(h + p) * s}em`) : y.setAttribute("dy", `${d * s}em`), y.textContent = l[p], this.appendChild(y), d = 0;
             }
         } else
-            h && this.setAttribute("y", `${h * s}em`), this.textContent = u[0];
-        if (o && !i && u[0] !== n[l]) {
-            const d = this.ownerDocument.createElementNS(Ko.svg, "title");
-            d.textContent = n[l], this.appendChild(d);
+            h && this.setAttribute("y", `${h * s}em`), this.textContent = l[0];
+        if (o && !r && l[0] !== n[u]) {
+            const d = this.ownerDocument.createElementNS(Es.svg, "title");
+            d.textContent = n[u], this.appendChild(d);
         }
     });
 }
 
-function Pc(e, {
+function ra(e, {
     x: t,
     y: n,
-    ...i
+    ...r
 } = {}) {
-    return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new E0(e, {
-        ...i,
+    return r.frameAnchor === void 0 && ([t, n] = Jn(t, n)), new Od(e, {
+        ...r,
         x: t,
         y: n
     });
 }
 
-function A8(e, {
-    x: t = Tt,
+function b$(e, {
+    x: t = yt,
     ...n
 } = {}) {
-    return new E0(e, b8({
+    return new Od(e, f$({
         ...n,
         x: t
     }));
 }
 
-function M8(e, {
-    y: t = Tt,
+function w$(e, {
+    y: t = yt,
     ...n
 } = {}) {
-    return new E0(e, g8({
+    return new Od(e, l$({
         ...n,
         y: t
     }));
 }
 
-function $8(e, t, n) {
-    yt(e, "text-anchor", t.textAnchor), yt(e, "font-family", t.fontFamily), yt(e, "font-size", t.fontSize), yt(e, "font-style", t.fontStyle), yt(e, "font-variant", t.fontVariant === void 0 ? cZ(n) : t.fontVariant), yt(e, "font-weight", t.fontWeight);
+function v$(e, t, n) {
+    at(e, "text-anchor", t.textAnchor), at(e, "font-family", t.fontFamily), at(e, "font-size", t.fontSize), at(e, "font-style", t.fontStyle), at(e, "font-variant", t.fontVariant === void 0 ? gW(n) : t.fontVariant), at(e, "font-weight", t.fontWeight);
 }
 
-function cZ(e) {
-    return e && (nc(e) || gn(e)) ? "tabular-nums" : void 0;
+function gW(e) {
+    return e && (wo(e) || qe(e)) ? "tabular-nums" : void 0;
 }
-const lZ = /* @__PURE__ */ new Set([
+const bW = /* @__PURE__ */ new Set([
     // global keywords
     "inherit",
     "initial",
     "revert",
     "unset",
     // absolute keywords
     "xx-small",
@@ -27656,62 +28219,62 @@
     "xx-large",
     "xxx-large",
     // relative keywords
     "larger",
     "smaller"
 ]);
 
-function uZ(e) {
-    return e == null || typeof e == "number" ? [void 0, e] : typeof e != "string" ? [e, void 0] : (e = e.trim().toLowerCase(), lZ.has(e) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(e) ? [void 0, e] : [e, void 0]);
+function wW(e) {
+    return e == null || typeof e == "number" ? [void 0, e] : typeof e != "string" ? [e, void 0] : (e = e.trim().toLowerCase(), bW.has(e) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(e) ? [void 0, e] : [e, void 0]);
 }
 
-function fZ(e, t, n) {
-    const i = [];
-    let r, s = 0;
-    for (const [o, a, c] of hZ(e)) {
-        if (r === void 0 && (r = o), s > r && n(e, r, a) > t && (i.push(e.slice(r, s) + (e[s - 1] === S8 ? "-" : "")), r = o), c) {
-            i.push(e.slice(r, a)), r = void 0;
+function vW(e, t, n) {
+    const r = [];
+    let i, s = 0;
+    for (const [o, a, c] of _W(e)) {
+        if (i === void 0 && (i = o), s > i && n(e, i, a) > t && (r.push(e.slice(i, s) + (e[s - 1] === m$ ? "-" : "")), i = o), c) {
+            r.push(e.slice(i, a)), i = void 0;
             continue;
         }
         s = a;
     }
-    return i;
+    return r;
 }
 
-function* hZ(e) {
+function* _W(e) {
     let t = 0,
         n = 0;
-    const i = e.length;
-    for (; n < i;) {
-        let r = 1;
+    const r = e.length;
+    for (; n < r;) {
+        let i = 1;
         switch (e[n]) {
-            case S8:
+            case m$:
             case "-":
                 ++n, yield [t, n, !1], t = n;
                 break;
             case " ":
                 for (yield [t, n, !1]; e[++n] === " ";)
                 ;
                 t = n;
                 break;
             case "\r":
                 e[n + 1] === `
-` && ++r;
+` && ++i;
             case `
 `:
-                yield [t, n, !0], n += r, t = n;
+                yield [t, n, !0], n += i, t = n;
                 break;
             default:
                 ++n;
                 break;
         }
     }
     yield [t, n, !0];
 }
-const hS = {
+const T2 = {
     a: 56,
     b: 63,
     c: 57,
     d: 63,
     e: 58,
     f: 37,
     g: 62,
@@ -27786,1263 +28349,1263 @@
     "": 31,
     "": 31,
     "": 47,
     "": 47,
     "": 82
 };
 
-function iv(e, t = 0, n = e.length) {
-    let i = 0;
-    for (let r = t; r < n; r = ll(e, r))
-        i += hS[e[r]] ?? (B8(e, r) ? 120 : hS.e);
-    return i;
+function kg(e, t = 0, n = e.length) {
+    let r = 0;
+    for (let i = t; i < n; i = _a(e, i))
+        r += T2[e[i]] ?? (M$(e, i) ? 120 : T2.e);
+    return r;
 }
 
-function rv(e, t = 0, n = e.length) {
-    let i = 0;
-    for (let r = t; r < n; r = ll(e, r))
-        i += B8(e, r) ? 126 : 63;
-    return i;
+function Rg(e, t = 0, n = e.length) {
+    let r = 0;
+    for (let i = t; i < n; i = _a(e, i))
+        r += M$(e, i) ? 126 : 63;
+    return r;
 }
 
-function T8({
+function _$({
     monospace: e,
     lineWidth: t,
     textOverflow: n
 }) {
     if (n != null || t == 1 / 0)
         return (s) => s.split(/\r\n?|\n/g);
-    const i = e ? rv : iv,
-        r = t * 100;
-    return (s) => fZ(s, r, i);
+    const r = e ? Rg : kg,
+        i = t * 100;
+    return (s) => vW(s, i, r);
 }
 
-function D8({
+function x$({
     monospace: e,
     lineWidth: t,
     textOverflow: n
 }) {
     if (n == null || t == 1 / 0)
         return (s) => s;
-    const i = e ? rv : iv,
-        r = t * 100;
+    const r = e ? Rg : kg,
+        i = t * 100;
     switch (n) {
         case "clip-start":
-            return (s) => pS(s, r, i, "");
+            return (s) => N2(s, i, r, "");
         case "clip-end":
-            return (s) => dS(s, r, i, "");
+            return (s) => E2(s, i, r, "");
         case "ellipsis-start":
-            return (s) => pS(s, r, i, yc);
+            return (s) => N2(s, i, r, Oo);
         case "ellipsis-middle":
-            return (s) => dZ(s, r, i, yc);
+            return (s) => xW(s, i, r, Oo);
         case "ellipsis-end":
-            return (s) => dS(s, r, i, yc);
+            return (s) => E2(s, i, r, Oo);
     }
 }
-const yc = "";
+const Oo = "";
 
-function Vc(e, t, n, i) {
-    const r = [];
+function ia(e, t, n, r) {
+    const i = [];
     let s = 0;
     for (let o = 0, a = 0, c = e.length; o < c; o = a) {
-        a = ll(e, o);
-        const l = n(e, o, a);
-        if (s + l > t) {
-            for (s += i; s > t && o > 0;)
-                a = o, o = r.pop(), s -= n(e, o, a);
+        a = _a(e, o);
+        const u = n(e, o, a);
+        if (s + u > t) {
+            for (s += r; s > t && o > 0;)
+                a = o, o = i.pop(), s -= n(e, o, a);
             return [o, t - s];
         }
-        s += l, r.push(o);
+        s += u, i.push(o);
     }
     return [-1, 0];
 }
 
-function dS(e, t, n, i) {
+function E2(e, t, n, r) {
     e = e.trim();
-    const r = n(i),
-        [s] = Vc(e, t, n, r);
-    return s < 0 ? e : e.slice(0, s).trimEnd() + i;
+    const i = n(r),
+        [s] = ia(e, t, n, i);
+    return s < 0 ? e : e.slice(0, s).trimEnd() + r;
 }
 
-function dZ(e, t, n, i) {
+function xW(e, t, n, r) {
     e = e.trim();
-    const r = n(e);
-    if (r <= t)
+    const i = n(e);
+    if (i <= t)
         return e;
-    const s = n(i) / 2,
-        [o, a] = Vc(e, t / 2, n, s),
-        [c] = Vc(e, r - t / 2 - a + s, n, -s);
-    return c < 0 ? i : e.slice(0, o).trimEnd() + i + e.slice(ll(e, c)).trimStart();
+    const s = n(r) / 2,
+        [o, a] = ia(e, t / 2, n, s),
+        [c] = ia(e, i - t / 2 - a + s, n, -s);
+    return c < 0 ? r : e.slice(0, o).trimEnd() + r + e.slice(_a(e, c)).trimStart();
 }
 
-function pS(e, t, n, i) {
+function N2(e, t, n, r) {
     e = e.trim();
-    const r = n(e);
-    if (r <= t)
+    const i = n(e);
+    if (i <= t)
         return e;
-    const s = n(i),
-        [o] = Vc(e, r - t + s, n, -s);
-    return o < 0 ? i : i + e.slice(ll(e, o)).trimStart();
+    const s = n(r),
+        [o] = ia(e, i - t + s, n, -s);
+    return o < 0 ? r : r + e.slice(_a(e, o)).trimStart();
 }
-const E1 = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy,
-    yS = new RegExp("\\p{Extended_Pictographic}", "uy");
+const xy = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy,
+    D2 = new RegExp("\\p{Extended_Pictographic}", "uy");
 
-function ll(e, t) {
-    return t += pZ(e, t) ? 2 : 1, mZ(e, t) && (t = E1.lastIndex), yZ(e, t) ? ll(e, t + 1) : t;
+function _a(e, t) {
+    return t += SW(e, t) ? 2 : 1, AW(e, t) && (t = xy.lastIndex), MW(e, t) ? _a(e, t + 1) : t;
 }
 
-function N8(e, t) {
+function S$(e, t) {
     return e.charCodeAt(t) < 128;
 }
 
-function pZ(e, t) {
+function SW(e, t) {
     const n = e.charCodeAt(t);
     if (n >= 55296 && n < 56320) {
-        const i = e.charCodeAt(t + 1);
-        return i >= 56320 && i < 57344;
+        const r = e.charCodeAt(t + 1);
+        return r >= 56320 && r < 57344;
     }
     return !1;
 }
 
-function yZ(e, t) {
+function MW(e, t) {
     return e.charCodeAt(t) === 8205;
 }
 
-function mZ(e, t) {
-    return N8(e, t) ? !1 : (E1.lastIndex = t, E1.test(e));
+function AW(e, t) {
+    return S$(e, t) ? !1 : (xy.lastIndex = t, xy.test(e));
 }
 
-function B8(e, t) {
-    return N8(e, t) ? !1 : (yS.lastIndex = t, yS.test(e));
+function M$(e, t) {
+    return S$(e, t) ? !1 : (D2.lastIndex = t, D2.test(e));
 }
-const O8 = {
+const A$ = {
         ariaLabel: "vector",
         fill: "none",
         stroke: "currentColor",
         strokeWidth: 1.5,
         strokeLinejoin: "round",
         strokeLinecap: "round"
     },
-    F8 = 3.5,
-    gZ = F8 * 5,
-    E8 = {
+    $$ = 3.5,
+    $W = $$ * 5,
+    I$ = {
         draw(e, t, n) {
-            const i = t * n / gZ;
-            e.moveTo(0, 0), e.lineTo(0, -t), e.moveTo(-i, i - t), e.lineTo(0, -t), e.lineTo(i, i - t);
+            const r = t * n / $W;
+            e.moveTo(0, 0), e.lineTo(0, -t), e.moveTo(-r, r - t), e.lineTo(0, -t), e.lineTo(r, r - t);
         }
     },
-    L8 = {
+    T$ = {
         draw(e, t, n) {
             e.moveTo(-n, 0), e.lineTo(0, -t), e.lineTo(n, 0);
         }
     },
-    bZ = /* @__PURE__ */ new Map([
-        ["arrow", E8],
-        ["spike", L8]
+    IW = /* @__PURE__ */ new Map([
+        ["arrow", I$],
+        ["spike", T$]
     ]);
 
-function wZ(e) {
+function TW(e) {
     return e && typeof e.draw == "function";
 }
 
-function vZ(e) {
-    if (wZ(e))
+function EW(e) {
+    if (TW(e))
         return e;
-    const t = bZ.get(`${e}`.toLowerCase());
+    const t = IW.get(`${e}`.toLowerCase());
     if (t)
         return t;
     throw new Error(`invalid shape: ${e}`);
 }
-let L0 = class extends fe {
+class Ld extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
-            r: s = F8,
+            x: r,
+            y: i,
+            r: s = $$,
             length: o,
             rotate: a,
-            shape: c = E8,
-            anchor: l = "middle",
-            frameAnchor: u
-        } = n, [f, h] = Be(o, 12), [d, p] = Be(a, 0);
+            shape: c = I$,
+            anchor: u = "middle",
+            frameAnchor: l
+        } = n, [f, h] = ue(o, 12), [d, p] = ue(a, 0);
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     optional: !0
                 },
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y",
                     optional: !0
                 },
                 length: {
                     value: f,
                     scale: "length",
                     optional: !0
                 },
                 rotate: {
                     value: d,
                     optional: !0
                 }
             },
             n,
-            O8
-        ), this.r = +s, this.length = h, this.rotate = p, this.shape = vZ(c), this.anchor = qn(l, "anchor", ["start", "middle", "end"]), this.frameAnchor = Rf(u);
+            A$
+        ), this.r = +s, this.length = h, this.rotate = p, this.shape = EW(c), this.anchor = hn(u, "anchor", ["start", "middle", "end"]), this.frameAnchor = Au(l);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y: l,
-            length: u,
+            y: u,
+            length: l,
             rotate: f
-        } = i, {
+        } = r, {
             length: h,
             rotate: d,
             anchor: p,
-            shape: m,
-            r: g
-        } = this, [y, b] = _r(this, r);
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+            shape: y,
+            r: m
+        } = this, [g, b] = Ir(this, i);
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             x: c && o,
-            y: l && a
+            y: u && a
         }).call(
-            (w) => w.selectAll().data(t).enter().append("path").call(be, this).attr(
+            (w) => w.selectAll().data(t).enter().append("path").call(Qt, this).attr(
                 "transform",
-                F0`translate(${c ? (v) => c[v] : y},${l ? (v) => l[v] : b})${f ? (v) => ` rotate(${f[v]})` : d ? ` rotate(${d})` : ""}${p === "start" ? "" : p === "end" ? u ? (v) => ` translate(0,${u[v]})` : ` translate(0,${h})` : u ? (v) => ` translate(0,${u[v] / 2})` : ` translate(0,${h / 2})`}`
+                Dd`translate(${c ? (v) => c[v] : g},${u ? (v) => u[v] : b})${f ? (v) => ` rotate(${f[v]})` : d ? ` rotate(${d})` : ""}${p === "start" ? "" : p === "end" ? l ? (v) => ` translate(0,${l[v]})` : ` translate(0,${h})` : l ? (v) => ` translate(0,${l[v] / 2})` : ` translate(0,${h / 2})`}`
             ).attr(
                 "d",
-                u ? (v) => {
-                    const x = Xr();
-                    return m.draw(x, u[v], g), x;
+                l ? (v) => {
+                    const x = Gr();
+                    return y.draw(x, l[v], m), x;
                 } : (() => {
-                    const v = Xr();
-                    return m.draw(v, h, g), v;
+                    const v = Gr();
+                    return y.draw(v, h, m), v;
                 })()
-            ).call(Pe, this, i)
+            ).call(me, this, r)
         ).node();
     }
-};
+}
 
-function R8(e, t = {}) {
+function E$(e, t = {}) {
     let {
         x: n,
-        y: i,
-        ...r
+        y: r,
+        ...i
     } = t;
-    return t.frameAnchor === void 0 && ([n, i] = ki(n, i)), new L0(e, {
-        ...r,
+    return t.frameAnchor === void 0 && ([n, r] = Jn(n, r)), new Ld(e, {
+        ...i,
         x: n,
-        y: i
+        y: r
     });
 }
 
-function C8(e, t = {}) {
+function N$(e, t = {}) {
     const {
-        x: n = Tt,
-        ...i
+        x: n = yt,
+        ...r
     } = t;
-    return new L0(e, {
-        ...i,
+    return new Ld(e, {
+        ...r,
         x: n
     });
 }
 
-function k8(e, t = {}) {
+function D$(e, t = {}) {
     const {
-        y: n = Tt,
-        ...i
+        y: n = yt,
+        ...r
     } = t;
-    return new L0(e, {
-        ...i,
+    return new Ld(e, {
+        ...r,
         y: n
     });
 }
 
-function _Z(e, t = {}) {
+function NW(e, t = {}) {
     const {
-        shape: n = L8,
-        stroke: i = O8.stroke,
-        strokeWidth: r = 1,
-        fill: s = i,
+        shape: n = T$,
+        stroke: r = A$.stroke,
+        strokeWidth: i = 1,
+        fill: s = r,
         fillOpacity: o = 0.3,
         anchor: a = "start",
         ...c
     } = t;
-    return R8(e, {
+    return E$(e, {
         ...c,
         shape: n,
-        stroke: i,
-        strokeWidth: r,
+        stroke: r,
+        strokeWidth: i,
         fill: s,
         fillOpacity: o,
         anchor: a
     });
 }
 
-function uo(e, t) {
-    return arguments.length < 2 && !hs(e) && (t = e, e = null), t === void 0 && (t = {}), [e, t];
+function es(e, t) {
+    return arguments.length < 2 && !li(e) && (t = e, e = null), t === void 0 && (t = {}), [e, t];
 }
 
-function R0({
+function kd({
     anchor: e
 } = {}, t) {
-    return e === void 0 ? t[0] : qn(e, "anchor", t);
+    return e === void 0 ? t[0] : hn(e, "anchor", t);
 }
 
-function U8(e) {
-    return R0(e, ["left", "right"]);
+function O$(e) {
+    return kd(e, ["left", "right"]);
 }
 
-function z8(e) {
-    return R0(e, ["right", "left"]);
+function L$(e) {
+    return kd(e, ["right", "left"]);
 }
 
-function P8(e) {
-    return R0(e, ["bottom", "top"]);
+function k$(e) {
+    return kd(e, ["bottom", "top"]);
 }
 
-function V8(e) {
-    return R0(e, ["top", "bottom"]);
+function R$(e) {
+    return kd(e, ["top", "bottom"]);
 }
 
-function sv() {
-    const [e, t] = uo(...arguments);
-    return Y8("y", U8(t), e, t);
+function Fg() {
+    const [e, t] = es(...arguments);
+    return C$("y", O$(t), e, t);
 }
 
-function j8() {
-    const [e, t] = uo(...arguments);
-    return Y8("fy", z8(t), e, t);
+function F$() {
+    const [e, t] = es(...arguments);
+    return C$("fy", L$(t), e, t);
 }
 
-function ov() {
-    const [e, t] = uo(...arguments);
-    return W8("x", P8(t), e, t);
+function Bg() {
+    const [e, t] = es(...arguments);
+    return P$("x", k$(t), e, t);
 }
 
-function q8() {
-    const [e, t] = uo(...arguments);
-    return W8("fx", V8(t), e, t);
+function B$() {
+    const [e, t] = es(...arguments);
+    return P$("fx", R$(t), e, t);
 }
 
-function Y8(e, t, n, {
-    color: i = "currentColor",
-    opacity: r = 1,
-    stroke: s = i,
-    strokeOpacity: o = r,
+function C$(e, t, n, {
+    color: r = "currentColor",
+    opacity: i = 1,
+    stroke: s = r,
+    strokeOpacity: o = i,
     strokeWidth: a = 1,
-    fill: c = i,
-    fillOpacity: l = r,
-    textAnchor: u,
+    fill: c = r,
+    fillOpacity: u = i,
+    textAnchor: l,
     textStroke: f,
     textStrokeOpacity: h,
     textStrokeWidth: d,
     tickSize: p = e === "y" ? 6 : 0,
-    tickPadding: m,
-    tickRotate: g,
-    x: y,
+    tickPadding: y,
+    tickRotate: m,
+    x: g,
     margin: b,
     marginTop: w = b === void 0 ? 20 : b,
     marginRight: v = b === void 0 ? t === "right" ? 40 : 0 : b,
     marginBottom: x = b === void 0 ? 20 : b,
     marginLeft: _ = b === void 0 ? t === "left" ? 40 : 0 : b,
-    label: I,
-    labelAnchor: A,
-    labelArrow: M,
+    label: M,
+    labelAnchor: T,
+    labelArrow: $,
     labelOffset: N,
-    ...$
+    ...A
 }) {
-    return p = qt(p), m = qt(m), g = qt(g), A !== void 0 && (A = qn(A, "labelAnchor", ["center", "top", "bottom"])), M = r4(M), ui(
-        p && !we(s) ? xZ(e, t, n, {
+    return p = Nt(p), y = Nt(y), m = Nt(m), T !== void 0 && (T = hn(T, "labelAnchor", ["center", "top", "bottom"])), $ = Z$($), Tn(
+        p && !te(s) ? DW(e, t, n, {
             stroke: s,
             strokeOpacity: o,
             strokeWidth: a,
             tickSize: p,
-            tickPadding: m,
-            tickRotate: g,
-            x: y,
-            ...$
+            tickPadding: y,
+            tickRotate: m,
+            x: g,
+            ...A
         }) : null,
-        we(c) ? null : IZ(e, t, n, {
+        te(c) ? null : LW(e, t, n, {
             fill: c,
-            fillOpacity: l,
+            fillOpacity: u,
             stroke: f,
             strokeOpacity: h,
             strokeWidth: d,
-            textAnchor: u,
+            textAnchor: l,
             tickSize: p,
-            tickPadding: m,
-            tickRotate: g,
-            x: y,
+            tickPadding: y,
+            tickRotate: m,
+            x: g,
             marginTop: w,
             marginRight: v,
             marginBottom: x,
             marginLeft: _,
-            ...$
+            ...A
         }),
-        !we(c) && I !== null ? Pc(
+        !te(c) && M !== null ? ra(
             [],
-            t4({
+            X$({
                 fill: c,
-                fillOpacity: l,
-                ...$
-            }, function(B, R, S, T, D) {
-                const L = T[e],
+                fillOpacity: u,
+                ...A
+            }, function(D, R, S, I, E) {
+                const k = I[e],
                     {
-                        marginTop: k,
-                        marginRight: U,
-                        marginBottom: C,
-                        marginLeft: z
-                    } = e === "y" && D.inset || D,
-                    P = A ?? (L.bandwidth ? "center" : "top"),
-                    G = N ?? (t === "right" ? U : z) - 3;
-                return P === "center" ? (this.textAnchor = void 0, this.lineAnchor = t === "right" ? "bottom" : "top", this.frameAnchor = t, this.rotate = -90) : (this.textAnchor = t === "right" ? "end" : "start", this.lineAnchor = P, this.frameAnchor = `${P}-${t}`, this.rotate = 0), this.dy = P === "top" ? 3 - k : P === "bottom" ? C - 3 : 0, this.dx = t === "right" ? G : -G, this.ariaLabel = `${e}-axis label`, {
+                        marginTop: B,
+                        marginRight: C,
+                        marginBottom: F,
+                        marginLeft: P
+                    } = e === "y" && E.inset || E,
+                    U = T ?? (k.bandwidth ? "center" : "top"),
+                    Y = N ?? (t === "right" ? C : P) - 3;
+                return U === "center" ? (this.textAnchor = void 0, this.lineAnchor = t === "right" ? "bottom" : "top", this.frameAnchor = t, this.rotate = -90) : (this.textAnchor = t === "right" ? "end" : "start", this.lineAnchor = U, this.frameAnchor = `${U}-${t}`, this.rotate = 0), this.dy = U === "top" ? 3 - B : U === "bottom" ? F - 3 : 0, this.dx = t === "right" ? Y : -Y, this.ariaLabel = `${e}-axis label`, {
                     facets: [
                         [0]
                     ],
                     channels: {
                         text: {
-                            value: [i4(e, L, {
+                            value: [J$(e, k, {
                                 anchor: t,
-                                label: I,
-                                labelAnchor: P,
-                                labelArrow: M
+                                label: M,
+                                labelAnchor: U,
+                                labelArrow: $
                             })]
                         }
                     }
                 };
             })
         ) : null
     );
 }
 
-function W8(e, t, n, {
-    color: i = "currentColor",
-    opacity: r = 1,
-    stroke: s = i,
-    strokeOpacity: o = r,
+function P$(e, t, n, {
+    color: r = "currentColor",
+    opacity: i = 1,
+    stroke: s = r,
+    strokeOpacity: o = i,
     strokeWidth: a = 1,
-    fill: c = i,
-    fillOpacity: l = r,
-    textAnchor: u,
+    fill: c = r,
+    fillOpacity: u = i,
+    textAnchor: l,
     textStroke: f,
     textStrokeOpacity: h,
     textStrokeWidth: d,
     tickSize: p = e === "x" ? 6 : 0,
-    tickPadding: m,
-    tickRotate: g,
-    y,
+    tickPadding: y,
+    tickRotate: m,
+    y: g,
     margin: b,
     marginTop: w = b === void 0 ? t === "top" ? 30 : 0 : b,
     marginRight: v = b === void 0 ? 20 : b,
     marginBottom: x = b === void 0 ? t === "bottom" ? 30 : 0 : b,
     marginLeft: _ = b === void 0 ? 20 : b,
-    label: I,
-    labelAnchor: A,
-    labelArrow: M,
+    label: M,
+    labelAnchor: T,
+    labelArrow: $,
     labelOffset: N,
-    ...$
+    ...A
 }) {
-    return p = qt(p), m = qt(m), g = qt(g), A !== void 0 && (A = qn(A, "labelAnchor", ["center", "left", "right"])), M = r4(M), ui(
-        p && !we(s) ? SZ(e, t, n, {
+    return p = Nt(p), y = Nt(y), m = Nt(m), T !== void 0 && (T = hn(T, "labelAnchor", ["center", "left", "right"])), $ = Z$($), Tn(
+        p && !te(s) ? OW(e, t, n, {
             stroke: s,
             strokeOpacity: o,
             strokeWidth: a,
             tickSize: p,
-            tickPadding: m,
-            tickRotate: g,
-            y,
-            ...$
+            tickPadding: y,
+            tickRotate: m,
+            y: g,
+            ...A
         }) : null,
-        we(c) ? null : AZ(e, t, n, {
+        te(c) ? null : kW(e, t, n, {
             fill: c,
-            fillOpacity: l,
+            fillOpacity: u,
             stroke: f,
             strokeOpacity: h,
             strokeWidth: d,
-            textAnchor: u,
+            textAnchor: l,
             tickSize: p,
-            tickPadding: m,
-            tickRotate: g,
-            y,
+            tickPadding: y,
+            tickRotate: m,
+            y: g,
             marginTop: w,
             marginRight: v,
             marginBottom: x,
             marginLeft: _,
-            ...$
+            ...A
         }),
-        !we(c) && I !== null ? Pc(
+        !te(c) && M !== null ? ra(
             [],
-            t4({
+            X$({
                 fill: c,
-                fillOpacity: l,
-                ...$
-            }, function(B, R, S, T, D) {
-                const L = T[e],
+                fillOpacity: u,
+                ...A
+            }, function(D, R, S, I, E) {
+                const k = I[e],
                     {
-                        marginTop: k,
-                        marginRight: U,
-                        marginBottom: C,
-                        marginLeft: z
-                    } = e === "x" && D.inset || D,
-                    P = A ?? (L.bandwidth ? "center" : "right"),
-                    G = N ?? (t === "top" ? k : C) - 3;
-                return P === "center" ? (this.frameAnchor = t, this.textAnchor = void 0) : (this.frameAnchor = `${t}-${P}`, this.textAnchor = P === "right" ? "end" : "start"), this.lineAnchor = t, this.dy = t === "top" ? -G : G, this.dx = P === "right" ? U - 3 : P === "left" ? 3 - z : 0, this.ariaLabel = `${e}-axis label`, {
+                        marginTop: B,
+                        marginRight: C,
+                        marginBottom: F,
+                        marginLeft: P
+                    } = e === "x" && E.inset || E,
+                    U = T ?? (k.bandwidth ? "center" : "right"),
+                    Y = N ?? (t === "top" ? B : F) - 3;
+                return U === "center" ? (this.frameAnchor = t, this.textAnchor = void 0) : (this.frameAnchor = `${t}-${U}`, this.textAnchor = U === "right" ? "end" : "start"), this.lineAnchor = t, this.dy = t === "top" ? -Y : Y, this.dx = U === "right" ? C - 3 : U === "left" ? 3 - P : 0, this.ariaLabel = `${e}-axis label`, {
                     facets: [
                         [0]
                     ],
                     channels: {
                         text: {
-                            value: [i4(e, L, {
+                            value: [J$(e, k, {
                                 anchor: t,
-                                label: I,
-                                labelAnchor: P,
-                                labelArrow: M
+                                label: M,
+                                labelAnchor: U,
+                                labelArrow: $
                             })]
                         }
                     }
                 };
             })
         ) : null
     );
 }
 
-function xZ(e, t, n, {
-    strokeWidth: i = 1,
-    strokeLinecap: r = null,
+function DW(e, t, n, {
+    strokeWidth: r = 1,
+    strokeLinecap: i = null,
     strokeLinejoin: s = null,
     facetAnchor: o = t + (e === "y" ? "-empty" : ""),
     frameAnchor: a = t,
     tickSize: c,
-    inset: l = 0,
-    insetLeft: u = l,
-    insetRight: f = l,
+    inset: u = 0,
+    insetLeft: l = u,
+    insetRight: f = u,
     dx: h = 0,
     y: d = e === "y" ? void 0 : null,
     ...p
 }) {
-    return ul(
-        k8,
+    return xa(
+        D$,
         e,
         n, {
             ariaLabel: `${e}-axis tick`,
             ariaHidden: !0
         }, {
-            strokeWidth: i,
-            strokeLinecap: r,
+            strokeWidth: r,
+            strokeLinecap: i,
             strokeLinejoin: s,
             facetAnchor: o,
             frameAnchor: a,
             y: d,
             ...p,
-            dx: t === "left" ? +h - He + +u : +h + He - f,
+            dx: t === "left" ? +h - Me + +l : +h + Me - f,
             anchor: "start",
             length: c,
-            shape: t === "left" ? DZ : NZ
+            shape: t === "left" ? CW : PW
         }
     );
 }
 
-function SZ(e, t, n, {
-    strokeWidth: i = 1,
-    strokeLinecap: r = null,
+function OW(e, t, n, {
+    strokeWidth: r = 1,
+    strokeLinecap: i = null,
     strokeLinejoin: s = null,
     facetAnchor: o = t + (e === "x" ? "-empty" : ""),
     frameAnchor: a = t,
     tickSize: c,
-    inset: l = 0,
-    insetTop: u = l,
-    insetBottom: f = l,
+    inset: u = 0,
+    insetTop: l = u,
+    insetBottom: f = u,
     dy: h = 0,
     x: d = e === "x" ? void 0 : null,
     ...p
 }) {
-    return ul(
-        C8,
+    return xa(
+        N$,
         e,
         n, {
             ariaLabel: `${e}-axis tick`,
             ariaHidden: !0
         }, {
-            strokeWidth: i,
+            strokeWidth: r,
             strokeLinejoin: s,
-            strokeLinecap: r,
+            strokeLinecap: i,
             facetAnchor: o,
             frameAnchor: a,
             x: d,
             ...p,
-            dy: t === "bottom" ? +h - He - f : +h + He + +u,
+            dy: t === "bottom" ? +h - Me - f : +h + Me + +l,
             anchor: "start",
             length: c,
-            shape: t === "bottom" ? $Z : TZ
+            shape: t === "bottom" ? FW : BW
         }
     );
 }
 
-function IZ(e, t, n, {
-    facetAnchor: i = t + (e === "y" ? "-empty" : ""),
-    frameAnchor: r = t,
+function LW(e, t, n, {
+    facetAnchor: r = t + (e === "y" ? "-empty" : ""),
+    frameAnchor: i = t,
     tickSize: s,
     tickRotate: o = 0,
-    tickPadding: a = Math.max(3, 9 - s) + (Math.abs(o) > 60 ? 4 * Math.cos(o * Wp) : 0),
+    tickPadding: a = Math.max(3, 9 - s) + (Math.abs(o) > 60 ? 4 * Math.cos(o * gh) : 0),
     text: c,
-    textAnchor: l = Math.abs(o) > 60 ? "middle" : t === "left" ? "end" : "start",
-    lineAnchor: u = o > 60 ? "top" : o < -60 ? "bottom" : "middle",
+    textAnchor: u = Math.abs(o) > 60 ? "middle" : t === "left" ? "end" : "start",
+    lineAnchor: l = o > 60 ? "top" : o < -60 ? "bottom" : "middle",
     fontVariant: f,
     inset: h = 0,
     insetLeft: d = h,
     insetRight: p = h,
-    dx: m = 0,
-    y: g = e === "y" ? void 0 : null,
-    ...y
+    dx: y = 0,
+    y: m = e === "y" ? void 0 : null,
+    ...g
 }) {
-    return ul(
-        M8,
+    return xa(
+        w$,
         e,
         n, {
             ariaLabel: `${e}-axis tick label`
         }, {
-            facetAnchor: i,
-            frameAnchor: r,
+            facetAnchor: r,
+            frameAnchor: i,
             text: c,
-            textAnchor: l,
-            lineAnchor: u,
+            textAnchor: u,
+            lineAnchor: l,
             fontVariant: f,
             rotate: o,
-            y: g,
-            ...y,
-            dx: t === "left" ? +m - s - a + +d : +m + +s + +a - p
+            y: m,
+            ...g,
+            dx: t === "left" ? +y - s - a + +d : +y + +s + +a - p
         },
         function(b, w, v, x, _) {
-            f === void 0 && (this.fontVariant = n4(b)), c === void 0 && (_.text = e4(b, w, v, x, t));
+            f === void 0 && (this.fontVariant = H$(b)), c === void 0 && (_.text = G$(b, w, v, x, t));
         }
     );
 }
 
-function AZ(e, t, n, {
-    facetAnchor: i = t + (e === "x" ? "-empty" : ""),
-    frameAnchor: r = t,
+function kW(e, t, n, {
+    facetAnchor: r = t + (e === "x" ? "-empty" : ""),
+    frameAnchor: i = t,
     tickSize: s,
     tickRotate: o = 0,
-    tickPadding: a = Math.max(3, 9 - s) + (Math.abs(o) >= 10 ? 4 * Math.cos(o * Wp) : 0),
+    tickPadding: a = Math.max(3, 9 - s) + (Math.abs(o) >= 10 ? 4 * Math.cos(o * gh) : 0),
     text: c,
-    textAnchor: l = Math.abs(o) >= 10 ? o < 0 ^ t === "bottom" ? "start" : "end" : "middle",
-    lineAnchor: u = Math.abs(o) >= 10 ? "middle" : t === "bottom" ? "top" : "bottom",
+    textAnchor: u = Math.abs(o) >= 10 ? o < 0 ^ t === "bottom" ? "start" : "end" : "middle",
+    lineAnchor: l = Math.abs(o) >= 10 ? "middle" : t === "bottom" ? "top" : "bottom",
     fontVariant: f,
     inset: h = 0,
     insetTop: d = h,
     insetBottom: p = h,
-    dy: m = 0,
-    x: g = e === "x" ? void 0 : null,
-    ...y
+    dy: y = 0,
+    x: m = e === "x" ? void 0 : null,
+    ...g
 }) {
-    return ul(
-        A8,
+    return xa(
+        b$,
         e,
         n, {
             ariaLabel: `${e}-axis tick label`
         }, {
-            facetAnchor: i,
-            frameAnchor: r,
+            facetAnchor: r,
+            frameAnchor: i,
             text: c === void 0 ? null : c,
-            textAnchor: l,
-            lineAnchor: u,
+            textAnchor: u,
+            lineAnchor: l,
             fontVariant: f,
             rotate: o,
-            x: g,
-            ...y,
-            dy: t === "bottom" ? +m + +s + +a - p : +m - s - a + +d
+            x: m,
+            ...g,
+            dy: t === "bottom" ? +y + +s + +a - p : +y - s - a + +d
         },
         function(b, w, v, x, _) {
-            f === void 0 && (this.fontVariant = n4(b)), c === void 0 && (_.text = e4(b, w, v, x, t));
+            f === void 0 && (this.fontVariant = H$(b)), c === void 0 && (_.text = G$(b, w, v, x, t));
         }
     );
 }
 
-function G8() {
-    const [e, t] = uo(...arguments);
-    return K8("y", U8(t), e, t);
+function U$() {
+    const [e, t] = es(...arguments);
+    return V$("y", O$(t), e, t);
 }
 
-function X8() {
-    const [e, t] = uo(...arguments);
-    return K8("fy", z8(t), e, t);
+function z$() {
+    const [e, t] = es(...arguments);
+    return V$("fy", L$(t), e, t);
 }
 
-function H8() {
-    const [e, t] = uo(...arguments);
-    return Z8("x", P8(t), e, t);
+function q$() {
+    const [e, t] = es(...arguments);
+    return Y$("x", k$(t), e, t);
 }
 
-function J8() {
-    const [e, t] = uo(...arguments);
-    return Z8("fx", V8(t), e, t);
+function j$() {
+    const [e, t] = es(...arguments);
+    return Y$("fx", R$(t), e, t);
 }
 
-function K8(e, t, n, {
-    y: i = e === "y" ? void 0 : null,
-    x: r = null,
-    x1: s = t === "left" ? r : null,
-    x2: o = t === "right" ? r : null,
+function V$(e, t, n, {
+    y: r = e === "y" ? void 0 : null,
+    x: i = null,
+    x1: s = t === "left" ? i : null,
+    x2: o = t === "right" ? i : null,
     ...a
 }) {
-    return ul(Ks, e, n, {
+    return xa(Vi, e, n, {
         ariaLabel: `${e}-grid`,
         ariaHidden: !0
     }, {
-        y: i,
+        y: r,
         x1: s,
         x2: o,
-        ...Q8(a)
+        ...W$(a)
     });
 }
 
-function Z8(e, t, n, {
-    x: i = e === "x" ? void 0 : null,
-    y: r = null,
-    y1: s = t === "top" ? r : null,
-    y2: o = t === "bottom" ? r : null,
+function Y$(e, t, n, {
+    x: r = e === "x" ? void 0 : null,
+    y: i = null,
+    y1: s = t === "top" ? i : null,
+    y2: o = t === "bottom" ? i : null,
     ...a
 }) {
-    return ul(Js, e, n, {
+    return xa(ji, e, n, {
         ariaLabel: `${e}-grid`,
         ariaHidden: !0
     }, {
-        x: i,
+        x: r,
         y1: s,
         y2: o,
-        ...Q8(a)
+        ...W$(a)
     });
 }
 
-function Q8({
+function W$({
     color: e = "currentColor",
     opacity: t = 0.1,
     stroke: n = e,
-    strokeOpacity: i = t,
-    strokeWidth: r = 1,
+    strokeOpacity: r = t,
+    strokeWidth: i = 1,
     ...s
 }) {
     return {
         stroke: n,
-        strokeOpacity: i,
-        strokeWidth: r,
+        strokeOpacity: r,
+        strokeWidth: i,
         ...s
     };
 }
 
-function t4({
+function X$({
     fill: e,
     fillOpacity: t,
     fontFamily: n,
-    fontSize: i,
-    fontStyle: r,
+    fontSize: r,
+    fontStyle: i,
     fontVariant: s,
     fontWeight: o,
     monospace: a,
     pointerEvents: c,
-    shapeRendering: l,
-    clip: u = !1
+    shapeRendering: u,
+    clip: l = !1
 }, f) {
-    return [, e] = mn(e), [, t] = Be(t), {
+    return [, e] = ze(e), [, t] = ue(t), {
         facet: "super",
         x: null,
         y: null,
         fill: e,
         fillOpacity: t,
         fontFamily: n,
-        fontSize: i,
-        fontStyle: r,
+        fontSize: r,
+        fontStyle: i,
         fontVariant: s,
         fontWeight: o,
         monospace: a,
         pointerEvents: c,
-        shapeRendering: l,
-        clip: u,
+        shapeRendering: u,
+        clip: l,
         initializer: f
     };
 }
 
-function ul(e, t, n, i, r, s) {
+function xa(e, t, n, r, i, s) {
     let o;
 
-    function a(u, f, h, d, p, m) {
-        const g = u == null && (t === "fx" || t === "fy"),
+    function a(l, f, h, d, p, y) {
+        const m = l == null && (t === "fx" || t === "fy"),
             {
-                [t]: y
+                [t]: g
             } = d;
-        if (!y)
+        if (!g)
             throw new Error(`missing scale: ${t}`);
-        const b = y.domain();
+        const b = g.domain();
         let {
             interval: w,
             ticks: v,
             tickFormat: x,
             tickSpacing: _ = t === "x" ? 80 : 35
-        } = r;
-        if (typeof v == "string" && s4(y) && (w = v, v = void 0), v === void 0 && (v = ol(w, y.type) ?? MZ(y, _)), u == null) {
-            if (hs(v))
-                u = Nn(v);
-            else if (ec(v))
-                u = Km(v, ...ke(b));
-            else if (y.interval) {
-                let A = y.interval;
-                if (y.ticks) {
-                    const [M, N] = ke(b), $ = (N - M) / A[Ef];
-                    A = Vx(A, $ / v) ?? A, u = Km(A, M, N);
+        } = i;
+        if (typeof v == "string" && K$(g) && (w = v, v = void 0), v === void 0 && (v = ba(w, g.type) ?? RW(g, _)), l == null) {
+            if (li(v))
+                l = Qe(v);
+            else if (bo(v))
+                l = Wp(v, ...de(b));
+            else if (g.interval) {
+                let T = g.interval;
+                if (g.ticks) {
+                    const [$, N] = de(b), A = (N - $) / T[Su];
+                    T = i2(T, A / v) ?? T, l = Wp(T, $, N);
                 } else {
-                    u = b;
-                    const M = u.length;
-                    A = Vx(A, M / v) ?? A, A !== y.interval && (u = Km(A, ...ke(u)));
-                }
-                if (A === y.interval) {
-                    const M = Math.round(u.length / v);
-                    M > 1 && (u = u.filter((N, $) => $ % M === 0));
+                    l = b;
+                    const $ = l.length;
+                    T = i2(T, $ / v) ?? T, T !== g.interval && (l = Wp(T, ...de(l)));
+                }
+                if (T === g.interval) {
+                    const $ = Math.round(l.length / v);
+                    $ > 1 && (l = l.filter((N, A) => A % $ === 0));
                 }
             } else
-                y.ticks ? u = y.ticks(v) : u = b;
-            if (!y.ticks && u.length && u !== b) {
-                const A = new el(b);
-                u = u.filter((M) => A.has(M)), u.length || ts(`Warning: the ${t}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
+                g.ticks ? l = g.ticks(v) : l = b;
+            if (!g.ticks && l.length && l !== b) {
+                const T = new da(b);
+                l = l.filter(($) => T.has($)), l.length || ti(`Warning: the ${t}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
             }
-            t === "y" || t === "x" ? f = [fs(u)] : o[t] = {
+            t === "y" || t === "x" ? f = [ui(l)] : o[t] = {
                 scale: t,
-                value: Tt
+                value: yt
             };
         }
-        s == null || s.call(this, y, u, v, x, o);
-        const I = Object.fromEntries(
-            Object.entries(o).map(([A, M]) => [A, {
-                ...M,
-                value: Pt(u, M.value)
+        s == null || s.call(this, g, l, v, x, o);
+        const M = Object.fromEntries(
+            Object.entries(o).map(([T, $]) => [T, {
+                ...$,
+                value: $t(l, $.value)
             }])
         );
-        return g && (f = m.filterFacets(u, I)), {
-            data: u,
+        return m && (f = y.filterFacets(l, M)), {
+            data: l,
             facets: f,
-            channels: I
+            channels: M
         };
     }
-    const c = Bn(r).initializer,
-        l = e(n, Bn({
-            ...r,
+    const c = tn(i).initializer,
+        u = e(n, tn({
+            ...i,
             initializer: a
         }, c));
-    return n == null ? (o = l.channels, l.channels = {}) : o = {}, i !== void 0 && Object.assign(l, i), l.clip === void 0 && (l.clip = !1), l;
+    return n == null ? (o = u.channels, u.channels = {}) : o = {}, r !== void 0 && Object.assign(u, r), u.clip === void 0 && (u.clip = !1), u;
 }
 
-function MZ(e, t) {
-    const [n, i] = ke(e.range());
-    return (i - n) / t;
+function RW(e, t) {
+    const [n, r] = de(e.range());
+    return (r - n) / t;
 }
 
-function e4(e, t, n, i, r) {
+function G$(e, t, n, r, i) {
     return {
-        value: av(e, t, n, i, r)
+        value: Cg(e, t, n, r, i)
     };
 }
 
-function av(e, t, n, i, r) {
-    return typeof i == "function" ? i : i === void 0 && t && gn(t) ? zH(e.type, t, r) ?? ra : e.tickFormat ? e.tickFormat(typeof n == "number" ? n : null, i) : i === void 0 ? ra : typeof i == "string" ? (gn(e.domain()) ? Of : rl)(i) : jn(i);
+function Cg(e, t, n, r, i) {
+    return typeof r == "function" ? r : r === void 0 && t && qe(t) ? Hj(e.type, t, i) ?? Fs : e.tickFormat ? e.tickFormat(typeof n == "number" ? n : null, r) : r === void 0 ? Fs : typeof r == "string" ? (qe(e.domain()) ? _u : ma)(r) : fn(r);
 }
 
-function Km(e, t, n) {
+function Wp(e, t, n) {
     return e.range(t, e.offset(e.floor(n)));
 }
-const $Z = {
+const FW = {
         draw(e, t) {
             e.moveTo(0, 0), e.lineTo(0, t);
         }
     },
-    TZ = {
+    BW = {
         draw(e, t) {
             e.moveTo(0, 0), e.lineTo(0, -t);
         }
     },
-    DZ = {
+    CW = {
         draw(e, t) {
             e.moveTo(0, 0), e.lineTo(-t, 0);
         }
     },
-    NZ = {
+    PW = {
         draw(e, t) {
             e.moveTo(0, 0), e.lineTo(t, 0);
         }
     };
 
-function n4(e) {
+function H$(e) {
     return e.bandwidth && !e.interval ? void 0 : "tabular-nums";
 }
 
-function i4(e, t, {
+function J$(e, t, {
     anchor: n,
-    label: i = t.label,
-    labelAnchor: r,
+    label: r = t.label,
+    labelAnchor: i,
     labelArrow: s
 } = {}) {
-    if (!(i == null || i.inferred && s4(t) && /^(date|time|year)$/i.test(i))) {
-        if (i = String(i), s === "auto" && (s = (!t.bandwidth || t.interval) && !/[]/.test(i)), !s)
-            return i;
+    if (!(r == null || r.inferred && K$(t) && /^(date|time|year)$/i.test(r))) {
+        if (r = String(r), s === "auto" && (s = (!t.bandwidth || t.interval) && !/[]/.test(r)), !s)
+            return r;
         if (s === !0) {
-            const o = HD(t);
-            o && (s = /x$/.test(e) || r === "center" ? /x$/.test(e) === o < 0 ? "left" : "right" : o < 0 ? "up" : "down");
+            const o = qA(t);
+            o && (s = /x$/.test(e) || i === "center" ? /x$/.test(e) === o < 0 ? "left" : "right" : o < 0 ? "up" : "down");
         }
         switch (s) {
             case "left":
-                return ` ${i}`;
+                return ` ${r}`;
             case "right":
-                return `${i} `;
+                return `${r} `;
             case "up":
-                return n === "right" ? `${i} ` : ` ${i}`;
+                return n === "right" ? `${r} ` : ` ${r}`;
             case "down":
-                return n === "right" ? `${i} ` : ` ${i}`;
+                return n === "right" ? `${r} ` : ` ${r}`;
         }
-        return i;
+        return r;
     }
 }
 
-function r4(e = "auto") {
-    return we(e) ? !1 : typeof e == "boolean" ? e : qn(e, "labelArrow", ["auto", "up", "right", "down", "left"]);
+function Z$(e = "auto") {
+    return te(e) ? !1 : typeof e == "boolean" ? e : hn(e, "labelArrow", ["auto", "up", "right", "down", "left"]);
 }
 
-function s4(e) {
-    return gn(e.domain());
+function K$(e) {
+    return qe(e.domain());
 }
 
-function mS(e, t) {
+function O2(e, t) {
     if (t == null)
         return t;
     const n = e(t);
     if (!n)
         throw new Error(`scale not found: ${t}`);
     return n;
 }
 
-function BZ(e, {
+function UW(e, {
     opacity: t,
     ...n
 } = {}) {
-    if (!ua(e) && !t8(e))
+    if (!qs(e) && !XA(e))
         throw new Error(`swatches legend requires ordinal or threshold color scale (not ${e.type})`);
-    return o4(
+    return Q$(
         e,
         n,
-        (i, r, s, o) => i.append("svg").attr("width", s).attr("height", o).attr("fill", r.scale).attr("fill-opacity", Be(t)[1]).append("rect").attr("width", "100%").attr("height", "100%")
+        (r, i, s, o) => r.append("svg").attr("width", s).attr("height", o).attr("fill", i.scale).attr("fill-opacity", ue(t)[1]).append("rect").attr("width", "100%").attr("height", "100%")
     );
 }
 
-function OZ(e, {
-    fill: t = ((l) => (l = e.hint) == null ? void 0 : l.fill)() !== void 0 ? e.hint.fill : "none",
+function zW(e, {
+    fill: t = ((u) => (u = e.hint) == null ? void 0 : u.fill)() !== void 0 ? e.hint.fill : "none",
     fillOpacity: n = 1,
-    stroke: i = ((u) => (u = e.hint) == null ? void 0 : u.stroke)() !== void 0 ? e.hint.stroke : we(t) ? "currentColor" : "none",
-    strokeOpacity: r = 1,
+    stroke: r = ((l) => (l = e.hint) == null ? void 0 : l.stroke)() !== void 0 ? e.hint.stroke : te(t) ? "currentColor" : "none",
+    strokeOpacity: i = 1,
     strokeWidth: s = 1.5,
     r: o = 4.5,
     ...a
 } = {}, c) {
-    const [f, h] = mn(t), [d, p] = mn(i), m = mS(c, f), g = mS(c, d), y = o * o * Math.PI;
-    return n = Be(n)[1], r = Be(r)[1], s = Be(s)[1], o4(
+    const [f, h] = ze(t), [d, p] = ze(r), y = O2(c, f), m = O2(c, d), g = o * o * Math.PI;
+    return n = ue(n)[1], i = ue(i)[1], s = ue(s)[1], Q$(
         e,
         a,
-        (b, w, v, x) => b.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", v).attr("height", x).attr("fill", f === "color" ? (_) => m.scale(_) : h).attr("fill-opacity", n).attr("stroke", d === "color" ? (_) => g.scale(_) : p).attr("stroke-opacity", r).attr("stroke-width", s).append("path").attr("d", (_) => {
-            const I = Xr();
-            return e.scale(_).draw(I, y), I;
+        (b, w, v, x) => b.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", v).attr("height", x).attr("fill", f === "color" ? (_) => y.scale(_) : h).attr("fill-opacity", n).attr("stroke", d === "color" ? (_) => m.scale(_) : p).attr("stroke-opacity", i).attr("stroke-width", s).append("path").attr("d", (_) => {
+            const M = Gr();
+            return e.scale(_).draw(M, g), M;
         })
     );
 }
 
-function o4(e, t = {}, n) {
+function Q$(e, t = {}, n) {
     let {
-        columns: i,
-        tickFormat: r,
-        fontVariant: s = c8(e),
+        columns: r,
+        tickFormat: i,
+        fontVariant: s = e$(e),
         // TODO label,
         swatchSize: o = 15,
         swatchWidth: a = o,
         swatchHeight: c = o,
-        marginLeft: l = 0,
-        className: u,
+        marginLeft: u = 0,
+        className: l,
         style: f,
         width: h
     } = t;
-    const d = $0(t);
-    u = Kw(u), r = av(e.scale, e.domain, void 0, r);
-    const p = Gt("div", d).attr(
+    const d = Sd(t);
+    l = Ng(l), i = Cg(e.scale, e.domain, void 0, i);
+    const p = Ot("div", d).attr(
         "class",
-        `${u}-swatches ${u}-swatches-${i != null ? "columns" : "wrap"}`
+        `${l}-swatches ${l}-swatches-${r != null ? "columns" : "wrap"}`
     );
-    let m;
-    return i != null ? (m = `:where(.${u}-swatches-columns .${u}-swatch) {
+    let y;
+    return r != null ? (y = `:where(.${l}-swatches-columns .${l}-swatch) {
   display: flex;
   align-items: center;
   break-inside: avoid;
   padding-bottom: 1px;
 }
-:where(.${u}-swatches-columns .${u}-swatch::before) {
+:where(.${l}-swatches-columns .${l}-swatch::before) {
   flex-shrink: 0;
 }
-:where(.${u}-swatches-columns .${u}-swatch-label) {
+:where(.${l}-swatches-columns .${l}-swatch-label) {
   white-space: nowrap;
   overflow: hidden;
   text-overflow: ellipsis;
-}`, p.style("columns", i).selectAll().data(e.domain).enter().append("div").attr("class", `${u}-swatch`).call(n, e, a, c).call(
-        (g) => g.append("div").attr("class", `${u}-swatch-label`).attr("title", r).text(r)
-    )) : (m = `:where(.${u}-swatches-wrap) {
+}`, p.style("columns", r).selectAll().data(e.domain).enter().append("div").attr("class", `${l}-swatch`).call(n, e, a, c).call(
+        (m) => m.append("div").attr("class", `${l}-swatch-label`).attr("title", i).text(i)
+    )) : (y = `:where(.${l}-swatches-wrap) {
   display: flex;
   align-items: center;
   min-height: 33px;
   flex-wrap: wrap;
 }
-:where(.${u}-swatches-wrap .${u}-swatch) {
+:where(.${l}-swatches-wrap .${l}-swatch) {
   display: inline-flex;
   align-items: center;
   margin-right: 1em;
-}`, p.selectAll().data(e.domain).enter().append("span").attr("class", `${u}-swatch`).call(n, e, a, c).append(function() {
-        return this.ownerDocument.createTextNode(r.apply(this, arguments));
+}`, p.selectAll().data(e.domain).enter().append("span").attr("class", `${l}-swatch`).call(n, e, a, c).append(function() {
+        return this.ownerDocument.createTextNode(i.apply(this, arguments));
     })), p.call(
-        (g) => g.insert("style", "*").text(
-            `:where(.${u}-swatches) {
+        (m) => m.insert("style", "*").text(
+            `:where(.${l}-swatches) {
   font-family: system-ui, sans-serif;
   font-size: 10px;
   margin-bottom: 0.5em;
 }
-:where(.${u}-swatch > svg) {
+:where(.${l}-swatch > svg) {
   margin-right: 0.5em;
   overflow: visible;
 }
-${m}`
+${y}`
         )
-    ).style("margin-left", l ? `${+l}px` : null).style("width", h === void 0 ? null : `${+h}px`).style("font-variant", Me(s, "normal")).call(Zw, f).node();
+    ).style("margin-left", u ? `${+u}px` : null).style("width", h === void 0 ? null : `${+h}px`).style("font-variant", se(s, "normal")).call(Dg, f).node();
 }
-const Gp = /* @__PURE__ */ new Map([
-    ["symbol", OZ],
-    ["color", a4],
-    ["opacity", LZ]
+const bh = /* @__PURE__ */ new Map([
+    ["symbol", zW],
+    ["color", t4],
+    ["opacity", VW]
 ]);
 
-function FZ(e = {}) {
-    for (const [t, n] of Gp) {
-        const i = e[t];
-        if (jo(i)) {
-            const r = $0(e);
+function qW(e = {}) {
+    for (const [t, n] of bh) {
+        const r = e[t];
+        if (xs(r)) {
+            const i = Sd(e);
             let s;
             if (t === "symbol") {
                 const {
                     fill: o,
-                    stroke: a = o === void 0 && jo(e.color) ? "color" : void 0
+                    stroke: a = o === void 0 && xs(e.color) ? "color" : void 0
                 } = e;
                 s = {
                     fill: o,
                     stroke: a
                 };
             }
             return n(
-                B1(t, i, s),
-                cv(r, i, e),
-                (o) => jo(e[o]) ? B1(o, e[o]) : null
+                wy(t, r, s),
+                Pg(i, r, e),
+                (o) => xs(e[o]) ? wy(o, e[o]) : null
             );
         }
     }
     throw new Error("unknown legend type; no scale found");
 }
 
-function EZ(e, t, n = {}) {
-    return (i, r) => {
-        if (!Gp.has(i))
-            throw new Error(`unknown legend type: ${i}`);
-        if (i in e)
-            return Gp.get(i)(e[i], cv(t, n[i], r), (s) => e[s]);
+function jW(e, t, n = {}) {
+    return (r, i) => {
+        if (!bh.has(r))
+            throw new Error(`unknown legend type: ${r}`);
+        if (r in e)
+            return bh.get(r)(e[r], Pg(t, n[r], i), (s) => e[s]);
     };
 }
 
-function cv({
+function Pg({
     className: e,
     ...t
 }, {
     label: n,
-    ticks: i,
-    tickFormat: r
+    ticks: r,
+    tickFormat: i
 } = {}, s) {
-    return nJ(s, {
+    return fV(s, {
         className: e,
         ...t
     }, {
         label: n,
-        ticks: i,
-        tickFormat: r
+        ticks: r,
+        tickFormat: i
     });
 }
 
-function a4(e, {
+function t4(e, {
     legend: t = !0,
     ...n
 }) {
     if (t === !0 && (t = e.type === "ordinal" ? "swatches" : "ramp"), e.domain !== void 0)
         switch (`${t}`.toLowerCase()) {
             case "swatches":
-                return BZ(e, n);
+                return UW(e, n);
             case "ramp":
-                return eZ(e, n);
+                return lW(e, n);
             default:
                 throw new Error(`unknown legend type: ${t}`);
         }
 }
 
-function LZ({
+function VW({
     type: e,
     interpolate: t,
     ...n
 }, {
-    legend: i = !0,
-    color: r = Pn(0, 0, 0),
+    legend: r = !0,
+    color: i = un(0, 0, 0),
     ...s
 }) {
     if (!t)
         throw new Error(`${e} opacity scales are not supported`);
-    if (i === !0 && (i = "ramp"), `${i}`.toLowerCase() !== "ramp")
-        throw new Error(`${i} opacity legends are not supported`);
-    return a4({
+    if (r === !0 && (r = "ramp"), `${r}`.toLowerCase() !== "ramp")
+        throw new Error(`${r} opacity legends are not supported`);
+    return t4({
         type: e,
         ...n,
-        interpolate: RZ(r)
+        interpolate: YW(i)
     }, {
-        legend: i,
+        legend: r,
         ...s
     });
 }
 
-function RZ(e) {
+function YW(e) {
     const {
         r: t,
         g: n,
-        b: i
-    } = Pn(e) || Pn(0, 0, 0);
-    return (r) => `rgba(${t},${n},${i},${r})`;
+        b: r
+    } = un(e) || un(0, 0, 0);
+    return (i) => `rgba(${t},${n},${r},${i})`;
 }
 
-function CZ(e, t, n) {
-    const i = [];
-    for (const [r, s] of Gp) {
-        const o = n[r];
-        if (o != null && o.legend && r in e) {
-            const a = s(e[r], cv(t, e[r], o), (c) => e[c]);
-            a != null && i.push(a);
+function WW(e, t, n) {
+    const r = [];
+    for (const [i, s] of bh) {
+        const o = n[i];
+        if (o != null && o.legend && i in e) {
+            const a = s(e[i], Pg(t, e[i], o), (c) => e[c]);
+            a != null && r.push(a);
         }
     }
-    return i;
+    return r;
 }
-const kZ = {
+const XW = {
         ariaLabel: "frame",
         fill: "none",
         stroke: "currentColor",
         clip: !1
     },
-    UZ = {
+    GW = {
         ariaLabel: "frame",
         fill: null,
         stroke: "currentColor",
         strokeLinecap: "square",
         clip: !1
     };
-class c4 extends fe {
+class e4 extends Ht {
     constructor(t = {}) {
         const {
             anchor: n = null,
-            inset: i = 0,
-            insetTop: r = i,
-            insetRight: s = i,
-            insetBottom: o = i,
-            insetLeft: a = i,
+            inset: r = 0,
+            insetTop: i = r,
+            insetRight: s = r,
+            insetBottom: o = r,
+            insetLeft: a = r,
             rx: c,
-            ry: l
+            ry: u
         } = t;
-        super(yu, void 0, t, n == null ? kZ : UZ), this.anchor = uD(n, "anchor", ["top", "right", "bottom", "left"]), this.insetTop = qt(r), this.insetRight = qt(s), this.insetBottom = qt(o), this.insetLeft = qt(a), this.rx = qt(c), this.ry = qt(l);
+        super(hc, void 0, t, n == null ? XW : GW), this.anchor = rA(n, "anchor", ["top", "right", "bottom", "left"]), this.insetTop = Nt(i), this.insetRight = Nt(s), this.insetBottom = Nt(o), this.insetLeft = Nt(a), this.rx = Nt(c), this.ry = Nt(u);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             marginTop: o,
             marginRight: a,
             marginBottom: c,
-            marginLeft: l,
-            width: u,
+            marginLeft: u,
+            width: l,
             height: f
-        } = r, {
+        } = i, {
             anchor: h,
             insetTop: d,
             insetRight: p,
-            insetBottom: m,
-            insetLeft: g,
-            rx: y,
+            insetBottom: y,
+            insetLeft: m,
+            rx: g,
             ry: b
-        } = this, w = l + g, v = u - a - p, x = o + d, _ = f - c - m;
-        return Gt(h ? "svg:line" : "svg:rect", s).datum(0).call(ve, this, r, s).call(be, this).call(Pe, this, i).call(ue, this, {}).call(
-            h === "left" ? (I) => I.attr("x1", w).attr("x2", w).attr("y1", x).attr("y2", _) : h === "right" ? (I) => I.attr("x1", v).attr("x2", v).attr("y1", x).attr("y2", _) : h === "top" ? (I) => I.attr("x1", w).attr("x2", v).attr("y1", x).attr("y2", x) : h === "bottom" ? (I) => I.attr("x1", w).attr("x2", v).attr("y1", _).attr("y2", _) : (I) => I.attr("x", w).attr("y", x).attr("width", v - w).attr("height", _ - x).attr("rx", y).attr("ry", b)
+        } = this, w = u + m, v = l - a - p, x = o + d, _ = f - c - y;
+        return Ot(h ? "svg:line" : "svg:rect", s).datum(0).call(ee, this, i, s).call(Qt, this).call(me, this, r).call(Gt, this, {}).call(
+            h === "left" ? (M) => M.attr("x1", w).attr("x2", w).attr("y1", x).attr("y2", _) : h === "right" ? (M) => M.attr("x1", v).attr("x2", v).attr("y1", x).attr("y2", _) : h === "top" ? (M) => M.attr("x1", w).attr("x2", v).attr("y1", x).attr("y2", x) : h === "bottom" ? (M) => M.attr("x1", w).attr("x2", v).attr("y1", _).attr("y2", _) : (M) => M.attr("x", w).attr("y", x).attr("width", v - w).attr("height", _ - x).attr("rx", g).attr("ry", b)
         ).node();
     }
 }
 
-function lv(e) {
-    return new c4(e);
+function Ug(e) {
+    return new e4(e);
 }
-const Zm = {
+const Xp = {
         ariaLabel: "tip",
         fill: "var(--plot-background)",
         stroke: "currentColor"
     },
-    zZ = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
-class l4 extends fe {
+    HW = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
+class n4 extends Ht {
     constructor(t, n = {}) {
         n.tip && (n = {
             ...n,
             tip: !1
-        }), n.title === void 0 && hs(t) && mD(t) && (n = {
+        }), n.title === void 0 && li(t) && uA(t) && (n = {
             ...n,
-            title: Tt
+            title: yt
         });
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             x1: s,
             x2: o,
             y1: a,
             y2: c,
-            anchor: l,
-            preferredAnchor: u = "bottom",
+            anchor: u,
+            preferredAnchor: l = "bottom",
             monospace: f,
             fontFamily: h = f ? "ui-monospace, monospace" : void 0,
             fontSize: d,
             fontStyle: p,
-            fontVariant: m,
-            fontWeight: g,
-            lineHeight: y = 1,
+            fontVariant: y,
+            fontWeight: m,
+            lineHeight: g = 1,
             lineWidth: b = 20,
             frameAnchor: w,
             format: v,
             textAnchor: x = "start",
             textOverflow: _,
-            textPadding: I = 8,
-            title: A,
-            pointerSize: M = 12,
+            textPadding: M = 8,
+            title: T,
+            pointerSize: $ = 12,
             pathFilter: N = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
         } = n;
         super(
             t, {
                 x: {
-                    value: s != null && o != null ? null : i,
+                    value: s != null && o != null ? null : r,
                     scale: "x",
                     optional: !0
                 },
                 // ignore midpoint
                 y: {
-                    value: a != null && c != null ? null : r,
+                    value: a != null && c != null ? null : i,
                     scale: "y",
                     optional: !0
                 },
                 // ignore midpoint
                 x1: {
                     value: s,
                     scale: "x",
@@ -29060,196 +29623,196 @@
                 },
                 y2: {
                     value: c,
                     scale: "y",
                     optional: a == null
                 },
                 title: {
-                    value: A,
+                    value: T,
                     optional: !0
                 }
                 // filter: defined
             },
             n,
-            Zm
-        ), this.anchor = A1(l, "anchor"), this.preferredAnchor = A1(u, "preferredAnchor"), this.frameAnchor = Rf(w), this.textAnchor = Me(x, "middle"), this.textPadding = +I, this.pointerSize = +M, this.pathFilter = tn(N), this.lineHeight = +y, this.lineWidth = +b, this.textOverflow = I8(_), this.monospace = !!f, this.fontFamily = tn(h), this.fontSize = qt(d), this.fontStyle = tn(p), this.fontVariant = tn(m), this.fontWeight = tn(g);
-        for (const $ in Zm)
-            $ in this.channels && (this[$] = Zm[$]);
-        this.splitLines = T8(this), this.clipLine = D8(this), this.format = {
+            Xp
+        ), this.anchor = dy(u, "anchor"), this.preferredAnchor = dy(l, "preferredAnchor"), this.frameAnchor = Au(w), this.textAnchor = se(x, "middle"), this.textPadding = +M, this.pointerSize = +$, this.pathFilter = Ee(N), this.lineHeight = +g, this.lineWidth = +b, this.textOverflow = g$(_), this.monospace = !!f, this.fontFamily = Ee(h), this.fontSize = Nt(d), this.fontStyle = Ee(p), this.fontVariant = Ee(y), this.fontWeight = Ee(m);
+        for (const A in Xp)
+            A in this.channels && (this[A] = Xp[A]);
+        this.splitLines = _$(this), this.clipLine = x$(this), this.format = {
             ...v
         };
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const o = this,
             {
                 x: a,
                 y: c,
-                fx: l,
-                fy: u
+                fx: u,
+                fy: l
             } = n,
             {
                 ownerSVGElement: f,
                 document: h
             } = s,
             {
                 anchor: d,
                 monospace: p,
-                lineHeight: m,
-                lineWidth: g
+                lineHeight: y,
+                lineWidth: m
             } = this,
             {
-                textPadding: y,
+                textPadding: g,
                 pointerSize: b,
                 pathFilter: w
             } = this,
             {
                 marginTop: v,
                 marginLeft: x
-            } = r,
+            } = i,
             {
                 x1: _,
-                y1: I,
-                x2: A,
-                y2: M,
-                x: N = _ ?? A,
-                y: $ = I ?? M
-            } = i,
-            B = l ? l(t.fx) - x : 0,
-            R = u ? u(t.fy) - v : 0,
-            [S, T] = _r(this, r),
-            D = o8(i, S),
-            L = a8(i, T),
-            k = p ? rv : iv,
-            U = k(yc);
-        let C, z;
-        "title" in i ? (C = i.channels, z = YZ) : (C = qZ.call(this, i, n), z = WZ);
-        const P = Gt("svg:g", s).call(ve, this, r, s).call($8, this).call(ue, this, {
+                y1: M,
+                x2: T,
+                y2: $,
+                x: N = _ ?? T,
+                y: A = M ?? $
+            } = r,
+            D = u ? u(t.fx) - x : 0,
+            R = l ? l(t.fy) - v : 0,
+            [S, I] = Ir(this, i),
+            E = QA(r, S),
+            k = t$(r, I),
+            B = p ? Rg : kg,
+            C = B(Oo);
+        let F, P;
+        "title" in r ? (F = r.channels, P = tX) : (F = QW.call(this, r, n), P = eX);
+        const U = Ot("svg:g", s).call(ee, this, i, s).call(v$, this).call(Gt, this, {
             x: N && a,
-            y: $ && c
+            y: A && c
         }).call(
-            (et) => et.selectAll().data(t).enter().append("g").attr("transform", (Z) => `translate(${Math.round(D(Z))},${Math.round(L(Z))})`).call(be, this).call((Z) => Z.append("path").attr("filter", w)).call(
-                (Z) => Z.append("text").each(function(Y) {
-                    const X = ce(this);
+            (K) => K.selectAll().data(t).enter().append("g").attr("transform", (H) => `translate(${Math.round(E(H))},${Math.round(k(H))})`).call(Qt, this).call((H) => H.append("path").attr("filter", w)).call(
+                (H) => H.append("text").each(function(V) {
+                    const W = Wt(this);
                     this.setAttribute("fill", "currentColor"), this.setAttribute("fill-opacity", 1), this.setAttribute("stroke", "none");
-                    const j = z.call(o, Y, t, C, n, i);
-                    if (typeof j == "string")
-                        for (const J of o.splitLines(j))
-                            G(X, {
-                                value: o.clipLine(J)
+                    const q = P.call(o, V, t, F, n, r);
+                    if (typeof q == "string")
+                        for (const X of o.splitLines(q))
+                            Y(W, {
+                                value: o.clipLine(X)
                             });
                     else {
-                        const J = /* @__PURE__ */ new Set();
-                        for (const tt of j) {
+                        const X = /* @__PURE__ */ new Set();
+                        for (const Z of q) {
                             const {
-                                label: V = ""
-                            } = tt;
-                            V && J.has(V) || (J.add(V), G(X, tt));
+                                label: z = ""
+                            } = Z;
+                            z && X.has(z) || (X.add(z), Y(W, Z));
                         }
                     }
                 })
             )
         );
 
-        function G(et, {
-            label: Z,
-            value: Y,
-            color: X,
-            opacity: j
+        function Y(K, {
+            label: H,
+            value: V,
+            color: W,
+            opacity: q
         }) {
-            Z ?? (Z = ""), Y ?? (Y = "");
-            const J = X != null || j != null;
-            let tt, V = g * 100;
-            const [Ft] = Vc(Z, V, k, U);
-            if (Ft >= 0)
-                Z = Z.slice(0, Ft).trimEnd() + yc, tt = Y.trim(), Y = "";
+            H ?? (H = ""), V ?? (V = "");
+            const X = W != null || q != null;
+            let Z, z = m * 100;
+            const [wt] = ia(H, z, B, C);
+            if (wt >= 0)
+                H = H.slice(0, wt).trimEnd() + Oo, Z = V.trim(), V = "";
             else {
-                (Z || !Y && !J) && (Y = " " + Y);
-                const [Vt] = Vc(Y, V - k(Z), k, U);
-                Vt >= 0 && (tt = Y.trim(), Y = Y.slice(0, Vt).trimEnd() + yc);
+                (H || !V && !X) && (V = " " + V);
+                const [It] = ia(V, z - B(H), B, C);
+                It >= 0 && (Z = V.trim(), V = V.slice(0, It).trimEnd() + Oo);
             }
-            const rt = et.append("tspan").attr("x", 0).attr("dy", `${m}em`).text("");
-            Z && rt.append("tspan").attr("font-weight", "bold").text(Z), Y && rt.append(() => h.createTextNode(Y)), J && rt.append("tspan").text(" ").attr("fill", X).attr("fill-opacity", j).style("user-select", "none"), tt && rt.append("title").text(tt);
+            const tt = K.append("tspan").attr("x", 0).attr("dy", `${y}em`).text("");
+            H && tt.append("tspan").attr("font-weight", "bold").text(H), V && tt.append(() => h.createTextNode(V)), X && tt.append("tspan").text(" ").attr("fill", W).attr("fill-opacity", q).style("user-select", "none"), Z && tt.append("title").text(Z);
         }
 
-        function K() {
+        function G() {
             const {
-                width: et,
-                height: Z
-            } = r.facet ?? r;
-            P.selectChildren().each(function(Y) {
+                width: K,
+                height: H
+            } = i.facet ?? i;
+            U.selectChildren().each(function(V) {
                 let {
-                    x: X,
-                    width: j,
-                    height: J
+                    x: W,
+                    width: q,
+                    height: X
                 } = this.getBBox();
-                j = Math.round(j), J = Math.round(J);
-                let tt = d;
-                if (tt === void 0) {
-                    const rt = D(Y) + B,
-                        Vt = L(Y) + R,
-                        jt = rt + j + b + y * 2 < et,
-                        Q = rt - j - b - y * 2 > 0,
-                        Zt = Vt + J + b + y * 2 < Z,
-                        En = Vt - J - b - y * 2 > 0;
-                    tt = jt && Q ? Zt && En ? o.preferredAnchor : En ? "bottom" : "top" : Zt && En ? jt ? "left" : "right" : (jt || Q) && (Zt || En) ? `${En ? "bottom" : "top"}-${jt ? "left" : "right"}` : o.preferredAnchor;
-                }
-                const V = this.firstChild,
-                    Ft = this.lastChild;
-                if (V.setAttribute("d", jZ(tt, b, y, j, J)), X)
-                    for (const rt of Ft.childNodes)
-                        rt.setAttribute("x", -X);
-                Ft.setAttribute("y", `${+PZ(tt, Ft.childNodes.length, m).toFixed(6)}em`), Ft.setAttribute("transform", `translate(${VZ(tt, b, y, j, J)})`);
-            }), P.attr("visibility", null);
+                q = Math.round(q), X = Math.round(X);
+                let Z = d;
+                if (Z === void 0) {
+                    const tt = E(V) + D,
+                        It = k(V) + R,
+                        Et = tt + q + b + g * 2 < K,
+                        J = tt - q - b - g * 2 > 0,
+                        Bt = It + X + b + g * 2 < H,
+                        en = It - X - b - g * 2 > 0;
+                    Z = Et && J ? Bt && en ? o.preferredAnchor : en ? "bottom" : "top" : Bt && en ? Et ? "left" : "right" : (Et || J) && (Bt || en) ? `${en ? "bottom" : "top"}-${Et ? "left" : "right"}` : o.preferredAnchor;
+                }
+                const z = this.firstChild,
+                    wt = this.lastChild;
+                if (z.setAttribute("d", KW(Z, b, g, q, X)), W)
+                    for (const tt of wt.childNodes)
+                        tt.setAttribute("x", -W);
+                wt.setAttribute("y", `${+JW(Z, wt.childNodes.length, y).toFixed(6)}em`), wt.setAttribute("transform", `translate(${ZW(Z, b, g, q, X)})`);
+            }), U.attr("visibility", null);
         }
-        return t.length && (P.attr("visibility", "hidden"), f.isConnected ? Promise.resolve().then(K) : typeof requestAnimationFrame < "u" && requestAnimationFrame(K)), P.node();
+        return t.length && (U.attr("visibility", "hidden"), f.isConnected ? Promise.resolve().then(G) : typeof requestAnimationFrame < "u" && requestAnimationFrame(G)), U.node();
     }
 }
 
-function u4(e, {
+function r4(e, {
     x: t,
     y: n,
-    ...i
+    ...r
 } = {}) {
-    return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new l4(e, {
-        ...i,
+    return r.frameAnchor === void 0 && ([t, n] = Jn(t, n)), new n4(e, {
+        ...r,
         x: t,
         y: n
     });
 }
 
-function PZ(e, t, n) {
+function JW(e, t, n) {
     return /^top(?:-|$)/.test(e) ? 0.94 - n : -0.29 - t * n;
 }
 
-function VZ(e, t, n, i, r) {
+function ZW(e, t, n, r, i) {
     switch (e) {
         case "middle":
-            return [-i / 2, r / 2];
+            return [-r / 2, i / 2];
         case "top-left":
             return [n, t + n];
         case "top":
-            return [-i / 2, t / 2 + n];
+            return [-r / 2, t / 2 + n];
         case "top-right":
-            return [-i - n, t + n];
+            return [-r - n, t + n];
         case "right":
-            return [-t / 2 - i - n, r / 2];
+            return [-t / 2 - r - n, i / 2];
         case "bottom-left":
             return [n, -t - n];
         case "bottom":
-            return [-i / 2, -t / 2 - n];
+            return [-r / 2, -t / 2 - n];
         case "bottom-right":
-            return [-i - n, -t - n];
+            return [-r - n, -t - n];
         case "left":
-            return [n + t / 2, r / 2];
+            return [n + t / 2, i / 2];
     }
 }
 
-function jZ(e, t, n, i, r) {
-    const s = i + n * 2,
-        o = r + n * 2;
+function KW(e, t, n, r, i) {
+    const s = r + n * 2,
+        o = i + n * 2;
     switch (e) {
         case "middle":
             return `M${-s / 2},${-o / 2}h${s}v${o}h${-s}z`;
         case "top-left":
             return `M0,0l${t},${t}h${s - t}v${o}h${-s}z`;
         case "top":
             return `M0,0l${t / 2},${t / 2}h${(s - t) / 2}v${o}h${-s}v${-o}h${(s - t) / 2}z`;
@@ -29264,2927 +29827,2927 @@
         case "bottom-right":
             return `M0,0l${-t},${-t}h${t - s}v${-o}h${s}z`;
         case "left":
             return `M0,0l${t / 2},${-t / 2}v${t / 2 - o / 2}h${s}v${o}h${-s}v${t / 2 - o / 2}z`;
     }
 }
 
-function qZ({
+function QW({
     channels: e
 }, t) {
-    var r, s;
+    var i, s;
     const n = {};
-    let i = this.format;
-    i = gS(i, e, "x"), i = gS(i, e, "y"), this.format = i;
-    for (const o in i) {
-        const a = i[o];
+    let r = this.format;
+    r = L2(r, e, "x"), r = L2(r, e, "y"), this.format = r;
+    for (const o in r) {
+        const a = r[o];
         if (!(a === null || a === !1))
             if (o === "fx" || o === "fy")
                 n[o] = !0;
             else {
-                const c = $1(e, o);
+                const c = yy(e, o);
                 c && (n[o] = c);
             }
     }
     for (const o in e) {
-        if (o in n || o in i || zZ.has(o))
+        if (o in n || o in r || HW.has(o))
             continue;
-        const a = $1(e, o);
+        const a = yy(e, o);
         a && (n[o] = a);
     }
-    this.facet && (t.fx && !("fx" in i) && (n.fx = !0), t.fy && !("fy" in i) && (n.fy = !0));
+    this.facet && (t.fx && !("fx" in r) && (n.fx = !0), t.fy && !("fy" in r) && (n.fy = !0));
     for (const o in n) {
         const a = this.format[o];
         if (typeof a == "string") {
-            const c = ((r = n[o]) == null ? void 0 : r.value) ?? ((s = t[o]) == null ? void 0 : s.domain()) ?? [];
-            this.format[o] = (gn(c) ? Of : rl)(a);
+            const c = ((i = n[o]) == null ? void 0 : i.value) ?? ((s = t[o]) == null ? void 0 : s.domain()) ?? [];
+            this.format[o] = (qe(c) ? _u : ma)(a);
         } else if (a === void 0 || a === !0) {
             const c = t[o];
-            this.format[o] = c != null && c.bandwidth ? av(c, c.domain()) : ra;
+            this.format[o] = c != null && c.bandwidth ? Cg(c, c.domain()) : Fs;
         }
     }
     return n;
 }
 
-function gS(e, t, n) {
+function L2(e, t, n) {
     if (!(n in e))
         return e;
-    const i = `${n}1`,
-        r = `${n}2`;
-    if ((i in e || !(i in t)) && (r in e || !(r in t)))
+    const r = `${n}1`,
+        i = `${n}2`;
+    if ((r in e || !(r in t)) && (i in e || !(i in t)))
         return e;
     const s = Object.entries(e),
         o = e[n];
-    return s.splice(s.findIndex(([a]) => a === n) + 1, 0, [i, o], [r, o]), Object.fromEntries(s);
+    return s.splice(s.findIndex(([a]) => a === n) + 1, 0, [r, o], [i, o]), Object.fromEntries(s);
 }
 
-function YZ(e, t, {
+function tX(e, t, {
     title: n
 }) {
-    return ra(n.value[e], e);
+    return Fs(n.value[e], e);
 }
 
-function* WZ(e, t, n, i, r) {
+function* eX(e, t, n, r, i) {
     for (const s in n) {
         if (s === "fx" || s === "fy") {
             yield {
-                label: Xp(i, n, s),
+                label: wh(r, n, s),
                 value: this.format[s](t[s], e)
             };
             continue;
         }
         if (s === "x1" && "x2" in n || s === "y1" && "y2" in n)
             continue;
         const o = n[s];
         if (s === "x2" && "x1" in n)
             yield {
-                label: wS(i, n, "x"),
-                value: bS(this.format.x2, n.x1, o, e)
+                label: R2(r, n, "x"),
+                value: k2(this.format.x2, n.x1, o, e)
             };
         else if (s === "y2" && "y1" in n)
             yield {
-                label: wS(i, n, "y"),
-                value: bS(this.format.y2, n.y1, o, e)
+                label: R2(r, n, "y"),
+                value: k2(this.format.y2, n.y1, o, e)
             };
         else {
             const a = o.value[e],
                 c = o.scale;
-            if (!dn(a) && c == null)
+            if (!Ce(a) && c == null)
                 continue;
             yield {
-                label: Xp(i, n, s),
+                label: wh(r, n, s),
                 value: this.format[s](a, e),
-                color: c === "color" ? r[s][e] : null,
-                opacity: c === "opacity" ? r[s][e] : null
+                color: c === "color" ? i[s][e] : null,
+                opacity: c === "opacity" ? i[s][e] : null
             };
         }
     }
 }
 
-function bS(e, t, n, i) {
-    var r;
-    return (r = n.hint) != null && r.length ? `${e(n.value[i] - t.value[i], i)}` : `${e(t.value[i], i)}${e(n.value[i], i)}`;
+function k2(e, t, n, r) {
+    var i;
+    return (i = n.hint) != null && i.length ? `${e(n.value[r] - t.value[r], r)}` : `${e(t.value[r], r)}${e(n.value[r], r)}`;
 }
 
-function wS(e, t, n) {
-    const i = Xp(e, t, `${n}1`, n),
-        r = Xp(e, t, `${n}2`, n);
-    return i === r ? i : `${i}${r}`;
+function R2(e, t, n) {
+    const r = wh(e, t, `${n}1`, n),
+        i = wh(e, t, `${n}2`, n);
+    return r === i ? r : `${r}${i}`;
 }
 
-function Xp(e, t, n, i = n) {
-    const r = t[n],
-        s = e[(r == null ? void 0 : r.scale) ?? n];
-    return String((s == null ? void 0 : s.label) ?? (r == null ? void 0 : r.label) ?? i);
+function wh(e, t, n, r = n) {
+    const i = t[n],
+        s = e[(i == null ? void 0 : i.scale) ?? n];
+    return String((s == null ? void 0 : s.label) ?? (i == null ? void 0 : i.label) ?? r);
 }
 
-function uv(e = {}) {
-    var U;
+function zg(e = {}) {
+    var C;
     const {
         facet: t,
         style: n,
-        title: i,
-        subtitle: r,
+        title: r,
+        subtitle: i,
         caption: s,
         ariaLabel: o,
         ariaDescription: a
-    } = e, c = Kw(e.className), l = e.marks === void 0 ? [] : _S(e.marks);
-    l.push(...tQ(l));
-    const u = ZZ(t, e),
+    } = e, c = Ng(e.className), u = e.marks === void 0 ? [] : B2(e.marks);
+    u.push(...uX(u));
+    const l = aX(t, e),
         f = /* @__PURE__ */ new Map();
-    for (const C of l) {
-        const z = xS(C, u, e);
-        z && f.set(C, z);
+    for (const F of u) {
+        const P = C2(F, l, e);
+        P && f.set(F, P);
     }
     const h = /* @__PURE__ */ new Map();
-    u && Tl(h, [u], e), Tl(h, f, e);
-    const d = _S(eQ(l, h, e));
-    for (const C of d) {
-        const z = xS(C, u, e);
-        z && f.set(C, z);
+    l && Pa(h, [l], e), Pa(h, f, e);
+    const d = B2(lX(u, h, e));
+    for (const F of d) {
+        const P = C2(F, l, e);
+        P && f.set(F, P);
     }
-    l.unshift(...d);
-    let p = PK(h, e);
+    u.unshift(...d);
+    let p = JY(h, e);
     if (p !== void 0) {
-        const C = u ? Xm(p, u) : void 0;
-        for (const P of l) {
-            if (P.facet === null || P.facet === "super")
+        const F = l ? jp(p, l) : void 0;
+        for (const U of u) {
+            if (U.facet === null || U.facet === "super")
                 continue;
-            const G = f.get(P);
-            G !== void 0 && (G.facetsIndex = P.fx != null || P.fy != null ? Xm(p, G) : C);
+            const Y = f.get(U);
+            Y !== void 0 && (Y.facetsIndex = U.fx != null || U.fy != null ? jp(p, Y) : F);
         }
-        const z = /* @__PURE__ */ new Set();
+        const P = /* @__PURE__ */ new Set();
         for (const {
-                facetsIndex: P
+                facetsIndex: U
             }
             of f.values())
-            P == null || P.forEach((G, K) => {
-                (G == null ? void 0 : G.length) > 0 && z.add(K);
+            U == null || U.forEach((Y, G) => {
+                (Y == null ? void 0 : Y.length) > 0 && P.add(G);
             });
         p.forEach(
-            0 < z.size && z.size < p.length ? (P, G) => P.empty = !z.has(G) : (P) => P.empty = !1
+            0 < P.size && P.size < p.length ? (U, Y) => U.empty = !P.has(Y) : (U) => U.empty = !1
         );
-        for (const P of l)
-            if (P.facet === "exclude") {
-                const G = f.get(P);
-                G !== void 0 && (G.facetsIndex = qK(G.facetsIndex));
+        for (const U of u)
+            if (U.facet === "exclude") {
+                const Y = f.get(U);
+                Y !== void 0 && (Y.facetsIndex = QY(Y.facetsIndex));
             }
     }
-    for (const C of Se.keys())
-        jo(e[C]) && C !== "fx" && C !== "fy" && h.set(C, []);
-    const m = /* @__PURE__ */ new Map();
-    for (const C of l) {
-        if (m.has(C))
+    for (const F of re.keys())
+        xs(e[F]) && F !== "fx" && F !== "fy" && h.set(F, []);
+    const y = /* @__PURE__ */ new Map();
+    for (const F of u) {
+        if (y.has(F))
             throw new Error("duplicate mark; each mark must be unique");
         const {
-            facetsIndex: z,
-            channels: P
-        } = f.get(C) ?? {}, {
-            data: G,
-            facets: K,
-            channels: et
-        } = C.initialize(z, P, e);
-        fv(et, e), m.set(C, {
-            data: G,
-            facets: K,
-            channels: et
-        });
-    }
-    const g = N1(Tl(h, m, e), e),
-        y = UK(g, l, e);
-    mK(g, y);
-    const b = nS(g),
+            facetsIndex: P,
+            channels: U
+        } = f.get(F) ?? {}, {
+            data: Y,
+            facets: G,
+            channels: K
+        } = F.initialize(P, U, e);
+        qg(K, e), y.set(F, {
+            data: Y,
+            facets: G,
+            channels: K
+        });
+    }
+    const m = by(Pa(h, y, e), e),
+        g = GY(m, u, e);
+    AY(m, g);
+    const b = b2(m),
         {
             fx: w,
             fy: v
         } = b,
-        x = w || v ? JD(g, y) : y,
-        _ = w || v ? cQ(b, y) : y,
-        I = $0(e),
-        A = I.document,
-        M = Ky("svg").call(A.documentElement);
-    let N = M;
-    I.ownerSVGElement = M, I.className = c, I.projection = NJ(e, x), I.filterFacets = (C, z) => Xm(p, {
-        channels: z,
-        groups: Qw(C, z)
-    }), I.getMarkState = (C) => {
-        const z = m.get(C),
-            P = f.get(C);
+        x = w || v ? jA(m, g) : g,
+        _ = w || v ? gX(b, g) : g,
+        M = Sd(e),
+        T = M.document,
+        $ = Xh("svg").call(T.documentElement);
+    let N = $;
+    M.ownerSVGElement = $, M.className = c, M.projection = PV(e, x), M.filterFacets = (F, P) => jp(p, {
+        channels: P,
+        groups: Og(F, P)
+    }), M.getMarkState = (F) => {
+        const P = y.get(F),
+            U = f.get(F);
         return {
-            ...z,
+            ...P,
             channels: {
-                ...z.channels,
-                ...P == null ? void 0 : P.channels
+                ...P.channels,
+                ...U == null ? void 0 : U.channels
             }
         };
-    }, I.dispatchValue = (C) => {
-        N.value !== C && (N.value = C, N.dispatchEvent(new Event("input", {
+    }, M.dispatchValue = (F) => {
+        N.value !== F && (N.value = F, N.dispatchEvent(new Event("input", {
             bubbles: !0
         })));
     };
-    const $ = /* @__PURE__ */ new Set();
-    for (const [C, z] of m)
-        if (C.initializer != null) {
-            const P = C.facet === "super" ? _ : x,
-                G = C.initializer(z.data, z.facets, z.channels, b, P, I);
-            if (G.data !== void 0 && (z.data = G.data), G.facets !== void 0 && (z.facets = G.facets), G.channels !== void 0) {
+    const A = /* @__PURE__ */ new Set();
+    for (const [F, P] of y)
+        if (F.initializer != null) {
+            const U = F.facet === "super" ? _ : x,
+                Y = F.initializer(P.data, P.facets, P.channels, b, U, M);
+            if (Y.data !== void 0 && (P.data = Y.data), Y.facets !== void 0 && (P.facets = Y.facets), Y.channels !== void 0) {
                 const {
-                    fx: K,
-                    fy: et,
-                    ...Z
-                } = G.channels;
-                KZ(Z), Object.assign(z.channels, Z);
-                for (const Y of Object.values(Z)) {
+                    fx: G,
+                    fy: K,
+                    ...H
+                } = Y.channels;
+                oX(H), Object.assign(P.channels, H);
+                for (const V of Object.values(H)) {
                     const {
-                        scale: X
-                    } = Y;
-                    X != null && !rJ(Se.get(X)) && (f4(Y, e), $.add(X));
+                        scale: W
+                    } = V;
+                    W != null && !dV(re.get(W)) && (i4(V, e), A.add(W));
                 }
-                (K != null || et != null) && f.set(C, !0);
+                (G != null || K != null) && f.set(F, !0);
             }
         }
-    if ($.size) {
-        const C = /* @__PURE__ */ new Map();
-        Tl(C, m, e, (K) => $.has(K)), Tl(h, m, e, (K) => $.has(K));
-        const z = aQ(N1(C, e), g),
+    if (A.size) {
+        const F = /* @__PURE__ */ new Map();
+        Pa(F, y, e, (G) => A.has(G)), Pa(h, y, e, (G) => A.has(G));
+        const P = mX(by(F, e), m),
             {
-                scales: P,
-                ...G
-            } = nS(z);
-        Object.assign(g, z), Object.assign(b, G), Object.assign(b.scales, P);
+                scales: U,
+                ...Y
+            } = b2(P);
+        Object.assign(m, P), Object.assign(b, Y), Object.assign(b.scales, U);
     }
-    let B, R;
-    p !== void 0 && (B = {
+    let D, R;
+    p !== void 0 && (D = {
         x: w == null ? void 0 : w.domain(),
         y: v == null ? void 0 : v.domain()
-    }, p = VK(p, B), R = jK(w, v, y));
-    for (const [C, z] of m)
-        z.values = C.scale(z.channels, b, I);
+    }, p = ZY(p, D), R = KY(w, v, g));
+    for (const [F, P] of y)
+        P.values = F.scale(P.channels, b, M);
     const {
         width: S,
-        height: T
-    } = y;
-    ce(M).attr("class", c).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", S).attr("height", T).attr("viewBox", `0 0 ${S} ${T}`).attr("aria-label", o).attr("aria-description", a).call(
-        (C) => (
+        height: I
+    } = g;
+    Wt($).attr("class", c).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", S).attr("height", I).attr("viewBox", `0 0 ${S} ${I}`).attr("aria-label", o).attr("aria-description", a).call(
+        (F) => (
             // Warning: if you edit this, change defaultClassName.
-            C.append("style").text(
+            F.append("style").text(
                 `:where(.${c}) {
   --plot-background: white;
   display: block;
   height: auto;
   height: intrinsic;
   max-width: 100%;
 }
 :where(.${c} text),
 :where(.${c} tspan) {
   white-space: pre;
 }`
             )
         )
-    ).call(Zw, n);
-    for (const C of l) {
+    ).call(Dg, n);
+    for (const F of u) {
         const {
-            channels: z,
-            values: P,
-            facets: G
-        } = m.get(C);
-        if (p === void 0 || C.facet === "super") {
-            let K = null;
-            if (G && (K = G[0], K = C.filter(K, z, P), K.length === 0))
+            channels: P,
+            values: U,
+            facets: Y
+        } = y.get(F);
+        if (p === void 0 || F.facet === "super") {
+            let G = null;
+            if (Y && (G = Y[0], G = F.filter(G, P, U), G.length === 0))
                 continue;
-            const et = C.render(K, b, P, _, I);
-            if (et == null)
+            const K = F.render(G, b, U, _, M);
+            if (K == null)
                 continue;
-            M.appendChild(et);
+            $.appendChild(K);
         } else {
-            let K;
-            for (const et of p) {
-                if (!(((U = C.facetAnchor) == null ? void 0 : U.call(C, p, B, et)) ?? !et.empty))
+            let G;
+            for (const K of p) {
+                if (!(((C = F.facetAnchor) == null ? void 0 : C.call(F, p, D, K)) ?? !K.empty))
                     continue;
-                let Z = null;
-                if (G) {
-                    const X = f.has(C);
-                    if (Z = G[X ? et.i : 0], Z = C.filter(Z, z, P), Z.length === 0)
+                let H = null;
+                if (Y) {
+                    const W = f.has(F);
+                    if (H = Y[W ? K.i : 0], H = F.filter(H, P, U), H.length === 0)
                         continue;
-                    !X && Z === G[0] && (Z = qo(Z)), Z.fx = et.x, Z.fy = et.y, Z.fi = et.i;
+                    !W && H === Y[0] && (H = Ss(H)), H.fx = K.x, H.fy = K.y, H.fi = K.i;
                 }
-                const Y = C.render(Z, b, P, x, I);
-                if (Y != null) {
-                    (K ?? (K = ce(M).append("g"))).append(() => Y).datum(et);
-                    for (const X of ["aria-label", "aria-description", "aria-hidden", "transform"])
-                        Y.hasAttribute(X) && (K.attr(X, Y.getAttribute(X)), Y.removeAttribute(X));
+                const V = F.render(H, b, U, x, M);
+                if (V != null) {
+                    (G ?? (G = Wt($).append("g"))).append(() => V).datum(K);
+                    for (const W of ["aria-label", "aria-description", "aria-hidden", "transform"])
+                        V.hasAttribute(W) && (G.attr(W, V.getAttribute(W)), V.removeAttribute(W));
                 }
             }
-            K == null || K.selectChildren().attr("transform", R);
+            G == null || G.selectChildren().attr("transform", R);
         }
     }
-    const D = CZ(g, I, e),
+    const E = WW(m, M, e),
         {
-            figure: L = i != null || r != null || s != null || D.length > 0
+            figure: k = r != null || i != null || s != null || E.length > 0
         } = e;
-    L && (N = A.createElement("figure"), N.className = `${c}-figure`, N.style.maxWidth = "initial", i != null && N.append(vS(A, i, "h2")), r != null && N.append(vS(A, r, "h3")), N.append(...D, M), s != null && N.append(GZ(A, s))), N.scale = xK(b.scales), N.legend = EZ(g, I, e);
-    const k = DJ();
-    return k > 0 && ce(M).append("text").attr("x", S).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("").append("title").text(`${k.toLocaleString("en-US")} warning${k === 1 ? "" : "s"}. Please check the console.`), N;
+    k && (N = T.createElement("figure"), N.className = `${c}-figure`, N.style.maxWidth = "initial", r != null && N.append(F2(T, r, "h2")), i != null && N.append(F2(T, i, "h3")), N.append(...E, $), s != null && N.append(nX(T, s))), N.scale = DY(b.scales), N.legend = jW(m, M, e);
+    const B = CV();
+    return B > 0 && Wt($).append("text").attr("x", S).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("").append("title").text(`${B.toLocaleString("en-US")} warning${B === 1 ? "" : "s"}. Please check the console.`), N;
 }
 
-function vS(e, t, n) {
+function F2(e, t, n) {
     if (t.ownerDocument)
         return t;
-    const i = e.createElement(n);
-    return i.append(t), i;
+    const r = e.createElement(n);
+    return r.append(t), r;
 }
 
-function GZ(e, t) {
+function nX(e, t) {
     const n = e.createElement("figcaption");
     return n.append(t), n;
 }
 
-function XZ({
+function rX({
     marks: e = [],
     ...t
 } = {}) {
-    return uv({
+    return zg({
         ...t,
         marks: [...e, this]
     });
 }
-fe.prototype.plot = XZ;
+Ht.prototype.plot = rX;
 
-function _S(e) {
-    return e.flat(1 / 0).filter((t) => t != null).map(HZ);
+function B2(e) {
+    return e.flat(1 / 0).filter((t) => t != null).map(iX);
 }
 
-function HZ(e) {
-    return typeof e.render == "function" ? e : new JZ(e);
+function iX(e) {
+    return typeof e.render == "function" ? e : new sX(e);
 }
-class JZ extends fe {
+class sX extends Ht {
     constructor(t) {
         if (typeof t != "function")
             throw new TypeError("invalid mark; missing render function");
         super(), this.render = t;
     }
     render() {}
 }
 
-function fv(e, t) {
+function qg(e, t) {
     for (const n in e)
-        f4(e[n], t);
+        i4(e[n], t);
     return e;
 }
 
-function f4(e, t) {
+function i4(e, t) {
     const {
         scale: n,
-        transform: i = !0
+        transform: r = !0
     } = e;
-    if (n == null || !i)
+    if (n == null || !r)
         return;
     const {
-        type: r,
+        type: i,
         percent: s,
         interval: o,
-        transform: a = s ? (c) => c * 100 : yD(o, r)
+        transform: a = s ? (c) => c * 100 : cA(o, i)
     } = t[n] ?? {};
-    a != null && (e.value = ye(e.value, a), e.transform = !1);
+    a != null && (e.value = Zt(e.value, a), e.transform = !1);
 }
 
-function KZ(e) {
+function oX(e) {
     for (const t in e)
-        BD(t, e[t]);
+        MA(t, e[t]);
 }
 
-function Tl(e, t, n, i = qH) {
-    var r, s;
+function Pa(e, t, n, r = Qj) {
+    var i, s;
     for (const {
             channels: o
         }
         of t.values())
         for (const a in o) {
             const c = o[a],
                 {
-                    scale: l
+                    scale: u
                 } = c;
-            if (l != null && i(l))
-                if (l === "projection") {
-                    if (!FJ(n)) {
-                        const u = ((r = n.x) == null ? void 0 : r.domain) === void 0,
+            if (u != null && r(u))
+                if (u === "projection") {
+                    if (!qV(n)) {
+                        const l = ((i = n.x) == null ? void 0 : i.domain) === void 0,
                             f = ((s = n.y) == null ? void 0 : s.domain) === void 0;
-                        if (u || f) {
-                            const [h, d] = LJ(c);
-                            u && Qm(e, "x", h), f && Qm(e, "y", d);
+                        if (l || f) {
+                            const [h, d] = VV(c);
+                            l && Gp(e, "x", h), f && Gp(e, "y", d);
                         }
                     }
                 } else
-                    Qm(e, l, c);
+                    Gp(e, u, c);
         }
     return e;
 }
 
-function Qm(e, t, n) {
-    const i = e.get(t);
-    i !== void 0 ? i.push(n) : e.set(t, [n]);
+function Gp(e, t, n) {
+    const r = e.get(t);
+    r !== void 0 ? r.push(n) : e.set(t, [n]);
 }
 
-function ZZ(e, t) {
+function aX(e, t) {
     if (e == null)
         return;
     const {
         x: n,
-        y: i
+        y: r
     } = e;
-    if (n == null && i == null)
+    if (n == null && r == null)
         return;
-    const r = Nn(e.data);
-    if (r == null)
+    const i = Qe(e.data);
+    if (i == null)
         throw new Error("missing facet data");
     const s = {};
-    n != null && (s.fx = Xu(r, {
+    n != null && (s.fx = Yc(i, {
         value: n,
         scale: "fx"
-    })), i != null && (s.fy = Xu(r, {
-        value: i,
+    })), r != null && (s.fy = Yc(i, {
+        value: r,
         scale: "fy"
-    })), fv(s, t);
-    const o = Qw(r, s);
+    })), qg(s, t);
+    const o = Og(i, s);
     return {
         channels: s,
         groups: o,
         data: e.data
     };
 }
 
-function xS(e, t, n) {
+function C2(e, t, n) {
     var c;
     if (e.facet === null || e.facet === "super")
         return;
     const {
-        fx: i,
-        fy: r
+        fx: r,
+        fy: i
     } = e;
-    if (i != null || r != null) {
-        const l = Nn(e.data ?? i ?? r);
-        if (l === void 0)
+    if (r != null || i != null) {
+        const u = Qe(e.data ?? r ?? i);
+        if (u === void 0)
             throw new Error(`missing facet data in ${e.ariaLabel}`);
-        if (l === null)
+        if (u === null)
             return;
-        const u = {};
-        return i != null && (u.fx = Xu(l, {
-            value: i,
-            scale: "fx"
-        })), r != null && (u.fy = Xu(l, {
+        const l = {};
+        return r != null && (l.fx = Yc(u, {
             value: r,
+            scale: "fx"
+        })), i != null && (l.fy = Yc(u, {
+            value: i,
             scale: "fy"
-        })), fv(u, n), {
-            channels: u,
-            groups: Qw(l, u)
+        })), qg(l, n), {
+            channels: l,
+            groups: Og(u, l)
         };
     }
     if (t === void 0)
         return;
     const {
         channels: s,
         groups: o,
         data: a
     } = t;
     if (e.facet !== "auto" || e.data === a)
         return {
             channels: s,
             groups: o
         };
-    a.length > 0 && (o.size > 1 || o.size === 1 && s.fx && s.fy && [...o][0][1].size > 1) && ((c = Nn(e.data)) == null ? void 0 : c.length) === a.length && ts(
+    a.length > 0 && (o.size > 1 || o.size === 1 && s.fx && s.fy && [...o][0][1].size > 1) && ((c = Qe(e.data)) == null ? void 0 : c.length) === a.length && ti(
         `Warning: the ${e.ariaLabel} mark appears to use faceted data, but isnt faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
     );
 }
 
-function QZ(e, t = {}) {
-    return Bn({
+function cX(e, t = {}) {
+    return tn({
         ...t,
         x: null,
         y: null
-    }, (n, i, r, s, o, a) => a.getMarkState(e));
+    }, (n, r, i, s, o, a) => a.getMarkState(e));
 }
 
-function tQ(e) {
+function uX(e) {
     const t = [];
     for (const n of e) {
-        let i = n.tip;
-        if (i) {
-            i === !0 ? i = {} : typeof i == "string" && (i = {
-                pointer: i
+        let r = n.tip;
+        if (r) {
+            r === !0 ? r = {} : typeof r == "string" && (r = {
+                pointer: r
             });
             let {
-                pointer: r,
+                pointer: i,
                 preferredAnchor: s
-            } = i;
-            r = /^x$/i.test(r) ? nv : /^y$/i.test(r) ? Yp : ev, i = r(QZ(n, i)), i.title = null, s === void 0 && (i.preferredAnchor = r === Yp ? "left" : "bottom");
-            const o = u4(n.data, i);
+            } = r;
+            i = /^x$/i.test(i) ? Ed : /^y$/i.test(i) ? Gc : Td, r = i(cX(n, r)), r.title = null, s === void 0 && (r.preferredAnchor = i === Gc ? "left" : "bottom");
+            const o = r4(n.data, r);
             o.facet = n.facet, o.facetAnchor = n.facetAnchor, t.push(o);
         }
     }
     return t;
 }
 
-function eQ(e, t, n) {
+function lX(e, t, n) {
     let {
-        projection: i,
-        x: r = {},
+        projection: r,
+        x: i = {},
         y: s = {},
         fx: o = {},
         fy: a = {},
         axis: c,
-        grid: l,
-        facet: u = {},
+        grid: u,
+        facet: l = {},
         facet: {
             axis: f = c,
             grid: h
-        } = u,
+        } = l,
         x: {
             axis: d = c,
-            grid: p = d === null ? null : l
-        } = r,
+            grid: p = d === null ? null : u
+        } = i,
         y: {
-            axis: m = c,
-            grid: g = m === null ? null : l
+            axis: y = c,
+            grid: m = y === null ? null : u
         } = s,
         fx: {
-            axis: y = f,
-            grid: b = y === null ? null : h
+            axis: g = f,
+            grid: b = g === null ? null : h
         } = o,
         fy: {
             axis: w = f,
             grid: v = w === null ? null : h
         } = a
     } = n;
-    (i || !jo(r) && !SS("x", e)) && (d = p = null), (i || !jo(s) && !SS("y", e)) && (m = g = null), t.has("fx") || (y = b = null), t.has("fy") || (w = v = null), d === void 0 && (d = !$h(e, "x")), m === void 0 && (m = !$h(e, "y")), y === void 0 && (y = !$h(e, "fx")), w === void 0 && (w = !$h(e, "fy")), d === !0 && (d = "bottom"), m === !0 && (m = "left"), y === !0 && (y = d === "top" || d === null ? "bottom" : "top"), w === !0 && (w = m === "right" || m === null ? "left" : "right");
+    (r || !xs(i) && !P2("x", e)) && (d = p = null), (r || !xs(s) && !P2("y", e)) && (y = m = null), t.has("fx") || (g = b = null), t.has("fy") || (w = v = null), d === void 0 && (d = !hl(e, "x")), y === void 0 && (y = !hl(e, "y")), g === void 0 && (g = !hl(e, "fx")), w === void 0 && (w = !hl(e, "fy")), d === !0 && (d = "bottom"), y === !0 && (y = "left"), g === !0 && (g = d === "top" || d === null ? "bottom" : "top"), w === !0 && (w = y === "right" || y === null ? "left" : "right");
     const x = [];
-    return Mh(x, v, X8, a), Ah(x, w, j8, "right", "left", u, a), Mh(x, b, J8, o), Ah(x, y, q8, "top", "bottom", u, o), Mh(x, g, G8, s), Ah(x, m, sv, "left", "right", n, s), Mh(x, p, H8, r), Ah(x, d, ov, "bottom", "top", n, r), x;
+    return fl(x, v, z$, a), ll(x, w, F$, "right", "left", l, a), fl(x, b, j$, o), ll(x, g, B$, "top", "bottom", l, o), fl(x, m, U$, s), ll(x, y, Fg, "left", "right", n, s), fl(x, p, q$, i), ll(x, d, Bg, "bottom", "top", n, i), x;
 }
 
-function Ah(e, t, n, i, r, s, o) {
+function ll(e, t, n, r, i, s, o) {
     if (!t)
         return;
-    const a = nQ(t);
-    o = iQ(a ? i : t, s, o);
+    const a = fX(t);
+    o = hX(a ? r : t, s, o);
     const {
         line: c
     } = o;
-    (n === sv || n === ov) && c && !zc(c) && e.push(lv(rQ(o))), e.push(n(o)), a && e.push(n({
+    (n === Fg || n === Bg) && c && !na(c) && e.push(Ug(dX(o))), e.push(n(o)), a && e.push(n({
         ...o,
-        anchor: r,
+        anchor: i,
         label: null
     }));
 }
 
-function Mh(e, t, n, i) {
-    !t || zc(t) || e.push(n(sQ(t, i)));
+function fl(e, t, n, r) {
+    !t || na(t) || e.push(n(pX(t, r)));
 }
 
-function nQ(e) {
+function fX(e) {
     return /^\s*both\s*$/i.test(e);
 }
 
-function iQ(e, t, {
+function hX(e, t, {
     line: n = t.line,
-    ticks: i,
-    tickSize: r,
+    ticks: r,
+    tickSize: i,
     tickSpacing: s,
     tickPadding: o,
     tickFormat: a,
     tickRotate: c,
-    fontVariant: l,
-    ariaLabel: u,
+    fontVariant: u,
+    ariaLabel: l,
     ariaDescription: f,
     label: h = t.label,
     labelAnchor: d,
     labelArrow: p = t.labelArrow,
-    labelOffset: m
+    labelOffset: y
 }) {
     return {
         anchor: e,
         line: n,
-        ticks: i,
-        tickSize: r,
+        ticks: r,
+        tickSize: i,
         tickSpacing: s,
         tickPadding: o,
         tickFormat: a,
         tickRotate: c,
-        fontVariant: l,
-        ariaLabel: u,
+        fontVariant: u,
+        ariaLabel: l,
         ariaDescription: f,
         label: h,
         labelAnchor: d,
         labelArrow: p,
-        labelOffset: m
+        labelOffset: y
     };
 }
 
-function rQ(e) {
+function dX(e) {
     const {
         anchor: t,
         line: n
     } = e;
     return {
         anchor: t,
         facetAnchor: t + "-empty",
         stroke: n === !0 ? void 0 : n
     };
 }
 
-function sQ(e, {
-    stroke: t = Lf(e) ? e : void 0,
-    ticks: n = oQ(e) ? e : void 0,
-    tickSpacing: i,
-    ariaLabel: r,
+function pX(e, {
+    stroke: t = Mu(e) ? e : void 0,
+    ticks: n = yX(e) ? e : void 0,
+    tickSpacing: r,
+    ariaLabel: i,
     ariaDescription: s
 }) {
     return {
         stroke: t,
         ticks: n,
-        tickSpacing: i,
-        ariaLabel: r,
+        tickSpacing: r,
+        ariaLabel: i,
         ariaDescription: s
     };
 }
 
-function oQ(e) {
+function yX(e) {
     switch (typeof e) {
         case "number":
             return !0;
         case "string":
-            return !Lf(e);
+            return !Mu(e);
     }
-    return hs(e) || typeof(e == null ? void 0 : e.range) == "function";
+    return li(e) || typeof(e == null ? void 0 : e.range) == "function";
 }
 
-function $h(e, t) {
+function hl(e, t) {
     const n = `${t}-axis `;
-    return e.some((i) => {
-        var r;
-        return (r = i.ariaLabel) == null ? void 0 : r.startsWith(n);
+    return e.some((r) => {
+        var i;
+        return (i = r.ariaLabel) == null ? void 0 : i.startsWith(n);
     });
 }
 
-function SS(e, t) {
+function P2(e, t) {
     for (const n of t)
-        for (const i in n.channels) {
+        for (const r in n.channels) {
             const {
-                scale: r
-            } = n.channels[i];
-            if (r === e || r === "projection")
+                scale: i
+            } = n.channels[r];
+            if (i === e || i === "projection")
                 return !0;
         }
     return !1;
 }
 
-function aQ(e, t) {
+function mX(e, t) {
     for (const n in e) {
-        const i = e[n],
-            r = t[n];
-        i.label === void 0 && r && (i.label = r.label);
+        const r = e[n],
+            i = t[n];
+        r.label === void 0 && i && (r.label = i.label);
     }
     return e;
 }
 
-function cQ({
+function gX({
     fx: e,
     fy: t
 }, n) {
     const {
-        marginTop: i,
-        marginRight: r,
+        marginTop: r,
+        marginRight: i,
         marginBottom: s,
         marginLeft: o,
         width: a,
         height: c
-    } = Xw(n), l = e && IS(e), u = t && IS(t);
+    } = Ig(n), u = e && U2(e), l = t && U2(t);
     return {
-        marginTop: t ? u[0] : i,
-        marginRight: e ? a - l[1] : r,
-        marginBottom: t ? c - u[1] : s,
-        marginLeft: e ? l[0] : o,
+        marginTop: t ? l[0] : r,
+        marginRight: e ? a - u[1] : i,
+        marginBottom: t ? c - l[1] : s,
+        marginLeft: e ? u[0] : o,
         // Some marks, namely the x- and y-axis labels, want to know what the
         // desired (rather than actual) margins are for positioning.
         inset: {
             marginTop: n.marginTop,
             marginRight: n.marginRight,
             marginBottom: n.marginBottom,
             marginLeft: n.marginLeft
         },
         width: a,
         height: c
     };
 }
 
-function IS(e) {
+function U2(e) {
     const t = e.domain();
     let n = e(t[0]),
-        i = e(t[t.length - 1]);
-    return i < n && ([n, i] = [i, n]), [n, i + e.bandwidth()];
+        r = e(t[t.length - 1]);
+    return r < n && ([n, r] = [r, n]), [n, r + e.bandwidth()];
 }
-const lQ = /* @__PURE__ */ new Map([
-    ["basis", fH],
-    ["basis-closed", hH],
-    ["basis-open", dH],
-    ["bundle", pH],
-    ["bump-x", tH],
-    ["bump-y", eH],
-    ["cardinal", yH],
-    ["cardinal-closed", mH],
-    ["cardinal-open", gH],
-    ["catmull-rom", bH],
-    ["catmull-rom-closed", wH],
-    ["catmull-rom-open", vH],
-    ["linear", Ff],
-    ["linear-closed", _H],
-    ["monotone-x", xH],
-    ["monotone-y", SH],
-    ["natural", IH],
-    ["step", AH],
-    ["step-after", $H],
-    ["step-before", MH]
+const bX = /* @__PURE__ */ new Map([
+    ["basis", vj],
+    ["basis-closed", _j],
+    ["basis-open", xj],
+    ["bundle", Sj],
+    ["bump-x", uj],
+    ["bump-y", lj],
+    ["cardinal", Mj],
+    ["cardinal-closed", Aj],
+    ["cardinal-open", $j],
+    ["catmull-rom", Ij],
+    ["catmull-rom-closed", Tj],
+    ["catmull-rom-open", Ej],
+    ["linear", xu],
+    ["linear-closed", Nj],
+    ["monotone-x", Dj],
+    ["monotone-y", Oj],
+    ["natural", Lj],
+    ["step", kj],
+    ["step-after", Fj],
+    ["step-before", Rj]
 ]);
 
-function hv(e = Ff, t) {
+function jg(e = xu, t) {
     if (typeof e == "function")
         return e;
-    const n = lQ.get(`${e}`.toLowerCase());
+    const n = bX.get(`${e}`.toLowerCase());
     if (!n)
         throw new Error(`unknown curve: ${e}`);
     if (t !== void 0) {
         if ("beta" in n)
             return n.beta(t);
         if ("tension" in n)
             return n.tension(t);
         if ("alpha" in n)
             return n.alpha(t);
     }
     return n;
 }
 
-function h4(e = jc, t) {
-    return typeof e != "function" && `${e}`.toLowerCase() === "auto" ? jc : hv(e, t);
+function s4(e = sa, t) {
+    return typeof e != "function" && `${e}`.toLowerCase() === "auto" ? sa : jg(e, t);
 }
 
-function jc(e) {
-    return Ff(e);
+function sa(e) {
+    return xu(e);
 }
 
-function Bs(e = {
+function Ai(e = {
     y: "count"
 }, t = {}) {
-    [e, t] = mv(e, t);
+    [e, t] = Xg(e, t);
     const {
         x: n,
-        y: i
+        y: r
     } = t;
-    return yv(Hp(n, t, Tt), null, null, i, e, jf(t));
+    return Wg(vh(n, t, yt), null, null, r, e, Ou(t));
 }
 
-function Os(e = {
+function $i(e = {
     x: "count"
 }, t = {}) {
-    [e, t] = mv(e, t);
+    [e, t] = Xg(e, t);
     const {
         x: n,
-        y: i
+        y: r
     } = t;
-    return yv(null, Hp(i, t, Tt), n, null, e, qf(t));
+    return Wg(null, vh(r, t, yt), n, null, e, Lu(t));
 }
 
-function No(e = {
+function ls(e = {
     fill: "count"
 }, t = {}) {
-    [e, t] = mv(e, t);
+    [e, t] = Xg(e, t);
     const {
         x: n,
-        y: i
-    } = uQ(t);
-    return yv(n, i, null, null, e, jf(qf(t)));
+        y: r
+    } = wX(t);
+    return Wg(n, r, null, null, e, Ou(Lu(t)));
 }
 
-function d4(e, t, n = {}) {
+function o4(e, t, n = {}) {
     if ((n == null ? void 0 : n.interval) == null)
         return n;
     const {
-        reduce: i = jw
-    } = n, r = {
+        reduce: r = xg
+    } = n, i = {
         filter: null
     };
-    return n[t] != null && (r[t] = i), n[`${t}1`] != null && (r[`${t}1`] = i), n[`${t}2`] != null && (r[`${t}2`] = i), e(r, n);
+    return n[t] != null && (i[t] = r), n[`${t}1`] != null && (i[`${t}1`] = r), n[`${t}2`] != null && (i[`${t}2`] = r), e(i, n);
 }
 
-function dv(e = {}) {
-    return d4(Bs, "y", fa(e, "x"));
+function Vg(e = {}) {
+    return o4(Ai, "y", js(e, "x"));
 }
 
-function pv(e = {}) {
-    return d4(Os, "x", fa(e, "y"));
+function Yg(e = {}) {
+    return o4($i, "x", js(e, "y"));
 }
 
-function yv(e, t, n, i, {
-    data: r = Vw,
+function Wg(e, t, n, r, {
+    data: i = _g,
     // TODO avoid materializing when unused?
-    filter: s = Pp,
+    filter: s = ph,
     // return only non-empty bins by default
     sort: o,
     reverse: a,
     ...c
     // output channel definitions
-} = {}, l = {}) {
-    e = AS(e), t = AS(t), c = fQ(c, l), r = g4(r, Tt), o = o == null ? void 0 : y4("sort", o, l), s = s == null ? void 0 : m4("filter", s, l), n != null && Rs(c, "x", "x1", "x2") && (n = null), i != null && Rs(c, "y", "y1", "y2") && (i = null);
-    const [u, f] = xn(e), [h, d] = xn(e), [p, m] = xn(t), [g, y] = xn(t), [b, w] = n != null ? [n, "x"] : i != null ? [i, "y"] : [], [v, x] = xn(b), {
+} = {}, u = {}) {
+    e = z2(e), t = z2(t), c = vX(c, u), i = l4(i, yt), o = o == null ? void 0 : c4("sort", o, u), s = s == null ? void 0 : u4("filter", s, u), n != null && Ni(c, "x", "x1", "x2") && (n = null), r != null && Ni(c, "y", "y1", "y2") && (r = null);
+    const [l, f] = We(e), [h, d] = We(e), [p, y] = We(t), [m, g] = We(t), [b, w] = n != null ? [n, "x"] : r != null ? [r, "y"] : [], [v, x] = We(b), {
         x: _,
-        y: I,
-        z: A,
-        fill: M,
+        y: M,
+        z: T,
+        fill: $,
         stroke: N,
-        x1: $,
-        x2: B,
+        x1: A,
+        x2: D,
         // consumed if x is an output
         y1: R,
         y2: S,
         // consumed if y is an output
-        domain: T,
-        cumulative: D,
-        thresholds: L,
-        interval: k,
-        ...U
-    } = l, [C, z] = xn(A), [P] = mn(M), [G] = mn(N), [K, et] = xn(P), [Z, Y] = xn(G);
-    return {
-        ..."z" in l && {
-            z: C || A
-        },
-        ..."fill" in l && {
-            fill: K || M
-        },
-        ..."stroke" in l && {
-            stroke: Z || N
-        },
-        ...vr(U, (X, j, J) => {
-            const tt = zp(Pt(X, b), J == null ? void 0 : J[w]),
-                V = Pt(X, A),
-                Ft = Pt(X, P),
-                rt = Pt(X, G),
-                Vt = Pw(c, {
-                    z: V,
-                    fill: Ft,
-                    stroke: rt
+        domain: I,
+        cumulative: E,
+        thresholds: k,
+        interval: B,
+        ...C
+    } = u, [F, P] = We(T), [U] = ze($), [Y] = ze(N), [G, K] = We(U), [H, V] = We(Y);
+    return {
+        ..."z" in u && {
+            z: F || T
+        },
+        ..."fill" in u && {
+            fill: G || $
+        },
+        ..."stroke" in u && {
+            stroke: H || N
+        },
+        ...$r(C, (W, q, X) => {
+            const Z = dh($t(W, b), X == null ? void 0 : X[w]),
+                z = $t(W, T),
+                wt = $t(W, U),
+                tt = $t(W, Y),
+                It = vg(c, {
+                    z,
+                    fill: wt,
+                    stroke: tt
                 }),
-                jt = [],
-                Q = [],
-                Zt = tt && x([]),
-                En = V && z([]),
-                zi = Ft && et([]),
-                SC = rt && Y([]),
-                x_ = e && f([]),
-                IC = e && d([]),
-                S_ = t && m([]),
-                AC = t && y([]),
-                MC = pQ(e, t, X);
-            let $C = 0;
-            for (const pa of c)
-                pa.initialize(X);
-            o && o.initialize(X), s && s.initialize(X);
-            for (const pa of j) {
-                const I_ = [];
-                for (const ya of c)
-                    ya.scope("facet", pa);
-                o && o.scope("facet", pa), s && s.scope("facet", pa);
-                for (const [ya, TC] of pc(pa, Vt))
-                    for (const [DC, th] of pc(TC, tt))
-                        for (const [Pi, xr] of MC(th))
-                            if (Vt && (xr.z = ya), !(s && !s.reduce(Pi, xr))) {
-                                I_.push($C++), Q.push(r.reduceIndex(Pi, X, xr)), tt && Zt.push(DC), V && En.push(Vt === V ? ya : V[(Pi.length > 0 ? Pi : th)[0]]), Ft && zi.push(Vt === Ft ? ya : Ft[(Pi.length > 0 ? Pi : th)[0]]), rt && SC.push(Vt === rt ? ya : rt[(Pi.length > 0 ? Pi : th)[0]]), x_ && (x_.push(xr.x1), IC.push(xr.x2)), S_ && (S_.push(xr.y1), AC.push(xr.y2));
-                                for (const NC of c)
-                                    NC.reduce(Pi, xr);
-                                o && o.reduce(Pi, xr);
+                Et = [],
+                J = [],
+                Bt = Z && x([]),
+                en = z && P([]),
+                Zn = wt && K([]),
+                TN = tt && V([]),
+                C1 = e && f([]),
+                EN = e && d([]),
+                P1 = t && y([]),
+                NN = t && g([]),
+                DN = SX(e, t, W);
+            let ON = 0;
+            for (const Vs of c)
+                Vs.initialize(W);
+            o && o.initialize(W), s && s.initialize(W);
+            for (const Vs of q) {
+                const U1 = [];
+                for (const Ys of c)
+                    Ys.scope("facet", Vs);
+                o && o.scope("facet", Vs), s && s.scope("facet", Vs);
+                for (const [Ys, LN] of Do(Vs, It))
+                    for (const [kN, Cu] of Do(LN, Z))
+                        for (const [Kn, Er] of DN(Cu))
+                            if (It && (Er.z = Ys), !(s && !s.reduce(Kn, Er))) {
+                                U1.push(ON++), J.push(i.reduceIndex(Kn, W, Er)), Z && Bt.push(kN), z && en.push(It === z ? Ys : z[(Kn.length > 0 ? Kn : Cu)[0]]), wt && Zn.push(It === wt ? Ys : wt[(Kn.length > 0 ? Kn : Cu)[0]]), tt && TN.push(It === tt ? Ys : tt[(Kn.length > 0 ? Kn : Cu)[0]]), C1 && (C1.push(Er.x1), EN.push(Er.x2)), P1 && (P1.push(Er.y1), NN.push(Er.y2));
+                                for (const RN of c)
+                                    RN.reduce(Kn, Er);
+                                o && o.reduce(Kn, Er);
                             }
-                jt.push(I_);
+                Et.push(U1);
             }
-            return TD(jt, o, a), {
-                data: Q,
-                facets: jt
+            return _A(Et, o, a), {
+                data: J,
+                facets: Et
             };
         }),
-        ...!Rs(c, "x") && (u ? {
-            x1: u,
+        ...!Ni(c, "x") && (l ? {
+            x1: l,
             x2: h,
-            x: Up(u, h)
+            x: hh(l, h)
         } : {
             x: _,
-            x1: $,
-            x2: B
+            x1: A,
+            x2: D
         }),
-        ...!Rs(c, "y") && (p ? {
+        ...!Ni(c, "y") && (p ? {
             y1: p,
-            y2: g,
-            y: Up(p, g)
+            y2: m,
+            y: hh(p, m)
         } : {
-            y: I,
+            y: M,
             y1: R,
             y2: S
         }),
         ...v && {
             [w]: v
         },
         ...Object.fromEntries(c.map(({
-            name: X,
-            output: j
-        }) => [X, j]))
+            name: W,
+            output: q
+        }) => [W, q]))
     };
 }
 
-function mv({
+function Xg({
     cumulative: e,
     domain: t,
     thresholds: n,
-    interval: i,
-    ...r
+    interval: r,
+    ...i
 }, s) {
-    return [r, {
+    return [i, {
         cumulative: e,
         domain: t,
         thresholds: n,
-        interval: i,
+        interval: r,
         ...s
     }];
 }
 
-function Hp(e, {
+function vh(e, {
     cumulative: t,
     domain: n,
-    thresholds: i,
-    interval: r
+    thresholds: r,
+    interval: i
 }, s) {
     return e = {
-        ...al(e)
-    }, e.domain === void 0 && (e.domain = n), e.cumulative === void 0 && (e.cumulative = t), e.thresholds === void 0 && (e.thresholds = i), e.interval === void 0 && (e.interval = r), e.value === void 0 && (e.value = s), e.thresholds = p4(e.thresholds, e.interval), e;
+        ...wa(e)
+    }, e.domain === void 0 && (e.domain = n), e.cumulative === void 0 && (e.cumulative = t), e.thresholds === void 0 && (e.thresholds = r), e.interval === void 0 && (e.interval = i), e.value === void 0 && (e.value = s), e.thresholds = a4(e.thresholds, e.interval), e;
 }
 
-function uQ(e) {
+function wX(e) {
     let {
         x: t,
         y: n
     } = e;
-    return t = Hp(t, e), n = Hp(n, e), [t.value, n.value] = ki(t.value, n.value), {
+    return t = vh(t, e), n = vh(n, e), [t.value, n.value] = Jn(t.value, n.value), {
         x: t,
         y: n
     };
 }
 
-function AS(e) {
+function z2(e) {
     if (e == null)
         return;
     const {
         value: t,
         cumulative: n,
-        domain: i = ke,
-        thresholds: r
+        domain: r = de,
+        thresholds: i
     } = e, s = (o) => {
-        let a = Pt(o, t),
+        let a = $t(o, t),
             c;
-        if (gn(a) || dQ(r)) {
-            a = ye(a, lD, Float64Array);
-            let [u, f] = typeof i == "function" ? i(a) : i, h = typeof r == "function" && !ec(r) ? r(a, u, f) : r;
-            typeof h == "number" && (h = c6(u, f, h)), ec(h) && (i === ke && (u = h.floor(u), f = h.offset(h.floor(f))), h = h.range(u, h.offset(f))), c = h;
+        if (qe(a) || xX(i)) {
+            a = Zt(a, nA, Float64Array);
+            let [l, f] = typeof r == "function" ? r(a) : r, h = typeof i == "function" && !bo(i) ? i(a, l, f) : i;
+            typeof h == "number" && (h = t6(l, f, h)), bo(h) && (r === de && (l = h.floor(l), f = h.offset(h.floor(f))), h = h.range(l, h.offset(f))), c = h;
         } else {
-            a = An(a);
-            let [u, f] = typeof i == "function" ? i(a) : i, h = typeof r == "function" && !ec(r) ? r(a, u, f) : r;
+            a = He(a);
+            let [l, f] = typeof r == "function" ? r(a) : r, h = typeof i == "function" && !bo(i) ? i(a, l, f) : i;
             if (typeof h == "number")
-                if (i === ke) {
-                    let d = Ou(u, f, h);
+                if (r === de) {
+                    let d = Ec(l, f, h);
                     if (isFinite(d))
                         if (d > 0) {
-                            let p = Math.round(u / d),
-                                m = Math.round(f / d);
-                            p * d <= u || --p, m * d > f || ++m;
-                            let g = m - p + 1;
-                            h = new Float64Array(g);
-                            for (let y = 0; y < g; ++y)
-                                h[y] = (p + y) * d;
+                            let p = Math.round(l / d),
+                                y = Math.round(f / d);
+                            p * d <= l || --p, y * d > f || ++y;
+                            let m = y - p + 1;
+                            h = new Float64Array(m);
+                            for (let g = 0; g < m; ++g)
+                                h[g] = (p + g) * d;
                         } else if (d < 0) {
                         d = -d;
-                        let p = Math.round(u * d),
-                            m = Math.round(f * d);
-                        p / d <= u || --p, m / d > f || ++m;
-                        let g = m - p + 1;
-                        h = new Float64Array(g);
-                        for (let y = 0; y < g; ++y)
-                            h[y] = (p + y) / d;
+                        let p = Math.round(l * d),
+                            y = Math.round(f * d);
+                        p / d <= l || --p, y / d > f || ++y;
+                        let m = y - p + 1;
+                        h = new Float64Array(m);
+                        for (let g = 0; g < m; ++g)
+                            h[g] = (p + g) / d;
                     } else
-                        h = [u];
+                        h = [l];
                     else
-                        h = [u];
+                        h = [l];
                 } else
-                    h = Ys(u, f, h);
+                    h = Ci(l, f, h);
             else
-                ec(h) && (i === ke && (u = h.floor(u), f = h.offset(h.floor(f))), h = h.range(u, h.offset(f)));
+                bo(h) && (r === de && (l = h.floor(l), f = h.offset(h.floor(f))), h = h.range(l, h.offset(f)));
             c = h;
         }
-        const l = [];
+        const u = [];
         if (c.length === 1)
-            l.push([c[0], c[0]]);
+            u.push([c[0], c[0]]);
         else
-            for (let u = 1; u < c.length; ++u)
-                l.push([c[u - 1], c[u]]);
-        return l.bin = (n < 0 ? mQ : n > 0 ? yQ : gv)(l, c, a), l;
+            for (let l = 1; l < c.length; ++l)
+                u.push([c[l - 1], c[l]]);
+        return u.bin = (n < 0 ? AX : n > 0 ? MX : Gg)(u, c, a), u;
     };
-    return s.label = wr(t), s;
+    return s.label = Ar(t), s;
 }
 
-function p4(e, t, n = MS) {
+function a4(e, t, n = q2) {
     if (e === void 0)
-        return t === void 0 ? n : ol(t);
+        return t === void 0 ? n : ba(t);
     if (typeof e == "string") {
         switch (e.toLowerCase()) {
             case "freedman-diaconis":
-                return Pz;
+                return Jk;
             case "scott":
-                return f3;
+                return rS;
             case "sturges":
-                return qb;
+                return Sm;
             case "auto":
-                return MS;
+                return q2;
         }
-        return Aw(e);
+        return ig(e);
     }
     return e;
 }
 
-function fQ(e, t) {
-    return SD(e, t, y4);
+function vX(e, t) {
+    return mA(e, t, c4);
 }
 
-function y4(e, t, n) {
-    return Uw(e, t, n, m4);
+function c4(e, t, n) {
+    return bg(e, t, n, u4);
 }
 
-function m4(e, t, n) {
-    return zw(e, t, n, g4);
+function u4(e, t, n) {
+    return wg(e, t, n, l4);
 }
 
-function g4(e, t) {
-    return M0(e, t, hQ);
+function l4(e, t) {
+    return xd(e, t, _X);
 }
 
-function hQ(e) {
+function _X(e) {
     switch (`${e}`.toLowerCase()) {
         case "x":
-            return gQ;
+            return $X;
         case "x1":
-            return wQ;
+            return TX;
         case "x2":
-            return vQ;
+            return EX;
         case "y":
-            return bQ;
+            return IX;
         case "y1":
-            return _Q;
+            return NX;
         case "y2":
-            return xQ;
+            return DX;
         case "z":
-            return DD;
+            return xA;
     }
     throw new Error(`invalid bin reduce: ${e}`);
 }
 
-function MS(e, t, n) {
-    return Math.min(200, f3(e, t, n));
+function q2(e, t, n) {
+    return Math.min(200, rS(e, t, n));
 }
 
-function dQ(e) {
-    return XH(e) || hs(e) && gn(e);
+function xX(e) {
+    return rV(e) || li(e) && qe(e);
 }
 
-function pQ(e, t, n) {
-    const i = e == null ? void 0 : e(n),
-        r = t == null ? void 0 : t(n);
-    return i && r ? function*(s) {
-        const o = i.bin(s);
-        for (const [a, [c, l]] of i.entries()) {
-            const u = r.bin(o[a]);
-            for (const [f, [h, d]] of r.entries())
-                yield [u[f], {
+function SX(e, t, n) {
+    const r = e == null ? void 0 : e(n),
+        i = t == null ? void 0 : t(n);
+    return r && i ? function*(s) {
+        const o = r.bin(s);
+        for (const [a, [c, u]] of r.entries()) {
+            const l = i.bin(o[a]);
+            for (const [f, [h, d]] of i.entries())
+                yield [l[f], {
                     data: n,
                     x1: c,
                     y1: h,
-                    x2: l,
+                    x2: u,
                     y2: d
                 }];
         }
-    } : i ? function*(s) {
-        const o = i.bin(s);
-        for (const [a, [c, l]] of i.entries())
+    } : r ? function*(s) {
+        const o = r.bin(s);
+        for (const [a, [c, u]] of r.entries())
             yield [o[a], {
                 data: n,
                 x1: c,
-                x2: l
+                x2: u
             }];
     } : function*(s) {
-        const o = r.bin(s);
-        for (const [a, [c, l]] of r.entries())
+        const o = i.bin(s);
+        for (const [a, [c, u]] of i.entries())
             yield [o[a], {
                 data: n,
                 y1: c,
-                y2: l
+                y2: u
             }];
     };
 }
 
-function gv(e, t, n) {
-    return t = An(t), (i) => {
+function Gg(e, t, n) {
+    return t = He(t), (r) => {
         var s;
-        const r = e.map(() => []);
-        for (const o of i)
-            (s = r[Wy(t, n[o]) - 1]) == null || s.push(o);
-        return r;
+        const i = e.map(() => []);
+        for (const o of r)
+            (s = i[qh(t, n[o]) - 1]) == null || s.push(o);
+        return i;
     };
 }
 
-function yQ(e, t, n) {
-    const i = gv(e, t, n);
-    return (r) => {
-        const s = i(r);
+function MX(e, t, n) {
+    const r = Gg(e, t, n);
+    return (i) => {
+        const s = r(i);
         for (let o = 1, a = s.length; o < a; ++o) {
             const c = s[o - 1],
-                l = s[o];
-            for (const u of c)
-                l.push(u);
+                u = s[o];
+            for (const l of c)
+                u.push(l);
         }
         return s;
     };
 }
 
-function mQ(e, t, n) {
-    const i = gv(e, t, n);
-    return (r) => {
-        const s = i(r);
+function AX(e, t, n) {
+    const r = Gg(e, t, n);
+    return (i) => {
+        const s = r(i);
         for (let o = s.length - 2; o >= 0; --o) {
             const a = s[o + 1],
                 c = s[o];
-            for (const l of a)
-                c.push(l);
+            for (const u of a)
+                c.push(u);
         }
         return s;
     };
 }
 
-function b4(e, t) {
+function f4(e, t) {
     const n = (+e + +t) / 2;
     return e instanceof Date ? new Date(n) : n;
 }
-const gQ = {
+const $X = {
         reduceIndex(e, t, {
             x1: n,
-            x2: i
+            x2: r
         }) {
-            return b4(n, i);
+            return f4(n, r);
         }
     },
-    bQ = {
+    IX = {
         reduceIndex(e, t, {
             y1: n,
-            y2: i
+            y2: r
         }) {
-            return b4(n, i);
+            return f4(n, r);
         }
     },
-    wQ = {
+    TX = {
         reduceIndex(e, t, {
             x1: n
         }) {
             return n;
         }
     },
-    vQ = {
+    EX = {
         reduceIndex(e, t, {
             x2: n
         }) {
             return n;
         }
     },
-    _Q = {
+    NX = {
         reduceIndex(e, t, {
             y1: n
         }) {
             return n;
         }
     },
-    xQ = {
+    DX = {
         reduceIndex(e, t, {
             y2: n
         }) {
             return n;
         }
     };
 
-function bv(e = {}) {
-    return fD(e) ? e : {
+function Hg(e = {}) {
+    return iA(e) ? e : {
         ...e,
-        x: Tt
+        x: yt
     };
 }
 
-function wv(e = {}) {
-    return hD(e) ? e : {
+function Jg(e = {}) {
+    return sA(e) ? e : {
         ...e,
-        y: Tt
+        y: yt
     };
 }
 
-function SQ(e, t) {
+function OX(e, t) {
     if (t.length === 1)
         return {
             data: e,
             facets: t
         };
     const n = e.length,
-        i = new Uint8Array(n);
-    let r = 0;
+        r = new Uint8Array(n);
+    let i = 0;
     for (const a of t)
         for (const c of a)
-            i[c] && ++r, i[c] = 1;
-    if (r === 0)
+            r[c] && ++i, r[c] = 1;
+    if (i === 0)
         return {
             data: e,
             facets: t
         };
-    e = Yu(e);
-    const s = e[aD] = new Uint32Array(n + r);
-    t = t.map((a) => Yu(a, Uint32Array));
+    e = qc(e);
+    const s = e[tA] = new Uint32Array(n + i);
+    t = t.map((a) => qc(a, Uint32Array));
     let o = n;
-    i.fill(0);
+    r.fill(0);
     for (const a of t)
-        for (let c = 0, l = a.length; c < l; ++c) {
-            const u = a[c];
-            i[u] ? (a[c] = o, e[o] = e[u], s[o] = u, ++o) : s[u] = u, i[u] = 1;
+        for (let c = 0, u = a.length; c < u; ++c) {
+            const l = a[c];
+            r[l] ? (a[c] = o, e[o] = e[l], s[o] = l, ++o) : s[l] = l, r[l] = 1;
         }
     return {
         data: e,
         facets: t
     };
 }
 
-function w4(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = fl(e));
+function h4(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = Sa(e));
     const {
         y1: n,
-        y: i = n,
-        x: r,
+        y: r = n,
+        x: i,
         ...s
-    } = t, [o, a, c, l] = hl(i, r, "y", "x", e, s);
+    } = t, [o, a, c, u] = Ma(r, i, "y", "x", e, s);
     return {
         ...o,
         y1: n,
         y: a,
         x1: c,
-        x2: l,
-        x: Up(c, l)
+        x2: u,
+        x: hh(c, u)
     };
 }
 
-function IQ(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = fl(e));
+function LX(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = Sa(e));
     const {
         y1: n,
-        y: i = n,
-        x: r
-    } = t, [s, o, a] = hl(i, r, "y", "x", e, t);
+        y: r = n,
+        x: i
+    } = t, [s, o, a] = Ma(r, i, "y", "x", e, t);
     return {
         ...s,
         y1: n,
         y: o,
         x: a
     };
 }
 
-function AQ(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = fl(e));
+function kX(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = Sa(e));
     const {
         y1: n,
-        y: i = n,
-        x: r
-    } = t, [s, o, , a] = hl(i, r, "y", "x", e, t);
+        y: r = n,
+        x: i
+    } = t, [s, o, , a] = Ma(r, i, "y", "x", e, t);
     return {
         ...s,
         y1: n,
         y: o,
         x: a
     };
 }
 
-function v4(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = fl(e));
+function d4(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = Sa(e));
     const {
         x1: n,
-        x: i = n,
-        y: r,
+        x: r = n,
+        y: i,
         ...s
-    } = t, [o, a, c, l] = hl(i, r, "x", "y", e, s);
+    } = t, [o, a, c, u] = Ma(r, i, "x", "y", e, s);
     return {
         ...o,
         x1: n,
         x: a,
         y1: c,
-        y2: l,
-        y: Up(c, l)
+        y2: u,
+        y: hh(c, u)
     };
 }
 
-function MQ(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = fl(e));
+function RX(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = Sa(e));
     const {
         x1: n,
-        x: i = n,
-        y: r
-    } = t, [s, o, a] = hl(i, r, "x", "y", e, t);
+        x: r = n,
+        y: i
+    } = t, [s, o, a] = Ma(r, i, "x", "y", e, t);
     return {
         ...s,
         x1: n,
         x: o,
         y: a
     };
 }
 
-function $Q(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = fl(e));
+function FX(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = Sa(e));
     const {
         x1: n,
-        x: i = n,
-        y: r
-    } = t, [s, o, , a] = hl(i, r, "x", "y", e, t);
+        x: r = n,
+        y: i
+    } = t, [s, o, , a] = Ma(r, i, "x", "y", e, t);
     return {
         ...s,
         x1: n,
         x: o,
         y: a
     };
 }
 
-function vv({
+function Zg({
     x: e,
     x1: t,
     x2: n,
-    ...i
+    ...r
 } = {}) {
-    return i = fa(i, "y"), t === void 0 && n === void 0 ? w4({
+    return r = js(r, "y"), t === void 0 && n === void 0 ? h4({
         x: e,
-        ...i
-    }) : ([t, n] = dD(e, t, n), {
-        ...i,
+        ...r
+    }) : ([t, n] = oA(e, t, n), {
+        ...r,
         x1: t,
         x2: n
     });
 }
 
-function _v({
+function Kg({
     y: e,
     y1: t,
     y2: n,
-    ...i
+    ...r
 } = {}) {
-    return i = fa(i, "x"), t === void 0 && n === void 0 ? v4({
+    return r = js(r, "x"), t === void 0 && n === void 0 ? d4({
         y: e,
-        ...i
-    }) : ([t, n] = dD(e, t, n), {
-        ...i,
+        ...r
+    }) : ([t, n] = oA(e, t, n), {
+        ...r,
         y1: t,
         y2: n
     });
 }
 
-function fl(e) {
+function Sa(e) {
     const {
         offset: t,
         order: n,
-        reverse: i,
-        ...r
+        reverse: r,
+        ...i
     } = e;
     return [{
         offset: t,
         order: n,
-        reverse: i
-    }, r];
+        reverse: r
+    }, i];
 }
-const TQ = {
+const BX = {
     length: !0
 };
 
-function hl(e, t = Mw, n, i, {
-    offset: r,
+function Ma(e, t = sg, n, r, {
+    offset: i,
     order: s,
     reverse: o
 }, a) {
     if (t === null)
-        throw new Error(`stack requires ${i}`);
-    const c = co(a),
-        [l, u] = xn(e),
-        [f, h] = Un(t),
-        [d, p] = Un(t);
-    return f.hint = d.hint = TQ, r = DQ(r), s = OQ(s, r, i), [
-        vr(a, (m, g, y) => {
+        throw new Error(`stack requires ${r}`);
+    const c = Qi(a),
+        [u, l] = We(e),
+        [f, h] = an(t),
+        [d, p] = an(t);
+    return f.hint = d.hint = BX, i = CX(i), s = zX(s, i, r), [
+        $r(a, (y, m, g) => {
             ({
-                data: m,
-                facets: g
-            } = SQ(m, g));
-            const b = e == null ? void 0 : u(zp(Pt(m, e), y == null ? void 0 : y[n])),
-                w = Pt(m, t, Float64Array),
-                v = Pt(m, c),
-                x = s && s(m, b, w, v),
-                _ = m.length,
-                I = h(new Float64Array(_)),
-                A = p(new Float64Array(_)),
-                M = [];
-            for (const N of g) {
-                const $ = b ? Array.from(us(N, (B) => b[B]).values()) : [N];
+                data: y,
+                facets: m
+            } = OX(y, m));
+            const b = e == null ? void 0 : l(dh($t(y, e), g == null ? void 0 : g[n])),
+                w = $t(y, t, Float64Array),
+                v = $t(y, c),
+                x = s && s(y, b, w, v),
+                _ = y.length,
+                M = h(new Float64Array(_)),
+                T = p(new Float64Array(_)),
+                $ = [];
+            for (const N of m) {
+                const A = b ? Array.from(ci(N, (D) => b[D]).values()) : [N];
                 if (x)
-                    for (const B of $)
-                        B.sort(x);
-                for (const B of $) {
+                    for (const D of A)
+                        D.sort(x);
+                for (const D of A) {
                     let R = 0,
                         S = 0;
-                    o && B.reverse();
-                    for (const T of B) {
-                        const D = w[T];
-                        D < 0 ? R = A[T] = (I[T] = R) + D : D > 0 ? S = A[T] = (I[T] = S) + D : A[T] = I[T] = S;
+                    o && D.reverse();
+                    for (const I of D) {
+                        const E = w[I];
+                        E < 0 ? R = T[I] = (M[I] = R) + E : E > 0 ? S = T[I] = (M[I] = S) + E : T[I] = M[I] = S;
                     }
                 }
-                M.push($);
+                $.push(A);
             }
-            return r && r(M, I, A, v), {
-                data: m,
-                facets: g
+            return i && i($, M, T, v), {
+                data: y,
+                facets: m
             };
         }),
-        l,
+        u,
         f,
         d
     ];
 }
 
-function DQ(e) {
+function CX(e) {
     if (e != null) {
         if (typeof e == "function")
             return e;
         switch (`${e}`.toLowerCase()) {
             case "expand":
             case "normalize":
-                return NQ;
+                return PX;
             case "center":
             case "silhouette":
-                return BQ;
+                return UX;
             case "wiggle":
-                return x4;
+                return y4;
         }
         throw new Error(`unknown offset: ${e}`);
     }
 }
 
-function _4(e, t) {
+function p4(e, t) {
     let n = 0,
-        i = 0;
-    for (const r of e) {
-        const s = t[r];
-        s < n && (n = s), s > i && (i = s);
+        r = 0;
+    for (const i of e) {
+        const s = t[i];
+        s < n && (n = s), s > r && (r = s);
     }
-    return [n, i];
+    return [n, r];
 }
 
-function NQ(e, t, n) {
-    for (const i of e)
-        for (const r of i) {
-            const [s, o] = _4(r, n);
-            for (const a of r) {
+function PX(e, t, n) {
+    for (const r of e)
+        for (const i of r) {
+            const [s, o] = p4(i, n);
+            for (const a of i) {
                 const c = 1 / (o - s || 1);
                 t[a] = c * (t[a] - s), n[a] = c * (n[a] - s);
             }
         }
 }
 
-function BQ(e, t, n) {
-    for (const i of e) {
-        for (const r of i) {
-            const [s, o] = _4(r, n);
-            for (const a of r) {
+function UX(e, t, n) {
+    for (const r of e) {
+        for (const i of r) {
+            const [s, o] = p4(i, n);
+            for (const a of i) {
                 const c = (o + s) / 2;
                 t[a] -= c, n[a] -= c;
             }
         }
-        S4(i, t, n);
+        m4(r, t, n);
     }
-    I4(e, t, n);
+    g4(e, t, n);
 }
 
-function x4(e, t, n, i) {
-    for (const r of e) {
-        const s = new Jo();
+function y4(e, t, n, r) {
+    for (const i of e) {
+        const s = new Ts();
         let o = 0;
-        for (const a of r) {
+        for (const a of i) {
             let c = -1;
-            const l = a.map((d) => Math.abs(n[d] - t[d])),
-                u = a.map((d) => {
-                    c = i ? i[d] : ++c;
+            const u = a.map((d) => Math.abs(n[d] - t[d])),
+                l = a.map((d) => {
+                    c = r ? r[d] : ++c;
                     const p = n[d] - t[d],
-                        m = s.has(c) ? p - s.get(c) : 0;
-                    return s.set(c, p), m;
+                        y = s.has(c) ? p - s.get(c) : 0;
+                    return s.set(c, p), y;
                 }),
-                f = [0, ...Oz(u)];
+                f = [0, ...zk(l)];
             for (const d of a)
                 t[d] += o, n[d] += o;
-            const h = fr(l);
-            h && (o -= fr(l, (d, p) => (u[p] / 2 + f[p]) * d) / h);
+            const h = wr(u);
+            h && (o -= wr(u, (d, p) => (l[p] / 2 + f[p]) * d) / h);
         }
-        S4(r, t, n);
+        m4(i, t, n);
     }
-    I4(e, t, n);
+    g4(e, t, n);
 }
 
-function S4(e, t, n) {
-    const i = Ye(e, (r) => Ye(r, (s) => t[s]));
-    for (const r of e)
-        for (const s of r)
-            t[s] -= i, n[s] -= i;
+function m4(e, t, n) {
+    const r = ve(e, (i) => ve(i, (s) => t[s]));
+    for (const i of e)
+        for (const s of i)
+            t[s] -= r, n[s] -= r;
 }
 
-function I4(e, t, n) {
-    const i = e.length;
-    if (i === 1)
+function g4(e, t, n) {
+    const r = e.length;
+    if (r === 1)
         return;
-    const r = e.map((a) => a.flat()),
-        s = r.map((a) => (Ye(a, (c) => t[c]) + De(a, (c) => n[c])) / 2),
-        o = Ye(s);
-    for (let a = 0; a < i; a++) {
+    const i = e.map((a) => a.flat()),
+        s = i.map((a) => (ve(a, (c) => t[c]) + ae(a, (c) => n[c])) / 2),
+        o = ve(s);
+    for (let a = 0; a < r; a++) {
         const c = o - s[a];
-        for (const l of r[a])
-            t[l] += c, n[l] += c;
+        for (const u of i[a])
+            t[u] += c, n[u] += c;
     }
 }
 
-function OQ(e, t, n) {
-    if (e === void 0 && t === x4)
-        return $S(li);
+function zX(e, t, n) {
+    if (e === void 0 && t === y4)
+        return j2(In);
     if (e != null) {
         if (typeof e == "string") {
-            const i = e.startsWith("-"),
-                r = i ? Cp : li;
-            switch ((i ? e.slice(1) : e).toLowerCase()) {
+            const r = e.startsWith("-"),
+                i = r ? lh : In;
+            switch ((r ? e.slice(1) : e).toLowerCase()) {
                 case "value":
                 case n:
-                    return FQ(r);
+                    return qX(i);
                 case "z":
-                    return EQ(r);
+                    return jX(i);
                 case "sum":
-                    return LQ(r);
+                    return VX(i);
                 case "appearance":
-                    return RQ(r);
+                    return YX(i);
                 case "inside-out":
-                    return $S(r);
+                    return j2(i);
             }
-            return TS(cD(e));
+            return V2(eA(e));
         }
         if (typeof e == "function")
-            return (e.length === 1 ? TS : CQ)(e);
+            return (e.length === 1 ? V2 : WX)(e);
         if (Array.isArray(e))
-            return kQ(e);
+            return XX(e);
         throw new Error(`invalid order: ${e}`);
     }
 }
 
-function FQ(e) {
-    return (t, n, i) => (r, s) => e(i[r], i[s]);
+function qX(e) {
+    return (t, n, r) => (i, s) => e(r[i], r[s]);
 }
 
-function EQ(e) {
-    return (t, n, i, r) => (s, o) => e(r[s], r[o]);
+function jX(e) {
+    return (t, n, r, i) => (s, o) => e(i[s], i[o]);
 }
 
-function LQ(e) {
-    return C0(
+function VX(e) {
+    return Rd(
         e,
-        (t, n, i, r) => jb(
-            fs(t),
-            (s) => fr(s, (o) => i[o]),
-            (s) => r[s]
+        (t, n, r, i) => xm(
+            ui(t),
+            (s) => wr(s, (o) => r[o]),
+            (s) => i[s]
         )
     );
 }
 
-function RQ(e) {
-    return C0(
+function YX(e) {
+    return Rd(
         e,
-        (t, n, i, r) => jb(
-            fs(t),
-            (s) => n[Yb(s, (o) => i[o])],
-            (s) => r[s]
+        (t, n, r, i) => xm(
+            ui(t),
+            (s) => n[Mm(s, (o) => r[o])],
+            (s) => i[s]
         )
     );
 }
 
-function $S(e) {
-    return C0(e, (t, n, i, r) => {
-        const s = fs(t),
-            o = jb(
+function j2(e) {
+    return Rd(e, (t, n, r, i) => {
+        const s = ui(t),
+            o = xm(
                 s,
-                (f) => n[Yb(f, (h) => i[h])],
-                (f) => r[f]
+                (f) => n[Mm(f, (h) => r[h])],
+                (f) => i[f]
             ),
-            a = uc(
+            a = Io(
                 s,
-                (f) => fr(f, (h) => i[h]),
-                (f) => r[f]
+                (f) => wr(f, (h) => r[h]),
+                (f) => i[f]
             ),
             c = [],
-            l = [];
-        let u = 0;
+            u = [];
+        let l = 0;
         for (const f of o)
-            u < 0 ? (u += a.get(f), c.push(f)) : (u -= a.get(f), l.push(f));
-        return l.reverse().concat(c);
+            l < 0 ? (l += a.get(f), c.push(f)) : (l -= a.get(f), u.push(f));
+        return u.reverse().concat(c);
     });
 }
 
-function TS(e) {
+function V2(e) {
     return (t) => {
-        const n = Pt(t, e);
-        return (i, r) => li(n[i], n[r]);
+        const n = $t(t, e);
+        return (r, i) => In(n[r], n[i]);
     };
 }
 
-function CQ(e) {
-    return (t) => (n, i) => e(t[n], t[i]);
+function WX(e) {
+    return (t) => (n, r) => e(t[n], t[r]);
 }
 
-function kQ(e) {
-    return C0(li, () => e);
+function XX(e) {
+    return Rd(In, () => e);
 }
 
-function C0(e, t) {
-    return (n, i, r, s) => {
+function Rd(e, t) {
+    return (n, r, i, s) => {
         if (!s)
             throw new Error("missing channel: z");
-        const o = new Jo(t(n, i, r, s).map((a, c) => [a, c]));
+        const o = new Ts(t(n, r, i, s).map((a, c) => [a, c]));
         return (a, c) => e(o.get(s[a]), o.get(s[c]));
     };
 }
-const UQ = {
+const GX = {
     ariaLabel: "area",
     strokeWidth: 1,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-class k0 extends fe {
+class Fd extends Ht {
     constructor(t, n = {}) {
         const {
-            x1: i,
-            y1: r,
+            x1: r,
+            y1: i,
             x2: s,
             y2: o,
             z: a,
             curve: c,
-            tension: l
+            tension: u
         } = n;
         super(
             t, {
                 x1: {
-                    value: i,
+                    value: r,
                     scale: "x"
                 },
                 y1: {
-                    value: r,
+                    value: i,
                     scale: "y"
                 },
                 x2: {
                     value: s,
                     scale: "x",
                     optional: !0
                 },
                 y2: {
                     value: o,
                     scale: "y",
                     optional: !0
                 },
                 z: {
-                    value: co(n),
+                    value: Qi(n),
                     optional: !0
                 }
             },
             n,
-            UQ
-        ), this.z = a, this.curve = hv(c, l);
+            GX
+        ), this.z = a, this.curve = jg(c, u);
     }
     filter(t) {
         return t;
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x1: o,
             y1: a,
             x2: c = o,
-            y2: l = a
-        } = i;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n, 0, 0).call(
-            (u) => u.selectAll().data(r8(t, [o, a, c, l], this, i)).enter().append("path").call(be, this).call(jp, this, i).attr(
+            y2: u = a
+        } = r;
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n, 0, 0).call(
+            (l) => l.selectAll().data(ZA(t, [o, a, c, u], this, r)).enter().append("path").call(Qt, this).call(yh, this, r).attr(
                 "d",
-                yw().curve(this.curve).defined((f) => f >= 0).x0((f) => o[f]).y0((f) => a[f]).x1((f) => c[f]).y1((f) => l[f])
+                Hm().curve(this.curve).defined((f) => f >= 0).x0((f) => o[f]).y0((f) => a[f]).x1((f) => c[f]).y1((f) => u[f])
             )
         ).node();
     }
 }
 
-function L1(e, t) {
-    return t === void 0 ? qc(e, {
-        x: w0,
-        y: qu
-    }) : new k0(e, t);
+function Sy(e, t) {
+    return t === void 0 ? oa(e, {
+        x: yd,
+        y: zc
+    }) : new Fd(e, t);
 }
 
-function Ju(e, t) {
+function Hc(e, t) {
     const {
-        y: n = vn,
-        ...i
-    } = pv(t);
-    return new k0(e, vv(bv({
-        ...i,
+        y: n = Ve,
+        ...r
+    } = Yg(t);
+    return new Fd(e, Zg(Hg({
+        ...r,
         y1: n,
         y2: void 0
     })));
 }
 
-function qc(e, t) {
+function oa(e, t) {
     const {
-        x: n = vn,
-        ...i
-    } = dv(t);
-    return new k0(e, _v(wv({
-        ...i,
+        x: n = Ve,
+        ...r
+    } = Vg(t);
+    return new Fd(e, Kg(Jg({
+        ...r,
         x1: n,
         x2: void 0
     })));
 }
-const zQ = {
+const HX = {
     ariaLabel: "link",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1
 };
-class A4 extends fe {
+class b4 extends Ht {
     constructor(t, n = {}) {
         const {
-            x1: i,
-            y1: r,
+            x1: r,
+            y1: i,
             x2: s,
             y2: o,
             curve: a,
             tension: c
         } = n;
         super(
             t, {
                 x1: {
-                    value: i,
+                    value: r,
                     scale: "x"
                 },
                 y1: {
-                    value: r,
+                    value: i,
                     scale: "y"
                 },
                 x2: {
                     value: s,
                     scale: "x",
                     optional: !0
                 },
                 y2: {
                     value: o,
                     scale: "y",
                     optional: !0
                 }
             },
             n,
-            zQ
-        ), this.curve = h4(a, c), cl(this, n);
+            HX
+        ), this.curve = s4(a, c), va(this, n);
     }
-    project(t, n, i) {
-        this.curve !== jc && super.project(t, n, i);
+    project(t, n, r) {
+        this.curve !== sa && super.project(t, n, r);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x1: o,
             y1: a,
             x2: c = o,
-            y2: l = a
-        } = i, {
-            curve: u
+            y2: u = a
+        } = r, {
+            curve: l
         } = this;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
-            (f) => f.selectAll().data(t).enter().append("path").call(be, this).attr(
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n).call(
+            (f) => f.selectAll().data(t).enter().append("path").call(Qt, this).attr(
                 "d",
-                u === jc && s.projection ? PQ(s.projection, o, a, c, l) : (h) => {
-                    const d = Xr(),
-                        p = u(d);
-                    return p.lineStart(), p.point(o[h], a[h]), p.point(c[h], l[h]), p.lineEnd(), d;
+                l === sa && s.projection ? JX(s.projection, o, a, c, u) : (h) => {
+                    const d = Gr(),
+                        p = l(d);
+                    return p.lineStart(), p.point(o[h], a[h]), p.point(c[h], u[h]), p.lineEnd(), d;
                 }
-            ).call(Pe, this, i).call(Vf, this, i, s)
+            ).call(me, this, r).call(Du, this, r, s)
         ).node();
     }
 }
 
-function PQ(e, t, n, i, r) {
-    const s = oo(e);
-    return t = An(t), n = An(n), i = An(i), r = An(r), (o) => s({
+function JX(e, t, n, r, i) {
+    const s = Zi(e);
+    return t = He(t), n = He(n), r = He(r), i = He(i), (o) => s({
         type: "LineString",
         coordinates: [
             [t[o], n[o]],
-            [i[o], r[o]]
+            [r[o], i[o]]
         ]
     });
 }
 
-function M4(e, {
+function w4(e, {
     x: t,
     x1: n,
-    x2: i,
-    y: r,
+    x2: r,
+    y: i,
     y1: s,
     y2: o,
     ...a
 } = {}) {
-    return [n, i] = Jp(t, n, i), [s, o] = Jp(r, s, o), new A4(e, {
+    return [n, r] = _h(t, n, r), [s, o] = _h(i, s, o), new b4(e, {
         ...a,
         x1: n,
-        x2: i,
+        x2: r,
         y1: s,
         y2: o
     });
 }
 
-function Jp(e, t, n) {
+function _h(e, t, n) {
     if (e === void 0) {
         if (t === void 0) {
             if (n !== void 0)
                 return [n];
         } else if (n === void 0)
             return [t];
     } else {
         if (t === void 0)
             return n === void 0 ? [e] : [e, n];
         if (n === void 0)
             return [e, t];
     }
     return [t, n];
 }
-const VQ = {
+const ZX = {
     ariaLabel: "arrow",
     fill: "none",
     stroke: "currentColor",
     strokeLinecap: "round",
     strokeMiterlimit: 1,
     strokeWidth: 1.5
 };
-class $4 extends fe {
+class v4 extends Ht {
     constructor(t, n = {}) {
         const {
-            x1: i,
-            y1: r,
+            x1: r,
+            y1: i,
             x2: s,
             y2: o,
             bend: a = 0,
             headAngle: c = 60,
-            headLength: l = 8,
+            headLength: u = 8,
             // Disable the arrow with headLength = 0; or, use Plot.link.
-            inset: u = 0,
-            insetStart: f = u,
-            insetEnd: h = u,
+            inset: l = 0,
+            insetStart: f = l,
+            insetEnd: h = l,
             sweep: d
         } = n;
         super(
             t, {
                 x1: {
-                    value: i,
+                    value: r,
                     scale: "x"
                 },
                 y1: {
-                    value: r,
+                    value: i,
                     scale: "y"
                 },
                 x2: {
                     value: s,
                     scale: "x",
                     optional: !0
                 },
                 y2: {
                     value: o,
                     scale: "y",
                     optional: !0
                 }
             },
             n,
-            VQ
-        ), this.bend = a === !0 ? 22.5 : Math.max(-90, Math.min(90, a)), this.headAngle = +c, this.headLength = +l, this.insetStart = +f, this.insetEnd = +h, this.sweep = jQ(d);
+            ZX
+        ), this.bend = a === !0 ? 22.5 : Math.max(-90, Math.min(90, a)), this.headAngle = +c, this.headLength = +u, this.insetStart = +f, this.insetEnd = +h, this.sweep = KX(d);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x1: o,
             y1: a,
             x2: c = o,
-            y2: l = a,
-            SW: u
-        } = i, {
+            y2: u = a,
+            SW: l
+        } = r, {
             strokeWidth: f,
             bend: h,
             headAngle: d,
             headLength: p,
-            insetStart: m,
-            insetEnd: g
-        } = this, y = u ? (v) => u[v] : jn(f === void 0 ? 1 : f), b = d * Wp / 2, w = p / 1.5;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
-            (v) => v.selectAll().data(t).enter().append("path").call(be, this).attr("d", (x) => {
+            insetStart: y,
+            insetEnd: m
+        } = this, g = l ? (v) => l[v] : fn(f === void 0 ? 1 : f), b = d * gh / 2, w = p / 1.5;
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n).call(
+            (v) => v.selectAll().data(t).enter().append("path").call(Qt, this).attr("d", (x) => {
                 let _ = o[x],
-                    I = a[x],
-                    A = c[x],
-                    M = l[x];
-                const N = Math.hypot(A - _, M - I);
-                if (N <= m + g)
+                    M = a[x],
+                    T = c[x],
+                    $ = u[x];
+                const N = Math.hypot(T - _, $ - M);
+                if (N <= y + m)
                     return null;
-                let $ = Math.atan2(M - I, A - _);
-                const B = Math.min(w * y(x), N / 3),
-                    R = this.sweep(_, I, A, M) * h * Wp,
+                let A = Math.atan2($ - M, T - _);
+                const D = Math.min(w * g(x), N / 3),
+                    R = this.sweep(_, M, T, $) * h * gh,
                     S = Math.hypot(N / Math.tan(R), N) / 2;
-                if (m || g)
+                if (y || m)
                     if (S < 1e5) {
-                        const K = Math.sign(R),
-                            [et, Z] = qQ([_, I], [A, M], S, K);
-                        if (m && ([_, I] = DS([et, Z, S], [_, I, m], -K * Math.sign(m))), g) {
-                            const [Y, X] = DS([et, Z, S], [A, M, g], K * Math.sign(g));
-                            $ += Math.atan2(X - Z, Y - et) - Math.atan2(M - Z, A - et), A = Y, M = X;
+                        const G = Math.sign(R),
+                            [K, H] = QX([_, M], [T, $], S, G);
+                        if (y && ([_, M] = Y2([K, H, S], [_, M, y], -G * Math.sign(y))), m) {
+                            const [V, W] = Y2([K, H, S], [T, $, m], G * Math.sign(m));
+                            A += Math.atan2(W - H, V - K) - Math.atan2($ - H, T - K), T = V, $ = W;
                         }
                     } else {
-                        const K = A - _,
-                            et = M - I,
-                            Z = Math.hypot(K, et);
-                        m && (_ += K / Z * m, I += et / Z * m), g && (A -= K / Z * g, M -= et / Z * g);
+                        const G = T - _,
+                            K = $ - M,
+                            H = Math.hypot(G, K);
+                        y && (_ += G / H * y, M += K / H * y), m && (T -= G / H * m, $ -= K / H * m);
                     }
-                const T = $ + R,
-                    D = T + b,
-                    L = T - b,
-                    k = A - B * Math.cos(D),
-                    U = M - B * Math.sin(D),
-                    C = A - B * Math.cos(L),
-                    z = M - B * Math.sin(L),
-                    P = S < 1e5 ? `A${S},${S} 0,0,${R > 0 ? 1 : 0} ` : "L",
-                    G = B ? `M${k},${U}L${A},${M}L${C},${z}` : "";
-                return `M${_},${I}${P}${A},${M}${G}`;
-            }).call(Pe, this, i)
+                const I = A + R,
+                    E = I + b,
+                    k = I - b,
+                    B = T - D * Math.cos(E),
+                    C = $ - D * Math.sin(E),
+                    F = T - D * Math.cos(k),
+                    P = $ - D * Math.sin(k),
+                    U = S < 1e5 ? `A${S},${S} 0,0,${R > 0 ? 1 : 0} ` : "L",
+                    Y = D ? `M${B},${C}L${T},${$}L${F},${P}` : "";
+                return `M${_},${M}${U}${T},${$}${Y}`;
+            }).call(me, this, r)
         ).node();
     }
 }
 
-function jQ(e = 1) {
+function KX(e = 1) {
     if (typeof e == "number")
-        return jn(Math.sign(e));
+        return fn(Math.sign(e));
     if (typeof e == "function")
-        return (t, n, i, r) => Math.sign(e(t, n, i, r));
-    switch (qn(e, "sweep", ["+x", "-x", "+y", "-y"])) {
+        return (t, n, r, i) => Math.sign(e(t, n, r, i));
+    switch (hn(e, "sweep", ["+x", "-x", "+y", "-y"])) {
         case "+x":
-            return (t, n, i) => me(t, i);
+            return (t, n, r) => zt(t, r);
         case "-x":
-            return (t, n, i) => Ho(t, i);
+            return (t, n, r) => Is(t, r);
         case "+y":
-            return (t, n, i, r) => me(n, r);
+            return (t, n, r, i) => zt(n, i);
         case "-y":
-            return (t, n, i, r) => Ho(n, r);
+            return (t, n, r, i) => Is(n, i);
     }
 }
 
-function qQ([e, t], [n, i], r, s) {
+function QX([e, t], [n, r], i, s) {
     const o = n - e,
-        a = i - t,
+        a = r - t,
         c = Math.hypot(o, a),
-        l = s * Math.sqrt(r * r - c * c / 4) / c;
-    return [(e + n) / 2 - a * l, (t + i) / 2 + o * l];
+        u = s * Math.sqrt(i * i - c * c / 4) / c;
+    return [(e + n) / 2 - a * u, (t + r) / 2 + o * u];
 }
 
-function DS([e, t, n], [i, r, s], o) {
-    const a = i - e,
-        c = r - t,
-        l = Math.hypot(a, c),
-        u = (a * a + c * c - s * s + n * n) / (2 * l),
-        f = o * Math.sqrt(n * n - u * u);
-    return [e + (a * u + c * f) / l, t + (c * u - a * f) / l];
+function Y2([e, t, n], [r, i, s], o) {
+    const a = r - e,
+        c = i - t,
+        u = Math.hypot(a, c),
+        l = (a * a + c * c - s * s + n * n) / (2 * u),
+        f = o * Math.sqrt(n * n - l * l);
+    return [e + (a * l + c * f) / u, t + (c * l - a * f) / u];
 }
 
-function YQ(e, {
+function tG(e, {
     x: t,
     x1: n,
-    x2: i,
-    y: r,
+    x2: r,
+    y: i,
     y1: s,
     y2: o,
     ...a
 } = {}) {
-    return [n, i] = Jp(t, n, i), [s, o] = Jp(r, s, o), new $4(e, {
+    return [n, r] = _h(t, n, r), [s, o] = _h(i, s, o), new v4(e, {
         ...a,
         x1: n,
-        x2: i,
+        x2: r,
         y1: s,
         y2: o
     });
 }
-class xv extends fe {
-    constructor(t, n, i = {}, r) {
-        super(t, n, i, r);
+class Qg extends Ht {
+    constructor(t, n, r = {}, i) {
+        super(t, n, r, i);
         const {
             inset: s = 0,
             insetTop: o = s,
             insetRight: a = s,
             insetBottom: c = s,
-            insetLeft: l = s,
-            rx: u,
+            insetLeft: u = s,
+            rx: l,
             ry: f
-        } = i;
-        this.insetTop = qt(o), this.insetRight = qt(a), this.insetBottom = qt(c), this.insetLeft = qt(l), this.rx = Me(u, "auto"), this.ry = Me(f, "auto");
+        } = r;
+        this.insetTop = Nt(o), this.insetRight = Nt(a), this.insetBottom = Nt(c), this.insetLeft = Nt(u), this.rx = se(l, "auto"), this.ry = se(f, "auto");
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             rx: o,
             ry: a
         } = this;
-        return Gt("svg:g", s).call(ve, this, r, s).call(this._transform, this, n).call(
-            (c) => c.selectAll().data(t).enter().append("rect").call(be, this).attr("x", this._x(n, i, r)).attr("width", this._width(n, i, r)).attr("y", this._y(n, i, r)).attr("height", this._height(n, i, r)).call(yt, "rx", o).call(yt, "ry", a).call(Pe, this, i)
+        return Ot("svg:g", s).call(ee, this, i, s).call(this._transform, this, n).call(
+            (c) => c.selectAll().data(t).enter().append("rect").call(Qt, this).attr("x", this._x(n, r, i)).attr("width", this._width(n, r, i)).attr("y", this._y(n, r, i)).attr("height", this._height(n, r, i)).call(at, "rx", o).call(at, "ry", a).call(me, this, r)
         ).node();
     }
     _x(t, {
         x: n
     }, {
-        marginLeft: i
+        marginLeft: r
     }) {
         const {
-            insetLeft: r
+            insetLeft: i
         } = this;
-        return n ? (s) => n[s] + r : i + r;
+        return n ? (s) => n[s] + i : r + i;
     }
     _y(t, {
         y: n
     }, {
-        marginTop: i
+        marginTop: r
     }) {
         const {
-            insetTop: r
+            insetTop: i
         } = this;
-        return n ? (s) => n[s] + r : i + r;
+        return n ? (s) => n[s] + i : r + i;
     }
     _width({
         x: t
     }, {
         x: n
     }, {
-        marginRight: i,
-        marginLeft: r,
+        marginRight: r,
+        marginLeft: i,
         width: s
     }) {
         const {
             insetLeft: o,
             insetRight: a
-        } = this, c = n && t ? t.bandwidth() : s - i - r;
+        } = this, c = n && t ? t.bandwidth() : s - r - i;
         return Math.max(0, c - o - a);
     }
     _height({
         y: t
     }, {
         y: n
     }, {
-        marginTop: i,
-        marginBottom: r,
+        marginTop: r,
+        marginBottom: i,
         height: s
     }) {
         const {
             insetTop: o,
             insetBottom: a
-        } = this, c = n && t ? t.bandwidth() : s - i - r;
+        } = this, c = n && t ? t.bandwidth() : s - r - i;
         return Math.max(0, c - o - a);
     }
 }
-const T4 = {
+const _4 = {
     ariaLabel: "bar"
 };
-class D4 extends xv {
+class x4 extends Qg {
     constructor(t, n = {}) {
         const {
-            x1: i,
-            x2: r,
+            x1: r,
+            x2: i,
             y: s
         } = n;
         super(
             t, {
                 x1: {
-                    value: i,
+                    value: r,
                     scale: "x"
                 },
                 x2: {
-                    value: r,
+                    value: i,
                     scale: "x"
                 },
                 y: {
                     value: s,
                     scale: "y",
                     type: "band",
                     optional: !0
                 }
             },
             n,
-            T4
+            _4
         );
     }
     _transform(t, n, {
-        x: i
+        x: r
     }) {
-        t.call(ue, n, {
-            x: i
+        t.call(Gt, n, {
+            x: r
         }, 0, 0);
     }
     _x({
         x: t
     }, {
         x1: n,
-        x2: i
+        x2: r
     }, {
-        marginLeft: r
+        marginLeft: i
     }) {
         const {
             insetLeft: s
         } = this;
-        return oi(t) ? r + s : (o) => Math.min(n[o], i[o]) + s;
+        return Mn(t) ? i + s : (o) => Math.min(n[o], r[o]) + s;
     }
     _width({
         x: t
     }, {
         x1: n,
-        x2: i
+        x2: r
     }, {
-        marginRight: r,
+        marginRight: i,
         marginLeft: s,
         width: o
     }) {
         const {
             insetLeft: a,
             insetRight: c
         } = this;
-        return oi(t) ? o - r - s - a - c : (l) => Math.max(0, Math.abs(i[l] - n[l]) - a - c);
+        return Mn(t) ? o - i - s - a - c : (u) => Math.max(0, Math.abs(r[u] - n[u]) - a - c);
     }
 }
-class N4 extends xv {
+class S4 extends Qg {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y1: r,
+            x: r,
+            y1: i,
             y2: s
         } = n;
         super(
             t, {
                 y1: {
-                    value: r,
+                    value: i,
                     scale: "y"
                 },
                 y2: {
                     value: s,
                     scale: "y"
                 },
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     type: "band",
                     optional: !0
                 }
             },
             n,
-            T4
+            _4
         );
     }
     _transform(t, n, {
-        y: i
+        y: r
     }) {
-        t.call(ue, n, {
-            y: i
+        t.call(Gt, n, {
+            y: r
         }, 0, 0);
     }
     _y({
         y: t
     }, {
         y1: n,
-        y2: i
+        y2: r
     }, {
-        marginTop: r
+        marginTop: i
     }) {
         const {
             insetTop: s
         } = this;
-        return oi(t) ? r + s : (o) => Math.min(n[o], i[o]) + s;
+        return Mn(t) ? i + s : (o) => Math.min(n[o], r[o]) + s;
     }
     _height({
         y: t
     }, {
         y1: n,
-        y2: i
+        y2: r
     }, {
-        marginTop: r,
+        marginTop: i,
         marginBottom: s,
         height: o
     }) {
         const {
             insetTop: a,
             insetBottom: c
         } = this;
-        return oi(t) ? o - r - s - a - c : (l) => Math.max(0, Math.abs(i[l] - n[l]) - a - c);
+        return Mn(t) ? o - i - s - a - c : (u) => Math.max(0, Math.abs(r[u] - n[u]) - a - c);
     }
 }
 
-function Lo(e, t = {}) {
-    return v0(t) || (t = {
+function ms(e, t = {}) {
+    return md(t) || (t = {
         ...t,
-        y: vn,
-        x2: Tt
-    }), new D4(e, vv(y8(bv(t))));
+        y: Ve,
+        x2: yt
+    }), new x4(e, Zg(c$(Hg(t))));
 }
 
-function Ro(e, t = {}) {
-    return v0(t) || (t = {
+function gs(e, t = {}) {
+    return md(t) || (t = {
         ...t,
-        x: vn,
-        y2: Tt
-    }), new N4(e, _v(m8(wv(t))));
+        x: Ve,
+        y2: yt
+    }), new S4(e, Kg(u$(Jg(t))));
 }
-const WQ = {
+const eG = {
     ariaLabel: "cell"
 };
-class U0 extends xv {
+class Bd extends Qg {
     constructor(t, {
         x: n,
-        y: i,
-        ...r
+        y: r,
+        ...i
     } = {}) {
         super(
             t, {
                 x: {
                     value: n,
                     scale: "x",
                     type: "band",
                     optional: !0
                 },
                 y: {
-                    value: i,
+                    value: r,
                     scale: "y",
                     type: "band",
                     optional: !0
                 }
             },
-            r,
-            WQ
+            i,
+            eG
         );
     }
     _transform(t, n) {
-        t.call(ue, n, {}, 0, 0);
+        t.call(Gt, n, {}, 0, 0);
     }
 }
 
-function ic(e, {
+function vo(e, {
     x: t,
     y: n,
-    ...i
+    ...r
 } = {}) {
-    return [t, n] = ki(t, n), new U0(e, {
-        ...i,
+    return [t, n] = Jn(t, n), new Bd(e, {
+        ...r,
         x: t,
         y: n
     });
 }
 
-function GQ(e, {
-    x: t = vn,
+function nG(e, {
+    x: t = Ve,
     fill: n,
-    stroke: i,
-    ...r
+    stroke: r,
+    ...i
 } = {}) {
-    return n === void 0 && mn(i)[0] === void 0 && (n = Tt), new U0(e, {
-        ...r,
+    return n === void 0 && ze(r)[0] === void 0 && (n = yt), new Bd(e, {
+        ...i,
         x: t,
         fill: n,
-        stroke: i
+        stroke: r
     });
 }
 
-function XQ(e, {
-    y: t = vn,
+function rG(e, {
+    y: t = Ve,
     fill: n,
-    stroke: i,
-    ...r
+    stroke: r,
+    ...i
 } = {}) {
-    return n === void 0 && mn(i)[0] === void 0 && (n = Tt), new U0(e, {
-        ...r,
+    return n === void 0 && ze(r)[0] === void 0 && (n = yt), new Bd(e, {
+        ...i,
         y: t,
         fill: n,
-        stroke: i
+        stroke: r
     });
 }
-const HQ = {
+const iG = {
     ariaLabel: "dot",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1.5
 };
 
-function Sv(e) {
-    return e.sort === void 0 && e.reverse === void 0 ? _D({
+function t1(e) {
+    return e.sort === void 0 && e.reverse === void 0 ? pA({
         channel: "-r"
     }, e) : e;
 }
-class z0 extends fe {
+class Cd extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             r: s,
             rotate: o,
-            symbol: a = ju,
+            symbol: a = Uc,
             frameAnchor: c
-        } = n, [l, u] = Be(o, 0), [f, h] = cJ(a), [d, p] = Be(s, f == null ? 3 : 4.5);
+        } = n, [u, l] = ue(o, 0), [f, h] = gV(a), [d, p] = ue(s, f == null ? 3 : 4.5);
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     optional: !0
                 },
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y",
                     optional: !0
                 },
                 r: {
                     value: d,
                     scale: "r",
                     filter: Qr,
                     optional: !0
                 },
                 rotate: {
-                    value: l,
+                    value: u,
                     optional: !0
                 },
                 symbol: {
                     value: f,
                     scale: "auto",
                     optional: !0
                 }
             },
-            Sv(n),
-            HQ
-        ), this.r = p, this.rotate = u, this.symbol = h, this.frameAnchor = Rf(c);
+            t1(n),
+            iG
+        ), this.r = p, this.rotate = l, this.symbol = h, this.frameAnchor = Au(c);
         const {
-            channels: m
+            channels: y
         } = this, {
-            symbol: g
-        } = m;
-        if (g) {
+            symbol: m
+        } = y;
+        if (m) {
             const {
-                fill: y,
+                fill: g,
                 stroke: b
-            } = m;
-            g.hint = {
-                fill: y ? y.value === g.value ? "color" : "currentColor" : this.fill ?? "currentColor",
-                stroke: b ? b.value === g.value ? "color" : "currentColor" : this.stroke ?? "none"
+            } = y;
+            m.hint = {
+                fill: g ? g.value === m.value ? "color" : "currentColor" : this.fill ?? "currentColor",
+                stroke: b ? b.value === m.value ? "color" : "currentColor" : this.stroke ?? "none"
             };
         }
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y: l,
-            r: u,
+            y: u,
+            r: l,
             rotate: f,
             symbol: h
-        } = i, {
+        } = r, {
             r: d,
             rotate: p,
-            symbol: m
-        } = this, [g, y] = _r(this, r), b = m === ju, w = u ? void 0 : d * d * Math.PI;
-        return g0(d) && (t = []), Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+            symbol: y
+        } = this, [m, g] = Ir(this, i), b = y === Uc, w = l ? void 0 : d * d * Math.PI;
+        return dd(d) && (t = []), Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             x: c && o,
-            y: l && a
+            y: u && a
         }).call(
-            (v) => v.selectAll().data(t).enter().append(b ? "circle" : "path").call(be, this).call(
+            (v) => v.selectAll().data(t).enter().append(b ? "circle" : "path").call(Qt, this).call(
                 b ? (x) => {
-                    x.attr("cx", c ? (_) => c[_] : g).attr("cy", l ? (_) => l[_] : y).attr("r", u ? (_) => u[_] : d);
+                    x.attr("cx", c ? (_) => c[_] : m).attr("cy", u ? (_) => u[_] : g).attr("r", l ? (_) => l[_] : d);
                 } : (x) => {
                     x.attr(
                         "transform",
-                        F0`translate(${c ? (_) => c[_] : g},${l ? (_) => l[_] : y})${f ? (_) => ` rotate(${f[_]})` : p ? ` rotate(${p})` : ""}`
+                        Dd`translate(${c ? (_) => c[_] : m},${u ? (_) => u[_] : g})${f ? (_) => ` rotate(${f[_]})` : p ? ` rotate(${p})` : ""}`
                     ).attr(
                         "d",
-                        u && h ? (_) => {
-                            const I = Xr();
-                            return h[_].draw(I, u[_] * u[_] * Math.PI), I;
-                        } : u ? (_) => {
-                            const I = Xr();
-                            return m.draw(I, u[_] * u[_] * Math.PI), I;
+                        l && h ? (_) => {
+                            const M = Gr();
+                            return h[_].draw(M, l[_] * l[_] * Math.PI), M;
+                        } : l ? (_) => {
+                            const M = Gr();
+                            return y.draw(M, l[_] * l[_] * Math.PI), M;
                         } : h ? (_) => {
-                            const I = Xr();
-                            return h[_].draw(I, w), I;
+                            const M = Gr();
+                            return h[_].draw(M, w), M;
                         } : (() => {
-                            const _ = Xr();
-                            return m.draw(_, w), _;
+                            const _ = Gr();
+                            return y.draw(_, w), _;
                         })()
                     );
                 }
-            ).call(Pe, this, i)
+            ).call(me, this, r)
         ).node();
     }
 }
 
-function fo(e, {
+function ns(e, {
     x: t,
     y: n,
-    ...i
+    ...r
 } = {}) {
-    return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new z0(e, {
-        ...i,
+    return r.frameAnchor === void 0 && ([t, n] = Jn(t, n)), new Cd(e, {
+        ...r,
         x: t,
         y: n
     });
 }
 
-function JQ(e, {
-    x: t = Tt,
+function sG(e, {
+    x: t = yt,
     ...n
 } = {}) {
-    return new z0(e, b8({
+    return new Cd(e, f$({
         ...n,
         x: t
     }));
 }
 
-function KQ(e, {
-    y: t = Tt,
+function oG(e, {
+    y: t = yt,
     ...n
 } = {}) {
-    return new z0(e, g8({
+    return new Cd(e, l$({
         ...n,
         y: t
     }));
 }
 
-function ZQ(e, t) {
-    return fo(e, {
+function aG(e, t) {
+    return ns(e, {
         ...t,
         symbol: "circle"
     });
 }
 
-function QQ(e, t) {
-    return fo(e, {
+function cG(e, t) {
+    return ns(e, {
         ...t,
         symbol: "hexagon"
     });
 }
-const ttt = {
+const uG = {
     ariaLabel: "line",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1.5,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-class P0 extends fe {
+class Pd extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             z: s,
             curve: o,
             tension: a
         } = n;
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x"
                 },
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y"
                 },
                 z: {
-                    value: co(n),
+                    value: Qi(n),
                     optional: !0
                 }
             },
             n,
-            ttt
-        ), this.z = s, this.curve = h4(o, a), cl(this, n);
+            uG
+        ), this.z = s, this.curve = s4(o, a), va(this, n);
     }
     filter(t) {
         return t;
     }
-    project(t, n, i) {
-        this.curve !== jc && super.project(t, n, i);
+    project(t, n, r) {
+        this.curve !== sa && super.project(t, n, r);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
-        } = i, {
+        } = r, {
             curve: c
         } = this;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
-            (l) => l.selectAll().data(r8(t, [o, a], this, i)).enter().append("path").call(be, this).call(jp, this, i).call(sZ, this, i, s).attr(
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n).call(
+            (u) => u.selectAll().data(ZA(t, [o, a], this, r)).enter().append("path").call(Qt, this).call(yh, this, r).call(pW, this, r, s).attr(
                 "d",
-                c === jc && s.projection ? ett(s.projection, o, a) : NT().curve(c).defined((u) => u >= 0).x((u) => o[u]).y((u) => a[u])
+                c === sa && s.projection ? lG(s.projection, o, a) : xM().curve(c).defined((l) => l >= 0).x((l) => o[l]).y((l) => a[l])
             )
         ).node();
     }
 }
 
-function ett(e, t, n) {
-    const i = oo(e);
-    return t = An(t), n = An(n), (r) => {
+function lG(e, t, n) {
+    const r = Zi(e);
+    return t = He(t), n = He(n), (i) => {
         let s = [];
         const o = [s];
-        for (const a of r)
+        for (const a of i)
             a === -1 ? (s = [], o.push(s)) : s.push([t[a], n[a]]);
-        return i({
+        return r({
             type: "MultiLineString",
             coordinates: o
         });
     };
 }
 
-function V0(e, {
+function Ud(e, {
     x: t,
     y: n,
-    ...i
+    ...r
 } = {}) {
-    return [t, n] = ki(t, n), new P0(e, {
-        ...i,
+    return [t, n] = Jn(t, n), new Pd(e, {
+        ...r,
         x: t,
         y: n
     });
 }
 
-function Ku(e, {
-    x: t = Tt,
-    y: n = vn,
-    ...i
+function Jc(e, {
+    x: t = yt,
+    y: n = Ve,
+    ...r
 } = {}) {
-    return new P0(e, pv({
-        ...i,
+    return new Pd(e, Yg({
+        ...r,
         x: t,
         y: n
     }));
 }
 
-function Zu(e, {
-    x: t = vn,
-    y: n = Tt,
-    ...i
+function Zc(e, {
+    x: t = Ve,
+    y: n = yt,
+    ...r
 } = {}) {
-    return new P0(e, dv({
-        ...i,
+    return new Pd(e, Vg({
+        ...r,
         x: t,
         y: n
     }));
 }
-const ntt = {
+const fG = {
     ariaLabel: "rect"
 };
-class j0 extends fe {
+class zd extends Ht {
     constructor(t, n = {}) {
         const {
-            x1: i,
-            y1: r,
+            x1: r,
+            y1: i,
             x2: s,
             y2: o,
             inset: a = 0,
             insetTop: c = a,
-            insetRight: l = a,
-            insetBottom: u = a,
+            insetRight: u = a,
+            insetBottom: l = a,
             insetLeft: f = a,
             rx: h,
             ry: d
         } = n;
         super(
             t, {
                 x1: {
-                    value: i,
+                    value: r,
                     scale: "x",
-                    type: i != null && s == null ? "band" : void 0,
+                    type: r != null && s == null ? "band" : void 0,
                     optional: !0
                 },
                 y1: {
-                    value: r,
+                    value: i,
                     scale: "y",
-                    type: r != null && o == null ? "band" : void 0,
+                    type: i != null && o == null ? "band" : void 0,
                     optional: !0
                 },
                 x2: {
                     value: s,
                     scale: "x",
                     optional: !0
                 },
                 y2: {
                     value: o,
                     scale: "y",
                     optional: !0
                 }
             },
             n,
-            ntt
-        ), this.insetTop = qt(c), this.insetRight = qt(l), this.insetBottom = qt(u), this.insetLeft = qt(f), this.rx = Me(h, "auto"), this.ry = Me(d, "auto");
+            fG
+        ), this.insetTop = Nt(c), this.insetRight = Nt(u), this.insetBottom = Nt(l), this.insetLeft = Nt(f), this.rx = se(h, "auto"), this.ry = se(d, "auto");
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x1: c,
-            y1: l,
-            x2: u,
+            y1: u,
+            x2: l,
             y2: f
-        } = i, {
+        } = r, {
             marginTop: h,
             marginRight: d,
             marginBottom: p,
-            marginLeft: m,
-            width: g,
-            height: y
-        } = r, {
+            marginLeft: y,
+            width: m,
+            height: g
+        } = i, {
             projection: b
         } = s, {
             insetTop: w,
             insetRight: v,
             insetBottom: x,
             insetLeft: _,
-            rx: I,
-            ry: A
-        } = this, M = (o != null && o.bandwidth ? o.bandwidth() : 0) - _ - v, N = (a != null && a.bandwidth ? a.bandwidth() : 0) - w - x;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {}, 0, 0).call(
-            ($) => $.selectAll().data(t).enter().append("rect").call(be, this).attr(
+            rx: M,
+            ry: T
+        } = this, $ = (o != null && o.bandwidth ? o.bandwidth() : 0) - _ - v, N = (a != null && a.bandwidth ? a.bandwidth() : 0) - w - x;
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {}, 0, 0).call(
+            (A) => A.selectAll().data(t).enter().append("rect").call(Qt, this).attr(
                 "x",
-                c && (b || !oi(o)) ? u ? (B) => Math.min(c[B], u[B]) + _ : (B) => c[B] + _ : m + _
+                c && (b || !Mn(o)) ? l ? (D) => Math.min(c[D], l[D]) + _ : (D) => c[D] + _ : y + _
             ).attr(
                 "y",
-                l && (b || !oi(a)) ? f ? (B) => Math.min(l[B], f[B]) + w : (B) => l[B] + w : h + w
+                u && (b || !Mn(a)) ? f ? (D) => Math.min(u[D], f[D]) + w : (D) => u[D] + w : h + w
             ).attr(
                 "width",
-                c && (b || !oi(o)) ? u ? (B) => Math.max(0, Math.abs(u[B] - c[B]) + M) : M : g - d - m - v - _
+                c && (b || !Mn(o)) ? l ? (D) => Math.max(0, Math.abs(l[D] - c[D]) + $) : $ : m - d - y - v - _
             ).attr(
                 "height",
-                l && (b || !oi(a)) ? f ? (B) => Math.max(0, Math.abs(l[B] - f[B]) + N) : N : y - h - p - w - x
-            ).call(yt, "rx", I).call(yt, "ry", A).call(Pe, this, i)
+                u && (b || !Mn(a)) ? f ? (D) => Math.max(0, Math.abs(u[D] - f[D]) + N) : N : g - h - p - w - x
+            ).call(at, "rx", M).call(at, "ry", T).call(me, this, r)
         ).node();
     }
 }
 
-function Iv(e, t) {
-    return new j0(e, d8(p8(t)));
+function e1(e, t) {
+    return new zd(e, o$(a$(t)));
 }
 
-function Kp(e, t = {}) {
-    return v0(t) || (t = {
+function xh(e, t = {}) {
+    return md(t) || (t = {
         ...t,
-        y: vn,
-        x2: Tt,
+        y: Ve,
+        x2: yt,
         interval: 1
-    }), new j0(e, vv(p8(bv(t))));
+    }), new zd(e, Zg(a$(Hg(t))));
 }
 
-function Zp(e, t = {}) {
-    return v0(t) || (t = {
+function Sh(e, t = {}) {
+    return md(t) || (t = {
         ...t,
-        x: vn,
-        y2: Tt,
+        x: Ve,
+        y2: yt,
         interval: 1
-    }), new j0(e, _v(d8(wv(t))));
+    }), new zd(e, Kg(o$(Jg(t))));
 }
 
-function B4(e, t) {
-    t = rtt(t);
+function M4(e, t) {
+    t = dG(t);
     const {
         x: n,
-        y: i,
-        color: r,
+        y: r,
+        color: i,
         size: s
-    } = t, o = Th(e, n), a = Th(e, i), c = Th(e, r), l = Th(e, s);
+    } = t, o = dl(e, n), a = dl(e, r), c = dl(e, i), u = dl(e, s);
     let {
-        fx: u,
+        fx: l,
         fy: f,
         x: {
             value: h,
             reduce: d,
             zero: p,
-            ...m
+            ...y
         },
         y: {
-            value: g,
-            reduce: y,
+            value: m,
+            reduce: g,
             zero: b,
             ...w
         },
         color: {
             value: v,
             color: x,
             reduce: _
         },
         size: {
-            value: I,
-            reduce: A
+            value: M,
+            reduce: T
         },
         // TODO constant radius?
-        mark: M
+        mark: $
     } = t;
-    if (d === void 0 && (d = y == null && h == null && I == null && g != null ? "count" : null), y === void 0 && (y = d == null && g == null && I == null && h != null ? "count" : null), A === void 0 && I == null && _ == null && d == null && y == null && (h == null || Ae(o)) && (g == null || Ae(a)) && (A = "count"), p === void 0 && (p = Dh(d) ? !0 : void 0), b === void 0 && (b = Dh(y) ? !0 : void 0), h == null && g == null)
+    if (d === void 0 && (d = g == null && h == null && M == null && m != null ? "count" : null), g === void 0 && (g = d == null && m == null && M == null && h != null ? "count" : null), T === void 0 && M == null && _ == null && d == null && g == null && (h == null || ie(o)) && (m == null || ie(a)) && (T = "count"), p === void 0 && (p = pl(d) ? !0 : void 0), b === void 0 && (b = pl(g) ? !0 : void 0), h == null && m == null)
         throw new Error("must specify x or y");
-    if (d != null && g == null)
+    if (d != null && m == null)
         throw new Error("reducing x requires y");
-    if (y != null && h == null)
+    if (g != null && h == null)
         throw new Error("reducing y requires x");
-    M === void 0 && (M = I != null || A != null ? "dot" : Dh(d) || Dh(y) || _ != null ? "bar" : h != null && g != null ? Ae(o) || Ae(a) || d == null && y == null && !Dl(o) && !Dl(a) ? "dot" : "line" : h != null || g != null ? "rule" : null);
-    let N, $, B;
-    switch (M) {
+    $ === void 0 && ($ = M != null || T != null ? "dot" : pl(d) || pl(g) || _ != null ? "bar" : h != null && m != null ? ie(o) || ie(a) || d == null && g == null && !Ua(o) && !Ua(a) ? "dot" : "line" : h != null || m != null ? "rule" : null);
+    let N, A, D;
+    switch ($) {
         case "dot":
-            B = fo, $ = "stroke";
+            D = ns, A = "stroke";
             break;
         case "line":
-            B = o && a || d != null || y != null ? b || y != null || o && Dl(o) ? Zu : p || d != null || a && Dl(a) ? Ku : V0 : o ? Ku : Zu, $ = "stroke", BS(c) && (N = null);
+            D = o && a || d != null || g != null ? b || g != null || o && Ua(o) ? Zc : p || d != null || a && Ua(a) ? Jc : Ud : o ? Jc : Zc, A = "stroke", X2(c) && (N = null);
             break;
         case "area":
-            B = !(b || y != null) && (p || d != null || a && Dl(a)) ? Ju : qc, $ = "fill", BS(c) && (N = null);
+            D = !(b || g != null) && (p || d != null || a && Ua(a)) ? Hc : oa, A = "fill", X2(c) && (N = null);
             break;
         case "rule":
-            B = o ? Js : Ks, $ = "stroke";
+            D = o ? ji : Vi, A = "stroke";
             break;
         case "bar":
-            B = d != null ? Ae(a) ? NS(d) && o && Ae(o) ? ic : Lo : Kp : y != null ? Ae(o) ? NS(y) && a && Ae(a) ? ic : Ro : Zp : _ != null || A != null ? o && Ae(o) && a && Ae(a) ? ic : o && Ae(o) ? Ro : a && Ae(a) ? Lo : Iv : o && nc(o) && !(a && nc(a)) ? Lo : a && nc(a) && !(o && nc(o)) ? Ro : ic, $ = "fill";
+            D = d != null ? ie(a) ? W2(d) && o && ie(o) ? vo : ms : xh : g != null ? ie(o) ? W2(g) && a && ie(a) ? vo : gs : Sh : _ != null || T != null ? o && ie(o) && a && ie(a) ? vo : o && ie(o) ? gs : a && ie(a) ? ms : e1 : o && wo(o) && !(a && wo(a)) ? ms : a && wo(a) && !(o && wo(o)) ? gs : vo, A = "fill";
             break;
         default:
-            throw new Error(`invalid mark: ${M}`);
+            throw new Error(`invalid mark: ${$}`);
     }
     let R = {
-            fx: u,
+            fx: l,
             fy: f,
             x: o ?? void 0,
             // treat null x as undefined for implicit stack
             y: a ?? void 0,
             // treat null y as undefined for implicit stack
-            [$]: c ?? x,
+            [A]: c ?? x,
             z: N,
-            r: l ?? void 0,
+            r: u ?? void 0,
             // treat null size as undefined for default constant radius
             tip: !0
         },
-        S, T = {
-            [$]: _ ?? void 0,
-            r: A ?? void 0
+        S, I = {
+            [A]: _ ?? void 0,
+            r: T ?? void 0
         };
-    if (d != null && y != null)
+    if (d != null && g != null)
         throw new Error("cannot reduce both x and y");
-    return y != null ? (T.y = y, S = Ae(o) ? Wu : Bs) : d != null ? (T.x = d, S = Ae(a) ? Gu : Os) : (_ != null || A != null) && (o && a ? S = Ae(o) && Ae(a) ? kw : Ae(o) ? Os : Ae(a) ? Bs : No : o ? S = Ae(o) ? Wu : Bs : a && (S = Ae(a) ? Gu : Os)), (S === No || S === Bs) && (R.x = {
+    return g != null ? (I.y = g, S = ie(o) ? jc : Ai) : d != null ? (I.x = d, S = ie(a) ? Vc : $i) : (_ != null || T != null) && (o && a ? S = ie(o) && ie(a) ? gg : ie(o) ? $i : ie(a) ? Ai : ls : o ? S = ie(o) ? jc : Ai : a && (S = ie(a) ? Vc : $i)), (S === ls || S === Ai) && (R.x = {
         value: o,
-        ...m
-    }), (S === No || S === Os) && (R.y = {
+        ...y
+    }), (S === ls || S === $i) && (R.y = {
         value: a,
         ...w
-    }), p === void 0 && (p = o && !(S === No || S === Bs) && (B === Lo || B === Ju || B === Kp || B === Ks)), b === void 0 && (b = a && !(S === No || S === Os) && (B === Ro || B === qc || B === Zp || B === Js)), {
-        fx: u ?? null,
+    }), p === void 0 && (p = o && !(S === ls || S === Ai) && (D === ms || D === Hc || D === xh || D === Vi)), b === void 0 && (b = a && !(S === ls || S === $i) && (D === gs || D === oa || D === Sh || D === ji)), {
+        fx: l ?? null,
         fy: f ?? null,
         x: {
             value: h ?? null,
             reduce: d ?? null,
             zero: !!p,
-            ...m
+            ...y
         },
         y: {
-            value: g ?? null,
-            reduce: y ?? null,
+            value: m ?? null,
+            reduce: g ?? null,
             zero: !!b,
             ...w
         },
         color: {
             value: v ?? null,
             reduce: _ ?? null,
             ...x !== void 0 && {
                 color: x
             }
         },
         size: {
-            value: I ?? null,
-            reduce: A ?? null
+            value: M ?? null,
+            reduce: T ?? null
         },
-        mark: M,
-        markImpl: OS[B],
+        mark: $,
+        markImpl: G2[D],
         markOptions: R,
-        transformImpl: OS[S],
-        transformOptions: T,
-        colorMode: $
+        transformImpl: G2[S],
+        transformOptions: I,
+        colorMode: A
     };
 }
 
-function itt(e, t) {
-    const n = B4(e, t),
+function hG(e, t) {
+    const n = M4(e, t),
         {
-            fx: i,
-            fy: r,
+            fx: r,
+            fy: i,
             x: {
                 zero: s
             },
             y: {
                 zero: o
             },
             markOptions: a,
             transformOptions: c,
-            colorMode: l
+            colorMode: u
         } = n,
-        u = R1[n.markImpl],
-        f = R1[n.transformImpl],
-        h = i != null || r != null ? lv({
+        l = My[n.markImpl],
+        f = My[n.transformImpl],
+        h = r != null || i != null ? Ug({
             strokeOpacity: 0.1
         }) : null,
-        d = [s ? Js([0]) : null, o ? Ks([0]) : null],
-        p = u(e, f ? f(c, a) : a);
-    return l === "stroke" ? ui(h, d, p) : ui(h, p, d);
+        d = [s ? ji([0]) : null, o ? Vi([0]) : null],
+        p = l(e, f ? f(c, a) : a);
+    return u === "stroke" ? Tn(h, d, p) : Tn(h, p, d);
 }
 
-function Dl(e) {
+function Ua(e) {
     let t, n;
-    for (const i of e) {
-        if (i == null)
+    for (const r of e) {
+        if (r == null)
             continue;
         if (t === void 0) {
-            t = i;
+            t = r;
             continue;
         }
-        const r = Math.sign(me(t, i));
-        if (r) {
-            if (n !== void 0 && r !== n)
+        const i = Math.sign(zt(t, r));
+        if (i) {
+            if (n !== void 0 && i !== n)
                 return !1;
-            t = i, n = r;
+            t = r, n = i;
         }
     }
     return !0;
 }
 
-function rtt({
+function dG({
     x: e,
     y: t,
     color: n,
-    size: i,
-    fx: r,
+    size: r,
+    fx: i,
     fy: s,
     mark: o
 } = {}) {
-    return Hi(e) || (e = Ma(e)), Hi(t) || (t = Ma(t)), Hi(n) || (n = Lf(n) ? {
+    return rr(e) || (e = no(e)), rr(t) || (t = no(t)), rr(n) || (n = Mu(n) ? {
         color: n
-    } : Ma(n)), Hi(i) || (i = Ma(i)), Hi(r) && ({
-        value: r
-    } = Ma(r)), Hi(s) && ({
+    } : no(n)), rr(r) || (r = no(r)), rr(i) && ({
+        value: i
+    } = no(i)), rr(s) && ({
         value: s
-    } = Ma(s)), o != null && (o = `${o}`.toLowerCase()), {
+    } = no(s)), o != null && (o = `${o}`.toLowerCase()), {
         x: e,
         y: t,
         color: n,
-        size: i,
-        fx: r,
+        size: r,
+        fx: i,
         fy: s,
         mark: o
     };
 }
 
-function Th(e, t) {
-    const n = Pt(e, t.value);
-    return n && (n.label = wr(t.value)), n;
+function dl(e, t) {
+    const n = $t(e, t.value);
+    return n && (n.label = Ar(t.value)), n;
 }
 
-function Ma(e) {
-    return stt(e) ? {
+function no(e) {
+    return pG(e) ? {
         reduce: e
     } : {
         value: e
     };
 }
 
-function Dh(e) {
+function pl(e) {
     return /^(?:distinct|count|sum|proportion)$/i.test(e);
 }
 
-function NS(e) {
+function W2(e) {
     return /^(?:first|last|mode)$/i.test(e);
 }
 
-function stt(e) {
+function pG(e) {
     if (e == null)
         return !1;
-    if (typeof e.reduceIndex == "function" || typeof e.reduce == "function" && hi(e) || /^p\d{2}$/i.test(e))
+    if (typeof e.reduceIndex == "function" || typeof e.reduce == "function" && En(e) || /^p\d{2}$/i.test(e))
         return !0;
     switch (`${e}`.toLowerCase()) {
         case "first":
         case "last":
         case "count":
         case "distinct":
         case "sum":
@@ -32200,916 +32763,916 @@
         case "variance":
         case "mode":
             return !0;
     }
     return !1;
 }
 
-function BS(e) {
-    return e ? new el(e).size > e.length >> 1 : !1;
+function X2(e) {
+    return e ? new da(e).size > e.length >> 1 : !1;
 }
-const R1 = {
-        dot: fo,
-        line: V0,
-        lineX: Ku,
-        lineY: Zu,
-        areaX: Ju,
-        areaY: qc,
-        ruleX: Js,
-        ruleY: Ks,
-        barX: Lo,
-        barY: Ro,
-        rect: Iv,
-        rectX: Kp,
-        rectY: Zp,
-        cell: ic,
-        bin: No,
-        binX: Bs,
-        binY: Os,
-        group: kw,
-        groupX: Wu,
-        groupY: Gu
+const My = {
+        dot: ns,
+        line: Ud,
+        lineX: Jc,
+        lineY: Zc,
+        areaX: Hc,
+        areaY: oa,
+        ruleX: ji,
+        ruleY: Vi,
+        barX: ms,
+        barY: gs,
+        rect: e1,
+        rectX: xh,
+        rectY: Sh,
+        cell: vo,
+        bin: ls,
+        binX: Ai,
+        binY: $i,
+        group: gg,
+        groupX: jc,
+        groupY: Vc
     },
-    OS = Object.fromEntries(Object.entries(R1).map(([e, t]) => [t, e]));
+    G2 = Object.fromEntries(Object.entries(My).map(([e, t]) => [t, e]));
 
-function Av(e, t = {}) {
+function n1(e, t = {}) {
     let {
         x: n,
-        x1: i,
-        x2: r
+        x1: r,
+        x2: i
     } = t;
-    n === void 0 && i === void 0 && r === void 0 && (t = {
+    n === void 0 && r === void 0 && i === void 0 && (t = {
         ...t,
-        x: n = Tt
+        x: n = yt
     });
     const s = {};
-    return n != null && (s.x = e), i != null && (s.x1 = e), r != null && (s.x2 = e), pr(s, t);
+    return n != null && (s.x = e), r != null && (s.x1 = e), i != null && (s.x2 = e), xr(s, t);
 }
 
-function Mv(e, t = {}) {
+function r1(e, t = {}) {
     let {
         y: n,
-        y1: i,
-        y2: r
+        y1: r,
+        y2: i
     } = t;
-    n === void 0 && i === void 0 && r === void 0 && (t = {
+    n === void 0 && r === void 0 && i === void 0 && (t = {
         ...t,
-        y: n = Tt
+        y: n = yt
     });
     const s = {};
-    return n != null && (s.y = e), i != null && (s.y1 = e), r != null && (s.y2 = e), pr(s, t);
+    return n != null && (s.y = e), r != null && (s.y1 = e), i != null && (s.y2 = e), xr(s, t);
 }
 
-function pr(e = {}, t = {}) {
-    const n = co(t),
-        i = Object.entries(e).map(([r, s]) => {
-            const o = pD(r, t);
+function xr(e = {}, t = {}) {
+    const n = Qi(t),
+        r = Object.entries(e).map(([i, s]) => {
+            const o = aA(i, t);
             if (o == null)
-                throw new Error(`missing channel: ${r}`);
-            const [a, c] = Un(o);
+                throw new Error(`missing channel: ${i}`);
+            const [a, c] = an(o);
             return {
-                key: r,
+                key: i,
                 input: o,
                 output: a,
                 setOutput: c,
-                map: ott(s)
+                map: yG(s)
             };
         });
     return {
-        ...vr(t, (r, s) => {
-            const o = Pt(r, n),
-                a = i.map(({
-                    input: l
-                }) => Pt(r, l)),
-                c = i.map(({
-                    setOutput: l
-                }) => l(new Array(r.length)));
-            for (const l of s)
-                for (const u of o ? us(l, (f) => o[f]).values() : [l])
-                    i.forEach(({
+        ...$r(t, (i, s) => {
+            const o = $t(i, n),
+                a = r.map(({
+                    input: u
+                }) => $t(i, u)),
+                c = r.map(({
+                    setOutput: u
+                }) => u(new Array(i.length)));
+            for (const u of s)
+                for (const l of o ? ci(u, (f) => o[f]).values() : [u])
+                    r.forEach(({
                         map: f
-                    }, h) => f.mapIndex(u, a[h], c[h]));
+                    }, h) => f.mapIndex(l, a[h], c[h]));
             return {
-                data: r,
+                data: i,
                 facets: s
             };
         }),
-        ...Object.fromEntries(i.map(({
-            key: r,
+        ...Object.fromEntries(r.map(({
+            key: i,
             output: s
-        }) => [r, s]))
+        }) => [i, s]))
     };
 }
 
-function ott(e) {
+function yG(e) {
     if (e == null)
         throw new Error("missing map");
     if (typeof e.mapIndex == "function")
         return e;
-    if (typeof e.map == "function" && hi(e))
-        return att(e);
+    if (typeof e.map == "function" && En(e))
+        return mG(e);
     if (typeof e == "function")
-        return tg(Dw(e));
+        return Hp(cg(e));
     switch (`${e}`.toLowerCase()) {
         case "cumsum":
-            return ltt;
+            return bG;
         case "rank":
-            return tg((t, n) => p3(t, (i) => n[i]));
+            return Hp((t, n) => oS(t, (r) => n[r]));
         case "quantile":
-            return tg((t, n) => ctt(t, (i) => n[i]));
+            return Hp((t, n) => gG(t, (r) => n[r]));
     }
     throw new Error(`invalid map: ${e}`);
 }
 
-function att(e) {
+function mG(e) {
     return console.warn("deprecated map interface; implement mapIndex instead."), {
         mapIndex: e.map.bind(e)
     };
 }
 
-function ctt(e, t) {
-    const n = Gy(e, t) - 1;
-    return p3(e, t).map((i) => i / n);
+function gG(e, t) {
+    const n = jh(e, t) - 1;
+    return oS(e, t).map((r) => r / n);
 }
 
-function tg(e) {
+function Hp(e) {
     return {
-        mapIndex(t, n, i) {
-            const r = e(t, n);
-            if (r.length !== t.length)
+        mapIndex(t, n, r) {
+            const i = e(t, n);
+            if (i.length !== t.length)
                 throw new Error("map function returned a mismatched length");
             for (let s = 0, o = t.length; s < o; ++s)
-                i[t[s]] = r[s];
+                r[t[s]] = i[s];
         }
     };
 }
-const ltt = {
+const bG = {
     mapIndex(e, t, n) {
-        let i = 0;
-        for (const r of e)
-            n[r] = i += t[r];
+        let r = 0;
+        for (const i of e)
+            n[i] = r += t[i];
     }
 };
 
-function utt(e = {}, t) {
-    return arguments.length === 1 && (t = e), Av(q0(e), t);
+function wG(e = {}, t) {
+    return arguments.length === 1 && (t = e), n1(qd(e), t);
 }
 
-function ftt(e = {}, t) {
-    return arguments.length === 1 && (t = e), Mv(q0(e), t);
+function vG(e = {}, t) {
+    return arguments.length === 1 && (t = e), r1(qd(e), t);
 }
 
-function q0(e = {}) {
+function qd(e = {}) {
     typeof e == "number" && (e = {
         k: e
     });
     let {
         k: t,
         reduce: n,
-        shift: i,
-        anchor: r,
+        shift: r,
+        anchor: i,
         strict: s
     } = e;
-    if (r === void 0 && i !== void 0 && (r = dtt(i), ts(`Warning: the shift option is deprecated; please use anchor "${r}" instead.`)), !((t = Math.floor(t)) > 0))
+    if (i === void 0 && r !== void 0 && (i = xG(r), ti(`Warning: the shift option is deprecated; please use anchor "${i}" instead.`)), !((t = Math.floor(t)) > 0))
         throw new Error(`invalid k: ${t}`);
-    return ptt(n)(t, htt(r, t), s);
+    return SG(n)(t, _G(i, t), s);
 }
 
-function htt(e = "middle", t) {
+function _G(e = "middle", t) {
     switch (`${e}`.toLowerCase()) {
         case "middle":
             return t - 1 >> 1;
         case "start":
             return 0;
         case "end":
             return t - 1;
     }
     throw new Error(`invalid anchor: ${e}`);
 }
 
-function dtt(e) {
+function xG(e) {
     switch (`${e}`.toLowerCase()) {
         case "centered":
             return "middle";
         case "leading":
             return "start";
         case "trailing":
             return "end";
     }
     throw new Error(`invalid shift: ${e}`);
 }
 
-function ptt(e = "mean") {
+function SG(e = "mean") {
     if (typeof e == "string") {
         if (/^p\d{2}$/i.test(e))
-            return Nh($w(e));
+            return yl(og(e));
         switch (e.toLowerCase()) {
             case "deviation":
-                return Nh(gf);
+                return yl(au);
             case "max":
-                return Bh((t, n) => De(t, (i) => n[i]));
+                return ml((t, n) => ae(t, (r) => n[r]));
             case "mean":
-                return ytt;
+                return MG;
             case "median":
-                return Nh(Fu);
+                return yl(Nc);
             case "min":
-                return Bh((t, n) => Ye(t, (i) => n[i]));
+                return ml((t, n) => ve(t, (r) => n[r]));
             case "mode":
-                return Bh((t, n) => d3(t, (i) => n[i]));
+                return ml((t, n) => sS(t, (r) => n[r]));
             case "sum":
-                return O4;
+                return A4;
             case "variance":
-                return Nh(zb);
+                return yl(wm);
             case "difference":
-                return btt;
+                return IG;
             case "ratio":
-                return wtt;
+                return TG;
             case "first":
-                return vtt;
+                return EG;
             case "last":
-                return _tt;
+                return NG;
         }
     }
     if (typeof e != "function")
         throw new Error(`invalid reduce: ${e}`);
-    return Bh(Dw(e));
+    return ml(cg(e));
 }
 
-function Nh(e) {
-    return (t, n, i) => i ? {
-        mapIndex(r, s, o) {
-            const a = (l) => s[l] == null ? NaN : +s[l];
+function yl(e) {
+    return (t, n, r) => r ? {
+        mapIndex(i, s, o) {
+            const a = (u) => s[u] == null ? NaN : +s[u];
             let c = 0;
-            for (let l = 0; l < t - 1; ++l)
-                isNaN(a(l)) && ++c;
-            for (let l = 0, u = r.length - t + 1; l < u; ++l)
-                isNaN(a(l + t - 1)) && ++c, o[r[l + n]] = c === 0 ? e(qo(r, l, l + t), a) : NaN, isNaN(a(l)) && --c;
+            for (let u = 0; u < t - 1; ++u)
+                isNaN(a(u)) && ++c;
+            for (let u = 0, l = i.length - t + 1; u < l; ++u)
+                isNaN(a(u + t - 1)) && ++c, o[i[u + n]] = c === 0 ? e(Ss(i, u, u + t), a) : NaN, isNaN(a(u)) && --c;
         }
     } : {
-        mapIndex(r, s, o) {
+        mapIndex(i, s, o) {
             const a = (c) => s[c] == null ? NaN : +s[c];
             for (let c = -n; c < 0; ++c)
-                o[r[c + n]] = e(qo(r, 0, c + t), a);
-            for (let c = 0, l = r.length - n; c < l; ++c)
-                o[r[c + n]] = e(qo(r, c, c + t), a);
+                o[i[c + n]] = e(Ss(i, 0, c + t), a);
+            for (let c = 0, u = i.length - n; c < u; ++c)
+                o[i[c + n]] = e(Ss(i, c, c + t), a);
         }
     };
 }
 
-function Bh(e) {
-    return (t, n, i) => i ? {
-        mapIndex(r, s, o) {
+function ml(e) {
+    return (t, n, r) => r ? {
+        mapIndex(i, s, o) {
             let a = 0;
             for (let c = 0; c < t - 1; ++c)
-                a += dn(s[r[c]]);
-            for (let c = 0, l = r.length - t + 1; c < l; ++c)
-                a += dn(s[r[c + t - 1]]), a === t && (o[r[c + n]] = e(qo(r, c, c + t), s)), a -= dn(s[r[c]]);
+                a += Ce(s[i[c]]);
+            for (let c = 0, u = i.length - t + 1; c < u; ++c)
+                a += Ce(s[i[c + t - 1]]), a === t && (o[i[c + n]] = e(Ss(i, c, c + t), s)), a -= Ce(s[i[c]]);
         }
     } : {
-        mapIndex(r, s, o) {
+        mapIndex(i, s, o) {
             for (let a = -n; a < 0; ++a)
-                o[r[a + n]] = e(qo(r, 0, a + t), s);
-            for (let a = 0, c = r.length - n; a < c; ++a)
-                o[r[a + n]] = e(qo(r, a, a + t), s);
+                o[i[a + n]] = e(Ss(i, 0, a + t), s);
+            for (let a = 0, c = i.length - n; a < c; ++a)
+                o[i[a + n]] = e(Ss(i, a, a + t), s);
         }
     };
 }
 
-function O4(e, t, n) {
+function A4(e, t, n) {
     return n ? {
-        mapIndex(i, r, s) {
+        mapIndex(r, i, s) {
             let o = 0,
                 a = 0;
             for (let c = 0; c < e - 1; ++c) {
-                const l = r[i[c]];
-                l === null || isNaN(l) ? ++o : a += +l;
+                const u = i[r[c]];
+                u === null || isNaN(u) ? ++o : a += +u;
             }
-            for (let c = 0, l = i.length - e + 1; c < l; ++c) {
-                const u = r[i[c]],
-                    f = r[i[c + e - 1]];
-                f === null || isNaN(f) ? ++o : a += +f, s[i[c + t]] = o === 0 ? a : NaN, u === null || isNaN(u) ? --o : a -= +u;
+            for (let c = 0, u = r.length - e + 1; c < u; ++c) {
+                const l = i[r[c]],
+                    f = i[r[c + e - 1]];
+                f === null || isNaN(f) ? ++o : a += +f, s[r[c + t]] = o === 0 ? a : NaN, l === null || isNaN(l) ? --o : a -= +l;
             }
         }
     } : {
-        mapIndex(i, r, s) {
+        mapIndex(r, i, s) {
             let o = 0;
-            const a = i.length;
-            for (let c = 0, l = Math.min(a, e - t - 1); c < l; ++c)
-                o += +r[i[c]] || 0;
-            for (let c = -t, l = a - t; c < l; ++c)
-                o += +r[i[c + e - 1]] || 0, s[i[c + t]] = o, o -= +r[i[c]] || 0;
+            const a = r.length;
+            for (let c = 0, u = Math.min(a, e - t - 1); c < u; ++c)
+                o += +i[r[c]] || 0;
+            for (let c = -t, u = a - t; c < u; ++c)
+                o += +i[r[c + e - 1]] || 0, s[r[c + t]] = o, o -= +i[r[c]] || 0;
         }
     };
 }
 
-function ytt(e, t, n) {
+function MG(e, t, n) {
     if (n) {
-        const i = O4(e, t, n);
+        const r = A4(e, t, n);
         return {
-            mapIndex(r, s, o) {
-                i.mapIndex(r, s, o);
-                for (let a = 0, c = r.length - e + 1; a < c; ++a)
-                    o[r[a + t]] /= e;
+            mapIndex(i, s, o) {
+                r.mapIndex(i, s, o);
+                for (let a = 0, c = i.length - e + 1; a < c; ++a)
+                    o[i[a + t]] /= e;
             }
         };
     } else
         return {
-            mapIndex(i, r, s) {
+            mapIndex(r, i, s) {
                 let o = 0,
                     a = 0;
-                const c = i.length;
-                for (let l = 0, u = Math.min(c, e - t - 1); l < u; ++l) {
-                    let f = r[i[l]];
+                const c = r.length;
+                for (let u = 0, l = Math.min(c, e - t - 1); u < l; ++u) {
+                    let f = i[r[u]];
                     f !== null && !isNaN(f = +f) && (o += f, ++a);
                 }
-                for (let l = -t, u = c - t; l < u; ++l) {
-                    let f = r[i[l + e - 1]],
-                        h = r[i[l]];
-                    f !== null && !isNaN(f = +f) && (o += f, ++a), s[i[l + t]] = o / a, h !== null && !isNaN(h = +h) && (o -= h, --a);
+                for (let u = -t, l = c - t; u < l; ++u) {
+                    let f = i[r[u + e - 1]],
+                        h = i[r[u]];
+                    f !== null && !isNaN(f = +f) && (o += f, ++a), s[r[u + t]] = o / a, h !== null && !isNaN(h = +h) && (o -= h, --a);
                 }
             }
         };
 }
 
-function mtt(e, t, n, i) {
-    for (let r = n + i; n < r; ++n) {
+function AG(e, t, n, r) {
+    for (let i = n + r; n < i; ++n) {
         const s = e[t[n]];
-        if (dn(s))
+        if (Ce(s))
             return s;
     }
 }
 
-function gtt(e, t, n, i) {
-    for (let r = n + i - 1; r >= n; --r) {
-        const s = e[t[r]];
-        if (dn(s))
+function $G(e, t, n, r) {
+    for (let i = n + r - 1; i >= n; --i) {
+        const s = e[t[i]];
+        if (Ce(s))
             return s;
     }
 }
 
-function F4(e, t, n, i) {
-    for (let r = n + i; n < r; ++n) {
+function $4(e, t, n, r) {
+    for (let i = n + r; n < i; ++n) {
         let s = e[t[n]];
         if (s !== null && !isNaN(s = +s))
             return s;
     }
 }
 
-function E4(e, t, n, i) {
-    for (let r = n + i - 1; r >= n; --r) {
-        let s = e[t[r]];
+function I4(e, t, n, r) {
+    for (let i = n + r - 1; i >= n; --i) {
+        let s = e[t[i]];
         if (s !== null && !isNaN(s = +s))
             return s;
     }
 }
 
-function btt(e, t, n) {
+function IG(e, t, n) {
     return n ? {
-        mapIndex(i, r, s) {
-            for (let o = 0, a = i.length - e; o < a; ++o) {
-                const c = r[i[o]],
-                    l = r[i[o + e - 1]];
-                s[i[o + t]] = c === null || l === null ? NaN : l - c;
+        mapIndex(r, i, s) {
+            for (let o = 0, a = r.length - e; o < a; ++o) {
+                const c = i[r[o]],
+                    u = i[r[o + e - 1]];
+                s[r[o + t]] = c === null || u === null ? NaN : u - c;
             }
         }
     } : {
-        mapIndex(i, r, s) {
-            for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
-                s[i[o + t]] = E4(r, i, o, e) - F4(r, i, o, e);
+        mapIndex(r, i, s) {
+            for (let o = -t, a = r.length - e + t + 1; o < a; ++o)
+                s[r[o + t]] = I4(i, r, o, e) - $4(i, r, o, e);
         }
     };
 }
 
-function wtt(e, t, n) {
+function TG(e, t, n) {
     return n ? {
-        mapIndex(i, r, s) {
-            for (let o = 0, a = i.length - e; o < a; ++o) {
-                const c = r[i[o]],
-                    l = r[i[o + e - 1]];
-                s[i[o + t]] = c === null || l === null ? NaN : l / c;
+        mapIndex(r, i, s) {
+            for (let o = 0, a = r.length - e; o < a; ++o) {
+                const c = i[r[o]],
+                    u = i[r[o + e - 1]];
+                s[r[o + t]] = c === null || u === null ? NaN : u / c;
             }
         }
     } : {
-        mapIndex(i, r, s) {
-            for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
-                s[i[o + t]] = E4(r, i, o, e) / F4(r, i, o, e);
+        mapIndex(r, i, s) {
+            for (let o = -t, a = r.length - e + t + 1; o < a; ++o)
+                s[r[o + t]] = I4(i, r, o, e) / $4(i, r, o, e);
         }
     };
 }
 
-function vtt(e, t, n) {
+function EG(e, t, n) {
     return n ? {
-        mapIndex(i, r, s) {
-            for (let o = 0, a = i.length - e; o < a; ++o)
-                s[i[o + t]] = r[i[o]];
+        mapIndex(r, i, s) {
+            for (let o = 0, a = r.length - e; o < a; ++o)
+                s[r[o + t]] = i[r[o]];
         }
     } : {
-        mapIndex(i, r, s) {
-            for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
-                s[i[o + t]] = mtt(r, i, o, e);
+        mapIndex(r, i, s) {
+            for (let o = -t, a = r.length - e + t + 1; o < a; ++o)
+                s[r[o + t]] = AG(i, r, o, e);
         }
     };
 }
 
-function _tt(e, t, n) {
+function NG(e, t, n) {
     return n ? {
-        mapIndex(i, r, s) {
-            for (let o = 0, a = i.length - e; o < a; ++o)
-                s[i[o + t]] = r[i[o + e - 1]];
+        mapIndex(r, i, s) {
+            for (let o = 0, a = r.length - e; o < a; ++o)
+                s[r[o + t]] = i[r[o + e - 1]];
         }
     } : {
-        mapIndex(i, r, s) {
-            for (let o = -t, a = i.length - e + t + 1; o < a; ++o)
-                s[i[o + t]] = gtt(r, i, o, e);
+        mapIndex(r, i, s) {
+            for (let o = -t, a = r.length - e + t + 1; o < a; ++o)
+                s[r[o + t]] = $G(i, r, o, e);
         }
     };
 }
-const es = {
+const ei = {
     n: 20,
     k: 2,
     color: "currentColor",
     opacity: 0.2,
     strict: !0,
     anchor: "end"
 };
 
-function xtt(e, {
-    x: t = Tt,
+function DG(e, {
+    x: t = yt,
     y: n,
-    k: i = es.k,
-    color: r = es.color,
-    opacity: s = es.opacity,
-    fill: o = r,
+    k: r = ei.k,
+    color: i = ei.color,
+    opacity: s = ei.opacity,
+    fill: o = i,
     fillOpacity: a = s,
-    stroke: c = r,
-    strokeOpacity: l,
-    strokeWidth: u,
+    stroke: c = i,
+    strokeOpacity: u,
+    strokeWidth: l,
     ...f
 } = {}) {
-    return ui(
-        we(o) ? null : Ju(
+    return Tn(
+        te(o) ? null : Hc(
             e,
-            pr({
-                x1: Yo({
-                    k: -i,
+            xr({
+                x1: Ms({
+                    k: -r,
                     ...f
                 }),
-                x2: Yo({
-                    k: i,
+                x2: Ms({
+                    k: r,
                     ...f
                 })
             }, {
                 x1: t,
                 x2: t,
                 y: n,
                 fill: o,
                 fillOpacity: a,
                 ...f
             })
         ),
-        we(c) ? null : Ku(e, pr({
-            x: Yo(f)
+        te(c) ? null : Jc(e, xr({
+            x: Ms(f)
         }, {
             x: t,
             y: n,
             stroke: c,
-            strokeOpacity: l,
-            strokeWidth: u,
+            strokeOpacity: u,
+            strokeWidth: l,
             ...f
         }))
     );
 }
 
-function Stt(e, {
+function OG(e, {
     x: t,
-    y: n = Tt,
-    k: i = es.k,
-    color: r = es.color,
-    opacity: s = es.opacity,
-    fill: o = r,
+    y: n = yt,
+    k: r = ei.k,
+    color: i = ei.color,
+    opacity: s = ei.opacity,
+    fill: o = i,
     fillOpacity: a = s,
-    stroke: c = r,
-    strokeOpacity: l,
-    strokeWidth: u,
+    stroke: c = i,
+    strokeOpacity: u,
+    strokeWidth: l,
     ...f
 } = {}) {
-    return ui(
-        we(o) ? null : qc(
+    return Tn(
+        te(o) ? null : oa(
             e,
-            pr({
-                y1: Yo({
-                    k: -i,
+            xr({
+                y1: Ms({
+                    k: -r,
                     ...f
                 }),
-                y2: Yo({
-                    k: i,
+                y2: Ms({
+                    k: r,
                     ...f
                 })
             }, {
                 x: t,
                 y1: n,
                 y2: n,
                 fill: o,
                 fillOpacity: a,
                 ...f
             })
         ),
-        we(c) ? null : Zu(e, pr({
-            y: Yo(f)
+        te(c) ? null : Zc(e, xr({
+            y: Ms(f)
         }, {
             x: t,
             y: n,
             stroke: c,
-            strokeOpacity: l,
-            strokeWidth: u,
+            strokeOpacity: u,
+            strokeWidth: l,
             ...f
         }))
     );
 }
 
-function Yo({
-    n: e = es.n,
+function Ms({
+    n: e = ei.n,
     k: t = 0,
-    strict: n = es.strict,
-    anchor: i = es.anchor
+    strict: n = ei.strict,
+    anchor: r = ei.anchor
 } = {}) {
-    return q0({
+    return qd({
         k: e,
-        reduce: (r) => Xy(r) + t * (gf(r) || 0),
+        reduce: (i) => Vh(i) + t * (au(i) || 0),
         strict: n,
-        anchor: i
+        anchor: r
     });
 }
-const Itt = {
+const LG = {
     ariaLabel: "tick",
     fill: null,
     stroke: "currentColor"
 };
-class L4 extends fe {
-    constructor(t, n, i) {
-        super(t, n, i, Itt), cl(this, i);
-    }
-    render(t, n, i, r, s) {
-        return Gt("svg:g", s).call(ve, this, r, s).call(this._transform, this, n).call(
-            (o) => o.selectAll().data(t).enter().append("line").call(be, this).attr("x1", this._x1(n, i, r)).attr("x2", this._x2(n, i, r)).attr("y1", this._y1(n, i, r)).attr("y2", this._y2(n, i, r)).call(Pe, this, i).call(Vf, this, i, s)
+class T4 extends Ht {
+    constructor(t, n, r) {
+        super(t, n, r, LG), va(this, r);
+    }
+    render(t, n, r, i, s) {
+        return Ot("svg:g", s).call(ee, this, i, s).call(this._transform, this, n).call(
+            (o) => o.selectAll().data(t).enter().append("line").call(Qt, this).attr("x1", this._x1(n, r, i)).attr("x2", this._x2(n, r, i)).attr("y1", this._y1(n, r, i)).attr("y2", this._y2(n, r, i)).call(me, this, r).call(Du, this, r, s)
         ).node();
     }
 }
-class R4 extends L4 {
+class E4 extends T4 {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             inset: s = 0,
             insetTop: o = s,
             insetBottom: a = s
         } = n;
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x"
                 },
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y",
                     type: "band",
                     optional: !0
                 }
             },
             n
-        ), this.insetTop = qt(o), this.insetBottom = qt(a);
+        ), this.insetTop = Nt(o), this.insetBottom = Nt(a);
     }
     _transform(t, n, {
-        x: i
+        x: r
     }) {
-        t.call(ue, n, {
-            x: i
-        }, He, 0);
+        t.call(Gt, n, {
+            x: r
+        }, Me, 0);
     }
     _x1(t, {
         x: n
     }) {
-        return (i) => n[i];
+        return (r) => n[r];
     }
     _x2(t, {
         x: n
     }) {
-        return (i) => n[i];
+        return (r) => n[r];
     }
     _y1({
         y: t
     }, {
         y: n
     }, {
-        marginTop: i
+        marginTop: r
     }) {
         const {
-            insetTop: r
+            insetTop: i
         } = this;
-        return n && t ? (s) => n[s] + r : i + r;
+        return n && t ? (s) => n[s] + i : r + i;
     }
     _y2({
         y: t
     }, {
         y: n
     }, {
-        height: i,
-        marginBottom: r
+        height: r,
+        marginBottom: i
     }) {
         const {
             insetBottom: s
         } = this;
-        return n && t ? (o) => n[o] + t.bandwidth() - s : i - r - s;
+        return n && t ? (o) => n[o] + t.bandwidth() - s : r - i - s;
     }
 }
-class C4 extends L4 {
+class N4 extends T4 {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             inset: s = 0,
             insetRight: o = s,
             insetLeft: a = s
         } = n;
         super(
             t, {
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y"
                 },
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     type: "band",
                     optional: !0
                 }
             },
             n
-        ), this.insetRight = qt(o), this.insetLeft = qt(a);
+        ), this.insetRight = Nt(o), this.insetLeft = Nt(a);
     }
     _transform(t, n, {
-        y: i
+        y: r
     }) {
-        t.call(ue, n, {
-            y: i
-        }, 0, He);
+        t.call(Gt, n, {
+            y: r
+        }, 0, Me);
     }
     _x1({
         x: t
     }, {
         x: n
     }, {
-        marginLeft: i
+        marginLeft: r
     }) {
         const {
-            insetLeft: r
+            insetLeft: i
         } = this;
-        return n && t ? (s) => n[s] + r : i + r;
+        return n && t ? (s) => n[s] + i : r + i;
     }
     _x2({
         x: t
     }, {
         x: n
     }, {
-        width: i,
-        marginRight: r
+        width: r,
+        marginRight: i
     }) {
         const {
             insetRight: s
         } = this;
-        return n && t ? (o) => n[o] + t.bandwidth() - s : i - r - s;
+        return n && t ? (o) => n[o] + t.bandwidth() - s : r - i - s;
     }
     _y1(t, {
         y: n
     }) {
-        return (i) => n[i];
+        return (r) => n[r];
     }
     _y2(t, {
         y: n
     }) {
-        return (i) => n[i];
+        return (r) => n[r];
     }
 }
 
-function k4(e, {
-    x: t = Tt,
+function D4(e, {
+    x: t = yt,
     ...n
 } = {}) {
-    return new R4(e, {
+    return new E4(e, {
         ...n,
         x: t
     });
 }
 
-function U4(e, {
-    y: t = Tt,
+function O4(e, {
+    y: t = yt,
     ...n
 } = {}) {
-    return new C4(e, {
+    return new N4(e, {
         ...n,
         y: t
     });
 }
 
-function Att(e, {
-    x: t = Tt,
+function kG(e, {
+    x: t = yt,
     y: n = null,
-    fill: i = "#ccc",
-    fillOpacity: r,
+    fill: r = "#ccc",
+    fillOpacity: i,
     stroke: s = "currentColor",
     strokeOpacity: o,
     strokeWidth: a = 2,
     sort: c,
-    ...l
+    ...u
 } = {}) {
-    const u = n != null ? Gu : Cw;
-    return ui(
-        Ks(e, u({
-            x1: $v,
-            x2: Tv
+    const l = n != null ? Vc : mg;
+    return Tn(
+        Vi(e, l({
+            x1: i1,
+            x2: s1
         }, {
             x: t,
             y: n,
             stroke: s,
             strokeOpacity: o,
-            ...l
+            ...u
         })),
-        Lo(e, u({
+        ms(e, l({
             x1: "p25",
             x2: "p75"
         }, {
             x: t,
             y: n,
-            fill: i,
-            fillOpacity: r,
-            ...l
+            fill: r,
+            fillOpacity: i,
+            ...u
         })),
-        k4(e, u({
+        D4(e, l({
             x: "p50"
         }, {
             x: t,
             y: n,
             stroke: s,
             strokeOpacity: o,
             strokeWidth: a,
             sort: c,
-            ...l
+            ...u
         })),
-        fo(e, pr({
-            x: z4
+        ns(e, xr({
+            x: L4
         }, {
             x: t,
             y: n,
             z: n,
             stroke: s,
             strokeOpacity: o,
-            ...l
+            ...u
         }))
     );
 }
 
-function Mtt(e, {
-    y: t = Tt,
+function RG(e, {
+    y: t = yt,
     x: n = null,
-    fill: i = "#ccc",
-    fillOpacity: r,
+    fill: r = "#ccc",
+    fillOpacity: i,
     stroke: s = "currentColor",
     strokeOpacity: o,
     strokeWidth: a = 2,
     sort: c,
-    ...l
+    ...u
 } = {}) {
-    const u = n != null ? Wu : Cw;
-    return ui(
-        Js(e, u({
-            y1: $v,
-            y2: Tv
+    const l = n != null ? jc : mg;
+    return Tn(
+        ji(e, l({
+            y1: i1,
+            y2: s1
         }, {
             x: n,
             y: t,
             stroke: s,
             strokeOpacity: o,
-            ...l
+            ...u
         })),
-        Ro(e, u({
+        gs(e, l({
             y1: "p25",
             y2: "p75"
         }, {
             x: n,
             y: t,
-            fill: i,
-            fillOpacity: r,
-            ...l
+            fill: r,
+            fillOpacity: i,
+            ...u
         })),
-        U4(e, u({
+        O4(e, l({
             y: "p50"
         }, {
             x: n,
             y: t,
             stroke: s,
             strokeOpacity: o,
             strokeWidth: a,
             sort: c,
-            ...l
+            ...u
         })),
-        fo(e, pr({
-            y: z4
+        ns(e, xr({
+            y: L4
         }, {
             x: n,
             y: t,
             z: n,
             stroke: s,
             strokeOpacity: o,
-            ...l
+            ...u
         }))
     );
 }
 
-function z4(e) {
-    const t = $v(e),
-        n = Tv(e);
-    return e.map((i) => i < t || i > n ? i : NaN);
+function L4(e) {
+    const t = i1(e),
+        n = s1(e);
+    return e.map((r) => r < t || r > n ? r : NaN);
 }
 
-function $v(e) {
-    const t = P4(e) * 2.5 - V4(e) * 1.5;
-    return Ye(e, (n) => n >= t ? n : NaN);
+function i1(e) {
+    const t = k4(e) * 2.5 - R4(e) * 1.5;
+    return ve(e, (n) => n >= t ? n : NaN);
 }
 
-function Tv(e) {
-    const t = V4(e) * 2.5 - P4(e) * 1.5;
-    return De(e, (n) => n <= t ? n : NaN);
+function s1(e) {
+    const t = R4(e) * 2.5 - k4(e) * 1.5;
+    return ae(e, (n) => n <= t ? n : NaN);
 }
 
-function P4(e) {
-    return Ws(e, 0.25);
+function k4(e) {
+    return Pi(e, 0.25);
 }
 
-function V4(e) {
-    return Ws(e, 0.75);
+function R4(e) {
+    return Pi(e, 0.75);
 }
-const $tt = {
+const FG = {
     ariaLabel: "raster",
     stroke: null,
     pixelSize: 1
 };
 
-function $a(e, t) {
+function ro(e, t) {
     const n = +e;
     if (isNaN(n))
         throw new Error(`invalid ${t}: ${e}`);
     return n;
 }
 
-function FS(e, t) {
+function H2(e, t) {
     const n = Math.floor(e);
     if (isNaN(n))
         throw new Error(`invalid ${t}: ${e}`);
     return n;
 }
-class j4 extends fe {
-    constructor(t, n, i = {}, r) {
+class F4 extends Ht {
+    constructor(t, n, r = {}, i) {
         let {
             width: s,
             height: o,
             x: a,
             y: c,
-            x1: l = a == null ? 0 : void 0,
-            y1: u = c == null ? 0 : void 0,
+            x1: u = a == null ? 0 : void 0,
+            y1: l = c == null ? 0 : void 0,
             x2: f = a == null ? s : void 0,
             y2: h = c == null ? o : void 0,
-            pixelSize: d = r.pixelSize,
+            pixelSize: d = i.pixelSize,
             blur: p = 0,
-            interpolate: m
-        } = i;
-        if (s != null && (s = FS(s, "width")), o != null && (o = FS(o, "height")), l != null && (l = $a(l, "x1")), u != null && (u = $a(u, "y1")), f != null && (f = $a(f, "x2")), h != null && (h = $a(h, "y2")), a == null && (l == null || f == null))
+            interpolate: y
+        } = r;
+        if (s != null && (s = H2(s, "width")), o != null && (o = H2(o, "height")), u != null && (u = ro(u, "x1")), l != null && (l = ro(l, "y1")), f != null && (f = ro(f, "x2")), h != null && (h = ro(h, "y2")), a == null && (u == null || f == null))
             throw new Error("missing x");
-        if (c == null && (u == null || h == null))
+        if (c == null && (l == null || h == null))
             throw new Error("missing y");
-        t != null && s != null && o != null && (a === void 0 && l != null && f != null && (a = Rtt(l, f, s)), c === void 0 && u != null && h != null && (c = Ctt(u, h, s, o))), super(
+        t != null && s != null && o != null && (a === void 0 && u != null && f != null && (a = YG(u, f, s)), c === void 0 && l != null && h != null && (c = WG(l, h, s, o))), super(
             t, {
                 x: {
                     value: a,
                     scale: "x",
                     optional: !0
                 },
                 y: {
                     value: c,
                     scale: "y",
                     optional: !0
                 },
                 x1: {
-                    value: l == null ? null : [l],
+                    value: u == null ? null : [u],
                     scale: "x",
                     optional: !0,
                     filter: null
                 },
                 y1: {
-                    value: u == null ? null : [u],
+                    value: l == null ? null : [l],
                     scale: "y",
                     optional: !0,
                     filter: null
                 },
                 x2: {
                     value: f == null ? null : [f],
                     scale: "x",
@@ -33120,888 +33683,888 @@
                     value: h == null ? null : [h],
                     scale: "y",
                     optional: !0,
                     filter: null
                 },
                 ...n
             },
-            i,
-            r
-        ), this.width = s, this.height = o, this.pixelSize = $a(d, "pixelSize"), this.blur = $a(p, "blur"), this.interpolate = a == null || c == null ? null : Dtt(m);
+            r,
+            i
+        ), this.width = s, this.height = o, this.pixelSize = ro(d, "pixelSize"), this.blur = ro(p, "blur"), this.interpolate = a == null || c == null ? null : CG(y);
     }
 }
-class q4 extends j4 {
+class B4 extends F4 {
     constructor(t, n = {}) {
         const {
-            imageRendering: i
+            imageRendering: r
         } = n;
         if (t == null) {
             const {
-                fill: r,
+                fill: i,
                 fillOpacity: s
             } = n;
-            Be(s)[0] !== void 0 && (n = C1("fillOpacity", n)), mn(r)[0] !== void 0 && (n = C1("fill", n));
+            ue(s)[0] !== void 0 && (n = Ay("fillOpacity", n)), ze(i)[0] !== void 0 && (n = Ay("fill", n));
         }
-        super(t, void 0, n, $tt), this.imageRendering = Me(i, "auto");
+        super(t, void 0, n, FG), this.imageRendering = se(r, "auto");
     }
     // Ignore the color scale, so the fill channel is returned unscaled.
     scale(t, {
         color: n,
-        ...i
-    }, r) {
-        return super.scale(t, i, r);
+        ...r
+    }, i) {
+        return super.scale(t, r, i);
     }
-    render(t, n, i, r, s) {
-        var T;
-        const o = n[(T = i.channels.fill) == null ? void 0 : T.scale] ?? ((D) => D),
+    render(t, n, r, i, s) {
+        var I;
+        const o = n[(I = r.channels.fill) == null ? void 0 : I.scale] ?? ((E) => E),
             {
                 x: a,
                 y: c
-            } = i,
+            } = r,
             {
-                document: l
+                document: u
             } = s,
-            [u, f, h, d] = W4(i, r, s),
-            p = h - u,
-            m = d - f,
+            [l, f, h, d] = P4(r, i, s),
+            p = h - l,
+            y = d - f,
             {
-                pixelSize: g,
-                width: y = Math.round(Math.abs(p) / g),
-                height: b = Math.round(Math.abs(m) / g)
+                pixelSize: m,
+                width: g = Math.round(Math.abs(p) / m),
+                height: b = Math.round(Math.abs(y) / m)
             } = this,
-            w = y * b;
+            w = g * b;
         let {
             fill: v,
             fillOpacity: x
-        } = i, _ = 0;
+        } = r, _ = 0;
         if (this.interpolate) {
-            const D = y / p,
-                L = b / m,
-                k = ye(a, (C) => (C - u) * D, Float64Array),
-                U = ye(c, (C) => (C - f) * L, Float64Array);
-            v && (v = this.interpolate(t, y, b, k, U, v)), x && (x = this.interpolate(t, y, b, k, U, x));
+            const E = g / p,
+                k = b / y,
+                B = Zt(a, (F) => (F - l) * E, Float64Array),
+                C = Zt(c, (F) => (F - f) * k, Float64Array);
+            v && (v = this.interpolate(t, g, b, B, C, v)), x && (x = this.interpolate(t, g, b, B, C, x));
         } else
             this.data == null && t && (_ = t.fi * w);
-        const I = l.createElement("canvas");
-        I.width = y, I.height = b;
-        const A = I.getContext("2d"),
-            M = A.createImageData(y, b),
-            N = M.data;
+        const M = u.createElement("canvas");
+        M.width = g, M.height = b;
+        const T = M.getContext("2d"),
+            $ = T.createImageData(g, b),
+            N = $.data;
         let {
-            r: $,
-            g: B,
+            r: A,
+            g: D,
             b: R
-        } = Pn(this.fill) ?? {
+        } = un(this.fill) ?? {
             r: 0,
             g: 0,
             b: 0
         }, S = (this.fillOpacity ?? 1) * 255;
-        for (let D = 0; D < w; ++D) {
-            const L = D << 2;
+        for (let E = 0; E < w; ++E) {
+            const k = E << 2;
             if (v) {
-                const k = o(v[D + _]);
-                if (k == null) {
-                    N[L + 3] = 0;
+                const B = o(v[E + _]);
+                if (B == null) {
+                    N[k + 3] = 0;
                     continue;
                 }
                 ({
-                    r: $,
-                    g: B,
+                    r: A,
+                    g: D,
                     b: R
-                } = Pn(k));
+                } = un(B));
             }
-            x && (S = x[D + _] * 255), N[L + 0] = $, N[L + 1] = B, N[L + 2] = R, N[L + 3] = S;
+            x && (S = x[E + _] * 255), N[k + 0] = A, N[k + 1] = D, N[k + 2] = R, N[k + 3] = S;
         }
-        return this.blur > 0 && Iz(M, this.blur), A.putImageData(M, 0, 0), Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
-            (D) => D.append("image").attr("transform", `translate(${u},${f}) scale(${Math.sign(h - u)},${Math.sign(d - f)})`).attr("width", Math.abs(p)).attr("height", Math.abs(m)).attr("preserveAspectRatio", "none").call(yt, "image-rendering", this.imageRendering).call(be, this).attr("xlink:href", I.toDataURL())
+        return this.blur > 0 && Lk($, this.blur), T.putImageData($, 0, 0), Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n).call(
+            (E) => E.append("image").attr("transform", `translate(${l},${f}) scale(${Math.sign(h - l)},${Math.sign(d - f)})`).attr("width", Math.abs(p)).attr("height", Math.abs(y)).attr("preserveAspectRatio", "none").call(at, "image-rendering", this.imageRendering).call(Qt, this).attr("xlink:href", M.toDataURL())
         ).node();
     }
 }
 
-function Y4(e, t, n) {
+function C4(e, t, n) {
     arguments.length < 3 && (n = t, t = null);
     let {
-        x: i,
-        y: r,
+        x: r,
+        y: i,
         [e]: s,
         ...o
     } = n;
-    return i === void 0 && r === void 0 && JH(t) && (i = w0, r = qu, s === void 0 && (s = YH)), [t, {
+    return r === void 0 && i === void 0 && sV(t) && (r = yd, i = zc, s === void 0 && (s = tV)), [t, {
         ...o,
-        x: i,
-        y: r,
+        x: r,
+        y: i,
         [e]: s
     }];
 }
 
-function Ttt() {
-    const [e, t] = Y4("fill", ...arguments);
-    return new q4(
+function BG() {
+    const [e, t] = C4("fill", ...arguments);
+    return new B4(
         e,
         e == null || t.fill !== void 0 || t.fillOpacity !== void 0 ? t : {
             ...t,
-            fill: Tt
+            fill: yt
         }
     );
 }
 
-function W4({
+function P4({
     x1: e,
     y1: t,
     x2: n,
-    y2: i
-}, r, {
+    y2: r
+}, i, {
     projection: s
 }) {
     const {
         width: o,
         height: a,
         marginTop: c,
-        marginRight: l,
-        marginBottom: u,
+        marginRight: u,
+        marginBottom: l,
         marginLeft: f
-    } = r;
+    } = i;
     return [
         e && s == null ? e[0] : f,
         t && s == null ? t[0] : c,
-        n && s == null ? n[0] : o - l,
-        i && s == null ? i[0] : a - u
+        n && s == null ? n[0] : o - u,
+        r && s == null ? r[0] : a - l
     ];
 }
 
-function G4({
+function U4({
     x1: e,
     y1: t,
     x2: n,
-    y2: i
-}, r, s, o) {
+    y2: r
+}, i, s, o) {
     const a = {};
-    return e && (a.x1 = e), t && (a.y1 = t), n && (a.x2 = n), i && (a.y2 = i), W4(qw(a, r), s, o);
+    return e && (a.x1 = e), t && (a.y1 = t), n && (a.x2 = n), r && (a.y2 = r), P4(Sg(a, i), s, o);
 }
 
-function C1(e, t = {}) {
+function Ay(e, t = {}) {
     const {
         [e]: n
     } = t;
     if (typeof n != "function")
         throw new Error(`invalid ${e}: not a function`);
-    return Bn({
+    return tn({
         ...t,
         [e]: void 0
-    }, function(i, r, s, o, a, c) {
+    }, function(r, i, s, o, a, c) {
         const {
-            x: l,
-            y: u
+            x: u,
+            y: l
         } = o;
-        if (!l)
-            throw new Error("missing scale: x");
         if (!u)
+            throw new Error("missing scale: x");
+        if (!l)
             throw new Error("missing scale: y");
-        const [f, h, d, p] = G4(s, o, a, c), m = d - f, g = p - h, {
-            pixelSize: y
+        const [f, h, d, p] = U4(s, o, a, c), y = d - f, m = p - h, {
+            pixelSize: g
         } = this, {
-            width: b = Math.round(Math.abs(m) / y),
-            height: w = Math.round(Math.abs(g) / y)
-        } = t, v = new Array(b * w * (r ? r.length : 1)), x = m / b, _ = g / w;
-        let I = 0;
-        for (const A of r ?? [void 0])
-            for (let M = 0.5; M < w; ++M)
-                for (let N = 0.5; N < b; ++N, ++I)
-                    v[I] = n(l.invert(f + N * x), u.invert(h + M * _), A);
+            width: b = Math.round(Math.abs(y) / g),
+            height: w = Math.round(Math.abs(m) / g)
+        } = t, v = new Array(b * w * (i ? i.length : 1)), x = y / b, _ = m / w;
+        let M = 0;
+        for (const T of i ?? [void 0])
+            for (let $ = 0.5; $ < w; ++$)
+                for (let N = 0.5; N < b; ++N, ++M)
+                    v[M] = n(u.invert(f + N * x), l.invert(h + $ * _), T);
         return {
             data: v,
-            facets: r,
+            facets: i,
             channels: {
                 [e]: {
                     value: v,
                     scale: "auto"
                 }
             }
         };
     });
 }
 
-function Dtt(e) {
+function CG(e) {
     if (typeof e == "function")
         return e;
     if (e == null)
-        return k1;
+        return $y;
     switch (`${e}`.toLowerCase()) {
         case "none":
-            return k1;
+            return $y;
         case "nearest":
-            return H4;
+            return a1;
         case "barycentric":
-            return X4();
+            return o1();
         case "random-walk":
-            return J4();
+            return c1();
     }
     throw new Error(`invalid interpolate: ${e}`);
 }
 
-function k1(e, t, n, i, r, s) {
+function $y(e, t, n, r, i, s) {
     const o = new Array(t * n);
     for (const a of e)
-        i[a] < 0 || i[a] >= t || r[a] < 0 || r[a] >= n || (o[Math.floor(r[a]) * t + Math.floor(i[a])] = s[a]);
+        r[a] < 0 || r[a] >= t || i[a] < 0 || i[a] >= n || (o[Math.floor(i[a]) * t + Math.floor(r[a])] = s[a]);
     return o;
 }
 
-function X4({
-    random: e = Sf(42)
+function o1({
+    random: e = jm(42)
 } = {}) {
-    return (t, n, i, r, s, o) => {
+    return (t, n, r, i, s, o) => {
         const {
             points: a,
             triangles: c,
-            hull: l
-        } = Ci.from(
+            hull: u
+        } = Ji.from(
             t,
-            (d) => r[d],
+            (d) => i[d],
             (d) => s[d]
-        ), u = new o.constructor(n * i).fill(NaN), f = new Uint8Array(n * i), h = Ltt(o, e);
+        ), l = new o.constructor(n * r).fill(NaN), f = new Uint8Array(n * r), h = VG(o, e);
         for (let d = 0; d < c.length; d += 3) {
             const p = c[d],
-                m = c[d + 1],
-                g = c[d + 2],
-                y = a[2 * p],
-                b = a[2 * m],
-                w = a[2 * g],
+                y = c[d + 1],
+                m = c[d + 2],
+                g = a[2 * p],
+                b = a[2 * y],
+                w = a[2 * m],
                 v = a[2 * p + 1],
-                x = a[2 * m + 1],
-                _ = a[2 * g + 1],
-                I = Math.min(y, b, w),
-                A = Math.max(y, b, w),
-                M = Math.min(v, x, _),
+                x = a[2 * y + 1],
+                _ = a[2 * m + 1],
+                M = Math.min(g, b, w),
+                T = Math.max(g, b, w),
+                $ = Math.min(v, x, _),
                 N = Math.max(v, x, _),
-                $ = (x - _) * (y - w) + (v - _) * (w - b);
-            if (!$)
+                A = (x - _) * (g - w) + (v - _) * (w - b);
+            if (!A)
                 continue;
-            const B = o[t[p]],
-                R = o[t[m]],
-                S = o[t[g]];
-            for (let T = Math.floor(I); T < A; ++T)
-                for (let D = Math.floor(M); D < N; ++D) {
-                    if (T < 0 || T >= n || D < 0 || D >= i)
+            const D = o[t[p]],
+                R = o[t[y]],
+                S = o[t[m]];
+            for (let I = Math.floor(M); I < T; ++I)
+                for (let E = Math.floor($); E < N; ++E) {
+                    if (I < 0 || I >= n || E < 0 || E >= r)
                         continue;
-                    const L = T + 0.5,
-                        k = D + 0.5,
-                        U = ((x - _) * (L - w) + (k - _) * (w - b)) / $;
-                    if (U < 0)
-                        continue;
-                    const C = ((_ - v) * (L - w) + (k - _) * (y - w)) / $;
+                    const k = I + 0.5,
+                        B = E + 0.5,
+                        C = ((x - _) * (k - w) + (B - _) * (w - b)) / A;
                     if (C < 0)
                         continue;
-                    const z = 1 - U - C;
-                    if (z < 0)
+                    const F = ((_ - v) * (k - w) + (B - _) * (g - w)) / A;
+                    if (F < 0)
+                        continue;
+                    const P = 1 - C - F;
+                    if (P < 0)
                         continue;
-                    const P = T + n * D;
-                    u[P] = h(B, U, R, C, S, z, T, D), f[P] = 1;
+                    const U = I + n * E;
+                    l[U] = h(D, C, R, F, S, P, I, E), f[U] = 1;
                 }
         }
-        return Ntt(u, f, r, s, o, n, i, l, t, h), u;
+        return PG(l, f, i, s, o, n, r, u, t, h), l;
     };
 }
 
-function Ntt(e, t, n, i, r, s, o, a, c, l) {
-    n = Float64Array.from(a, (d) => n[c[d]]), i = Float64Array.from(a, (d) => i[c[d]]), r = Array.from(a, (d) => r[c[d]]);
-    const u = n.length,
+function PG(e, t, n, r, i, s, o, a, c, u) {
+    n = Float64Array.from(a, (d) => n[c[d]]), r = Float64Array.from(a, (d) => r[c[d]]), i = Array.from(a, (d) => i[c[d]]);
+    const l = n.length,
         f = Array.from({
-            length: u
-        }, (d, p) => Ott(p, n, i));
+            length: l
+        }, (d, p) => zG(p, n, r));
     let h = 0;
     for (let d = 0; d < o; ++d) {
         const p = d + 0.5;
-        for (let m = 0; m < s; ++m) {
-            const g = m + s * d;
-            if (!t[g]) {
-                const y = m + 0.5;
-                for (let b = 0; b < u; ++b) {
-                    const w = (u + h + (b % 2 ? (b + 1) / 2 : -b / 2)) % u;
-                    if (f[w](y, p)) {
-                        const v = Btt(n.at(w - 1), i.at(w - 1), n[w], i[w], y, p);
-                        e[g] = l(r.at(w - 1), v, r[w], 1 - v, r[w], 0, m, d), h = w;
+        for (let y = 0; y < s; ++y) {
+            const m = y + s * d;
+            if (!t[m]) {
+                const g = y + 0.5;
+                for (let b = 0; b < l; ++b) {
+                    const w = (l + h + (b % 2 ? (b + 1) / 2 : -b / 2)) % l;
+                    if (f[w](g, p)) {
+                        const v = UG(n.at(w - 1), r.at(w - 1), n[w], r[w], g, p);
+                        e[m] = u(i.at(w - 1), v, i[w], 1 - v, i[w], 0, y, d), h = w;
                         break;
                     }
                 }
             }
         }
     }
 }
 
-function Btt(e, t, n, i, r, s) {
+function UG(e, t, n, r, i, s) {
     const o = n - e,
-        a = i - t,
-        c = o * (n - r) + a * (i - s),
-        l = o * (r - e) + a * (s - t);
-    return c > 0 && l > 0 ? c / (c + l) : +(c > l);
+        a = r - t,
+        c = o * (n - i) + a * (r - s),
+        u = o * (i - e) + a * (s - t);
+    return c > 0 && u > 0 ? c / (c + u) : +(c > u);
 }
 
-function Nl(e, t, n, i) {
-    return e * i - n * t;
+function za(e, t, n, r) {
+    return e * r - n * t;
 }
 
-function Ott(e, t, n) {
-    const i = t.length,
-        r = t.at(e - 2),
+function zG(e, t, n) {
+    const r = t.length,
+        i = t.at(e - 2),
         s = n.at(e - 2),
         o = t.at(e - 1),
         a = n.at(e - 1),
         c = t[e],
-        l = n[e],
-        u = t.at(e + 1 - i),
-        f = n.at(e + 1 - i),
+        u = n[e],
+        l = t.at(e + 1 - r),
+        f = n.at(e + 1 - r),
         h = o - c,
-        d = a - l,
-        p = r - o,
-        m = s - a,
-        g = c - u,
-        y = l - f,
+        d = a - u,
+        p = i - o,
+        y = s - a,
+        m = c - l,
+        g = u - f,
         b = Math.hypot(h, d),
-        w = Math.hypot(p, m),
-        v = Math.hypot(g, y);
+        w = Math.hypot(p, y),
+        v = Math.hypot(m, g);
     return (x, _) => {
-        const I = x - o,
-            A = _ - a,
-            M = x - c,
-            N = _ - l;
-        return Nl(I, A, M, N) > -1e-6 && Nl(I, A, h, d) * w - Nl(I, A, p, m) * b > -1e-6 && Nl(M, N, g, y) * b - Nl(M, N, h, d) * v <= 0;
+        const M = x - o,
+            T = _ - a,
+            $ = x - c,
+            N = _ - u;
+        return za(M, T, $, N) > -1e-6 && za(M, T, h, d) * w - za(M, T, p, y) * b > -1e-6 && za($, N, m, g) * b - za($, N, h, d) * v <= 0;
     };
 }
 
-function H4(e, t, n, i, r, s) {
+function a1(e, t, n, r, i, s) {
     const o = new s.constructor(t * n),
-        a = Ci.from(
+        a = Ji.from(
             e,
-            (u) => i[u],
-            (u) => r[u]
+            (l) => r[l],
+            (l) => i[l]
         );
-    let c, l;
-    for (let u = 0.5, f = 0; u < n; ++u) {
-        l = c;
+    let c, u;
+    for (let l = 0.5, f = 0; l < n; ++l) {
+        u = c;
         for (let h = 0.5; h < t; ++h, ++f)
-            l = a.find(h, u, l), h === 0.5 && (c = l), o[f] = s[e[l]];
+            u = a.find(h, l, u), h === 0.5 && (c = u), o[f] = s[e[u]];
     }
     return o;
 }
 
-function J4({
-    random: e = Sf(42),
+function c1({
+    random: e = jm(42),
     minDistance: t = 0.5,
     maxSteps: n = 2
 } = {}) {
-    return (i, r, s, o, a, c) => {
-        const l = new c.constructor(r * s),
-            u = Ci.from(
-                i,
+    return (r, i, s, o, a, c) => {
+        const u = new c.constructor(i * s),
+            l = Ji.from(
+                r,
                 (p) => o[p],
                 (p) => a[p]
             );
         let f, h, d;
-        for (let p = 0.5, m = 0; p < s; ++p) {
+        for (let p = 0.5, y = 0; p < s; ++p) {
             h = f;
-            for (let g = 0.5; g < r; ++g, ++m) {
-                let y = g,
+            for (let m = 0.5; m < i; ++m, ++y) {
+                let g = m,
                     b = p;
-                d = h = u.find(y, b, h), g === 0.5 && (f = h);
+                d = h = l.find(g, b, h), m === 0.5 && (f = h);
                 let w, v = 0;
                 for (;
-                    (w = Math.hypot(o[i[d]] - y, a[i[d]] - b)) > t && v < n;) {
-                    const x = e(g, p, v) * 2 * Math.PI;
-                    y += Math.cos(x) * w, b += Math.sin(x) * w, d = u.find(y, b, d), ++v;
+                    (w = Math.hypot(o[r[d]] - g, a[r[d]] - b)) > t && v < n;) {
+                    const x = e(m, p, v) * 2 * Math.PI;
+                    g += Math.cos(x) * w, b += Math.sin(x) * w, d = l.find(g, b, d), ++v;
                 }
-                l[m] = c[i[d]];
+                u[y] = c[r[d]];
             }
         }
-        return l;
+        return u;
     };
 }
 
-function Ftt(e, t, n, i, r, s) {
-    return t * e + i * n + s * r;
+function qG(e, t, n, r, i, s) {
+    return t * e + r * n + s * i;
 }
 
-function Ett(e) {
-    return (t, n, i, r, s, o, a, c) => {
-        const l = e(a, c);
-        return l < n ? t : l < n + r ? i : s;
+function jG(e) {
+    return (t, n, r, i, s, o, a, c) => {
+        const u = e(a, c);
+        return u < n ? t : u < n + i ? r : s;
     };
 }
 
-function Ltt(e, t) {
-    return nc(e) || gn(e) ? Ftt : Ett(t);
+function VG(e, t) {
+    return wo(e) || qe(e) ? qG : jG(t);
 }
 
-function Rtt(e, t, n) {
+function YG(e, t, n) {
     return {
-        transform(i) {
-            const r = i.length,
-                s = new Float64Array(r),
+        transform(r) {
+            const i = r.length,
+                s = new Float64Array(i),
                 o = (t - e) / n,
                 a = e + o / 2;
-            for (let c = 0; c < r; ++c)
+            for (let c = 0; c < i; ++c)
                 s[c] = c % n * o + a;
             return s;
         }
     };
 }
 
-function Ctt(e, t, n, i) {
+function WG(e, t, n, r) {
     return {
-        transform(r) {
-            const s = r.length,
+        transform(i) {
+            const s = i.length,
                 o = new Float64Array(s),
-                a = (t - e) / i,
+                a = (t - e) / r,
                 c = e + a / 2;
-            for (let l = 0; l < s; ++l)
-                o[l] = Math.floor(l / n) % i * a + c;
+            for (let u = 0; u < s; ++u)
+                o[u] = Math.floor(u / n) % r * a + c;
             return o;
         }
     };
 }
-const ES = {
+const J2 = {
     ariaLabel: "contour",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1,
     pixelSize: 2
 };
-class K4 extends j4 {
+class z4 extends F4 {
     constructor(t, {
         smooth: n = !0,
-        value: i,
-        ...r
+        value: r,
+        ...i
     } = {}) {
-        const s = i8({}, r, ES);
-        if (i === void 0) {
+        const s = JA({}, i, J2);
+        if (r === void 0) {
             for (const a in s)
                 if (s[a].value != null) {
-                    if (i !== void 0)
+                    if (r !== void 0)
                         throw new Error("ambiguous contour value");
-                    i = r[a], r[a] = "value";
+                    r = i[a], i[a] = "value";
                 }
         }
-        if (i != null) {
+        if (r != null) {
             const a = {
-                transform: (c) => c.map((l) => l.value),
-                label: wr(i)
+                transform: (c) => c.map((u) => u.value),
+                label: Ar(r)
             };
             for (const c in s)
-                r[c] === "value" && (r[c] = a);
+                i[c] === "value" && (i[c] = a);
         }
         if (t == null) {
-            if (i == null)
+            if (r == null)
                 throw new Error("missing contour value");
-            r = C1("value", {
-                value: i,
-                ...r
-            }), i = null;
+            i = Ay("value", {
+                value: r,
+                ...i
+            }), r = null;
         } else {
             let {
                 interpolate: a
-            } = r;
-            i === void 0 && (i = Tt), a === void 0 && (r.interpolate = "nearest");
+            } = i;
+            r === void 0 && (r = yt), a === void 0 && (i.interpolate = "nearest");
         }
         super(t, {
             value: {
-                value: i,
+                value: r,
                 optional: !0
             }
-        }, ktt(r), ES);
+        }, XG(i), J2);
         const o = {
             geometry: {
-                value: Tt
+                value: yt
             }
         };
         for (const a in this.channels) {
             const c = this.channels[a],
                 {
-                    scale: l
+                    scale: u
                 } = c;
-            l === "x" || l === "y" || a === "value" || (o[a] = c, delete this.channels[a]);
+            u === "x" || u === "y" || a === "value" || (o[a] = c, delete this.channels[a]);
         }
         this.contourChannels = o, this.smooth = !!n;
     }
     filter(t, {
         x: n,
-        y: i,
-        value: r,
+        y: r,
+        value: i,
         ...s
     }, o) {
         return super.filter(t, s, o);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             geometry: o
-        } = i, a = oo();
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call((c) => {
-            c.selectAll().data(t).enter().append("path").call(be, this).attr("d", (l) => a(o[l])).call(Pe, this, i);
+        } = r, a = Zi();
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n).call((c) => {
+            c.selectAll().data(t).enter().append("path").call(Qt, this).attr("d", (u) => a(o[u])).call(me, this, r);
         }).node();
     }
 }
 
-function ktt({
+function XG({
     thresholds: e,
     interval: t,
     ...n
 }) {
-    return e = p4(e, t, qb), Bn(n, function(i, r, s, o, a, c) {
-        const [l, u, f, h] = G4(s, o, a, c), d = f - l, p = h - u, {
-            pixelSize: m,
-            width: g = Math.round(Math.abs(d) / m),
-            height: y = Math.round(Math.abs(p) / m)
-        } = this, b = g / d, w = y / p, v = s.value.value, x = [];
+    return e = a4(e, t, Sm), tn(n, function(r, i, s, o, a, c) {
+        const [u, l, f, h] = U4(s, o, a, c), d = f - u, p = h - l, {
+            pixelSize: y,
+            width: m = Math.round(Math.abs(d) / y),
+            height: g = Math.round(Math.abs(p) / y)
+        } = this, b = m / d, w = g / p, v = s.value.value, x = [];
         if (this.interpolate) {
             const {
                 x: N,
-                y: $
-            } = T0(s, o, c), B = ye(N, (D) => (D - l) * b, Float64Array), R = ye($, (D) => (D - u) * w, Float64Array), S = [s.x, s.y, s.value], T = [B, R, v];
-            for (const D of r) {
-                const L = this.filter(D, S, T);
-                x.push(this.interpolate(L, g, y, B, R, v));
-            }
-        } else if (r) {
-            const N = g * y,
-                $ = r.length;
-            for (let B = 0; B < $; ++B)
-                x.push(v.slice(B * N, B * N + N));
+                y: A
+            } = Md(s, o, c), D = Zt(N, (E) => (E - u) * b, Float64Array), R = Zt(A, (E) => (E - l) * w, Float64Array), S = [s.x, s.y, s.value], I = [D, R, v];
+            for (const E of i) {
+                const k = this.filter(E, S, I);
+                x.push(this.interpolate(k, m, g, D, R, v));
+            }
+        } else if (i) {
+            const N = m * g,
+                A = i.length;
+            for (let D = 0; D < A; ++D)
+                x.push(v.slice(D * N, D * N + N));
         } else
             x.push(v);
         if (this.blur > 0)
             for (const N of x)
-                i3({
+                Hx({
                     data: N,
-                    width: g,
-                    height: y
+                    width: m,
+                    height: g
                 }, this.blur);
-        const _ = Utt(e, v, ...Ptt(x));
+        const _ = GG(e, v, ...JG(x));
         if (_ === null)
             throw new Error(`unsupported thresholds: ${e}`);
         const {
-            contour: I
-        } = rp().size([g, y]).smooth(this.smooth), A = [], M = [];
+            contour: M
+        } = Df().size([m, g]).smooth(this.smooth), T = [], $ = [];
         for (const N of x)
-            M.push(Cn(A.length, A.push(...ye(_, ($) => I(N, $)))));
+            $.push(sn(T.length, T.push(...Zt(_, (A) => M(N, A)))));
         for (const {
                 coordinates: N
             }
-            of A)
-            for (const $ of N)
-                for (const B of $)
-                    for (const R of B)
-                        R[0] = R[0] / b + l, R[1] = R[1] / w + u;
+            of T)
+            for (const A of N)
+                for (const D of A)
+                    for (const R of D)
+                        R[0] = R[0] / b + u, R[1] = R[1] / w + l;
         return {
-            data: A,
-            facets: M,
-            channels: ND(this.contourChannels, A)
+            data: T,
+            facets: $,
+            channels: SA(this.contourChannels, T)
         };
     });
 }
 
-function Utt(e, t, n, i) {
+function GG(e, t, n, r) {
     if (typeof(e == null ? void 0 : e.range) == "function")
-        return e.range(e.floor(n), i);
-    if (typeof e == "function" && (e = e(t, n, i)), typeof e != "number")
-        return Nn(e);
-    const r = Ys(...l3(n, i, e), e);
-    for (; r[r.length - 1] >= i;)
-        r.pop();
-    for (; r[1] < n;)
-        r.shift();
-    return r;
+        return e.range(e.floor(n), r);
+    if (typeof e == "function" && (e = e(t, n, r)), typeof e != "number")
+        return Qe(e);
+    const i = Ci(...eS(n, r, e), e);
+    for (; i[i.length - 1] >= r;)
+        i.pop();
+    for (; i[1] < n;)
+        i.shift();
+    return i;
 }
 
-function ztt() {
-    return new K4(...Y4("value", ...arguments));
+function HG() {
+    return new z4(...C4("value", ...arguments));
 }
 
-function Ptt(e) {
-    return [Ye(e, (t) => Ye(t, LS)), De(e, (t) => De(t, LS))];
+function JG(e) {
+    return [ve(e, (t) => ve(t, Z2)), ae(e, (t) => ae(t, Z2))];
 }
 
-function LS(e) {
+function Z2(e) {
     return isFinite(e) ? e : NaN;
 }
 
-function Vtt(e, t) {
-    return Dv(ev, e, t);
+function ZG(e, t) {
+    return u1(Td, e, t);
 }
 
-function jtt(e, t = {}) {
-    return Dv(nv, e, t);
+function KG(e, t = {}) {
+    return u1(Ed, e, t);
 }
 
-function qtt(e, t = {}) {
-    return Dv(Yp, e, t);
+function QG(e, t = {}) {
+    return u1(Gc, e, t);
 }
 
-function Dv(e, t, n = {}) {
+function u1(e, t, n = {}) {
     const {
-        x: i,
-        y: r,
+        x: r,
+        y: i,
         maxRadius: s
     } = n, o = e({
-        px: i,
-        py: r,
+        px: r,
+        py: i,
         maxRadius: s
     }), a = [];
-    i != null && a.push(Js(t, RS("x", {
+    r != null && a.push(ji(t, K2("x", {
         ...o,
         inset: -6
-    }, n))), r != null && a.push(Ks(t, RS("y", {
+    }, n))), i != null && a.push(Vi(t, K2("y", {
         ...o,
         inset: -6
-    }, n))), i != null && a.push(Pc(t, CS("x", {
+    }, n))), r != null && a.push(ra(t, Q2("x", {
         ...o,
         dy: 9,
         frameAnchor: "bottom",
         lineAnchor: "top"
-    }, n))), r != null && a.push(Pc(t, CS("y", {
+    }, n))), i != null && a.push(ra(t, Q2("y", {
         ...o,
         dx: -9,
         frameAnchor: "left",
         textAnchor: "end"
     }, n)));
     for (const c of a)
         c.ariaLabel = `crosshair ${c.ariaLabel}`;
-    return ui(...a);
+    return Tn(...a);
 }
 
-function Z4(e, {
+function q4(e, {
     channels: t,
     ...n
 }, {
-    facet: i,
-    facetAnchor: r,
+    facet: r,
+    facetAnchor: i,
     fx: s,
     fy: o,
     [e]: a,
     channels: c,
-    transform: l,
-    initializer: u
+    transform: u,
+    initializer: l
 }) {
     return {
         ...n,
-        facet: i,
-        facetAnchor: r,
+        facet: r,
+        facetAnchor: i,
         fx: s,
         fy: o,
         [e]: a,
         channels: {
             ...t,
             ...c
         },
-        transform: l,
-        initializer: Ytt(e, u)
+        transform: u,
+        initializer: tH(e, l)
     };
 }
 
-function Ytt(e, t) {
-    return t == null ? t : function(n, i, {
-        x: r,
+function tH(e, t) {
+    return t == null ? t : function(n, r, {
+        x: i,
         y: s,
         px: o,
         py: a,
         ...c
-    }, ...l) {
+    }, ...u) {
         const {
             channels: {
-                x: u,
+                x: l,
                 y: f,
                 ...h
             } = {},
             ...d
-        } = t.call(this, n, i, {
+        } = t.call(this, n, r, {
             ...c,
             x: o,
             y: a
-        }, ...l);
+        }, ...u);
         return {
             channels: {
                 ...h,
-                ...u && {
-                    px: u,
+                ...l && {
+                    px: l,
                     ...e === "x" && {
-                        x: u
+                        x: l
                     }
                 },
                 ...f && {
                     py: f,
                     ...e === "y" && {
                         y: f
                     }
                 }
             },
             ...d
         };
     };
 }
 
-function RS(e, t, n) {
+function K2(e, t, n) {
     const {
-        color: i = "currentColor",
-        opacity: r = 0.2,
-        ruleStroke: s = i,
-        ruleStrokeOpacity: o = r,
+        color: r = "currentColor",
+        opacity: i = 0.2,
+        ruleStroke: s = r,
+        ruleStrokeOpacity: o = i,
         ruleStrokeWidth: a
     } = n;
     return {
-        ...Z4(e, t, n),
+        ...q4(e, t, n),
         stroke: s,
         strokeOpacity: o,
         strokeWidth: a
     };
 }
 
-function CS(e, t, n) {
+function Q2(e, t, n) {
     const {
-        color: i = "currentColor",
-        textFill: r = i,
+        color: r = "currentColor",
+        textFill: i = r,
         textFillOpacity: s,
         textStroke: o = "var(--plot-background)",
         textStrokeOpacity: a,
         textStrokeWidth: c = 5
     } = n;
     return {
-        ...Z4(e, t, Wtt(e, n)),
-        fill: r,
+        ...q4(e, t, eH(e, n)),
+        fill: i,
         fillOpacity: s,
         stroke: o,
         strokeOpacity: a,
         strokeWidth: c
     };
 }
 
-function Wtt(e, t) {
-    return Bn(t, (n, i, r) => {
+function eH(e, t) {
+    return tn(t, (n, r, i) => {
         var s;
         return {
             channels: {
                 text: {
-                    value: (s = $1(r, e)) == null ? void 0 : s.value
+                    value: (s = yy(i, e)) == null ? void 0 : s.value
                 }
             }
         };
     });
 }
-const Gtt = {
+const nH = {
         ariaLabel: "delaunay link",
         fill: "none",
         stroke: "currentColor",
         strokeMiterlimit: 1
     },
-    Xtt = {
+    rH = {
         ariaLabel: "delaunay mesh",
         fill: null,
         stroke: "currentColor",
         strokeOpacity: 0.2
     },
-    Htt = {
+    iH = {
         ariaLabel: "hull",
         fill: "none",
         stroke: "currentColor",
         strokeWidth: 1.5,
         strokeMiterlimit: 1
     },
-    Jtt = {
+    sH = {
         ariaLabel: "voronoi",
         fill: "none",
         stroke: "currentColor",
         strokeMiterlimit: 1
     },
-    Ktt = {
+    oH = {
         ariaLabel: "voronoi mesh",
         fill: null,
         stroke: "currentColor",
         strokeOpacity: 0.2
     };
-class Ztt extends fe {
+class aH extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             z: s,
             curve: o,
             tension: a
         } = n;
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     optional: !0
                 },
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y",
                     optional: !0
                 },
                 z: {
                     value: s,
                     optional: !0
                 }
             },
             n,
-            Gtt
-        ), this.curve = hv(o, a), cl(this, n);
+            nH
+        ), this.curve = jg(o, a), va(this, n);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y: l,
-            z: u
-        } = i, {
+            y: u,
+            z: l
+        } = r, {
             curve: f
-        } = this, [h, d] = _r(this, r), p = c ? (b) => c[b] : jn(h), m = l ? (b) => l[b] : jn(d), g = this;
+        } = this, [h, d] = Ir(this, i), p = c ? (b) => c[b] : fn(h), y = u ? (b) => u[b] : fn(d), m = this;
 
-        function y(b) {
+        function g(b) {
             let w = -1;
             const v = [],
                 x = {};
-            for (const S in i)
+            for (const S in r)
                 x[S] = [];
             const _ = [],
-                I = [],
-                A = [],
-                M = [];
+                M = [],
+                T = [],
+                $ = [];
 
-            function N(S, T) {
-                S = b[S], T = b[T], v.push(++w), _[w] = p(S), A[w] = m(S), I[w] = p(T), M[w] = m(T);
-                for (const D in i)
-                    x[D].push(i[D][T]);
+            function N(S, I) {
+                S = b[S], I = b[I], v.push(++w), _[w] = p(S), T[w] = y(S), M[w] = p(I), $[w] = y(I);
+                for (const E in r)
+                    x[E].push(r[E][I]);
             }
             const {
-                halfedges: $,
-                hull: B,
+                halfedges: A,
+                hull: D,
                 triangles: R
-            } = Ci.from(b, p, m);
-            for (let S = 0; S < $.length; ++S) {
-                const T = $[S];
-                T > S && N(R[S], R[T]);
-            }
-            for (let S = 0; S < B.length; ++S)
-                N(B[S], B[(S + 1) % B.length]);
-            ce(this).selectAll().data(v).enter().append("path").call(be, g).attr("d", (S) => {
-                const T = Xr(),
-                    D = f(T);
-                return D.lineStart(), D.point(_[S], A[S]), D.point(I[S], M[S]), D.lineEnd(), T;
-            }).call(Pe, g, x).call(Vf, g, x, s);
+            } = Ji.from(b, p, y);
+            for (let S = 0; S < A.length; ++S) {
+                const I = A[S];
+                I > S && N(R[S], R[I]);
+            }
+            for (let S = 0; S < D.length; ++S)
+                N(D[S], D[(S + 1) % D.length]);
+            Wt(this).selectAll().data(v).enter().append("path").call(Qt, m).attr("d", (S) => {
+                const I = Gr(),
+                    E = f(I);
+                return E.lineStart(), E.point(_[S], T[S]), E.point(M[S], $[S]), E.lineEnd(), I;
+            }).call(me, m, x).call(Du, m, x, s);
         }
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             x: c && o,
-            y: l && a
+            y: u && a
         }).call(
-            u ? (b) => b.selectAll().data(us(t, (w) => u[w]).values()).enter().append("g").each(y) : (b) => b.datum(t).each(y)
+            l ? (b) => b.selectAll().data(ci(t, (w) => l[w]).values()).enter().append("g").each(g) : (b) => b.datum(t).each(g)
         ).node();
     }
 }
-class Nv extends fe {
-    constructor(t, n = {}, i, r = ({
+class l1 extends Ht {
+    constructor(t, n = {}, r, i = ({
         z: s
     }) => s) {
         const {
             x: s,
             y: o
         } = n;
         super(
@@ -34013,506 +34576,506 @@
                 },
                 y: {
                     value: o,
                     scale: "y",
                     optional: !0
                 },
                 z: {
-                    value: r(n),
+                    value: i(n),
                     optional: !0
                 }
             },
             n,
-            i
+            r
         );
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y: l,
-            z: u
-        } = i, [f, h] = _r(this, r), d = c ? (y) => c[y] : jn(f), p = l ? (y) => l[y] : jn(h), m = this;
-
-        function g(y) {
-            const b = Ci.from(y, d, p);
-            ce(this).append("path").datum(y[0]).call(be, m).attr("d", m._render(b, r)).call(Pe, m, i);
+            y: u,
+            z: l
+        } = r, [f, h] = Ir(this, i), d = c ? (g) => c[g] : fn(f), p = u ? (g) => u[g] : fn(h), y = this;
+
+        function m(g) {
+            const b = Ji.from(g, d, p);
+            Wt(this).append("path").datum(g[0]).call(Qt, y).attr("d", y._render(b, i)).call(me, y, r);
         }
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             x: c && o,
-            y: l && a
+            y: u && a
         }).call(
-            u ? (y) => y.selectAll().data(us(t, (b) => u[b]).values()).enter().append("g").each(g) : (y) => y.datum(t).each(g)
+            l ? (g) => g.selectAll().data(ci(t, (b) => l[b]).values()).enter().append("g").each(m) : (g) => g.datum(t).each(m)
         ).node();
     }
 }
-class Qtt extends Nv {
+class cH extends l1 {
     constructor(t, n = {}) {
-        super(t, n, Xtt), this.fill = "none";
+        super(t, n, rH), this.fill = "none";
     }
     _render(t) {
         return t.render();
     }
 }
-class tet extends Nv {
+class uH extends l1 {
     constructor(t, n = {}) {
-        super(t, n, Htt, co);
+        super(t, n, iH, Qi);
     }
     _render(t) {
         return t.renderHull();
     }
 }
-class eet extends fe {
+class lH extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             z: s
         } = n;
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     optional: !0
                 },
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y",
                     optional: !0
                 },
                 z: {
                     value: s,
                     optional: !0
                 }
             },
             n,
-            Jtt
+            sH
         );
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y: l,
-            z: u
-        } = i, [f, h] = _r(this, r), d = c ? (y) => c[y] : jn(f), p = l ? (y) => l[y] : jn(h), m = this;
-
-        function g(y) {
-            const b = Ci.from(y, d, p),
-                w = Q4(b, r);
-            ce(this).selectAll().data(y).enter().append("path").call(be, m).attr("d", (v, x) => w.renderCell(x)).call(Pe, m, i);
+            y: u,
+            z: l
+        } = r, [f, h] = Ir(this, i), d = c ? (g) => c[g] : fn(f), p = u ? (g) => u[g] : fn(h), y = this;
+
+        function m(g) {
+            const b = Ji.from(g, d, p),
+                w = j4(b, i);
+            Wt(this).selectAll().data(g).enter().append("path").call(Qt, y).attr("d", (v, x) => w.renderCell(x)).call(me, y, r);
         }
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             x: c && o,
-            y: l && a
+            y: u && a
         }).call(
-            u ? (y) => y.selectAll().data(us(t, (b) => u[b]).values()).enter().append("g").each(g) : (y) => y.datum(t).each(g)
+            l ? (g) => g.selectAll().data(ci(t, (b) => l[b]).values()).enter().append("g").each(m) : (g) => g.datum(t).each(m)
         ).node();
     }
 }
-class net extends Nv {
+class fH extends l1 {
     constructor(t, n) {
-        super(t, n, Ktt), this.fill = "none";
+        super(t, n, oH), this.fill = "none";
     }
     _render(t, n) {
-        return Q4(t, n).render();
+        return j4(t, n).render();
     }
 }
 
-function Q4(e, t) {
+function j4(e, t) {
     const {
         width: n,
-        height: i,
-        marginTop: r,
+        height: r,
+        marginTop: i,
         marginRight: s,
         marginBottom: o,
         marginLeft: a
     } = t;
-    return e.voronoi([a, r, n - s, i - o]);
+    return e.voronoi([a, i, n - s, r - o]);
 }
 
-function Yf(e, t, {
+function ku(e, t, {
     x: n,
-    y: i,
-    ...r
+    y: r,
+    ...i
 } = {}) {
-    return [n, i] = ki(n, i), new e(t, {
-        ...r,
+    return [n, r] = Jn(n, r), new e(t, {
+        ...i,
         x: n,
-        y: i
+        y: r
     });
 }
 
-function iet(e, t) {
-    return Yf(Ztt, e, t);
+function hH(e, t) {
+    return ku(aH, e, t);
 }
 
-function ret(e, t) {
-    return Yf(Qtt, e, t);
+function dH(e, t) {
+    return ku(cH, e, t);
 }
 
-function set(e, t) {
-    return Yf(tet, e, t);
+function pH(e, t) {
+    return ku(uH, e, t);
 }
 
-function oet(e, t) {
-    return Yf(eet, e, t);
+function yH(e, t) {
+    return ku(lH, e, t);
 }
 
-function aet(e, t) {
-    return Yf(net, e, t);
+function mH(e, t) {
+    return ku(fH, e, t);
 }
-const cet = {
+const gH = {
     ariaLabel: "density",
     fill: "none",
     stroke: "currentColor",
     strokeMiterlimit: 1
 };
-class tN extends fe {
+class V4 extends Ht {
     constructor(t, {
         x: n,
-        y: i,
-        z: r,
+        y: r,
+        z: i,
         weight: s,
         fill: o,
         stroke: a,
         ...c
     } = {}) {
-        const l = kS(o) && (o = "currentColor", !0),
-            u = kS(a) && (a = "currentColor", !0);
+        const u = tv(o) && (o = "currentColor", !0),
+            l = tv(a) && (a = "currentColor", !0);
         super(
             t, {
                 x: {
                     value: n,
                     scale: "x",
                     optional: !0
                 },
                 y: {
-                    value: i,
+                    value: r,
                     scale: "y",
                     optional: !0
                 },
                 z: {
-                    value: co({
-                        z: r,
+                    value: Qi({
+                        z: i,
                         fill: o,
                         stroke: a
                     }),
                     optional: !0
                 },
                 weight: {
                     value: s,
                     optional: !0
                 }
             },
-            het({
+            vH({
                 ...c,
                 fill: o,
                 stroke: a
-            }, l, u),
-            cet
-        ), l && (this.fill = void 0), u && (this.stroke = void 0), this.z = r;
+            }, u, l),
+            gH
+        ), u && (this.fill = void 0), l && (this.stroke = void 0), this.z = i;
     }
     filter(t) {
         return t;
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             contours: o
-        } = i, a = oo();
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {}).call(
-            (c) => c.selectAll().data(t).enter().append("path").call(be, this).call(Pe, this, i).attr("d", (l) => a(o[l]))
+        } = r, a = Zi();
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {}).call(
+            (c) => c.selectAll().data(t).enter().append("path").call(Qt, this).call(me, this, r).attr("d", (u) => a(o[u]))
         ).node();
     }
 }
 
-function uet(e, {
+function bH(e, {
     x: t,
     y: n,
-    ...i
+    ...r
 } = {}) {
-    return [t, n] = ki(t, n), new tN(e, {
-        ...i,
+    return [t, n] = Jn(t, n), new V4(e, {
+        ...r,
         x: t,
         y: n
     });
 }
-const fet = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
+const wH = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
 
-function het(e, t, n) {
+function vH(e, t, n) {
     let {
-        bandwidth: r,
+        bandwidth: i,
         thresholds: s
     } = e;
-    return r = r === void 0 ? 20 : +r, s = s === void 0 ? 20 : typeof(s == null ? void 0 : s[Symbol.iterator]) == "function" ? An(s) : +s, Bn(e, function(o, a, c, l, u, f) {
+    return i = i === void 0 ? 20 : +i, s = s === void 0 ? 20 : typeof(s == null ? void 0 : s[Symbol.iterator]) == "function" ? He(s) : +s, tn(e, function(o, a, c, u, l, f) {
         var R;
-        const h = c.weight ? An(c.weight.value) : null,
+        const h = c.weight ? He(c.weight.value) : null,
             d = (R = c.z) == null ? void 0 : R.value,
             {
                 z: p
             } = this,
-            [m, g] = _r(this, u),
+            [y, m] = Ir(this, l),
             {
-                width: y,
+                width: g,
                 height: b
-            } = u,
+            } = l,
             {
                 x: w,
                 y: v
-            } = T0(c, l, f),
+            } = Md(c, u, f),
             x = Object.fromEntries(
-                Object.entries(c).filter(([S]) => !fet.has(S)).map(([S, T]) => [S, {
-                    ...T,
+                Object.entries(c).filter(([S]) => !wH.has(S)).map(([S, I]) => [S, {
+                    ...I,
                     value: []
                 }])
             ),
             _ = t && [],
-            I = n && [],
-            A = sY().x(w ? (S) => w[S] : m).y(v ? (S) => v[S] : g).weight(h ? (S) => h[S] : 1).size([y, b]).bandwidth(r),
-            M = [];
+            M = n && [],
+            T = pP().x(w ? (S) => w[S] : y).y(v ? (S) => v[S] : m).weight(h ? (S) => h[S] : 1).size([g, b]).bandwidth(i),
+            $ = [];
         for (const S of a) {
-            const T = [];
-            M.push(T);
-            for (const D of d ? Jw(S, d, p) : [S]) {
-                const L = A.contours(D);
-                T.push([D, L]);
+            const I = [];
+            $.push(I);
+            for (const E of d ? Eg(S, d, p) : [S]) {
+                const k = T.contours(E);
+                I.push([E, k]);
             }
         }
         let N = s;
-        if (!(N instanceof Uc)) {
+        if (!(N instanceof ea)) {
             let S = 0;
-            for (const T of M)
-                for (const [, D] of T) {
-                    const L = D.max;
-                    L > S && (S = L);
+            for (const I of $)
+                for (const [, E] of I) {
+                    const k = E.max;
+                    k > S && (S = k);
                 }
             N = Float64Array.from({
                 length: s - 1
-            }, (T, D) => S * 100 * (D + 1) / s);
+            }, (I, E) => S * 100 * (E + 1) / s);
         }
-        const $ = [],
-            B = [];
-        for (const S of M) {
-            const T = [];
-            $.push(T);
-            for (const [D, L] of S)
-                for (const k of N) {
-                    T.push(B.length), B.push(L(k / 100)), _ && _.push(k), I && I.push(k);
-                    for (const U in x)
-                        x[U].value.push(c[U].value[D[0]]);
+        const A = [],
+            D = [];
+        for (const S of $) {
+            const I = [];
+            A.push(I);
+            for (const [E, k] of S)
+                for (const B of N) {
+                    I.push(D.length), D.push(k(B / 100)), _ && _.push(B), M && M.push(B);
+                    for (const C in x)
+                        x[C].value.push(c[C].value[E[0]]);
                 }
         }
-        return _ && _.push(0), I && I.push(0), {
+        return _ && _.push(0), M && M.push(0), {
             data: o,
-            facets: $,
+            facets: A,
             channels: {
                 ...x,
                 ..._ && {
                     fill: {
                         value: _,
                         scale: "color"
                     }
                 },
-                ...I && {
+                ...M && {
                     stroke: {
-                        value: I,
+                        value: M,
                         scale: "color"
                     }
                 },
                 contours: {
-                    value: B
+                    value: D
                 }
             }
         };
     });
 }
 
-function kS(e) {
+function tv(e) {
     return /^density$/i.test(e);
 }
 
-function det(e, {
+function _H(e, {
     x1: t,
     x2: n,
-    y1: i,
-    y2: r,
-    x: s = t === void 0 && n === void 0 ? vn : void 0,
-    y: o = i === void 0 && r === void 0 ? Tt : void 0,
+    y1: r,
+    y2: i,
+    x: s = t === void 0 && n === void 0 ? Ve : void 0,
+    y: o = r === void 0 && i === void 0 ? yt : void 0,
     fill: a,
     // ignored
     positiveFill: c = "#3ca951",
-    negativeFill: l = "#4269d0",
-    fillOpacity: u = 1,
-    positiveFillOpacity: f = u,
-    negativeFillOpacity: h = u,
+    negativeFill: u = "#4269d0",
+    fillOpacity: l = 1,
+    positiveFillOpacity: f = l,
+    negativeFillOpacity: h = l,
     stroke: d,
     strokeOpacity: p,
-    z: m = mn(d)[0],
-    clip: g,
+    z: y = ze(d)[0],
+    clip: m,
     // optional additional clip for area
-    tip: y,
+    tip: g,
     render: b,
     ...w
 } = {}) {
-    return [t, n] = US(s, t, n), [i, r] = US(o, i, r), t === n && i === r && (i = Ss(0)), {
-        tip: y
-    } = fa({
-        tip: y
-    }, "x"), ui(
-        we(c) ? null : Object.assign(
-            L1(e, {
+    return [t, n] = ev(s, t, n), [r, i] = ev(o, r, i), t === n && r === i && (r = bi(0)), {
+        tip: g
+    } = js({
+        tip: g
+    }, "x"), Tn(
+        te(c) ? null : Object.assign(
+            Sy(e, {
                 x1: t,
                 x2: n,
-                y1: i,
-                y2: r,
-                z: m,
+                y1: r,
+                y2: i,
+                z: y,
                 fill: c,
                 fillOpacity: f,
-                render: qp(b, zS(!0)),
-                clip: g,
+                render: mh(b, nv(!0)),
+                clip: m,
                 ...w
             }), {
                 ariaLabel: "positive difference"
             }
         ),
-        we(l) ? null : Object.assign(
-            L1(e, {
+        te(u) ? null : Object.assign(
+            Sy(e, {
                 x1: t,
                 x2: n,
-                y1: i,
-                y2: r,
-                z: m,
-                fill: l,
+                y1: r,
+                y2: i,
+                z: y,
+                fill: u,
                 fillOpacity: h,
-                render: qp(b, zS(!1)),
-                clip: g,
+                render: mh(b, nv(!1)),
+                clip: m,
                 ...w
             }), {
                 ariaLabel: "negative difference"
             }
         ),
-        V0(e, {
+        Ud(e, {
             x: n,
-            y: r,
-            z: m,
+            y: i,
+            z: y,
             stroke: d,
             strokeOpacity: p,
-            tip: y,
+            tip: g,
             clip: !0,
             ...w
         })
     );
 }
 
-function US(e, t, n) {
-    return t === void 0 && n === void 0 ? t = n = Ss(e) : t === void 0 ? (n = Ss(n), t = e === void 0 ? n : Ss(e)) : n === void 0 ? (t = Ss(t), n = e === void 0 ? t : Ss(e)) : (t = Ss(t), n = Ss(n)), [t, n];
+function ev(e, t, n) {
+    return t === void 0 && n === void 0 ? t = n = bi(e) : t === void 0 ? (n = bi(n), t = e === void 0 ? n : bi(e)) : n === void 0 ? (t = bi(t), n = e === void 0 ? t : bi(e)) : (t = bi(t), n = bi(n)), [t, n];
 }
 
-function Ss(e) {
+function bi(e) {
     let t;
     const {
         value: n,
-        label: i = wr(n)
-    } = al(e);
+        label: r = Ar(n)
+    } = wa(e);
     return {
-        transform: (r) => t || (t = Pt(r, n)),
-        label: i
+        transform: (i) => t || (t = $t(i, n)),
+        label: r
     };
 }
 
-function zS(e) {
-    return (t, n, i, r, s, o) => {
+function nv(e) {
+    return (t, n, r, i, s, o) => {
         const {
             x1: a,
             x2: c
-        } = i, {
-            height: l
-        } = r, u = new Float32Array(a.length), f = new Float32Array(c.length);
-        (e === HD(n.y) < 0 ? u : f).fill(l);
+        } = r, {
+            height: u
+        } = i, l = new Float32Array(a.length), f = new Float32Array(c.length);
+        (e === qA(n.y) < 0 ? l : f).fill(u);
         const h = o(t, n, {
-                ...i,
+                ...r,
                 x2: a,
                 y2: f
-            }, r, s),
+            }, i, s),
             d = o(t, n, {
-                ...i,
+                ...r,
                 x1: c,
-                y1: u
-            }, r, s),
+                y1: l
+            }, i, s),
             p = h.querySelector("g") ?? h,
-            m = d.querySelector("g") ?? d;
-        for (let g = 0; p.firstChild; g += 2) {
-            const y = O1(),
-                b = Gt("svg:clipPath", s).attr("id", y).node();
-            b.appendChild(p.firstChild), m.childNodes[g].setAttribute("clip-path", `url(#${y})`), m.insertBefore(b, m.childNodes[g]);
+            y = d.querySelector("g") ?? d;
+        for (let m = 0; p.firstChild; m += 2) {
+            const g = vy(),
+                b = Ot("svg:clipPath", s).attr("id", g).node();
+            b.appendChild(p.firstChild), y.childNodes[m].setAttribute("clip-path", `url(#${g})`), y.insertBefore(b, y.childNodes[m]);
         }
         return d;
     };
 }
-const pet = {
+const xH = {
     ariaLabel: "geo",
     fill: "none",
     stroke: "currentColor",
     strokeWidth: 1,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-class eN extends fe {
+class Y4 extends Ht {
     constructor(t, n = {}) {
-        const [i, r] = Be(n.r, 3);
+        const [r, i] = ue(n.r, 3);
         super(
             t, {
                 geometry: {
                     value: n.geometry,
                     scale: "projection"
                 },
                 r: {
-                    value: i,
+                    value: r,
                     scale: "r",
                     filter: Qr,
                     optional: !0
                 }
             },
-            Sv(n),
-            pet
-        ), this.r = r;
+            t1(n),
+            xH
+        ), this.r = i;
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             geometry: o,
             r: a
-        } = i, c = oo(s.projection ?? yet(n)), {
-            r: l
+        } = r, c = Zi(s.projection ?? SH(n)), {
+            r: u
         } = this;
-        return g0(l) ? t = [] : l !== void 0 && c.pointRadius(l), Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call((u) => {
-            u.selectAll().data(t).enter().append("path").call(be, this).attr("d", a ? (f) => c.pointRadius(a[f])(o[f]) : (f) => c(o[f])).call(Pe, this, i);
+        return dd(u) ? t = [] : u !== void 0 && c.pointRadius(u), Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n).call((l) => {
+            l.selectAll().data(t).enter().append("path").call(Qt, this).attr("d", a ? (f) => c.pointRadius(a[f])(o[f]) : (f) => c(o[f])).call(me, this, r);
         }).node();
     }
 }
 
-function yet({
+function SH({
     x: e,
     y: t
 }) {
     if (e || t)
-        return e ?? (e = (n) => n), t ?? (t = (n) => n), Ip({
-            point(n, i) {
-                this.stream.point(e(n), t(i));
+        return e ?? (e = (n) => n), t ?? (t = (n) => n), Zf({
+            point(n, r) {
+                this.stream.point(e(n), t(r));
             }
         });
 }
 
-function Bv(e, {
-    geometry: t = Tt,
+function f1(e, {
+    geometry: t = yt,
     ...n
 } = {}) {
     switch (e == null ? void 0 : e.type) {
         case "FeatureCollection":
             e = e.features;
             break;
         case "GeometryCollection":
@@ -34525,292 +35088,292 @@
         case "MultiPolygon":
         case "Point":
         case "Polygon":
         case "Sphere":
             e = [e];
             break;
     }
-    return new eN(e, {
+    return new Y4(e, {
         geometry: t,
         ...n
     });
 }
 
-function met({
+function MH({
     strokeWidth: e = 1.5,
     ...t
 } = {}) {
-    return Bv({
+    return f1({
         type: "Sphere"
     }, {
         strokeWidth: e,
         ...t
     });
 }
 
-function get({
+function AH({
     strokeOpacity: e = 0.1,
     ...t
 } = {}) {
-    return Bv(tW(), {
+    return f1(uU(), {
         strokeOpacity: e,
         ...t
     });
 }
-const mu = 0.5,
-    gu = 0;
+const dc = 0.5,
+    pc = 0;
 
-function bet(e = {
+function $H(e = {
     fill: "count"
 }, {
     binWidth: t,
     ...n
 } = {}) {
     const {
-        z: i
+        z: r
     } = n;
-    return t = t === void 0 ? 20 : qt(t), e = ID(e, n), Rs(e, "fill") && (n.channels = {
+    return t = t === void 0 ? 20 : Nt(t), e = gA(e, n), Ni(e, "fill") && (n.channels = {
         ...n.channels,
         fill: {
             value: []
         }
-    }), n.symbol === void 0 && (n.symbol = "hexagon"), n.r === void 0 && !Rs(e, "r") && (n.r = t / 2), Bn(n, (r, s, o, a, c, l) => {
+    }), n.symbol === void 0 && (n.symbol = "hexagon"), n.r === void 0 && !Ni(e, "r") && (n.r = t / 2), tn(n, (i, s, o, a, c, u) => {
         let {
-            x: u,
+            x: l,
             y: f,
             z: h,
             fill: d,
             stroke: p,
-            symbol: m
+            symbol: y
         } = o;
-        if (u === void 0)
+        if (l === void 0)
             throw new Error("missing channel: x");
         if (f === void 0)
             throw new Error("missing channel: y");
         ({
-            x: u,
+            x: l,
             y: f
-        } = T0(o, a, l)), h = h ? h.value : Pt(r, i), d = d == null ? void 0 : d.value, p = p == null ? void 0 : p.value, m = m == null ? void 0 : m.value;
-        const g = Pw(e, {
+        } = Md(o, a, u)), h = h ? h.value : $t(i, r), d = d == null ? void 0 : d.value, p = p == null ? void 0 : p.value, y = y == null ? void 0 : y.value;
+        const m = vg(e, {
                 z: h,
                 fill: d,
                 stroke: p,
-                symbol: m
+                symbol: y
             }),
-            y = h && [],
+            g = h && [],
             b = d && [],
             w = p && [],
-            v = m && [],
+            v = y && [],
             x = [],
             _ = [],
-            I = [];
-        let A = -1;
-        for (const B of e)
-            B.initialize(r);
-        for (const B of s) {
+            M = [];
+        let T = -1;
+        for (const D of e)
+            D.initialize(i);
+        for (const D of s) {
             const R = [];
             for (const S of e)
-                S.scope("facet", B);
-            for (const [S, T] of pc(B, g))
+                S.scope("facet", D);
+            for (const [S, I] of Do(D, m))
                 for (const {
-                        index: D,
-                        extent: L
+                        index: E,
+                        extent: k
                     }
-                    of wet(r, T, u, f, t)) {
-                    R.push(++A), _.push(L.x), I.push(L.y), h && y.push(g === h ? S : h[D[0]]), d && b.push(g === d ? S : d[D[0]]), p && w.push(g === p ? S : p[D[0]]), m && v.push(g === m ? S : m[D[0]]);
-                    for (const k of e)
-                        k.reduce(D, L);
+                    of IH(i, I, l, f, t)) {
+                    R.push(++T), _.push(k.x), M.push(k.y), h && g.push(m === h ? S : h[E[0]]), d && b.push(m === d ? S : d[E[0]]), p && w.push(m === p ? S : p[E[0]]), y && v.push(m === y ? S : y[E[0]]);
+                    for (const B of e)
+                        B.reduce(E, k);
                 }
             x.push(R);
         }
-        const M = o.x.scale,
+        const $ = o.x.scale,
             N = o.y.scale,
-            $ = {
+            A = {
                 x: {
                     value: _,
-                    source: a[M] ? {
-                        value: ye(_, a[M].invert),
-                        scale: M
+                    source: a[$] ? {
+                        value: Zt(_, a[$].invert),
+                        scale: $
                     } : null
                 },
                 y: {
-                    value: I,
+                    value: M,
                     source: a[N] ? {
-                        value: ye(I, a[N].invert),
+                        value: Zt(M, a[N].invert),
                         scale: N
                     } : null
                 },
                 ...h && {
                     z: {
-                        value: y
+                        value: g
                     }
                 },
                 ...d && {
                     fill: {
                         value: b,
                         scale: "auto"
                     }
                 },
                 ...p && {
                     stroke: {
                         value: w,
                         scale: "auto"
                     }
                 },
-                ...m && {
+                ...y && {
                     symbol: {
                         value: v,
                         scale: "auto"
                     }
                 },
                 ...Object.fromEntries(
                     e.map(({
-                        name: B,
+                        name: D,
                         output: R
                     }) => [
-                        B, {
+                        D, {
                             scale: "auto",
                             label: R.label,
-                            radius: B === "r" ? t / 2 : void 0,
+                            radius: D === "r" ? t / 2 : void 0,
                             value: R.transform()
                         }
                     ])
                 )
             };
         return {
-            data: r,
+            data: i,
             facets: x,
-            channels: $
+            channels: A
         };
     });
 }
 
-function wet(e, t, n, i, r) {
-    const s = r * (1.5 / wD),
+function IH(e, t, n, r, i) {
+    const s = i * (1.5 / hA),
         o = /* @__PURE__ */ new Map();
     for (const a of t) {
         let c = n[a],
-            l = i[a];
-        if (isNaN(c) || isNaN(l))
+            u = r[a];
+        if (isNaN(c) || isNaN(u))
             continue;
-        let u = Math.round(l = (l - gu) / s),
-            f = Math.round(c = (c - mu) / r - (u & 1) / 2),
-            h = l - u;
+        let l = Math.round(u = (u - pc) / s),
+            f = Math.round(c = (c - dc) / i - (l & 1) / 2),
+            h = u - l;
         if (Math.abs(h) * 3 > 1) {
-            let m = c - f,
-                g = f + (c < f ? -1 : 1) / 2,
-                y = u + (l < u ? -1 : 1),
-                b = c - g,
-                w = l - y;
-            m * m + h * h > b * b + w * w && (f = g + (u & 1 ? 1 : -1) / 2, u = y);
+            let y = c - f,
+                m = f + (c < f ? -1 : 1) / 2,
+                g = l + (u < l ? -1 : 1),
+                b = c - m,
+                w = u - g;
+            y * y + h * h > b * b + w * w && (f = m + (l & 1 ? 1 : -1) / 2, l = g);
         }
-        const d = `${f},${u}`;
+        const d = `${f},${l}`;
         let p = o.get(d);
         p === void 0 && (p = {
             index: [],
             extent: {
                 data: e,
-                x: (f + (u & 1) / 2) * r + mu,
-                y: u * s + gu
+                x: (f + (l & 1) / 2) * i + dc,
+                y: l * s + pc
             }
         }, o.set(d, p)), p.index.push(a);
     }
     return o.values();
 }
-const vet = {
+const TH = {
     ariaLabel: "hexgrid",
     fill: "none",
     stroke: "currentColor",
     strokeOpacity: 0.1
 };
 
-function _et(e) {
-    return new nN(e);
+function EH(e) {
+    return new W4(e);
 }
-class nN extends fe {
+class W4 extends Ht {
     constructor({
         binWidth: t = 20,
         clip: n = !0,
-        ...i
+        ...r
     } = {}) {
-        super(yu, void 0, {
+        super(hc, void 0, {
             clip: n,
-            ...i
-        }, vet), this.binWidth = qt(t);
+            ...r
+        }, TH), this.binWidth = Nt(t);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             binWidth: o
         } = this, {
             marginTop: a,
             marginRight: c,
-            marginBottom: l,
-            marginLeft: u,
+            marginBottom: u,
+            marginLeft: l,
             width: f,
             height: h
-        } = r, d = u - mu, p = f - c - mu, m = a - gu, g = h - l - gu, y = o / 2, b = y * vD, w = b / 2, v = y * 2, x = b * 1.5, _ = Math.floor(d / v), I = Math.ceil(p / v), A = Math.floor((m + w) / x), M = Math.ceil((g - w) / x) + 1, N = `m0,${ws(-b)}l${ws(y)},${ws(w)}v${ws(b)}l${ws(-y)},${ws(w)}`;
-        let $ = N;
-        for (let B = A; B < M; ++B)
-            for (let R = _; R < I; ++R)
-                $ += `M${ws(R * v + (B & 1) * y)},${ws(B * x)}${N}`;
-        return Gt("svg:g", s).datum(0).call(ve, this, r, s).call(ue, this, {}, He + mu, He + gu).call((B) => B.append("path").call(be, this).call(Pe, this, i).attr("d", $)).node();
+        } = i, d = l - dc, p = f - c - dc, y = a - pc, m = h - u - pc, g = o / 2, b = g * dA, w = b / 2, v = g * 2, x = b * 1.5, _ = Math.floor(d / v), M = Math.ceil(p / v), T = Math.floor((y + w) / x), $ = Math.ceil((m - w) / x) + 1, N = `m0,${yi(-b)}l${yi(g)},${yi(w)}v${yi(b)}l${yi(-g)},${yi(w)}`;
+        let A = N;
+        for (let D = T; D < $; ++D)
+            for (let R = _; R < M; ++R)
+                A += `M${yi(R * v + (D & 1) * g)},${yi(D * x)}${N}`;
+        return Ot("svg:g", s).datum(0).call(ee, this, i, s).call(Gt, this, {}, Me + dc, Me + pc).call((D) => D.append("path").call(Qt, this).call(me, this, r).attr("d", A)).node();
     }
 }
 
-function ws(e) {
+function yi(e) {
     return Math.round(e * 1e3) / 1e3;
 }
-const xet = {
+const NH = {
     ariaLabel: "image",
     fill: null,
     stroke: null
 };
 
-function Iet(e) {
+function DH(e) {
     return /^\.*\//.test(e);
 }
 
-function Aet(e) {
+function OH(e) {
     return /^(blob|data|file|http|https):/i.test(e);
 }
 
-function Met(e) {
-    return typeof e == "string" && (Iet(e) || Aet(e)) ? [void 0, e] : [e, void 0];
+function LH(e) {
+    return typeof e == "string" && (DH(e) || OH(e)) ? [void 0, e] : [e, void 0];
 }
-class iN extends fe {
+class X4 extends Ht {
     constructor(t, n = {}) {
         let {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             r: s,
             width: o,
             height: a,
             rotate: c,
-            src: l,
-            preserveAspectRatio: u,
+            src: u,
+            preserveAspectRatio: l,
             crossOrigin: f,
             frameAnchor: h,
             imageRendering: d
         } = n;
         s == null && (s = void 0), s === void 0 && o === void 0 && a === void 0 ? o = a = 16 : o === void 0 && a !== void 0 ? o = a : a === void 0 && o !== void 0 && (a = o);
-        const [p, m] = Met(l), [g, y] = Be(s), [b, w] = Be(o, y !== void 0 ? y * 2 : void 0), [v, x] = Be(a, y !== void 0 ? y * 2 : void 0), [_, I] = Be(c, 0);
+        const [p, y] = LH(u), [m, g] = ue(s), [b, w] = ue(o, g !== void 0 ? g * 2 : void 0), [v, x] = ue(a, g !== void 0 ? g * 2 : void 0), [_, M] = ue(c, 0);
         super(
             t, {
                 x: {
-                    value: i,
+                    value: r,
                     scale: "x",
                     optional: !0
                 },
                 y: {
-                    value: r,
+                    value: i,
                     scale: "y",
                     optional: !0
                 },
                 r: {
-                    value: g,
+                    value: m,
                     scale: "r",
                     filter: Qr,
                     optional: !0
                 },
                 width: {
                     value: b,
                     filter: Qr,
@@ -34826,1235 +35389,1235 @@
                     optional: !0
                 },
                 src: {
                     value: p,
                     optional: !0
                 }
             },
-            Sv(n),
-            xet
-        ), this.src = m, this.width = w, this.rotate = I, this.height = x, this.r = y, this.preserveAspectRatio = Me(u, "xMidYMid"), this.crossOrigin = tn(f), this.frameAnchor = Rf(h), this.imageRendering = Me(d, "auto");
+            t1(n),
+            NH
+        ), this.src = y, this.width = w, this.rotate = M, this.height = x, this.r = g, this.preserveAspectRatio = se(l, "xMidYMid"), this.crossOrigin = Ee(f), this.frameAnchor = Au(h), this.imageRendering = se(d, "auto");
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a
         } = n, {
             x: c,
-            y: l,
-            width: u,
+            y: u,
+            width: l,
             height: f,
             r: h,
             rotate: d,
             src: p
-        } = i, {
-            r: m,
-            width: g,
-            height: y,
+        } = r, {
+            r: y,
+            width: m,
+            height: g,
             rotate: b
-        } = this, [w, v] = _r(this, r);
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, {
+        } = this, [w, v] = Ir(this, i);
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, {
             x: c && o,
-            y: l && a
+            y: u && a
         }).call(
-            (x) => x.selectAll().data(t).enter().append("image").call(be, this).attr("x", PS(c, u, h, w, g, m)).attr("y", PS(l, f, h, v, y, m)).attr("width", u ? (_) => u[_] : g !== void 0 ? g : h ? (_) => h[_] * 2 : m * 2).attr("height", f ? (_) => f[_] : y !== void 0 ? y : h ? (_) => h[_] * 2 : m * 2).attr("transform", d ? (_) => `rotate(${d[_]})` : b ? `rotate(${b})` : null).attr("transform-origin", d || b ? F0`${c ? (_) => c[_] : w}px ${l ? (_) => l[_] : v}px` : null).call(yt, "href", p ? (_) => p[_] : this.src).call(yt, "preserveAspectRatio", this.preserveAspectRatio).call(yt, "crossorigin", this.crossOrigin).call(yt, "image-rendering", this.imageRendering).call(yt, "clip-path", h ? (_) => `circle(${h[_]}px)` : m !== void 0 ? `circle(${m}px)` : null).call(Pe, this, i)
+            (x) => x.selectAll().data(t).enter().append("image").call(Qt, this).attr("x", rv(c, l, h, w, m, y)).attr("y", rv(u, f, h, v, g, y)).attr("width", l ? (_) => l[_] : m !== void 0 ? m : h ? (_) => h[_] * 2 : y * 2).attr("height", f ? (_) => f[_] : g !== void 0 ? g : h ? (_) => h[_] * 2 : y * 2).attr("transform", d ? (_) => `rotate(${d[_]})` : b ? `rotate(${b})` : null).attr("transform-origin", d || b ? Dd`${c ? (_) => c[_] : w}px ${u ? (_) => u[_] : v}px` : null).call(at, "href", p ? (_) => p[_] : this.src).call(at, "preserveAspectRatio", this.preserveAspectRatio).call(at, "crossorigin", this.crossOrigin).call(at, "image-rendering", this.imageRendering).call(at, "clip-path", h ? (_) => `circle(${h[_]}px)` : y !== void 0 ? `circle(${y}px)` : null).call(me, this, r)
         ).node();
     }
 }
 
-function PS(e, t, n, i, r, s) {
-    return t && e ? (o) => e[o] - t[o] / 2 : t ? (o) => i - t[o] / 2 : e && r !== void 0 ? (o) => e[o] - r / 2 : r !== void 0 ? i - r / 2 : n && e ? (o) => e[o] - n[o] : n ? (o) => i - n[o] : e ? (o) => e[o] - s : i - s;
+function rv(e, t, n, r, i, s) {
+    return t && e ? (o) => e[o] - t[o] / 2 : t ? (o) => r - t[o] / 2 : e && i !== void 0 ? (o) => e[o] - i / 2 : i !== void 0 ? r - i / 2 : n && e ? (o) => e[o] - n[o] : n ? (o) => r - n[o] : e ? (o) => e[o] - s : r - s;
 }
 
-function $et(e, {
+function kH(e, {
     x: t,
     y: n,
-    ...i
+    ...r
 } = {}) {
-    return i.frameAnchor === void 0 && ([t, n] = ki(t, n)), new iN(e, {
-        ...i,
+    return r.frameAnchor === void 0 && ([t, n] = Jn(t, n)), new X4(e, {
+        ...r,
         x: t,
         y: n
     });
 }
 
-function Tet(e, t, n) {
-    var i = 1e-8,
-        r = t - 1,
+function RH(e, t, n) {
+    var r = 1e-8,
+        i = t - 1,
         s = n - 1,
         o = 0,
-        a, c, l, u, f, h, d, p, m, g, y;
+        a, c, u, l, f, h, d, p, y, m, g;
     if (e <= 0)
         return 0;
     if (e >= 1)
         return 1;
-    for (t >= 1 && n >= 1 ? (l = e < 0.5 ? e : 1 - e, u = Math.sqrt(-2 * Math.log(l)), d = (2.30753 + u * 0.27061) / (1 + u * (0.99229 + u * 0.04481)) - u, e < 0.5 && (d = -d), p = (d * d - 3) / 6, m = 2 / (1 / (2 * t - 1) + 1 / (2 * n - 1)), g = d * Math.sqrt(p + m) / m - (1 / (2 * n - 1) - 1 / (2 * t - 1)) * (p + 5 / 6 - 2 / (3 * m)), d = t / (t + n * Math.exp(2 * g))) : (a = Math.log(t / (t + n)), c = Math.log(n / (t + n)), u = Math.exp(t * a) / t, f = Math.exp(n * c) / n, g = u + f, e < u / g ? d = Math.pow(t * g * e, 1 / t) : d = 1 - Math.pow(n * g * (1 - e), 1 / n)), y = -mc(t) - mc(n) + mc(t + n); o < 10; o++) {
+    for (t >= 1 && n >= 1 ? (u = e < 0.5 ? e : 1 - e, l = Math.sqrt(-2 * Math.log(u)), d = (2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l, e < 0.5 && (d = -d), p = (d * d - 3) / 6, y = 2 / (1 / (2 * t - 1) + 1 / (2 * n - 1)), m = d * Math.sqrt(p + y) / y - (1 / (2 * n - 1) - 1 / (2 * t - 1)) * (p + 5 / 6 - 2 / (3 * y)), d = t / (t + n * Math.exp(2 * m))) : (a = Math.log(t / (t + n)), c = Math.log(n / (t + n)), l = Math.exp(t * a) / t, f = Math.exp(n * c) / n, m = l + f, e < l / m ? d = Math.pow(t * m * e, 1 / t) : d = 1 - Math.pow(n * m * (1 - e), 1 / n)), g = -Lo(t) - Lo(n) + Lo(t + n); o < 10; o++) {
         if (d === 0 || d === 1)
             return d;
-        if (h = Det(d, t, n) - e, u = Math.exp(r * Math.log(d) + s * Math.log(1 - d) + y), f = h / u, d -= u = f / (1 - 0.5 * Math.min(1, f * (r / d - s / (1 - d)))), d <= 0 && (d = 0.5 * (d + u)), d >= 1 && (d = 0.5 * (d + u + 1)), Math.abs(u) < i * d && o > 0)
+        if (h = FH(d, t, n) - e, l = Math.exp(i * Math.log(d) + s * Math.log(1 - d) + g), f = h / l, d -= l = f / (1 - 0.5 * Math.min(1, f * (i / d - s / (1 - d)))), d <= 0 && (d = 0.5 * (d + l)), d >= 1 && (d = 0.5 * (d + l + 1)), Math.abs(l) < r * d && o > 0)
             break;
     }
     return d;
 }
 
-function Det(e, t, n) {
-    var i = e === 0 || e === 1 ? 0 : Math.exp(mc(t + n) - mc(t) - mc(n) + t * Math.log(e) + n * Math.log(1 - e));
-    return e < 0 || e > 1 ? !1 : e < (t + 1) / (t + n + 2) ? i * VS(e, t, n) / t : 1 - i * VS(1 - e, n, t) / n;
+function FH(e, t, n) {
+    var r = e === 0 || e === 1 ? 0 : Math.exp(Lo(t + n) - Lo(t) - Lo(n) + t * Math.log(e) + n * Math.log(1 - e));
+    return e < 0 || e > 1 ? !1 : e < (t + 1) / (t + n + 2) ? r * iv(e, t, n) / t : 1 - r * iv(1 - e, n, t) / n;
 }
 
-function VS(e, t, n) {
-    var i = 1e-30,
-        r = 1,
+function iv(e, t, n) {
+    var r = 1e-30,
+        i = 1,
         s = t + n,
         o = t + 1,
         a = t - 1,
         c = 1,
-        l = 1 - s * e / o,
-        u, f, h, d;
-    for (Math.abs(l) < i && (l = i), l = 1 / l, d = l; r <= 100 && (u = 2 * r, f = r * (n - r) * e / ((a + u) * (t + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, d *= l * c, f = -(t + r) * (s + r) * e / ((t + u) * (o + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, h = l * c, d *= h, !(Math.abs(h - 1) < 3e-7)); r++)
+        u = 1 - s * e / o,
+        l, f, h, d;
+    for (Math.abs(u) < r && (u = r), u = 1 / u, d = u; i <= 100 && (l = 2 * i, f = i * (n - i) * e / ((a + l) * (t + l)), u = 1 + f * u, Math.abs(u) < r && (u = r), c = 1 + f / c, Math.abs(c) < r && (c = r), u = 1 / u, d *= u * c, f = -(t + i) * (s + i) * e / ((t + l) * (o + l)), u = 1 + f * u, Math.abs(u) < r && (u = r), c = 1 + f / c, Math.abs(c) < r && (c = r), u = 1 / u, h = u * c, d *= h, !(Math.abs(h - 1) < 3e-7)); i++)
     ;
     return d;
 }
 
-function mc(e) {
+function Lo(e) {
     var t = 0,
         n = [
             76.18009172947146,
             -86.5053203294167,
             24.01409824083091,
             -1.231739572450155,
             0.001208650973866179,
             -5395239384953e-18
         ],
-        i = 1.000000000190015,
-        r, s, o;
-    for (o = (s = r = e) + 5.5, o -= (r + 0.5) * Math.log(o); t < 6; t++)
-        i += n[t] / ++s;
-    return Math.log(2.506628274631 * i / r) - o;
+        r = 1.000000000190015,
+        i, s, o;
+    for (o = (s = i = e) + 5.5, o -= (i + 0.5) * Math.log(o); t < 6; t++)
+        r += n[t] / ++s;
+    return Math.log(2.506628274631 * r / i) - o;
 }
 
-function Net(e, t) {
-    var n = Tet(2 * Math.min(e, 1 - e), 0.5 * t, 0.5);
+function BH(e, t) {
+    var n = RH(2 * Math.min(e, 1 - e), 0.5 * t, 0.5);
     return n = Math.sqrt(t * (1 - n) / n), e > 0.5 ? n : -n;
 }
-const Bet = {
+const CH = {
     ariaLabel: "linear-regression",
     fill: "currentColor",
     fillOpacity: 0.1,
     stroke: "currentColor",
     strokeWidth: 1.5,
     strokeLinecap: "round",
     strokeLinejoin: "round",
     strokeMiterlimit: 1
 };
-class rN extends fe {
+class G4 extends Ht {
     constructor(t, n = {}) {
         const {
-            x: i,
-            y: r,
+            x: r,
+            y: i,
             z: s,
             ci: o = 0.95,
             precision: a = 4
         } = n;
         if (super(
                 t, {
                     x: {
-                        value: i,
+                        value: r,
                         scale: "x"
                     },
                     y: {
-                        value: r,
+                        value: i,
                         scale: "y"
                     },
                     z: {
-                        value: co(n),
+                        value: Qi(n),
                         optional: !0
                     }
                 },
                 n,
-                Bet
+                CH
             ), this.z = s, this.ci = +o, this.precision = +a, !(0 <= this.ci && this.ci < 1))
             throw new Error(`invalid ci; not in [0, 1): ${o}`);
         if (!(this.precision > 0))
             throw new Error(`invalid precision: ${a}`);
     }
-    render(t, n, i, r, s) {
+    render(t, n, r, i, s) {
         const {
             x: o,
             y: a,
             z: c
-        } = i, {
-            ci: l
+        } = r, {
+            ci: u
         } = this;
-        return Gt("svg:g", s).call(ve, this, r, s).call(ue, this, n).call(
-            (u) => u.selectAll().data(c ? Jw(t, c, this.z) : [t]).enter().call(
-                (f) => f.append("path").attr("fill", "none").call(be, this).call(jp, this, {
-                    ...i,
+        return Ot("svg:g", s).call(ee, this, i, s).call(Gt, this, n).call(
+            (l) => l.selectAll().data(c ? Eg(t, c, this.z) : [t]).enter().call(
+                (f) => f.append("path").attr("fill", "none").call(Qt, this).call(yh, this, {
+                    ...r,
                     fill: null,
                     fillOpacity: null
                 }).attr("d", (h) => this._renderLine(h, o, a)).call(
-                    l && !zc(this.fill) ? (h) => h.select(Oet).attr("stroke", "none").call(be, this).call(jp, this, {
-                        ...i,
+                    u && !na(this.fill) ? (h) => h.select(PH).attr("stroke", "none").call(Qt, this).call(yh, this, {
+                        ...r,
                         stroke: null,
                         strokeOpacity: null,
                         strokeWidth: null
                     }).attr("d", (d) => this._renderBand(d, o, a)) : () => {}
                 )
             )
         ).node();
     }
 }
 
-function Oet() {
-    return this.parentNode.insertBefore(this.ownerDocument.createElementNS(Ko.svg, "path"), this);
+function PH() {
+    return this.parentNode.insertBefore(this.ownerDocument.createElementNS(Es.svg, "path"), this);
 }
-class Fet extends rN {
+class UH extends G4 {
     constructor(t, n) {
         super(t, n);
     }
-    _renderBand(t, n, i) {
+    _renderBand(t, n, r) {
         const {
-            ci: r,
+            ci: i,
             precision: s
-        } = this, [o, a] = ke(t, (u) => i[u]), c = Qp(t, i, n), l = sN(t, i, n, (1 - r) / 2, c);
-        return yw().y((u) => u).x0((u) => l(u, -1)).x1((u) => l(u, 1))(Cn(o, a - s / 2, s).concat(a));
+        } = this, [o, a] = de(t, (l) => r[l]), c = Mh(t, r, n), u = H4(t, r, n, (1 - i) / 2, c);
+        return Hm().y((l) => l).x0((l) => u(l, -1)).x1((l) => u(l, 1))(sn(o, a - s / 2, s).concat(a));
     }
-    _renderLine(t, n, i) {
-        const [r, s] = ke(t, (a) => i[a]), o = Qp(t, i, n);
-        return `M${o(r)},${r}L${o(s)},${s}`;
+    _renderLine(t, n, r) {
+        const [i, s] = de(t, (a) => r[a]), o = Mh(t, r, n);
+        return `M${o(i)},${i}L${o(s)},${s}`;
     }
 }
-class Eet extends rN {
+class zH extends G4 {
     constructor(t, n) {
         super(t, n);
     }
-    _renderBand(t, n, i) {
+    _renderBand(t, n, r) {
         const {
-            ci: r,
+            ci: i,
             precision: s
-        } = this, [o, a] = ke(t, (u) => n[u]), c = Qp(t, n, i), l = sN(t, n, i, (1 - r) / 2, c);
-        return yw().x((u) => u).y0((u) => l(u, -1)).y1((u) => l(u, 1))(Cn(o, a - s / 2, s).concat(a));
+        } = this, [o, a] = de(t, (l) => n[l]), c = Mh(t, n, r), u = H4(t, n, r, (1 - i) / 2, c);
+        return Hm().x((l) => l).y0((l) => u(l, -1)).y1((l) => u(l, 1))(sn(o, a - s / 2, s).concat(a));
     }
-    _renderLine(t, n, i) {
-        const [r, s] = ke(t, (a) => n[a]), o = Qp(t, n, i);
-        return `M${r},${o(r)}L${s},${o(s)}`;
+    _renderLine(t, n, r) {
+        const [i, s] = de(t, (a) => n[a]), o = Mh(t, n, r);
+        return `M${i},${o(i)}L${s},${o(s)}`;
     }
 }
 
-function Let(e, {
-    y: t = vn,
-    x: n = Tt,
-    stroke: i,
-    fill: r = we(i) ? "currentColor" : i,
+function qH(e, {
+    y: t = Ve,
+    x: n = yt,
+    stroke: r,
+    fill: i = te(r) ? "currentColor" : r,
     ...s
 } = {}) {
-    return new Fet(e, pv({
+    return new UH(e, Yg({
         ...s,
         x: n,
         y: t,
-        fill: r,
-        stroke: i
+        fill: i,
+        stroke: r
     }));
 }
 
-function Ret(e, {
-    x: t = vn,
-    y: n = Tt,
-    stroke: i,
-    fill: r = we(i) ? "currentColor" : i,
+function jH(e, {
+    x: t = Ve,
+    y: n = yt,
+    stroke: r,
+    fill: i = te(r) ? "currentColor" : r,
     ...s
 } = {}) {
-    return new Eet(e, dv({
+    return new zH(e, Vg({
         ...s,
         x: t,
         y: n,
-        fill: r,
-        stroke: i
+        fill: i,
+        stroke: r
     }));
 }
 
-function Qp(e, t, n) {
-    let i = 0,
-        r = 0,
+function Mh(e, t, n) {
+    let r = 0,
+        i = 0,
         s = 0,
         o = 0;
-    for (const u of e) {
-        const f = t[u],
-            h = n[u];
-        i += f, r += h, s += f * h, o += f * f;
+    for (const l of e) {
+        const f = t[l],
+            h = n[l];
+        r += f, i += h, s += f * h, o += f * f;
     }
     const a = e.length,
-        c = (a * s - i * r) / (a * o - i * i),
-        l = (r - c * i) / a;
-    return (u) => c * u + l;
+        c = (a * s - r * i) / (a * o - r * r),
+        u = (i - c * r) / a;
+    return (l) => c * l + u;
 }
 
-function sN(e, t, n, i, r) {
-    const s = fr(e, (u) => t[u]) / e.length;
+function H4(e, t, n, r, i) {
+    const s = wr(e, (l) => t[l]) / e.length;
     let o = 0,
         a = 0;
-    for (const u of e)
-        o += (t[u] - s) ** 2, a += (n[u] - r(t[u])) ** 2;
+    for (const l of e)
+        o += (t[l] - s) ** 2, a += (n[l] - i(t[l])) ** 2;
     const c = Math.sqrt(a / (e.length - 2)),
-        l = Net(i, e.length - 2);
-    return (u, f) => {
-        const h = r(u),
-            d = c * Math.sqrt(1 / e.length + (u - s) ** 2 / o);
-        return h + f * l * d;
+        u = BH(r, e.length - 2);
+    return (l, f) => {
+        const h = i(l),
+            d = c * Math.sqrt(1 / e.length + (l - s) ** 2 / o);
+        return h + f * u * d;
     };
 }
 
-function U1({
-    path: e = Tt,
+function Iy({
+    path: e = yt,
     // the delimited path
     delimiter: t,
     // how the path is separated
     frameAnchor: n,
-    treeLayout: i = Tp,
-    treeSort: r,
+    treeLayout: r = eh,
+    treeSort: i,
     treeSeparation: s,
     treeAnchor: o,
     treeFilter: a,
     ...c
 } = {}) {
-    o = Ov(o), r = aN(r), a != null && (a = P1(a)), n === void 0 && (n = o.frameAnchor);
-    const l = cN(t),
-        u = yN(c, P1),
-        [f, h] = Un(),
-        [d, p] = Un();
+    o = h1(o), i = Z4(i), a != null && (a = Ey(a)), n === void 0 && (n = o.frameAnchor);
+    const u = K4(t),
+        l = s8(c, Ey),
+        [f, h] = an(),
+        [d, p] = an();
     return {
         x: f,
         y: d,
         frameAnchor: n,
-        ...vr(c, (m, g) => {
-            const y = l(Pt(m, e)),
+        ...$r(c, (y, m) => {
+            const g = u($t(y, e)),
                 b = h([]),
                 w = p([]);
             let v = -1;
             const x = [],
                 _ = [],
-                I = z$().path((M) => y[M]),
-                A = i();
-            A.nodeSize && A.nodeSize([1, 1]), A.separation && s !== void 0 && A.separation(s ?? Mw);
-            for (const M of u)
-                M[ty] = M[dN]([]);
-            for (const M of g) {
+                M = O3().path(($) => g[$]),
+                T = r();
+            T.nodeSize && T.nodeSize([1, 1]), T.separation && s !== void 0 && T.separation(s ?? sg);
+            for (const $ of l)
+                $[Ah] = $[r8]([]);
+            for (const $ of m) {
                 const N = [],
-                    $ = I(M.filter((B) => y[B] != null)).each((B) => B.data = m[B.data]);
-                r != null && $.sort(r), A($);
-                for (const B of $.descendants())
-                    if (!(a != null && !a(B))) {
-                        N.push(++v), x[v] = B.data, o.position(B, v, b, w);
-                        for (const R of u)
-                            R[ty][v] = R[pN](B);
+                    A = M($.filter((D) => g[D] != null)).each((D) => D.data = y[D.data]);
+                i != null && A.sort(i), T(A);
+                for (const D of A.descendants())
+                    if (!(a != null && !a(D))) {
+                        N.push(++v), x[v] = D.data, o.position(D, v, b, w);
+                        for (const R of l)
+                            R[Ah][v] = R[i8](D);
                     }
                 _.push(N);
             }
             return {
                 data: x,
                 facets: _
             };
         }),
-        ...Object.fromEntries(u)
+        ...Object.fromEntries(l)
     };
 }
 
-function oN({
-    path: e = Tt,
+function J4({
+    path: e = yt,
     // the delimited path
     delimiter: t,
     // how the path is separated
     curve: n = "bump-x",
-    stroke: i = "#555",
-    strokeWidth: r = 1.5,
+    stroke: r = "#555",
+    strokeWidth: i = 1.5,
     strokeOpacity: s = 0.5,
-    treeLayout: o = Tp,
+    treeLayout: o = eh,
     treeSort: a,
     treeSeparation: c,
-    treeAnchor: l,
-    treeFilter: u,
+    treeAnchor: u,
+    treeFilter: l,
     ...f
 } = {}) {
-    l = Ov(l), a = aN(a), u != null && (u = qS(u)), f = {
+    u = h1(u), a = Z4(a), l != null && (l = ov(l)), f = {
         curve: n,
-        stroke: i,
-        strokeWidth: r,
+        stroke: r,
+        strokeWidth: i,
         strokeOpacity: s,
         ...f
     };
-    const h = cN(t),
-        d = yN(f, qS),
-        [p, m] = Un(),
-        [g, y] = Un(),
-        [b, w] = Un(),
-        [v, x] = Un();
+    const h = K4(t),
+        d = s8(f, ov),
+        [p, y] = an(),
+        [m, g] = an(),
+        [b, w] = an(),
+        [v, x] = an();
     return {
         x1: p,
-        x2: g,
+        x2: m,
         y1: b,
         y2: v,
-        ...vr(f, (_, I) => {
-            const A = h(Pt(_, e)),
-                M = m([]),
-                N = y([]),
-                $ = w([]),
-                B = x([]);
+        ...$r(f, (_, M) => {
+            const T = h($t(_, e)),
+                $ = y([]),
+                N = g([]),
+                A = w([]),
+                D = x([]);
             let R = -1;
             const S = [],
-                T = [],
-                D = z$().path((k) => A[k]),
-                L = o();
-            L.nodeSize && L.nodeSize([1, 1]), L.separation && c !== void 0 && L.separation(c ?? Mw);
-            for (const k of d)
-                k[ty] = k[dN]([]);
-            for (const k of I) {
-                const U = [],
-                    C = D(k.filter((z) => A[z] != null)).each((z) => z.data = _[z.data]);
-                a != null && C.sort(a), L(C);
+                I = [],
+                E = O3().path((B) => T[B]),
+                k = o();
+            k.nodeSize && k.nodeSize([1, 1]), k.separation && c !== void 0 && k.separation(c ?? sg);
+            for (const B of d)
+                B[Ah] = B[r8]([]);
+            for (const B of M) {
+                const C = [],
+                    F = E(B.filter((P) => T[P] != null)).each((P) => P.data = _[P.data]);
+                a != null && F.sort(a), k(F);
                 for (const {
-                        source: z,
-                        target: P
+                        source: P,
+                        target: U
                     }
-                    of C.links())
-                    if (!(u != null && !u(P, z))) {
-                        U.push(++R), S[R] = P.data, l.position(z, R, M, $), l.position(P, R, N, B);
-                        for (const G of d)
-                            G[ty][R] = G[pN](P, z);
+                    of F.links())
+                    if (!(l != null && !l(U, P))) {
+                        C.push(++R), S[R] = U.data, u.position(P, R, $, A), u.position(U, R, N, D);
+                        for (const Y of d)
+                            Y[Ah][R] = Y[i8](U, P);
                     }
-                T.push(U);
+                I.push(C);
             }
             return {
                 data: S,
-                facets: T
+                facets: I
             };
         }),
         ...Object.fromEntries(d)
     };
 }
 
-function Ov(e = "left") {
+function h1(e = "left") {
     switch (`${e}`.trim().toLowerCase()) {
         case "left":
-            return Cet;
+            return VH;
         case "right":
-            return ket;
+            return YH;
     }
     throw new Error(`invalid tree anchor: ${e}`);
 }
-const Cet = {
+const VH = {
         frameAnchor: "left",
         dx: 6,
         position({
             x: e,
             y: t
-        }, n, i, r) {
-            i[n] = t, r[n] = -e;
+        }, n, r, i) {
+            r[n] = t, i[n] = -e;
         }
     },
-    ket = {
+    YH = {
         frameAnchor: "right",
         dx: -6,
         position({
             x: e,
             y: t
-        }, n, i, r) {
-            i[n] = -t, r[n] = -e;
+        }, n, r, i) {
+            r[n] = -t, i[n] = -e;
         }
     };
 
-function aN(e) {
-    return e == null || typeof e == "function" ? e : `${e}`.trim().toLowerCase().startsWith("node:") ? jS(P1(e)) : jS(Uet(e));
+function Z4(e) {
+    return e == null || typeof e == "function" ? e : `${e}`.trim().toLowerCase().startsWith("node:") ? sv(Ey(e)) : sv(WH(e));
 }
 
-function jS(e) {
-    return (t, n) => li(e(t), e(n));
+function sv(e) {
+    return (t, n) => In(e(t), e(n));
 }
 
-function Uet(e) {
+function WH(e) {
     return (t) => {
         var n;
         return (n = t.data) == null ? void 0 : n[e];
     };
 }
 
-function cN(e = "/") {
+function K4(e = "/") {
     if (e = `${e}`, e === "/")
         return (n) => n;
     if (e.length !== 1)
         throw new Error("delimiter must be exactly one character");
     const t = e.charCodeAt(0);
-    return (n) => n.map((i) => zet(i, t));
+    return (n) => n.map((r) => XH(r, t));
 }
-const z1 = 92,
-    lN = 47;
+const Ty = 92,
+    Q4 = 47;
 
-function zet(e, t) {
-    if (t === z1)
+function XH(e, t) {
+    if (t === Ty)
         throw new Error("delimiter cannot be backslash");
     let n = !1;
-    for (let i = 0, r = e.length; i < r; ++i) {
-        switch (e.charCodeAt(i)) {
-            case z1:
+    for (let r = 0, i = e.length; r < i; ++r) {
+        switch (e.charCodeAt(r)) {
+            case Ty:
                 if (!n) {
                     n = !0;
                     continue;
                 }
                 break;
             case t:
-                n ? (e = e.slice(0, i - 1) + e.slice(i), --i, --r) : e = e.slice(0, i) + "/" + e.slice(i + 1);
+                n ? (e = e.slice(0, r - 1) + e.slice(r), --r, --i) : e = e.slice(0, r) + "/" + e.slice(r + 1);
                 break;
-            case lN:
-                n ? (e = e.slice(0, i) + "\\\\" + e.slice(i), i += 2, r += 2) : (e = e.slice(0, i) + "\\" + e.slice(i), ++i, ++r);
+            case Q4:
+                n ? (e = e.slice(0, r) + "\\\\" + e.slice(r), r += 2, i += 2) : (e = e.slice(0, r) + "\\" + e.slice(r), ++r, ++i);
                 break;
         }
         n = !1;
     }
     return e;
 }
 
-function Pet(e) {
+function GH(e) {
     let t = !1;
-    for (let n = 0, i = e.length; n < i; ++n) {
+    for (let n = 0, r = e.length; n < r; ++n) {
         switch (e.charCodeAt(n)) {
-            case z1:
+            case Ty:
                 if (!t) {
                     t = !0;
                     continue;
                 }
-            case lN:
-                t && (e = e.slice(0, n - 1) + e.slice(n), --n, --i);
+            case Q4:
+                t && (e = e.slice(0, n - 1) + e.slice(n), --n, --r);
                 break;
         }
         t = !1;
     }
     return e;
 }
 
-function uN(e) {
-    return hi(e) && typeof e.node == "function";
+function t8(e) {
+    return En(e) && typeof e.node == "function";
 }
 
-function Vet(e) {
-    return hi(e) && typeof e.link == "function";
+function HH(e) {
+    return En(e) && typeof e.link == "function";
 }
 
-function P1(e) {
-    if (uN(e))
+function Ey(e) {
+    if (t8(e))
         return e.node;
     if (e = `${e}`.trim().toLowerCase(), !!e.startsWith("node:")) {
         switch (e) {
             case "node:name":
-                return j1;
+                return Dy;
             case "node:path":
-                return V1;
+                return Ny;
             case "node:internal":
-                return fN;
+                return e8;
             case "node:external":
-                return hN;
+                return n8;
             case "node:depth":
-                return q1;
+                return Oy;
             case "node:height":
-                return Y1;
+                return Ly;
         }
         throw new Error(`invalid node value: ${e}`);
     }
 }
 
-function qS(e) {
-    if (uN(e))
+function ov(e) {
+    if (t8(e))
         return e.node;
-    if (Vet(e))
+    if (HH(e))
         return e.link;
     if (e = `${e}`.trim().toLowerCase(), !(!e.startsWith("node:") && !e.startsWith("parent:"))) {
         switch (e) {
             case "parent:name":
-                return Oh(j1);
+                return gl(Dy);
             case "parent:path":
-                return Oh(V1);
+                return gl(Ny);
             case "parent:depth":
-                return Oh(q1);
+                return gl(Oy);
             case "parent:height":
-                return Oh(Y1);
+                return gl(Ly);
             case "node:name":
-                return j1;
+                return Dy;
             case "node:path":
-                return V1;
+                return Ny;
             case "node:internal":
-                return fN;
+                return e8;
             case "node:external":
-                return hN;
+                return n8;
             case "node:depth":
-                return q1;
+                return Oy;
             case "node:height":
-                return Y1;
+                return Ly;
         }
         throw new Error(`invalid link value: ${e}`);
     }
 }
 
-function V1(e) {
+function Ny(e) {
     return e.id;
 }
 
-function j1(e) {
-    return jet(e.id);
+function Dy(e) {
+    return JH(e.id);
 }
 
-function q1(e) {
+function Oy(e) {
     return e.depth;
 }
 
-function Y1(e) {
+function Ly(e) {
     return e.height;
 }
 
-function fN(e) {
+function e8(e) {
     return !!e.children;
 }
 
-function hN(e) {
+function n8(e) {
     return !e.children;
 }
 
-function Oh(e) {
+function gl(e) {
     return (t, n) => n == null ? void 0 : e(n);
 }
 
-function jet(e) {
+function JH(e) {
     let t = e.length;
-    for (; --t > 0 && !qet(e, t);)
+    for (; --t > 0 && !ZH(e, t);)
     ;
-    return Pet(e.slice(t + 1));
+    return GH(e.slice(t + 1));
 }
 
-function qet(e, t) {
+function ZH(e, t) {
     if (e[t] === "/") {
         let n = 0;
         for (; t > 0 && e[--t] === "\\";)
             ++n;
         if (!(n & 1))
             return !0;
     }
     return !1;
 }
-const dN = 2,
-    pN = 3,
-    ty = 4;
+const r8 = 2,
+    i8 = 3,
+    Ah = 4;
 
-function yN(e, t) {
+function s8(e, t) {
     const n = [];
-    for (const i in e) {
-        const r = e[i],
-            s = t(r);
-        s !== void 0 && n.push([i, ...Un(r), s]);
+    for (const r in e) {
+        const i = e[r],
+            s = t(i);
+        s !== void 0 && n.push([r, ...an(i), s]);
     }
     return n;
 }
 
-function mN(e, {
+function o8(e, {
     fill: t,
     stroke: n,
-    strokeWidth: i,
-    strokeOpacity: r,
+    strokeWidth: r,
+    strokeOpacity: i,
     strokeLinejoin: s,
     strokeLinecap: o,
     strokeMiterlimit: a,
     strokeDasharray: c,
-    strokeDashoffset: l,
-    marker: u,
-    markerStart: f = u,
-    markerEnd: h = u,
-    dot: d = we(f) && we(h),
+    strokeDashoffset: u,
+    marker: l,
+    markerStart: f = l,
+    markerEnd: h = l,
+    dot: d = te(f) && te(h),
     text: p = "node:name",
-    textStroke: m = "var(--plot-background)",
-    title: g = "node:path",
-    dx: y,
+    textStroke: y = "var(--plot-background)",
+    title: m = "node:path",
+    dx: g,
     dy: b,
     textAnchor: w,
-    treeLayout: v = Tp,
-    textLayout: x = v === Tp || v === C$ ? "mirrored" : "normal",
+    treeLayout: v = eh,
+    textLayout: x = v === eh || v === E3 ? "mirrored" : "normal",
     tip: _,
-    ...I
+    ...M
 } = {}) {
-    if (y === void 0 && (y = Ov(I.treeAnchor).dx), w !== void 0)
+    if (g === void 0 && (g = h1(M.treeAnchor).dx), w !== void 0)
         throw new Error("textAnchor is not a configurable tree option");
-    x = qn(x, "textLayout", ["mirrored", "normal"]);
+    x = hn(x, "textLayout", ["mirrored", "normal"]);
 
-    function A(M) {
-        return Pc(
+    function T($) {
+        return ra(
             e,
-            U1({
+            Iy({
                 treeLayout: v,
                 text: p,
                 fill: t === void 0 ? "currentColor" : t,
-                stroke: m,
-                dx: y,
+                stroke: y,
+                dx: g,
                 dy: b,
-                title: g,
-                ...M,
-                ...I
+                title: m,
+                ...$,
+                ...M
             })
         );
     }
-    return ui(
-        M4(
+    return Tn(
+        w4(
             e,
-            oN({
+            J4({
                 treeLayout: v,
                 markerStart: f,
                 markerEnd: h,
                 stroke: n !== void 0 ? n : t === void 0 ? "node:internal" : t,
-                strokeWidth: i,
-                strokeOpacity: r,
+                strokeWidth: r,
+                strokeOpacity: i,
                 strokeLinejoin: s,
                 strokeLinecap: o,
                 strokeMiterlimit: a,
                 strokeDasharray: c,
-                strokeDashoffset: l,
-                ...I
+                strokeDashoffset: u,
+                ...M
             })
         ),
-        d ? fo(e, U1({
+        d ? ns(e, Iy({
             treeLayout: v,
             fill: t === void 0 ? "node:internal" : t,
-            title: g,
+            title: m,
             tip: _,
-            ...I
+            ...M
         })) : null,
         p != null ? x === "mirrored" ? [
-            A({
+            T({
                 textAnchor: "start",
                 treeFilter: "node:external"
             }),
-            A({
+            T({
                 textAnchor: "end",
                 treeFilter: "node:internal",
-                dx: -y
+                dx: -g
             })
-        ] : A() : null
+        ] : T() : null
     );
 }
 
-function Yet(e, t) {
-    return mN(e, {
+function KH(e, t) {
+    return o8(e, {
         ...t,
-        treeLayout: C$
+        treeLayout: E3
     });
 }
 
-function Wet({
-    geometry: e = Tt,
+function QH({
+    geometry: e = yt,
     ...t
 } = {}) {
-    return Bn({
+    return tn({
         ...t,
         x: null,
         y: null
-    }, (n, i, r, s, o, {
+    }, (n, r, i, s, o, {
         projection: a
     }) => {
-        const c = Pt(n, e),
-            l = c.length,
-            u = new Float64Array(l),
-            f = new Float64Array(l),
-            h = oo(a);
-        for (let d = 0; d < l; ++d)
-            [u[d], f[d]] = h.centroid(c[d]);
+        const c = $t(n, e),
+            u = c.length,
+            l = new Float64Array(u),
+            f = new Float64Array(u),
+            h = Zi(a);
+        for (let d = 0; d < u; ++d)
+            [l[d], f[d]] = h.centroid(c[d]);
         return {
             data: n,
-            facets: i,
+            facets: r,
             channels: {
                 x: {
-                    value: u,
+                    value: l,
                     scale: a == null ? "x" : null,
                     source: null
                 },
                 y: {
                     value: f,
                     scale: a == null ? "y" : null,
                     source: null
                 }
             }
         };
     });
 }
 
-function Get({
-    geometry: e = Tt,
+function tJ({
+    geometry: e = yt,
     ...t
 } = {}) {
     let n;
     return {
         ...t,
         x: {
-            transform: (i) => Float64Array.from(n = Pt(Pt(i, e), VY), ([r]) => r)
+            transform: (r) => Float64Array.from(n = $t($t(r, e), ZP), ([i]) => i)
         },
         y: {
-            transform: () => Float64Array.from(n, ([, i]) => i)
+            transform: () => Float64Array.from(n, ([, r]) => r)
         }
     };
 }
 
-function Xet(e) {
+function eJ(e) {
     return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
 }
 
-function Het(e, t, n, i, r) {
-    for (var s = r + 1; i <= r;) {
-        var o = i + r >>> 1,
+function nJ(e, t, n, r, i) {
+    for (var s = i + 1; r <= i;) {
+        var o = r + i >>> 1,
             a = e[o],
             c = n !== void 0 ? n(a, t) : a - t;
-        c >= 0 ? (s = o, r = o - 1) : i = o + 1;
+        c >= 0 ? (s = o, i = o - 1) : r = o + 1;
     }
     return s;
 }
 
-function Jet(e, t, n, i, r) {
-    for (var s = r + 1; i <= r;) {
-        var o = i + r >>> 1,
+function rJ(e, t, n, r, i) {
+    for (var s = i + 1; r <= i;) {
+        var o = r + i >>> 1,
             a = e[o],
             c = n !== void 0 ? n(a, t) : a - t;
-        c > 0 ? (s = o, r = o - 1) : i = o + 1;
+        c > 0 ? (s = o, i = o - 1) : r = o + 1;
     }
     return s;
 }
 
-function Ket(e, t, n, i, r) {
-    for (var s = i - 1; i <= r;) {
-        var o = i + r >>> 1,
+function iJ(e, t, n, r, i) {
+    for (var s = r - 1; r <= i;) {
+        var o = r + i >>> 1,
             a = e[o],
             c = n !== void 0 ? n(a, t) : a - t;
-        c < 0 ? (s = o, i = o + 1) : r = o - 1;
+        c < 0 ? (s = o, r = o + 1) : i = o - 1;
     }
     return s;
 }
 
-function Zet(e, t, n, i, r) {
-    for (var s = i - 1; i <= r;) {
-        var o = i + r >>> 1,
+function sJ(e, t, n, r, i) {
+    for (var s = r - 1; r <= i;) {
+        var o = r + i >>> 1,
             a = e[o],
             c = n !== void 0 ? n(a, t) : a - t;
-        c <= 0 ? (s = o, i = o + 1) : r = o - 1;
+        c <= 0 ? (s = o, r = o + 1) : i = o - 1;
     }
     return s;
 }
 
-function Qet(e, t, n, i, r) {
-    for (; i <= r;) {
-        var s = i + r >>> 1,
+function oJ(e, t, n, r, i) {
+    for (; r <= i;) {
+        var s = r + i >>> 1,
             o = e[s],
             a = n !== void 0 ? n(o, t) : o - t;
         if (a === 0)
             return s;
-        a <= 0 ? i = s + 1 : r = s - 1;
+        a <= 0 ? r = s + 1 : i = s - 1;
     }
     return -1;
 }
 
-function Bl(e, t, n, i, r, s) {
-    return typeof n == "function" ? s(e, t, n, i === void 0 ? 0 : i | 0, r === void 0 ? e.length - 1 : r | 0) : s(e, t, void 0, n === void 0 ? 0 : n | 0, i === void 0 ? e.length - 1 : i | 0);
+function qa(e, t, n, r, i, s) {
+    return typeof n == "function" ? s(e, t, n, r === void 0 ? 0 : r | 0, i === void 0 ? e.length - 1 : i | 0) : s(e, t, void 0, n === void 0 ? 0 : n | 0, r === void 0 ? e.length - 1 : r | 0);
 }
-var tnt = {
-        ge: function(e, t, n, i, r) {
-            return Bl(e, t, n, i, r, Het);
+var aJ = {
+        ge: function(e, t, n, r, i) {
+            return qa(e, t, n, r, i, nJ);
         },
-        gt: function(e, t, n, i, r) {
-            return Bl(e, t, n, i, r, Jet);
+        gt: function(e, t, n, r, i) {
+            return qa(e, t, n, r, i, rJ);
         },
-        lt: function(e, t, n, i, r) {
-            return Bl(e, t, n, i, r, Ket);
+        lt: function(e, t, n, r, i) {
+            return qa(e, t, n, r, i, iJ);
         },
-        le: function(e, t, n, i, r) {
-            return Bl(e, t, n, i, r, Zet);
+        le: function(e, t, n, r, i) {
+            return qa(e, t, n, r, i, sJ);
         },
-        eq: function(e, t, n, i, r) {
-            return Bl(e, t, n, i, r, Qet);
+        eq: function(e, t, n, r, i) {
+            return qa(e, t, n, r, i, oJ);
         }
     },
-    ey = tnt,
-    rc = 0,
-    Do = 1,
-    ad = 2,
-    ent = int;
+    $h = aJ,
+    _o = 0,
+    us = 1,
+    zl = 2,
+    cJ = lJ;
 
-function Fv(e, t, n, i, r) {
-    this.mid = e, this.left = t, this.right = n, this.leftPoints = i, this.rightPoints = r, this.count = (t ? t.count : 0) + (n ? n.count : 0) + i.length;
+function d1(e, t, n, r, i) {
+    this.mid = e, this.left = t, this.right = n, this.leftPoints = r, this.rightPoints = i, this.count = (t ? t.count : 0) + (n ? n.count : 0) + r.length;
 }
-var Wf = Fv.prototype;
+var Ru = d1.prototype;
 
-function eg(e, t) {
+function Jp(e, t) {
     e.mid = t.mid, e.left = t.left, e.right = t.right, e.leftPoints = t.leftPoints, e.rightPoints = t.rightPoints, e.count = t.count;
 }
 
-function gN(e, t) {
-    var n = Yc(t);
+function a8(e, t) {
+    var n = aa(t);
     e.mid = n.mid, e.left = n.left, e.right = n.right, e.leftPoints = n.leftPoints, e.rightPoints = n.rightPoints, e.count = n.count;
 }
 
-function YS(e, t) {
+function av(e, t) {
     var n = e.intervals([]);
-    n.push(t), gN(e, n);
+    n.push(t), a8(e, n);
 }
 
-function WS(e, t) {
+function cv(e, t) {
     var n = e.intervals([]),
-        i = n.indexOf(t);
-    return i < 0 ? rc : (n.splice(i, 1), gN(e, n), Do);
+        r = n.indexOf(t);
+    return r < 0 ? _o : (n.splice(r, 1), a8(e, n), us);
 }
-Wf.intervals = function(e) {
+Ru.intervals = function(e) {
     return e.push.apply(e, this.leftPoints), this.left && this.left.intervals(e), this.right && this.right.intervals(e), e;
 };
-Wf.insert = function(e) {
+Ru.insert = function(e) {
     var t = this.count - this.leftPoints.length;
     if (this.count += 1, e[1] < this.mid)
-        this.left ? 4 * (this.left.count + 1) > 3 * (t + 1) ? YS(this, e) : this.left.insert(e) : this.left = Yc([e]);
+        this.left ? 4 * (this.left.count + 1) > 3 * (t + 1) ? av(this, e) : this.left.insert(e) : this.left = aa([e]);
     else if (e[0] > this.mid)
-        this.right ? 4 * (this.right.count + 1) > 3 * (t + 1) ? YS(this, e) : this.right.insert(e) : this.right = Yc([e]);
+        this.right ? 4 * (this.right.count + 1) > 3 * (t + 1) ? av(this, e) : this.right.insert(e) : this.right = aa([e]);
     else {
-        var n = ey.ge(this.leftPoints, e, Ev),
-            i = ey.ge(this.rightPoints, e, Lv);
-        this.leftPoints.splice(n, 0, e), this.rightPoints.splice(i, 0, e);
+        var n = $h.ge(this.leftPoints, e, p1),
+            r = $h.ge(this.rightPoints, e, y1);
+        this.leftPoints.splice(n, 0, e), this.rightPoints.splice(r, 0, e);
     }
 };
-Wf.remove = function(e) {
+Ru.remove = function(e) {
     var t = this.count - this.leftPoints;
     if (e[1] < this.mid) {
         if (!this.left)
-            return rc;
+            return _o;
         var n = this.right ? this.right.count : 0;
         if (4 * n > 3 * (t - 1))
-            return WS(this, e);
-        var i = this.left.remove(e);
-        return i === ad ? (this.left = null, this.count -= 1, Do) : (i === Do && (this.count -= 1), i);
+            return cv(this, e);
+        var r = this.left.remove(e);
+        return r === zl ? (this.left = null, this.count -= 1, us) : (r === us && (this.count -= 1), r);
     } else if (e[0] > this.mid) {
         if (!this.right)
-            return rc;
-        var r = this.left ? this.left.count : 0;
-        if (4 * r > 3 * (t - 1))
-            return WS(this, e);
-        var i = this.right.remove(e);
-        return i === ad ? (this.right = null, this.count -= 1, Do) : (i === Do && (this.count -= 1), i);
+            return _o;
+        var i = this.left ? this.left.count : 0;
+        if (4 * i > 3 * (t - 1))
+            return cv(this, e);
+        var r = this.right.remove(e);
+        return r === zl ? (this.right = null, this.count -= 1, us) : (r === us && (this.count -= 1), r);
     } else {
         if (this.count === 1)
-            return this.leftPoints[0] === e ? ad : rc;
+            return this.leftPoints[0] === e ? zl : _o;
         if (this.leftPoints.length === 1 && this.leftPoints[0] === e) {
             if (this.left && this.right) {
                 for (var s = this, o = this.left; o.right;)
                     s = o, o = o.right;
                 if (s === this)
                     o.right = this.right;
                 else {
                     var a = this.left,
-                        i = this.right;
-                    s.count -= o.count, s.right = o.left, o.left = a, o.right = i;
+                        r = this.right;
+                    s.count -= o.count, s.right = o.left, o.left = a, o.right = r;
                 }
-                eg(this, o), this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
+                Jp(this, o), this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
             } else
-                this.left ? eg(this, this.left) : eg(this, this.right);
-            return Do;
+                this.left ? Jp(this, this.left) : Jp(this, this.right);
+            return us;
         }
-        for (var a = ey.ge(this.leftPoints, e, Ev); a < this.leftPoints.length && this.leftPoints[a][0] === e[0]; ++a)
+        for (var a = $h.ge(this.leftPoints, e, p1); a < this.leftPoints.length && this.leftPoints[a][0] === e[0]; ++a)
             if (this.leftPoints[a] === e) {
                 this.count -= 1, this.leftPoints.splice(a, 1);
-                for (var i = ey.ge(this.rightPoints, e, Lv); i < this.rightPoints.length && this.rightPoints[i][1] === e[1]; ++i)
-                    if (this.rightPoints[i] === e)
-                        return this.rightPoints.splice(i, 1), Do;
+                for (var r = $h.ge(this.rightPoints, e, y1); r < this.rightPoints.length && this.rightPoints[r][1] === e[1]; ++r)
+                    if (this.rightPoints[r] === e)
+                        return this.rightPoints.splice(r, 1), us;
             }
-        return rc;
+        return _o;
     }
 };
 
-function bN(e, t, n) {
-    for (var i = 0; i < e.length && e[i][0] <= t; ++i) {
-        var r = n(e[i]);
-        if (r)
-            return r;
+function c8(e, t, n) {
+    for (var r = 0; r < e.length && e[r][0] <= t; ++r) {
+        var i = n(e[r]);
+        if (i)
+            return i;
     }
 }
 
-function wN(e, t, n) {
-    for (var i = e.length - 1; i >= 0 && e[i][1] >= t; --i) {
-        var r = n(e[i]);
-        if (r)
-            return r;
+function u8(e, t, n) {
+    for (var r = e.length - 1; r >= 0 && e[r][1] >= t; --r) {
+        var i = n(e[r]);
+        if (i)
+            return i;
     }
 }
 
-function vN(e, t) {
+function l8(e, t) {
     for (var n = 0; n < e.length; ++n) {
-        var i = t(e[n]);
-        if (i)
-            return i;
+        var r = t(e[n]);
+        if (r)
+            return r;
     }
 }
-Wf.queryPoint = function(e, t) {
+Ru.queryPoint = function(e, t) {
     if (e < this.mid) {
         if (this.left) {
             var n = this.left.queryPoint(e, t);
             if (n)
                 return n;
         }
-        return bN(this.leftPoints, e, t);
+        return c8(this.leftPoints, e, t);
     } else if (e > this.mid) {
         if (this.right) {
             var n = this.right.queryPoint(e, t);
             if (n)
                 return n;
         }
-        return wN(this.rightPoints, e, t);
+        return u8(this.rightPoints, e, t);
     } else
-        return vN(this.leftPoints, t);
+        return l8(this.leftPoints, t);
 };
-Wf.queryInterval = function(e, t, n) {
+Ru.queryInterval = function(e, t, n) {
     if (e < this.mid && this.left) {
-        var i = this.left.queryInterval(e, t, n);
-        if (i)
-            return i;
+        var r = this.left.queryInterval(e, t, n);
+        if (r)
+            return r;
     }
     if (t > this.mid && this.right) {
-        var i = this.right.queryInterval(e, t, n);
-        if (i)
-            return i;
+        var r = this.right.queryInterval(e, t, n);
+        if (r)
+            return r;
     }
-    return t < this.mid ? bN(this.leftPoints, t, n) : e > this.mid ? wN(this.rightPoints, e, n) : vN(this.leftPoints, n);
+    return t < this.mid ? c8(this.leftPoints, t, n) : e > this.mid ? u8(this.rightPoints, e, n) : l8(this.leftPoints, n);
 };
 
-function nnt(e, t) {
+function uJ(e, t) {
     return e - t;
 }
 
-function Ev(e, t) {
+function p1(e, t) {
     var n = e[0] - t[0];
     return n || e[1] - t[1];
 }
 
-function Lv(e, t) {
+function y1(e, t) {
     var n = e[1] - t[1];
     return n || e[0] - t[0];
 }
 
-function Yc(e) {
+function aa(e) {
     if (e.length === 0)
         return null;
     for (var t = [], n = 0; n < e.length; ++n)
         t.push(e[n][0], e[n][1]);
-    t.sort(nnt);
-    for (var i = t[t.length >> 1], r = [], s = [], o = [], n = 0; n < e.length; ++n) {
+    t.sort(uJ);
+    for (var r = t[t.length >> 1], i = [], s = [], o = [], n = 0; n < e.length; ++n) {
         var a = e[n];
-        a[1] < i ? r.push(a) : i < a[0] ? s.push(a) : o.push(a);
+        a[1] < r ? i.push(a) : r < a[0] ? s.push(a) : o.push(a);
     }
     var c = o,
-        l = o.slice();
-    return c.sort(Ev), l.sort(Lv), new Fv(
-        i,
-        Yc(r),
-        Yc(s),
+        u = o.slice();
+    return c.sort(p1), u.sort(y1), new d1(
+        r,
+        aa(i),
+        aa(s),
         c,
-        l
+        u
     );
 }
 
-function W1(e) {
+function ky(e) {
     this.root = e;
 }
-var dl = W1.prototype;
-dl.insert = function(e) {
-    this.root ? this.root.insert(e) : this.root = new Fv(e[0], null, null, [e], [e]);
+var Aa = ky.prototype;
+Aa.insert = function(e) {
+    this.root ? this.root.insert(e) : this.root = new d1(e[0], null, null, [e], [e]);
 };
-dl.remove = function(e) {
+Aa.remove = function(e) {
     if (this.root) {
         var t = this.root.remove(e);
-        return t === ad && (this.root = null), t !== rc;
+        return t === zl && (this.root = null), t !== _o;
     }
     return !1;
 };
-dl.queryPoint = function(e, t) {
+Aa.queryPoint = function(e, t) {
     if (this.root)
         return this.root.queryPoint(e, t);
 };
-dl.queryInterval = function(e, t, n) {
+Aa.queryInterval = function(e, t, n) {
     if (e <= t && this.root)
         return this.root.queryInterval(e, t, n);
 };
-Object.defineProperty(dl, "count", {
+Object.defineProperty(Aa, "count", {
     get: function() {
         return this.root ? this.root.count : 0;
     }
 });
-Object.defineProperty(dl, "intervals", {
+Object.defineProperty(Aa, "intervals", {
     get: function() {
         return this.root ? this.root.intervals([]) : [];
     }
 });
 
-function int(e) {
-    return !e || e.length === 0 ? new W1(null) : new W1(Yc(e));
+function lJ(e) {
+    return !e || e.length === 0 ? new ky(null) : new ky(aa(e));
 }
-const rnt = /* @__PURE__ */ Xet(ent),
-    snt = ({
+const fJ = /* @__PURE__ */ eJ(cJ),
+    hJ = ({
         marginLeft: e
     }) => [1, e],
-    ont = ({
+    dJ = ({
         width: e,
         marginRight: t
     }) => [-1, e - t],
-    ant = ({
+    pJ = ({
         width: e,
         marginLeft: t,
         marginRight: n
     }) => [0, (t + e - n) / 2],
-    cnt = ({
+    yJ = ({
         marginTop: e
     }) => [1, e],
-    lnt = ({
+    mJ = ({
         height: e,
         marginBottom: t
     }) => [-1, e - t],
-    unt = ({
+    gJ = ({
         height: e,
         marginTop: t,
         marginBottom: n
     }) => [0, (t + e - n) / 2];
 
-function _N(e) {
+function f8(e) {
     return typeof e == "string" ? {
         anchor: e
     } : e;
 }
 
-function fnt(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = xN(e));
+function bJ(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = h8(e));
     let {
         anchor: n = "left",
-        padding: i = 1,
-        r = t.r
-    } = _N(e);
+        padding: r = 1,
+        r: i = t.r
+    } = f8(e);
     switch (`${n}`.toLowerCase()) {
         case "left":
-            n = snt;
+            n = hJ;
             break;
         case "right":
-            n = ont;
+            n = dJ;
             break;
         case "middle":
-            n = ant;
+            n = pJ;
             break;
         default:
             throw new Error(`unknown dodge anchor: ${n}`);
     }
-    return SN("x", "y", n, qt(i), r, t);
+    return d8("x", "y", n, Nt(r), i, t);
 }
 
-function hnt(e = {}, t = {}) {
-    arguments.length === 1 && ([e, t] = xN(e));
+function wJ(e = {}, t = {}) {
+    arguments.length === 1 && ([e, t] = h8(e));
     let {
         anchor: n = "bottom",
-        padding: i = 1,
-        r = t.r
-    } = _N(e);
+        padding: r = 1,
+        r: i = t.r
+    } = f8(e);
     switch (`${n}`.toLowerCase()) {
         case "top":
-            n = cnt;
+            n = yJ;
             break;
         case "bottom":
-            n = lnt;
+            n = mJ;
             break;
         case "middle":
-            n = unt;
+            n = gJ;
             break;
         default:
             throw new Error(`unknown dodge anchor: ${n}`);
     }
-    return SN("y", "x", n, qt(i), r, t);
+    return d8("y", "x", n, Nt(r), i, t);
 }
 
-function xN(e) {
+function h8(e) {
     const {
         anchor: t,
         padding: n,
-        ...i
+        ...r
     } = e, {
-        r
-    } = i;
+        r: i
+    } = r;
     return [{
         anchor: t,
         padding: n,
-        r
-    }, i];
+        r: i
+    }, r];
 }
 
-function SN(e, t, n, i, r, s) {
-    if (r != null && typeof r != "number") {
+function d8(e, t, n, r, i, s) {
+    if (i != null && typeof i != "number") {
         let {
             channels: o,
             sort: a,
             reverse: c
         } = s;
-        o = Nw(o), (o == null ? void 0 : o.r) === void 0 && (s = {
+        o = ug(o), (o == null ? void 0 : o.r) === void 0 && (s = {
             ...s,
             channels: {
                 ...o,
                 r: {
-                    value: r,
+                    value: i,
                     scale: "r"
                 }
             }
         }), a === void 0 && c === void 0 && (s.sort = {
             channel: "-r"
         });
     }
-    return Bn(s, function(o, a, c, l, u, f) {
+    return tn(s, function(o, a, c, u, l, f) {
         let {
             [t]: h, r: d
         } = c;
         if (!c[t])
             throw new Error(`missing channel: ${t}`);
         ({
             [t]: h
-        } = T0(c, l, f));
-        const p = d ? void 0 : r !== void 0 ? qt(r) : this.r !== void 0 ? this.r : 3;
-        d && (d = Pt(d.value, l[d.scale] || Tt, Float64Array));
-        let [m, g] = n(u);
-        const y = m ? pnt : dnt,
+        } = Md(c, u, f));
+        const p = d ? void 0 : i !== void 0 ? Nt(i) : this.r !== void 0 ? this.r : 3;
+        d && (d = $t(d.value, u[d.scale] || yt, Float64Array));
+        let [y, m] = n(l);
+        const g = y ? _J : vJ,
             b = new Float64Array(h.length),
             w = d ? (v) => d[v] : () => p;
         for (let v of a) {
-            const x = rnt();
-            v = v.filter(d ? (I) => kp(h[I]) && Qr(d[I]) : (I) => kp(h[I]));
+            const x = fJ();
+            v = v.filter(d ? (M) => fh(h[M]) && Qr(d[M]) : (M) => fh(h[M]));
             const _ = new Float64Array(2 * v.length + 2);
-            for (const I of v) {
-                const A = w(I),
-                    M = m ? A + i : 0,
-                    N = h[I] - A,
-                    $ = h[I] + A;
-                let B = 2;
-                x.queryInterval(N - i, $ + i, ([, , S]) => {
-                    const T = b[S] - M,
-                        D = h[I] - h[S],
-                        L = i + (d ? d[I] + d[S] : 2 * p),
-                        k = Math.sqrt(L * L - D * D);
-                    _[B++] = T - k, _[B++] = T + k;
+            for (const M of v) {
+                const T = w(M),
+                    $ = y ? T + r : 0,
+                    N = h[M] - T,
+                    A = h[M] + T;
+                let D = 2;
+                x.queryInterval(N - r, A + r, ([, , S]) => {
+                    const I = b[S] - $,
+                        E = h[M] - h[S],
+                        k = r + (d ? d[M] + d[S] : 2 * p),
+                        B = Math.sqrt(k * k - E * E);
+                    _[D++] = I - B, _[D++] = I + B;
                 });
-                let R = _.slice(0, B);
-                m && (R = R.filter((S) => S >= 0));
+                let R = _.slice(0, D);
+                y && (R = R.filter((S) => S >= 0));
                 t:
-                    for (const S of R.sort(y)) {
-                        for (let T = 0; T < B; T += 2)
-                            if (_[T] + 1e-6 < S && S < _[T + 1] - 1e-6)
+                    for (const S of R.sort(g)) {
+                        for (let I = 0; I < D; I += 2)
+                            if (_[I] + 1e-6 < S && S < _[I + 1] - 1e-6)
                                 continue t;
-                        b[I] = S + M;
+                        b[M] = S + $;
                         break;
                     }
-                x.insert([N, $, I]);
+                x.insert([N, A, M]);
             }
         }
-        m || (m = 1);
+        y || (y = 1);
         for (const v of a)
             for (const x of v)
-                b[x] = b[x] * m + g;
+                b[x] = b[x] * y + m;
         return {
             data: o,
             facets: a,
             channels: {
                 [e]: {
                     value: b,
                     source: null
@@ -36071,404 +36634,404 @@
                     }
                 }
             }
         };
     });
 }
 
-function dnt(e, t) {
+function vJ(e, t) {
     return Math.abs(e) - Math.abs(t);
 }
 
-function pnt(e, t) {
+function _J(e, t) {
     return e - t;
 }
 
-function ynt(e, t) {
+function xJ(e, t) {
     return arguments.length === 1 && ({
         basis: e,
         ...t
-    } = e), Av(Rv(e), t);
+    } = e), n1(m1(e), t);
 }
 
-function mnt(e, t) {
+function SJ(e, t) {
     return arguments.length === 1 && ({
         basis: e,
         ...t
-    } = e), Mv(Rv(e), t);
+    } = e), r1(m1(e), t);
 }
 
-function Rv(e) {
+function m1(e) {
     if (e === void 0)
-        return GS;
+        return uv;
     if (typeof e == "function")
-        return Y0(Dw(e));
+        return jd(cg(e));
     if (/^p\d{2}$/i.test(e))
-        return pl($w(e));
+        return $a(og(e));
     switch (`${e}`.toLowerCase()) {
         case "deviation":
-            return wnt;
+            return $J;
         case "first":
-            return GS;
+            return uv;
         case "last":
-            return bnt;
+            return AJ;
         case "max":
-            return vnt;
+            return IJ;
         case "mean":
-            return _nt;
+            return TJ;
         case "median":
-            return xnt;
+            return EJ;
         case "min":
-            return Snt;
+            return NJ;
         case "sum":
-            return Int;
+            return DJ;
         case "extent":
-            return gnt;
+            return MJ;
     }
     throw new Error(`invalid basis: ${e}`);
 }
 
-function Y0(e) {
+function jd(e) {
     return {
-        mapIndex(t, n, i) {
-            const r = +e(t, n);
+        mapIndex(t, n, r) {
+            const i = +e(t, n);
             for (const s of t)
-                i[s] = n[s] === null ? NaN : n[s] / r;
+                r[s] = n[s] === null ? NaN : n[s] / i;
         }
     };
 }
 
-function pl(e) {
-    return Y0((t, n) => e(t, (i) => n[i]));
+function $a(e) {
+    return jd((t, n) => e(t, (r) => n[r]));
 }
-const gnt = {
+const MJ = {
         mapIndex(e, t, n) {
-            const [i, r] = ke(e, (o) => t[o]), s = r - i;
+            const [r, i] = de(e, (o) => t[o]), s = i - r;
             for (const o of e)
-                n[o] = t[o] === null ? NaN : (t[o] - i) / s;
+                n[o] = t[o] === null ? NaN : (t[o] - r) / s;
         }
     },
-    GS = Y0((e, t) => {
+    uv = jd((e, t) => {
         for (let n = 0; n < e.length; ++n) {
-            const i = t[e[n]];
-            if (dn(i))
-                return i;
+            const r = t[e[n]];
+            if (Ce(r))
+                return r;
         }
     }),
-    bnt = Y0((e, t) => {
+    AJ = jd((e, t) => {
         for (let n = e.length - 1; n >= 0; --n) {
-            const i = t[e[n]];
-            if (dn(i))
-                return i;
+            const r = t[e[n]];
+            if (Ce(r))
+                return r;
         }
     }),
-    wnt = {
+    $J = {
         mapIndex(e, t, n) {
-            const i = Xy(e, (s) => t[s]),
-                r = gf(e, (s) => t[s]);
+            const r = Vh(e, (s) => t[s]),
+                i = au(e, (s) => t[s]);
             for (const s of e)
-                n[s] = t[s] === null ? NaN : r ? (t[s] - i) / r : 0;
+                n[s] = t[s] === null ? NaN : i ? (t[s] - r) / i : 0;
         }
     },
-    vnt = pl(De),
-    _nt = pl(Xy),
-    xnt = pl(Fu),
-    Snt = pl(Ye),
-    Int = pl(fr);
+    IJ = $a(ae),
+    TJ = $a(Vh),
+    EJ = $a(Nc),
+    NJ = $a(ve),
+    DJ = $a(wr);
 
-function Ant(e, t) {
-    return Mnt("x", e, t);
+function OJ(e, t) {
+    return LJ("x", e, t);
 }
 
-function Mnt(e, t, n = {}) {
-    let i, r = 1;
+function LJ(e, t, n = {}) {
+    let r, i = 1;
     if (typeof t == "number")
-        r = t, i = (l, u) => +l + u;
+        i = t, r = (u, l) => +u + l;
     else {
         if (typeof t == "string") {
-            const l = t.startsWith("-") ? -1 : 1;
-            [t, r] = Iw(t.replace(/^[+-]/, "")), r *= l;
+            const u = t.startsWith("-") ? -1 : 1;
+            [t, i] = rg(t.replace(/^[+-]/, "")), i *= u;
         }
-        t = x0(t), i = (l, u) => t.offset(l, u);
+        t = bd(t), r = (u, l) => t.offset(u, l);
     }
     const s = `${e}1`,
         o = `${e}2`,
-        a = pr({
-                [s]: (l) => l.map((u) => i(u, r)),
-                [o]: (l) => l
+        a = xr({
+                [s]: (u) => u.map((l) => r(l, i)),
+                [o]: (u) => u
             },
             n
         ),
         c = a[o].transform;
     return a[o].transform = () => {
-        const l = c(),
-            [u, f] = ke(l);
-        return l.domain = r < 0 ? [u, i(f, r)] : [i(u, r), f], l;
+        const u = c(),
+            [l, f] = de(u);
+        return u.domain = i < 0 ? [l, r(f, i)] : [r(l, i), f], u;
     }, a;
 }
 
-function $nt(e, t = {}) {
+function kJ(e, t = {}) {
     if (typeof e == "string")
         switch (e.toLowerCase()) {
             case "first":
-                return IN(t);
+                return g1(t);
             case "last":
-                return AN(t);
+                return b1(t);
         }
     if (typeof e == "function")
-        return Zs(null, e, t);
-    let n, i;
+        return Yi(null, e, t);
+    let n, r;
     for (n in e) {
-        if (i !== void 0)
+        if (r !== void 0)
             throw new Error("ambiguous selector; multiple inputs");
-        i = Tnt(e[n]);
+        r = RJ(e[n]);
     }
-    if (i === void 0)
+    if (r === void 0)
         throw new Error(`invalid selector: ${e}`);
-    return Zs(n, i, t);
+    return Yi(n, r, t);
 }
 
-function Tnt(e) {
+function RJ(e) {
     if (typeof e == "function")
         return e;
     switch (`${e}`.toLowerCase()) {
         case "min":
-            return Cv;
+            return w1;
         case "max":
-            return kv;
+            return v1;
     }
     throw new Error(`unknown selector: ${e}`);
 }
 
-function IN(e) {
-    return Zs(null, Fnt, e);
+function g1(e) {
+    return Yi(null, FJ, e);
 }
 
-function AN(e) {
-    return Zs(null, Ent, e);
+function b1(e) {
+    return Yi(null, BJ, e);
 }
 
-function Dnt(e) {
-    return Zs("x", Cv, e);
+function p8(e) {
+    return Yi("x", w1, e);
 }
 
-function Nnt(e) {
-    return Zs("y", Cv, e);
+function y8(e) {
+    return Yi("y", w1, e);
 }
 
-function Bnt(e) {
-    return Zs("x", kv, e);
+function m8(e) {
+    return Yi("x", v1, e);
 }
 
-function Ont(e) {
-    return Zs("y", kv, e);
+function g8(e) {
+    return Yi("y", v1, e);
 }
 
-function* Fnt(e) {
+function* FJ(e) {
     yield e[0];
 }
 
-function* Ent(e) {
+function* BJ(e) {
     yield e[e.length - 1];
 }
 
-function* Cv(e, t) {
-    yield Yz(e, (n) => t[n]);
+function* w1(e, t) {
+    yield tR(e, (n) => t[n]);
 }
 
-function* kv(e, t) {
-    yield Yb(e, (n) => t[n]);
+function* v1(e, t) {
+    yield Mm(e, (n) => t[n]);
 }
 
-function Zs(e, t, n) {
+function Yi(e, t, n) {
     if (e != null) {
         if (n[e] == null)
             throw new Error(`missing channel: ${e}`);
         e = n[e];
     }
-    const i = co(n);
-    return vr(n, (r, s) => {
-        const o = Pt(r, i),
-            a = Pt(r, e),
+    const r = Qi(n);
+    return $r(n, (i, s) => {
+        const o = $t(i, r),
+            a = $t(i, e),
             c = [];
-        for (const l of s) {
-            const u = [];
-            for (const f of o ? us(l, (h) => o[h]).values() : [l])
+        for (const u of s) {
+            const l = [];
+            for (const f of o ? ci(u, (h) => o[h]).values() : [u])
                 for (const h of t(f, a))
-                    u.push(h);
-            c.push(u);
+                    l.push(h);
+            c.push(l);
         }
         return {
-            data: r,
+            data: i,
             facets: c
         };
     });
 }
-const XS = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+const CJ = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
         __proto__: null,
-        Area: k0,
-        Arrow: $4,
-        BarX: D4,
-        BarY: N4,
-        Cell: U0,
-        Contour: K4,
-        Density: tN,
-        Dot: z0,
-        Frame: c4,
-        Geo: eN,
-        Hexgrid: nN,
-        Image: iN,
-        Line: P0,
-        Link: A4,
-        Mark: fe,
-        Raster: q4,
-        Rect: j0,
-        RuleX: v8,
-        RuleY: _8,
-        Text: E0,
-        TickX: R4,
-        TickY: C4,
-        Tip: l4,
-        Vector: L0,
-        area: L1,
-        areaX: Ju,
-        areaY: qc,
-        arrow: YQ,
-        auto: itt,
-        autoSpec: B4,
-        axisFx: q8,
-        axisFy: j8,
-        axisX: ov,
-        axisY: sv,
-        barX: Lo,
-        barY: Ro,
-        bin: No,
-        binX: Bs,
-        binY: Os,
-        bollinger: Yo,
-        bollingerX: xtt,
-        bollingerY: Stt,
-        boxX: Att,
-        boxY: Mtt,
-        cell: ic,
-        cellX: GQ,
-        cellY: XQ,
-        centroid: Wet,
-        circle: ZQ,
-        cluster: Yet,
-        column: Un,
-        contour: ztt,
-        crosshair: Vtt,
-        crosshairX: jtt,
-        crosshairY: qtt,
-        delaunayLink: iet,
-        delaunayMesh: ret,
-        density: uet,
-        differenceY: det,
-        dodgeX: fnt,
-        dodgeY: hnt,
-        dot: fo,
-        dotX: JQ,
-        dotY: KQ,
-        filter: lJ,
-        find: IJ,
-        formatIsoDate: n8,
-        formatMonth: $K,
-        formatWeekday: TK,
-        frame: lv,
-        geo: Bv,
-        geoCentroid: Get,
-        graticule: get,
-        gridFx: J8,
-        gridFy: X8,
-        gridX: H8,
-        gridY: G8,
-        group: kw,
-        groupX: Wu,
-        groupY: Gu,
-        groupZ: Cw,
-        hexagon: QQ,
-        hexbin: bet,
-        hexgrid: _et,
-        hull: set,
-        identity: Tt,
-        image: $et,
-        indexOf: vn,
-        initializer: Bn,
-        interpolateNearest: H4,
-        interpolateNone: k1,
-        interpolatorBarycentric: X4,
-        interpolatorRandomWalk: J4,
-        legend: FZ,
-        line: V0,
-        lineX: Ku,
-        lineY: Zu,
-        linearRegressionX: Let,
-        linearRegressionY: Ret,
-        link: M4,
-        map: pr,
-        mapX: Av,
-        mapY: Mv,
-        marks: ui,
-        normalize: Rv,
-        normalizeX: ynt,
-        normalizeY: mnt,
-        plot: uv,
-        pointer: ev,
-        pointerX: nv,
-        pointerY: Yp,
-        raster: Ttt,
-        rect: Iv,
-        rectX: Kp,
-        rectY: Zp,
-        reverse: uJ,
-        ruleX: Js,
-        ruleY: Ks,
-        scale: Vp,
-        select: $nt,
-        selectFirst: IN,
-        selectLast: AN,
-        selectMaxX: Bnt,
-        selectMaxY: Ont,
-        selectMinX: Dnt,
-        selectMinY: Nnt,
-        shiftX: Ant,
-        shuffle: fJ,
-        sort: _D,
-        sphere: met,
-        spike: _Z,
-        stackX: w4,
-        stackX1: IQ,
-        stackX2: AQ,
-        stackY: v4,
-        stackY1: MQ,
-        stackY2: $Q,
-        text: Pc,
-        textX: A8,
-        textY: M8,
-        tickX: k4,
-        tickY: U4,
-        tip: u4,
-        transform: vr,
-        tree: mN,
-        treeLink: oN,
-        treeNode: U1,
-        valueof: Pt,
-        vector: R8,
-        vectorX: C8,
-        vectorY: k8,
-        voronoi: oet,
-        voronoiMesh: aet,
-        window: q0,
-        windowX: utt,
-        windowY: ftt
+        Area: Fd,
+        Arrow: v4,
+        BarX: x4,
+        BarY: S4,
+        Cell: Bd,
+        Contour: z4,
+        Density: V4,
+        Dot: Cd,
+        Frame: e4,
+        Geo: Y4,
+        Hexgrid: W4,
+        Image: X4,
+        Line: Pd,
+        Link: b4,
+        Mark: Ht,
+        Raster: B4,
+        Rect: zd,
+        RuleX: d$,
+        RuleY: p$,
+        Text: Od,
+        TickX: E4,
+        TickY: N4,
+        Tip: n4,
+        Vector: Ld,
+        area: Sy,
+        areaX: Hc,
+        areaY: oa,
+        arrow: tG,
+        auto: hG,
+        autoSpec: M4,
+        axisFx: B$,
+        axisFy: F$,
+        axisX: Bg,
+        axisY: Fg,
+        barX: ms,
+        barY: gs,
+        bin: ls,
+        binX: Ai,
+        binY: $i,
+        bollinger: Ms,
+        bollingerX: DG,
+        bollingerY: OG,
+        boxX: kG,
+        boxY: RG,
+        cell: vo,
+        cellX: nG,
+        cellY: rG,
+        centroid: QH,
+        circle: aG,
+        cluster: KH,
+        column: an,
+        contour: HG,
+        crosshair: ZG,
+        crosshairX: KG,
+        crosshairY: QG,
+        delaunayLink: hH,
+        delaunayMesh: dH,
+        density: bH,
+        differenceY: _H,
+        dodgeX: bJ,
+        dodgeY: wJ,
+        dot: ns,
+        dotX: sG,
+        dotY: oG,
+        filter: bV,
+        find: LV,
+        formatIsoDate: HA,
+        formatMonth: FY,
+        formatWeekday: BY,
+        frame: Ug,
+        geo: f1,
+        geoCentroid: tJ,
+        graticule: AH,
+        gridFx: j$,
+        gridFy: z$,
+        gridX: q$,
+        gridY: U$,
+        group: gg,
+        groupX: jc,
+        groupY: Vc,
+        groupZ: mg,
+        hexagon: cG,
+        hexbin: $H,
+        hexgrid: EH,
+        hull: pH,
+        identity: yt,
+        image: kH,
+        indexOf: Ve,
+        initializer: tn,
+        interpolateNearest: a1,
+        interpolateNone: $y,
+        interpolatorBarycentric: o1,
+        interpolatorRandomWalk: c1,
+        legend: qW,
+        line: Ud,
+        lineX: Jc,
+        lineY: Zc,
+        linearRegressionX: qH,
+        linearRegressionY: jH,
+        link: w4,
+        map: xr,
+        mapX: n1,
+        mapY: r1,
+        marks: Tn,
+        normalize: m1,
+        normalizeX: xJ,
+        normalizeY: SJ,
+        plot: zg,
+        pointer: Td,
+        pointerX: Ed,
+        pointerY: Gc,
+        raster: BG,
+        rect: e1,
+        rectX: xh,
+        rectY: Sh,
+        reverse: wV,
+        ruleX: ji,
+        ruleY: Vi,
+        scale: Xc,
+        select: kJ,
+        selectFirst: g1,
+        selectLast: b1,
+        selectMaxX: m8,
+        selectMaxY: g8,
+        selectMinX: p8,
+        selectMinY: y8,
+        shiftX: OJ,
+        shuffle: vV,
+        sort: pA,
+        sphere: MH,
+        spike: NW,
+        stackX: h4,
+        stackX1: LX,
+        stackX2: kX,
+        stackY: d4,
+        stackY1: RX,
+        stackY2: FX,
+        text: ra,
+        textX: b$,
+        textY: w$,
+        tickX: D4,
+        tickY: O4,
+        tip: r4,
+        transform: $r,
+        tree: o8,
+        treeLink: J4,
+        treeNode: Iy,
+        valueof: $t,
+        vector: E$,
+        vectorX: N$,
+        vectorY: D$,
+        voronoi: yH,
+        voronoiMesh: mH,
+        window: qd,
+        windowX: wG,
+        windowY: vG
     }, Symbol.toStringTag, {
         value: "Module"
     })),
-    Lnt = /* @__PURE__ */ new Map([
+    PJ = /* @__PURE__ */ new Map([
         ["style", "style"],
         ["width", "width"],
         ["height", "height"],
         ["margin", "margin"],
         ["marginLeft", "marginLeft"],
         ["marginRight", "marginRight"],
         ["marginTop", "marginTop"],
@@ -36476,15 +37039,14 @@
         ["align", "align"],
         ["aspectRatio", "aspectRatio"],
         ["axis", "axis"],
         ["inset", "inset"],
         ["grid", "grid"],
         ["label", "label"],
         ["padding", "padding"],
-        ["round", "round"],
         ["xScale", "x.type"],
         ["xDomain", "x.domain"],
         ["xRange", "x.range"],
         ["xNice", "x.nice"],
         ["xInset", "x.inset"],
         ["xInsetLeft", "x.insetLeft"],
         ["xInsetRight", "x.insetRight"],
@@ -36501,18 +37063,20 @@
         ["xTickPadding", "x.tickPadding"],
         ["xTickFormat", "x.tickFormat"],
         ["xTickRotate", "x.tickRotate"],
         ["xGrid", "x.grid"],
         ["xLine", "x.line"],
         ["xLabel", "x.label"],
         ["xLabelAnchor", "x.labelAnchor"],
+        ["xLabelArrow", "x.labelArrow"],
         ["xLabelOffset", "x.labelOffset"],
         ["xFontVariant", "x.fontVariant"],
         ["xAriaLabel", "x.ariaLabel"],
         ["xAriaDescription", "x.ariaDescription"],
+        ["xPercent", "x.percent"],
         ["xReverse", "x.reverse"],
         ["xZero", "x.zero"],
         ["xBase", "x.base"],
         ["xExponent", "x.exponent"],
         ["xConstant", "x.constant"],
         ["yScale", "y.type"],
         ["yDomain", "y.domain"],
@@ -36534,33 +37098,34 @@
         ["yTickPadding", "y.tickPadding"],
         ["yTickFormat", "y.tickFormat"],
         ["yTickRotate", "y.tickRotate"],
         ["yGrid", "y.grid"],
         ["yLine", "y.line"],
         ["yLabel", "y.label"],
         ["yLabelAnchor", "y.labelAnchor"],
+        ["yLabelArrow", "y.labelArrow"],
         ["yLabelOffset", "y.labelOffset"],
         ["yFontVariant", "y.fontVariant"],
         ["yAriaLabel", "y.ariaLabel"],
         ["yAriaDescription", "y.ariaDescription"],
+        ["yPercent", "y.percent"],
         ["yReverse", "y.reverse"],
         ["yZero", "y.zero"],
         ["yBase", "y.base"],
         ["yExponent", "y.exponent"],
         ["yConstant", "y.constant"],
         ["facetMargin", "facet.margin"],
         ["facetMarginTop", "facet.marginTop"],
         ["facetMarginBottom", "facet.marginBottom"],
         ["facetMarginLeft", "facet.marginLeft"],
         ["facetMarginRight", "facet.marginRight"],
         ["facetGrid", "facet.grid"],
         ["facetLabel", "facet.label"],
         ["fxDomain", "fx.domain"],
         ["fxRange", "fx.range"],
-        ["fxNice", "fx.nice"],
         ["fxInset", "fx.inset"],
         ["fxInsetLeft", "fx.insetLeft"],
         ["fxInsetRight", "fx.insetRight"],
         ["fxRound", "fx.round"],
         ["fxAlign", "fx.align"],
         ["fxPadding", "fx.padding"],
         ["fxPaddingInner", "fx.paddingInner"],
@@ -36579,15 +37144,14 @@
         ["fxLabelOffset", "fx.labelOffset"],
         ["fxFontVariant", "fx.fontVariant"],
         ["fxAriaLabel", "fx.ariaLabel"],
         ["fxAriaDescription", "fx.ariaDescription"],
         ["fxReverse", "fx.reverse"],
         ["fyDomain", "fy.domain"],
         ["fyRange", "fy.range"],
-        ["fyNice", "fy.mice"],
         ["fyInset", "fy,inset"],
         ["fyInsetTop", "fy.insetTop"],
         ["fyInsetBottom", "fy.insetBottom"],
         ["fyRound", "fy.round"],
         ["fyAlign", "fy.align"],
         ["fyPadding", "fy.padding"],
         ["fyPaddingInner", "fy.paddingInner"],
@@ -36615,46 +37179,53 @@
         ["colorN", "color.n"],
         ["colorNice", "color.nice"],
         ["colorScheme", "color.scheme"],
         ["colorInterpolate", "color.interpolate"],
         ["colorPivot", "color.pivot"],
         ["colorSymmetric", "color.symmetric"],
         ["colorLabel", "color.label"],
+        ["colorPercent", "color.percent"],
         ["colorReverse", "color.reverse"],
         ["colorZero", "color.zero"],
         ["colorTickFormat", "color.tickFormat"],
         ["colorBase", "color.base"],
         ["colorExponent", "color.exponent"],
         ["colorConstant", "color.constant"],
         ["opacityScale", "opacity.type"],
         ["opacityDomain", "opacity.domain"],
         ["opacityRange", "opacity.range"],
         ["opacityClamp", "opacity.clamp"],
         ["opacityNice", "opacity.nice"],
         ["opacityLabel", "opacity.label"],
+        ["opacityPercent", "opacity.percent"],
         ["opacityReverse", "opacity.reverse"],
         ["opacityZero", "opacity.zero"],
         ["opacityTickFormat", "opacity.tickFormat"],
         ["opacityBase", "opacity.base"],
         ["opacityExponent", "opacity.exponent"],
         ["opacityConstant", "opacity.constant"],
+        ["symbolScale", "symbol.type"],
+        ["symbolDomain", "symbol.domain"],
+        ["symbolRange", "symbol.range"],
         ["rScale", "r.type"],
         ["rDomain", "r.domain"],
         ["rRange", "r.range"],
         ["rClamp", "r.clamp"],
         ["rNice", "r.nice"],
+        ["rPercent", "r.percent"],
         ["rZero", "r.zero"],
         ["rBase", "r.base"],
         ["rExponent", "r.exponent"],
         ["rConstant", "r.constant"],
         ["lengthScale", "length.type"],
         ["lengthDomain", "length.domain"],
         ["lengthRange", "length.range"],
         ["lengthClamp", "length.clamp"],
         ["lengthNice", "length.nice"],
+        ["lengthPercent", "length.percent"],
         ["lengthZero", "length.zero"],
         ["lengthBase", "length.base"],
         ["lengthExponent", "length.exponent"],
         ["lengthConstant", "length.constant"],
         ["projectionType", "projection.type"],
         ["projectionParallels", "projection.parallels"],
         ["projectionPrecision", "projection.precision"],
@@ -36664,152 +37235,174 @@
         ["projectionInsetLeft", "projection.insetLeft"],
         ["projectionInsetRight", "projection.insetRight"],
         ["projectionInsetTop", "projection.insetTop"],
         ["projectionInsetBottom", "projection.insetBottom"],
         ["projectionClip", "projection.clip"]
     ]);
 
-function Rnt(e, t, n) {
-    for (let i = 0; i < t.length; ++i) {
-        const r = t[i];
-        i === t.length - 1 ? e[r] = n : e = e[r] || (e[r] = {});
+function UJ(e, t, n) {
+    for (let r = 0; r < t.length; ++r) {
+        const i = t[r];
+        r === t.length - 1 ? e[i] = n : e = e[i] || (e[i] = {});
     }
 }
 
-function Cnt(e, t, n) {
-    for (const i in e) {
-        const r = Lnt.get(i);
-        if (r == null)
-            throw new Error(`Unrecognized plot attribute: ${i}`);
-        const s = e[i];
-        typeof s == "symbol" ? n.push(i) : s !== void 0 && Rnt(t, r.split("."), s);
+function zJ(e, t, n) {
+    for (const r in e) {
+        const i = PJ.get(r);
+        if (i == null)
+            throw new Error(`Unrecognized plot attribute: ${r}`);
+        const s = e[r];
+        typeof s == "symbol" ? n.push(r) : s !== void 0 && UJ(t, i.split("."), s);
     }
 }
-const knt = /* @__PURE__ */ new Set([
-    "frame",
-    "hexgrid",
-    "sphere",
-    "graticule"
-]);
-async function Unt(e) {
+const qJ = /* @__PURE__ */ new Set([
+        "frame",
+        "hexgrid",
+        "sphere",
+        "graticule"
+    ]),
+    jJ = /* @__PURE__ */ new Map([
+        ["first", g1],
+        ["last", b1],
+        ["maxX", m8],
+        ["maxY", g8],
+        ["minX", p8],
+        ["minY", y8],
+        ["nearest", Td],
+        ["nearestX", Ed],
+        ["nearestXY", Gc]
+    ]);
+async function VJ(e) {
+    var a;
     const t = {
             marks: []
         },
         n = [],
         {
-            attributes: i,
-            marks: r
+            attributes: r,
+            marks: i
         } = e;
-    Cnt(i, t, n);
+    zJ(r, t, n);
     const s = [];
-    for (const a of r)
+    for (const c of i)
         for (const {
-                type: c,
+                type: u,
                 data: l,
-                options: u
+                options: f
             }
-            of a.plotSpecs())
-            knt.has(c) ? t.marks.push(XS[c](u)) : t.marks.push(XS[c](l, u)), s.push(a.index);
-    Pnt(t, e);
-    const o = uv(t);
-    Vnt(o, s), znt(e, o, i, n);
-    for (const a of e.interactors)
-        await a.init(o);
+            of c.plotSpecs()) {
+            const {
+                select: h,
+                ...d
+            } = f, p = ((a = jJ.get(h)) == null ? void 0 : a(d)) ?? d, y = qJ.has(u) ? [p] : [l, p];
+            t.marks.push(CJ[u](...y)), s.push(c.index);
+        }
+    WJ(t, e);
+    const o = zg(t);
+    XJ(o, s), YJ(e, o, r, n);
+    for (const c of e.interactors)
+        await c.init(o);
     return o;
 }
 
-function znt(e, t, n, i) {
-    i.forEach((r) => {
-        const s = n[r];
-        if (s === mf) {
-            if (!r.endsWith("Domain"))
-                throw new Error(`Unsupported fixed attribute: ${r}`);
-            const o = r.slice(0, -6),
+function YJ(e, t, n, r) {
+    r.forEach((i) => {
+        const s = n[i];
+        if (s === ou) {
+            if (!i.endsWith("Domain"))
+                throw new Error(`Unsupported fixed attribute: ${i}`);
+            const o = i.slice(0, -6),
                 a = t.scale(o);
-            a != null && a.domain && e.setAttribute(r, n[`${o}Reverse`] ? a.domain.slice().reverse() : a.domain);
+            a != null && a.domain && e.setAttribute(i, n[`${o}Reverse`] ? a.domain.slice().reverse() : a.domain);
         } else
             throw new Error(`Unrecognized symbol: ${s}`);
     });
 }
 
-function Pnt(e, t) {
+function WJ(e, t) {
     const {
         marks: n
     } = t;
-    Fh("x", e, n), Fh("y", e, n), Fh("fx", e, n), Fh("fy", e, n);
+    bl("x", e, n), bl("y", e, n), bl("fx", e, n), bl("fy", e, n);
 }
 
-function Fh(e, t, n) {
-    const i = t[e] || {};
-    if (i.axis === null || i.label !== void 0)
+function bl(e, t, n) {
+    const r = t[e] || {};
+    if (r.axis === null || r.label !== void 0)
         return;
-    const r = n.map((l) => {
-        var u;
-        return (u = l.channelField(e)) == null ? void 0 : u.field;
+    const i = n.map((u) => {
+        var l;
+        return (l = u.channelField(e)) == null ? void 0 : l.field;
     });
-    if (r.every((l) => l == null))
+    if (i.every((u) => u == null))
         return;
     let s, o, a;
-    for (let l = 0; l < r.length; ++l) {
+    for (let u = 0; u < i.length; ++u) {
         const {
-            column: u,
+            column: l,
             label: f
-        } = r[l] || {};
-        u === void 0 && f === void 0 || (s === void 0 && o === void 0 ? (s = u, o = f, a = jnt(n[l].data, e) || "number") : o !== f ? o = void 0 : s !== u && (s = void 0));
+        } = i[u] || {};
+        l === void 0 && f === void 0 || (s === void 0 && o === void 0 ? (s = l, o = f, a = GJ(n[u].data, e) || "number") : o !== f ? o = void 0 : s !== l && (s = void 0));
     }
     let c = o || s;
     if (c !== void 0) {
         if ((a === "number" || a === "date") && (e === "x" || e === "y")) {
-            i.percent && (c = `${c} (%)`);
-            const l = (e === "x" ? 1 : -1) * (i.reverse ? -1 : 1);
-            e === "x" || i.labelAnchor === "center" ? c = e === "x" == l < 0 ? ` ${c}` : `${c} ` : c = `${l < 0 ? " " : " "}${c}`;
+            r.percent && (c = `${c} (%)`);
+            const u = (e === "x" ? 1 : -1) * (r.reverse ? -1 : 1);
+            e === "x" || r.labelAnchor === "center" ? c = e === "x" == u < 0 ? ` ${c}` : `${c} ` : c = `${u < 0 ? " " : " "}${c}`;
         }
         t[e] = {
-            ...i,
+            ...r,
             label: c
         };
     }
 }
 
-function Vnt(e, t) {
+function XJ(e, t) {
     const n = e.querySelectorAll('g[aria-label="facet"]');
     if (n.length)
-        for (const i of n)
-            HS(i, t);
+        for (const r of n)
+            lv(r, t);
     else
-        HS(e, t);
+        lv(e, t);
 }
 
-function HS(e, t) {
+function lv(e, t) {
     let n = -1;
-    for (const i of e.children) {
-        const r = i.getAttribute("aria-label") || "";
-        i.nodeName === "style" || r.includes("-axis") || r.includes("-grid") || i.setAttribute("data-index", t[++n]);
+    for (const r of e.children) {
+        const i = r.getAttribute("aria-label") || "";
+        r.nodeName === "style" || i.includes("-axis") || i.includes("-grid") || r.setAttribute("data-index", t[++n]);
     }
 }
 
-function jnt(e, t) {
-    for (const n of e) {
-        const i = n[t] ?? n[t + "1"] ?? n[t + "2"];
-        if (i != null)
-            return i instanceof Date ? "date" : typeof i;
+function GJ(e, t) {
+    if (!e)
+        return;
+    const {
+        columns: n
+    } = e, r = n[t] ?? n[t + "1"] ?? n[t + "2"];
+    if (r) {
+        for (const i of r)
+            if (i != null)
+                return i instanceof Date ? "date" : typeof i;
     }
 }
-const qnt = {
+const HJ = {
     width: 640,
     marginLeft: 40,
     marginRight: 20,
     marginTop: 20,
     marginBottom: 30
 };
-class Ynt {
+class JJ {
     constructor(t) {
         this.attributes = {
-            ...qnt
-        }, this.listeners = null, this.interactors = [], this.legends = [], this.marks = [], this.markset = null, this.element = t || document.createElement("div"), this.element.setAttribute("class", "plot"), this.element.style.display = "flex", this.element.value = this, this.params = /* @__PURE__ */ new Map(), this.synch = vz();
+            ...HJ
+        }, this.listeners = null, this.interactors = [], this.legends = [], this.marks = [], this.markset = null, this.element = t || document.createElement("div"), this.element.setAttribute("class", "plot"), this.element.style.display = "flex", this.element.value = this, this.params = /* @__PURE__ */ new Map(), this.synch = Ek();
     }
     margins() {
         return {
             left: this.getAttribute("marginLeft"),
             top: this.getAttribute("marginTop"),
             bottom: this.getAttribute("marginBottom"),
             right: this.getAttribute("marginRight")
@@ -36821,61 +37414,81 @@
             right: n
         } = this.margins();
         return this.getAttribute("width") - t - n;
     }
     innerHeight(t = 400) {
         const {
             top: n,
-            bottom: i
+            bottom: r
         } = this.margins();
-        let r = this.getAttribute("height");
-        return r == null && t != null && (r = t, this.setAttribute("height", r, {
+        let i = this.getAttribute("height");
+        return i == null && t != null && (i = t, this.setAttribute("height", i, {
             silent: !0
-        })), r - n - i;
+        })), i - n - r;
     }
     pending(t) {
         this.synch.pending(t);
     }
     update(t) {
         return this.synch.ready(t) && !this.pendingRender && (this.pendingRender = !0, requestAnimationFrame(() => this.render())), this.synch.promise;
     }
     async render() {
         this.pendingRender = !1;
-        const t = await Unt(this),
+        const t = await VJ(this),
             n = this.legends.flatMap(({
-                legend: i,
-                include: r
+                legend: r,
+                include: i
             }) => {
-                const s = i.init(t);
-                return r ? s : [];
+                const s = r.init(t);
+                return i ? s : [];
             });
         this.element.replaceChildren(t, ...n), this.synch.resolve();
     }
+    /**
+     * @param {string} name The attribute to return.
+     * @returns {*} The value of the attribute.
+     */
     getAttribute(t) {
         return this.attributes[t];
     }
-    setAttribute(t, n, i) {
-        var r, s;
-        return t3(this.attributes[t], n) ? (n === void 0 ? delete this.attributes[t] : this.attributes[t] = n, i != null && i.silent || (s = (r = this.listeners) == null ? void 0 : r.get(t)) == null || s.forEach((o) => o(t, n)), !0) : !1;
+    /**
+     * @param {string} name The name of the attribute to set.
+     * @param {*} value The value to set.
+     * @param {{silent: boolean}} [options] Options for setting the attribute.
+     * @returns {boolean} whether the value changed.
+     */
+    setAttribute(t, n, r) {
+        var i, s;
+        return zx(this.attributes[t], n) ? (n === void 0 ? delete this.attributes[t] : this.attributes[t] = n, r != null && r.silent || (s = (i = this.listeners) == null ? void 0 : i.get(t)) == null || s.forEach((o) => o(t, n)), !0) : !1;
     }
+    /**
+     * @param {string} name The attribute name.
+     * @param {*} callback The function to call when the attribute changes.
+     * @returns {this}
+     */
     addAttributeListener(t, n) {
-        const i = this.listeners || (this.listeners = /* @__PURE__ */ new Map());
-        return i.has(t) || i.set(t, /* @__PURE__ */ new Set()), i.get(t).add(n), this;
+        const r = this.listeners || (this.listeners = /* @__PURE__ */ new Map());
+        return r.has(t) || r.set(t, /* @__PURE__ */ new Set()), r.get(t).add(n), this;
     }
+    /**
+     * @param {string} name The attribute name.
+     * @param {*} callback The function to call when the attribute changes.
+     * @returns {void}
+     */
     removeAttributeListener(t, n) {
-        var i, r;
-        return (r = (i = this.listeners) == null ? void 0 : i.get(t)) == null ? void 0 : r.delete(n);
+        var r, i;
+        return (i = (r = this.listeners) == null ? void 0 : r.get(t)) == null ? void 0 : i.delete(n);
     }
     addParams(t, n) {
         const {
-            params: i
+            params: r
         } = this;
-        for (const r of n)
-            i.has(r) ? i.get(r).push(t) : (i.set(r, [t]), r.addEventListener("value", () => Promise.allSettled(
-                i.get(r).map((s) => s.requestQuery())
+        for (const i of n)
+            r.has(i) ? r.get(i).push(t) : (r.set(i, [t]), i.addEventListener("value", () => Promise.allSettled(
+                r.get(i).map((s) => s.requestQuery())
             )));
     }
     addMark(t) {
         return t.setPlot(this, this.marks.length), this.marks.push(t), this.markset = null, this;
     }
     get markSet() {
         return this.markset || (this.markset = new Set(this.marks));
@@ -36887,20 +37500,20 @@
         t.setPlot(this), this.legends.push({
             legend: t,
             include: n
         });
     }
 }
 
-function MN(e) {
+function b8(e) {
     return typeof e != "string" ? !1 : (e = e.toLowerCase().trim(), e === "none" || e === "currentcolor" || e.startsWith("url(") && e.endsWith(")") || // <funciri>, e.g. pattern or gradient
         e.startsWith("var(") && e.endsWith(")") || // CSS variable
-        Gs(e) !== null);
+        Ui(e) !== null);
 }
-const Wnt = /* @__PURE__ */ new Set([
+const ZJ = /* @__PURE__ */ new Set([
     "order",
     "sort",
     "label",
     "anchor",
     "curve",
     "tension",
     "marker",
@@ -36927,21 +37540,22 @@
     "shapeRendering",
     "imageRendering",
     "preserveAspectRatio",
     "interpolate",
     "crossOrigin",
     "paintOrder",
     "pointerEvents",
-    "target"
+    "target",
+    "select"
 ]);
 
-function Gnt(e) {
-    return Wnt.has(e);
+function KJ(e) {
+    return ZJ.has(e);
 }
-const Xnt = /* @__PURE__ */ new Set([
+const QJ = /* @__PURE__ */ new Set([
     "asterisk",
     "circle",
     "cross",
     "diamond",
     "diamond2",
     "hexagon",
     "plus",
@@ -36950,1272 +37564,1169 @@
     "star",
     "times",
     "triangle",
     "triangle2",
     "wye"
 ]);
 
-function Hnt(e) {
-    return Xnt.has(`${e}`.toLowerCase());
+function tZ(e) {
+    return QJ.has(`${e}`.toLowerCase());
 }
 
-function $N(e) {
-    return Ub(e) ? Jnt(e) : e;
+function ca(e) {
+    return fk(e) ? eZ(e) : nZ(e);
 }
 
-function Jnt(e) {
+function eZ(e) {
     const {
-        batches: t,
-        numRows: n
-    } = e;
-    if (!n)
-        return [];
-    const i = Array.from({
-        length: n
-    }, () => ({}));
-    for (let r = 0, s = 0; s < t.length; ++s) {
-        const o = t[s],
-            {
-                schema: a,
-                numRows: c,
-                numCols: l
-            } = o;
-        for (let u = 0; u < l; ++u) {
-            const f = o.getChildAt(u),
-                {
-                    name: h,
-                    type: d
-                } = a.fields[u],
-                p = ZM(d);
-            for (let m = r, g = 0; g < c; ++g, ++m)
-                i[m][h] = p(f.get(g));
+        numRows: t,
+        numCols: n,
+        schema: {
+            fields: r
         }
-        r += c;
+    } = e, i = {};
+    for (let s = 0; s < n; ++s) {
+        const o = r[s].name;
+        i[o] ? console.warn(`Redundant column name "${o}". Skipping...`) : i[o] = dk(e.getChildAt(s));
     }
-    return i;
+    return {
+        numRows: t,
+        columns: i
+    };
+}
+
+function nZ(e) {
+    const t = e.length;
+    if (typeof e[0] == "object") {
+        const n = t ? Object.keys(e[0]) : [],
+            r = {};
+        return n.length > 0 && n.forEach((i) => {
+            r[i] = e.map((s) => s[i]);
+        }), {
+            numRows: t,
+            columns: r
+        };
+    } else
+        return {
+            numRows: t,
+            values: e
+        };
 }
-const TN = (e) => e === "stroke" || e === "fill",
-    Knt = (e) => e === "symbol",
-    Znt = (e, t) => e !== "sort" && e !== "tip" && t != null && !Array.isArray(t),
-    ng = (e, t) => ({
+const w8 = (e) => e === "stroke" || e === "fill",
+    rZ = (e) => /opacity$/i.test(e),
+    iZ = (e) => e === "symbol",
+    sZ = (e, t) => e !== "sort" && e !== "tip" && t != null && !Array.isArray(t),
+    Zp = (e, t) => ({
         channel: e,
         field: t,
-        as: t instanceof js ? t.column : e
+        as: t instanceof Fi ? t.column : e
     }),
-    ig = (e, t) => ({
+    Kp = (e, t) => ({
         channel: e,
         value: t
     }),
-    G1 = (e) => Array.isArray(e);
-class ha extends af {
-    constructor(t, n, i, r = {}) {
-        var l;
-        super((l = n == null ? void 0 : n.options) == null ? void 0 : l.filterBy), this.type = t, this.reqs = r, this.source = n, G1(this.source) && (this.data = this.source);
+    Ry = (e) => Array.isArray(e);
+class rs extends Kc {
+    constructor(t, n, r, i = {}) {
+        var u;
+        super((u = n == null ? void 0 : n.options) == null ? void 0 : u.filterBy), this.type = t, this.reqs = i, this.source = n, Ry(this.source) && (this.data = ca(this.source));
         const s = this.channels = [],
             o = this.detail = /* @__PURE__ */ new Set(),
             a = this.params = /* @__PURE__ */ new Set(),
-            c = (u, f) => {
+            c = (l, f) => {
                 const h = typeof f;
-                if (u === "channels")
+                if (l === "channels")
                     for (const d in f)
                         o.add(d), c(d, f[d]);
-                else if (h === "function" && f[e3]) {
-                    const d = f(this, u);
+                else if (h === "function" && f[Xx]) {
+                    const d = f(this, l);
                     for (const p in d)
                         c(p, d[p]);
                 } else if (h === "string")
-                    Gnt(u) || TN(u) && MN(f) || Knt(u) && Hnt(f) ? s.push(ig(u, f)) : s.push(ng(u, Py(f)));
-                else if (Mc(f))
+                    KJ(l) || w8(l) && b8(f) || iZ(l) && tZ(f) ? s.push(Kp(l, f)) : s.push(Zp(l, Bh(f)));
+                else if (qo(f))
                     if (Array.isArray(f.columns))
-                        s.push(ng(u, f)), a.add(f);
+                        s.push(Zp(l, f)), a.add(f);
                     else {
-                        const d = ig(u, f.value);
+                        const d = Kp(l, f.value);
                         s.push(d), f.addEventListener("value", (p) => (d.value = p, this.update()));
                     }
                 else
-                    h === "object" && Znt(u, f) ? s.push(ng(u, f)) : f !== void 0 && s.push(ig(u, f));
+                    h === "object" && sZ(l, f) ? s.push(Zp(l, f)) : f !== void 0 && s.push(Kp(l, f));
             };
-        for (const u in i)
-            c(u, i[u]);
+        for (const l in r)
+            c(l, r[l]);
     }
+    /**
+     * @param {import('../plot.js').Plot} plot The plot.
+     * @param {number} index
+     */
     setPlot(t, n) {
-        var i;
-        this.plot = t, this.index = n, t.addParams(this, this.params), (i = this.source) != null && i.table && this.queryPending();
+        var r;
+        this.plot = t, this.index = n, t.addParams(this, this.params), (r = this.source) != null && r.table && this.queryPending();
     }
     hasOwnData() {
-        return this.source == null || G1(this.source);
+        return this.source == null || Ry(this.source);
     }
     hasFieldInfo() {
         return !!this._fieldInfo;
     }
     channel(t) {
         return this.channels.find((n) => n.channel === t);
     }
     channelField(t, {
-        exact: n
+        exact: n = !1
     } = {}) {
-        const i = n ? this.channel(t) : this.channels.find((r) => r.channel.startsWith(t));
-        return i != null && i.field ? i : null;
+        const r = n ? this.channel(t) : this.channels.find((i) => i.channel.startsWith(t));
+        return r != null && r.field ? r : null;
     }
     fields() {
         var s, o, a;
         if (this.hasOwnData())
             return null;
         const {
             source: {
                 table: t
             },
             channels: n,
-            reqs: i
-        } = this, r = /* @__PURE__ */ new Map();
+            reqs: r
+        } = this, i = /* @__PURE__ */ new Map();
         for (const {
                 channel: c,
-                field: l
+                field: u
             }
             of n) {
-            if (!l)
+            if (!u)
                 continue;
-            const u = ((s = l.stats) == null ? void 0 : s.stats) || [],
-                f = ((o = l.stats) == null ? void 0 : o.column) ?? l,
-                h = r.get(f) ?? r.set(f, /* @__PURE__ */ new Set()).get(f);
-            u.forEach((d) => h.add(d)), (a = i[c]) == null || a.forEach((d) => h.add(d));
+            const l = ((s = u.stats) == null ? void 0 : s.stats) || [],
+                f = ((o = u.stats) == null ? void 0 : o.column) ?? u,
+                h = i.get(f) ?? i.set(f, /* @__PURE__ */ new Set()).get(f);
+            l.forEach((d) => h.add(d)), (a = r[c]) == null || a.forEach((d) => h.add(d));
         }
-        return Array.from(r, ([c, l]) => ({
+        return Array.from(i, ([c, u]) => ({
             table: t,
             column: c,
-            stats: l
+            stats: u
         }));
     }
     fieldInfo(t) {
-        var i;
-        const n = Object.fromEntries(t.map((r) => [r.column, r]));
-        for (const r of this.channels) {
+        var r;
+        const n = Object.fromEntries(t.map((i) => [i.column, i]));
+        for (const i of this.channels) {
             const {
                 field: s
-            } = r;
-            s && Object.assign(r, n[((i = s.stats) == null ? void 0 : i.column) ?? s]);
+            } = i;
+            s && Object.assign(i, n[((r = s.stats) == null ? void 0 : r.column) ?? s]);
         }
         return this._fieldInfo = !0, this;
     }
+    /**
+     * Return a query specifying the data needed by this Mark client.
+     * @param {*} [filter] The filtering criteria to apply in the query.
+     * @returns {*} The client query
+     */
     query(t = []) {
         if (this.hasOwnData())
             return null;
         const {
             channels: n,
             source: {
-                table: i
+                table: r
             }
         } = this;
-        return DN(n, i).where(t);
+        return _1(n, r).where(t);
     }
     queryPending() {
         return this.plot.pending(this), this;
     }
+    /**
+     * Provide query result data to the mark.
+     */
     queryResult(t) {
-        return this.data = $N(t), this;
+        return this.data = ca(t), this;
     }
     update() {
         return this.plot.update(this);
     }
+    /**
+     * Generate an array of Plot mark specifications.
+     * @returns {object[]}
+     */
     plotSpecs() {
         const {
             type: t,
             data: n,
-            detail: i,
-            channels: r
-        } = this, s = {}, o = {};
-        for (const a of r) {
-            const c = i.has(a.channel) ? o : s;
-            c[a.channel] = Cs(a);
-        }
-        return i.size && (s.channels = o), [{
-            type: t,
-            data: n,
-            options: s
-        }];
+            detail: r,
+            channels: i
+        } = this;
+        return v8(t, r, i, n);
     }
 }
 
-function Cs(e) {
-    return Object.hasOwn(e, "value") ? e.value : TN(e.channel) ? {
-        value: e.as,
+function gn(e, t) {
+    const n = (t == null ? void 0 : t[e.as]) ?? e.as;
+    return Object.hasOwn(e, "value") ? e.value : w8(e.channel) ? {
+        value: n,
         scale: "color"
-    } : e.as;
+    } : rZ(e.channel) ? {
+        value: n,
+        scale: "opacity"
+    } : n;
 }
 
-function DN(e, t, n = []) {
-    const i = Lt.from({
+function _1(e, t, n = []) {
+    const r = xt.from({
             source: t
         }),
-        r = /* @__PURE__ */ new Set();
+        i = /* @__PURE__ */ new Set();
     let s = !1;
     for (const o of e) {
         const {
             channel: a,
             field: c,
-            as: l
+            as: u
         } = o;
         if (!n.includes(a)) {
             if (a === "orderby")
-                i.orderby(o.value);
+                r.orderby(o.value);
             else if (c) {
                 if (c.aggregate)
                     s = !0;
                 else {
-                    if (r.has(l))
+                    if (i.has(u))
                         continue;
-                    r.add(l);
+                    i.add(u);
                 }
-                i.select({
-                    [l]: c
+                r.select({
+                    [u]: c
                 });
             }
         }
     }
-    return s && i.groupby(Array.from(r)), i;
+    return s && r.groupby(Array.from(i)), r;
 }
 
-function ny(e, t) {
+function v8(e, t, n, r, i = {}) {
+    const {
+        numRows: s,
+        values: o,
+        columns: a
+    } = r ?? {}, c = {};
+    for (const f of n) {
+        const h = t.has(f.channel) ? c : i;
+        h[f.channel] = gn(f, a);
+    }
+    return t.size && (i.channels = c), [{
+        type: e,
+        data: o ?? (r ? {
+            length: s
+        } : null),
+        options: i
+    }];
+}
+
+function Ih(e, t) {
     const {
         plot: n
     } = e;
-    let i = n.getAttribute(`${t}Scale`);
-    if (!i) {
+    let r = n.getAttribute(`${t}Scale`);
+    if (!r) {
         const {
             type: s
         } = e.channelField(t);
-        i = s === "date" ? "time" : "linear";
+        r = s === "date" ? "time" : "linear";
     }
-    const r = {
-        type: i
+    const i = {
+        type: r
     };
-    switch (i) {
+    switch (r) {
         case "log":
-            r.base = n.getAttribute(`${t}Base`) ?? 10;
+            i.base = n.getAttribute(`${t}Base`) ?? 10;
             break;
         case "pow":
-            r.exponent = n.getAttribute(`${t}Exponent`) ?? 1;
+            i.exponent = n.getAttribute(`${t}Exponent`) ?? 1;
             break;
         case "symlog":
-            r.constant = n.getAttribute(`${t}Constant`) ?? 1;
+            i.constant = n.getAttribute(`${t}Constant`) ?? 1;
             break;
     }
-    return GM(r);
+    return kx(i);
 }
 
-function Qs(e, t, n, i, r = 1, s) {
+function Wi(e, t, n, r, i = 1, s) {
     const {
         field: o
     } = e.channelField(t);
     s = s ?? o;
     const {
         type: a,
         apply: c,
-        sqlApply: l
-    } = ny(e, t), u = !!e.plot.getAttribute(`${t}Reverse`), [f, h] = i.map((b) => c(b)), d = l(s), p = a === "time" || a === "utc" ? d : s, m = h === f ? 0 : (n - r) / (h - f), g = m !== 1 ? ` * ${m}::DOUBLE` : "";
-    return [u ? q`(${h} - ${d}::DOUBLE)${g}` : q`(${d}::DOUBLE - ${f})${g}`, p];
+        sqlApply: u
+    } = Ih(e, t), l = !!e.plot.getAttribute(`${t}Reverse`), [f, h] = r.map((b) => c(b)), d = u(s), p = a === "time" || a === "utc" ? d : s, y = h === f ? 0 : (n - i) / (h - f), m = y !== 1 ? ` * ${y}::DOUBLE` : "";
+    return [l ? j`(${h} - ${d}::DOUBLE)${m}` : j`(${d}::DOUBLE - ${f})${m}`, p];
 }
-const NN = {
+const _8 = {
         x: ["min", "max"]
     },
-    BN = {
+    x8 = {
         y: ["min", "max"]
     },
-    ON = {
-        ...NN,
-        ...BN
+    S8 = {
+        ..._8,
+        ...x8
     };
 
-function FN(e, t, n, i, r) {
+function M8(e, t, n, r, i) {
     const {
         plot: s
-    } = e, o = s.getAttribute(i), a = s.getAttribute(r);
-    if (Array.isArray(o) && !o[Mi])
+    } = e, o = s.getAttribute(r), a = s.getAttribute(i);
+    if (Array.isArray(o) && !o[qn])
         return o;
     {
         const {
             column: c,
-            min: l,
-            max: u
-        } = e.channelField(n), f = EN(t, c) || (a ? c0().domain([l, u]).nice().domain() : [l, u]);
-        return o !== mf && (f[Mi] = !0), s.setAttribute(i, f, {
+            min: u,
+            max: l
+        } = e.channelField(n), f = A8(t, c) || (a ? id().domain([u, l]).nice().domain() : [u, l]);
+        return o !== ou && (f[qn] = !0), s.setAttribute(r, f, {
             silent: !0
         }), f;
     }
 }
 
-function Gf(e, t) {
-    return FN(e, t, "x", "xDomain", "xNice");
+function Fu(e, t) {
+    return M8(e, t, "x", "xDomain", "xNice");
 }
 
-function Xf(e, t) {
-    return FN(e, t, "y", "yDomain", "yNice");
+function Bu(e, t) {
+    return M8(e, t, "y", "yDomain", "yNice");
 }
 
-function EN(e, t) {
+function A8(e, t) {
     if (!e)
         return;
-    let n, i;
-    const r = (s, o) => {
+    let n, r;
+    const i = (s, o) => {
         if (s === "BETWEEN" && `${o.field}` === t) {
             const {
                 range: a
             } = o;
-            a && (n == null || a[0] < n) && (n = a[0]), a && (i == null || a[1] > i) && (i = a[1]);
+            a && (n == null || a[0] < n) && (n = a[0]), a && (r == null || a[1] > r) && (r = a[1]);
         }
     };
     return Array.isArray(e) ? e.forEach((s) => {
         var o;
-        return (o = s.visit) == null ? void 0 : o.call(s, r);
-    }) : e.visit && e.visit(r), n != null && i != null && n !== i ? [n, i] : void 0;
+        return (o = s.visit) == null ? void 0 : o.call(s, i);
+    }) : e.visit && e.visit(i), n != null && r != null && n !== r ? [n, r] : void 0;
 }
-class Qnt extends ha {
-    constructor(t, n, i) {
-        const r = t.endsWith("X") ? "y" : t.endsWith("Y") ? "x" : null,
-            s = r ? {
-                [r]: ["min", "max"]
+class oZ extends rs {
+    constructor(t, n, r) {
+        const i = t.endsWith("X") ? "y" : t.endsWith("Y") ? "x" : null,
+            s = i ? {
+                [i]: ["min", "max"]
             } : void 0;
-        super(t, n, i, s), this.dim = r;
+        super(t, n, r, s), this.dim = i;
     }
+    /**
+     * Return a query specifying the data needed by this Mark client.
+     * @param {*} [filter] The filtering criteria to apply in the query.
+     * @returns {*} The client query
+     */
     query(t = []) {
-        var m;
+        var y;
         const {
             plot: n,
-            dim: i,
-            source: r
+            dim: r,
+            source: i
         } = this, {
             optimize: s = !0
-        } = r.options || {}, o = super.query(t);
-        if (!i)
+        } = i.options || {}, o = super.query(t);
+        if (!r)
             return o;
-        const a = i === "x" ? "y" : "x",
-            c = (m = this.channelField(a, {
+        const a = r === "x" ? "y" : "x",
+            c = (y = this.channelField(a, {
                 exact: !0
-            })) == null ? void 0 : m.as,
+            })) == null ? void 0 : y.as,
             {
-                field: l,
-                as: u,
+                field: u,
+                as: l,
                 type: f,
                 min: h,
                 max: d
-            } = this.channelField(i);
+            } = this.channelField(r);
         if (s && (f === "date" || f === "number") && c) {
-            const g = i === "x" ? n.innerWidth() : n.innerHeight(),
-                [y, b] = EN(t, l) || [h, d],
-                [w] = Qs(this, i, g, [y, b], 1, u),
-                v = o.select().map((x) => x.as).filter((x) => x !== u && x !== c);
-            return tit(o, w, u, c, v);
+            const m = r === "x" ? n.innerWidth() : n.innerHeight(),
+                [g, b] = A8(t, u) || [h, d],
+                [w] = Wi(this, r, m, [g, b], 1, l),
+                v = o.select().map((x) => x.as).filter((x) => x !== l && x !== c);
+            return aZ(o, w, l, c, v);
         } else
-            return o.orderby(l);
+            return o.orderby(u);
     }
 }
 
-function tit(e, t, n, i, r = []) {
-    const s = q`FLOOR(${t})::INTEGER`,
-        o = (a) => Lt.from(e).select(a).groupby(s, r);
-    return Lt.union(
+function aZ(e, t, n, r, i = []) {
+    const s = j`FLOOR(${t})::INTEGER`,
+        o = (a) => xt.from(e).select(a).groupby(s, i);
+    return xt.union(
         o([{
-            [n]: Tc(n),
-            [i]: Dg(i, n)
-        }, ...r]),
+            [n]: Vo(n),
+            [r]: y0(r, n)
+        }, ...i]),
         o([{
-            [n]: $c(n),
-            [i]: Ng(i, n)
-        }, ...r]),
+            [n]: jo(n),
+            [r]: m0(r, n)
+        }, ...i]),
         o([{
-            [n]: Dg(n, i),
-            [i]: Tc(i)
-        }, ...r]),
+            [n]: y0(n, r),
+            [r]: Vo(r)
+        }, ...i]),
         o([{
-            [n]: Ng(n, i),
-            [i]: $c(i)
-        }, ...r])
-    ).orderby(r, n);
+            [n]: m0(n, r),
+            [r]: jo(r)
+        }, ...i])
+    ).orderby(i, n);
 }
 
-function LN(e, t = "density") {
-    var n;
-    return Ub(e) ? rz(e.getChild(t).type) : typeof((n = e[0]) == null ? void 0 : n[t]) == "number" ? Float64Array : Array;
+function $8(e, t = []) {
+    return new t.constructor(e);
 }
 
-function eit(e, t, n = "density") {
-    const i = new(LN(t))(e);
-    if (Ub(t)) {
-        const r = t.numRows;
-        if (r === 0)
-            return i;
-        const s = Gd(t.getChild("index")),
-            o = Gd(t.getChild(n));
-        for (let a = 0; a < r; ++a)
-            i[s[a]] = o[a];
-    } else
-        for (const r of t)
-            i[r.index] = r[n];
-    return i;
+function cZ(e, t, n) {
+    const r = $8(e, n),
+        i = n.length;
+    for (let s = 0; s < i; ++s)
+        r[t[s]] = n[s];
+    return r;
 }
 
-function nit(e, t, n, i, r = [], s) {
-    const o = e * t,
-        a = i.map((y) => LN(n, y)),
-        c = i.length,
-        l = (y) => {
-            const b = {};
-            return r.forEach((w, v) => b[w] = y[v]), i.forEach((w, v) => b[w] = new a[v](o)), b;
-        },
-        u = {},
-        f = r.length ? null : u[[]] = l([]),
-        h = r.length ? (y) => u[y] ?? (u[y] = l(y)) : () => f,
-        d = n.numRows;
-    if (d === 0)
-        return Object.values(u);
-    const p = Gd(n.getChild("index")),
-        m = i.map((y) => Gd(n.getChild(y))),
-        g = r.map((y) => n.getChild(y));
-    if (s) {
-        const y = p.map((w) => w % e),
-            b = p.map((w) => Math.floor(w / e));
-        if (r.length)
-            for (let w = 0; w < d; ++w) {
-                const v = g.map((_) => _.get(w)),
-                    x = h(v);
-                x.index || (x.index = []), x.index.push(w);
-            }
-        else
-            f.index = p.map((w, v) => v);
-        Object.values(u).forEach((w) => {
-            for (let v = 0; v < c; ++v)
-                s(w.index, e, t, y, b, m[v], w[i[v]]);
-            delete w.index;
+function uZ(e, t, n, r, i, s, o) {
+    const a = n.length,
+        c = e * t,
+        u = i.map((d) => r[d]),
+        l = {},
+        f = [],
+        h = new Int32Array(a);
+    if (s != null && s.length) {
+        const d = s.map((y) => r[y]),
+            p = {};
+        for (let y = 0; y < a; ++y) {
+            const m = d.map((g) => g[y]);
+            h[y] = p[m] ?? (p[m] = f.push(m) - 1);
+        }
+        for (let y = 0; y < s.length; ++y)
+            l[s[y]] = f.map((m) => m[y]);
+    } else
+        f.push([]);
+    if (o) {
+        const d = n.map((m) => m % e),
+            p = n.map((m) => Math.floor(m / e)),
+            y = f.map(() => []);
+        for (let m = 0; m < a; ++m)
+            y[h[m]].push(m);
+        i.forEach((m, g) => {
+            const b = u[g];
+            l[m] = f.map((w, v) => o(y[v], e, t, d, p, b));
         });
     } else
-        for (let y = 0; y < d; ++y) {
-            const b = g.map((v) => v.get(y)),
-                w = h(b);
-            for (let v = 0; v < c; ++v)
-                w[i[v]][p[y]] = m[v][y];
-        }
-    return Object.values(u);
+        i.forEach((d, p) => {
+            const y = u[p],
+                m = l[d] = f.map(() => $8(c, y));
+            for (let g = 0; g < a; ++g)
+                m[h[g]][n[g]] = y[g];
+        });
+    return {
+        numRows: f.length,
+        columns: l
+    };
 }
 
-function Uv(e, t) {
-    let n = 0,
-        i = 0;
+function x1(e) {
+    let t = 1 / 0,
+        n = -1 / 0;
     return e.forEach((r) => {
-        const s = r[t],
-            o = s.length;
-        for (let a = 0; a < o; ++a) {
-            const c = s[a];
-            c < n && (n = c), c > i && (i = c);
+        const i = r.length;
+        for (let s = 0; s < i; ++s) {
+            const o = r[s];
+            o < t && (t = o), o > n && (n = o);
         }
-    }), n === 0 && i === 0 ? [0, 1] : [n, i];
+    }), Number.isFinite(t) && Number.isFinite(n) ? [t, n] : [0, 1];
 }
 
-function iit(e, t) {
-    const n = new el();
-    return e.forEach((i) => {
-        const r = i[t],
-            s = r.length;
-        for (let o = 0; o < s; ++o)
-            n.add(r[o]);
-    }), Array.from(n).sort(me);
+function lZ(e) {
+    const t = new da();
+    return e.forEach((n) => {
+        const r = n.length;
+        for (let i = 0; i < r; ++i)
+            t.add(n[i]);
+    }), Array.from(t).sort(zt);
 }
 
-function Kn(e, t, n, i) {
-    Us(n) ? (i = i || (() => e.requestUpdate()), n.addEventListener("value", (r) => (e[t] = r, i())), e[t] = n.value) : e[t] = n;
+function Ge(e, t) {
+    return Oi(e) ? (e.addEventListener("value", t), e.value) : e;
 }
 
-function X1(e, t = !1) {
+function Fy(e, t = !1) {
     const n = new Float64Array(5),
-        i = new Float64Array(4);
-    rit(n, i, e);
-    const r = Float64Array.of(
+        r = new Float64Array(4);
+    fZ(n, r, e);
+    const i = Float64Array.of(
             0,
-            i[1] - n[1] * i[0],
-            i[2] - n[2] * i[0],
-            i[3] - n[3] * i[0],
-            -n[4] * i[0]
+            r[1] - n[1] * r[0],
+            r[2] - n[2] * r[0],
+            r[3] - n[3] * r[0],
+            -n[4] * r[0]
         ),
         s = 1 + n[1] + n[2] + n[3] + n[4],
-        o = (i[0] + i[1] + i[2] + i[3]) / s,
-        a = (r[1] + r[2] + r[3] + r[4]) / s;
+        o = (r[0] + r[1] + r[2] + r[3]) / s,
+        a = (i[1] + i[2] + i[3] + i[4]) / s;
     return {
         sigma: e,
         negative: t,
         a: n,
-        b_causal: i,
-        b_anticausal: r,
+        b_causal: r,
+        b_anticausal: i,
         sum_causal: o,
         sum_anticausal: a
     };
 }
 
-function rit(e, t, n) {
-    const r = Float64Array.of(
+function fZ(e, t, n) {
+    const i = Float64Array.of(
             0.84,
             1.8675,
             0.84,
             -1.8675,
             -0.34015,
             -0.1299,
             -0.34015,
             0.1299
         ),
         s = Math.exp(-1.783 / n),
         o = Math.exp(-1.723 / n),
         a = 0.6318 / n,
         c = 1.997 / n,
-        l = Float64Array.of(
+        u = Float64Array.of(
             -s * Math.cos(a),
             s * Math.sin(a),
             -s * Math.cos(-a),
             s * Math.sin(-a),
             -o * Math.cos(c),
             o * Math.sin(c),
             -o * Math.cos(-c),
             o * Math.sin(-c)
         ),
-        u = n * 2.5066282746310007,
-        f = Float64Array.of(r[0], r[1], 0, 0, 0, 0, 0, 0),
-        h = Float64Array.of(1, 0, l[0], l[1], 0, 0, 0, 0, 0, 0);
+        l = n * 2.5066282746310007,
+        f = Float64Array.of(i[0], i[1], 0, 0, 0, 0, 0, 0),
+        h = Float64Array.of(1, 0, u[0], u[1], 0, 0, 0, 0, 0, 0);
     let d, p;
     for (p = 2; p < 8; p += 2) {
-        for (f[p] = l[p] * f[p - 2] - l[p + 1] * f[p - 1], f[p + 1] = l[p] * f[p - 1] + l[p + 1] * f[p - 2], d = p - 2; d > 0; d -= 2)
-            f[d] += l[p] * f[d - 2] - l[p + 1] * f[d - 1], f[d + 1] += l[p] * f[d - 1] + l[p + 1] * f[d - 2];
+        for (f[p] = u[p] * f[p - 2] - u[p + 1] * f[p - 1], f[p + 1] = u[p] * f[p - 1] + u[p + 1] * f[p - 2], d = p - 2; d > 0; d -= 2)
+            f[d] += u[p] * f[d - 2] - u[p + 1] * f[d - 1], f[d + 1] += u[p] * f[d - 1] + u[p + 1] * f[d - 2];
         for (d = 0; d <= p; d += 2)
-            f[d] += r[p] * h[d] - r[p + 1] * h[d + 1], f[d + 1] += r[p] * h[d + 1] + r[p + 1] * h[d];
-        for (h[p + 2] = l[p] * h[p] - l[p + 1] * h[p + 1], h[p + 3] = l[p] * h[p + 1] + l[p + 1] * h[p], d = p; d > 0; d -= 2)
-            h[d] += l[p] * h[d - 2] - l[p + 1] * h[d - 1], h[d + 1] += l[p] * h[d - 1] + l[p + 1] * h[d - 2];
+            f[d] += i[p] * h[d] - i[p + 1] * h[d + 1], f[d + 1] += i[p] * h[d + 1] + i[p + 1] * h[d];
+        for (h[p + 2] = u[p] * h[p] - u[p + 1] * h[p + 1], h[p + 3] = u[p] * h[p + 1] + u[p + 1] * h[p], d = p; d > 0; d -= 2)
+            h[d] += u[p] * h[d - 2] - u[p + 1] * h[d - 1], h[d + 1] += u[p] * h[d - 1] + u[p + 1] * h[d - 2];
     }
     for (p = 0; p < 4; ++p)
-        d = p << 1, t[p] = f[d] / u, e[p + 1] = h[d + 2];
+        d = p << 1, t[p] = f[d] / l, e[p + 1] = h[d + 2];
 }
 
-function sit(e, t, n, [i, r]) {
-    const s = new Float64Array(Math.max(i, r)),
-        o = new Float64Array(Math.max(i, r)),
+function hZ(e, t, n, [r, i]) {
+    const s = new Float64Array(Math.max(r, i)),
+        o = new Float64Array(Math.max(r, i)),
         a = new Float64Array(5),
         c = new Float64Array(n.length);
-    for (let l = 0, u = 0; l < r; ++l, u += i) {
-        const f = c.subarray(u);
-        H1(e, n.subarray(u), i, 1, s, o, a, f);
-    }
-    for (let l = 0; l < i; ++l) {
-        const u = c.subarray(l);
-        H1(t, u, r, i, s, o, a, u);
+    for (let u = 0, l = 0; u < i; ++u, l += r) {
+        const f = c.subarray(l);
+        By(e, n.subarray(l), r, 1, s, o, a, f);
+    }
+    for (let u = 0; u < r; ++u) {
+        const l = c.subarray(u);
+        By(t, l, i, r, s, o, a, l);
     }
     return c;
 }
 
-function H1(e, t, n, i = 1, r = new Float64Array(n), s = new Float64Array(n), o = new Float64Array(5), a = r, c = oit) {
-    const l = i * 2,
-        u = i * 3,
-        f = i * 4,
-        h = i * n;
+function By(e, t, n, r = 1, i = new Float64Array(n), s = new Float64Array(n), o = new Float64Array(5), a = i, c = dZ) {
+    const u = r * 2,
+        l = r * 3,
+        f = r * 4,
+        h = r * n;
     let d, p;
     for (c(
-            r,
+            i,
             t,
             n,
-            i,
+            r,
             e.b_causal,
             3,
             e.a,
             4,
             e.sum_causal,
             o,
             e.sigma
-        ), p = 4, d = f; p < n; ++p, d += i)
-        r[p] = e.b_causal[0] * t[d] + e.b_causal[1] * t[d - i] + e.b_causal[2] * t[d - l] + e.b_causal[3] * t[d - u] - e.a[1] * r[p - 1] - e.a[2] * r[p - 2] - e.a[3] * r[p - 3] - e.a[4] * r[p - 4];
+        ), p = 4, d = f; p < n; ++p, d += r)
+        i[p] = e.b_causal[0] * t[d] + e.b_causal[1] * t[d - r] + e.b_causal[2] * t[d - u] + e.b_causal[3] * t[d - l] - e.a[1] * i[p - 1] - e.a[2] * i[p - 2] - e.a[3] * i[p - 3] - e.a[4] * i[p - 4];
     for (c(
             s,
             t,
             n,
-            -i,
+            -r,
             e.b_anticausal,
             4,
             e.a,
             4,
             e.sum_anticausal,
             o,
             e.sigma
-        ), p = 4, d = h - i * 5; p < n; ++p, d -= i)
-        s[p] = e.b_anticausal[1] * t[d + i] + e.b_anticausal[2] * t[d + l] + e.b_anticausal[3] * t[d + u] + e.b_anticausal[4] * t[d + f] - e.a[1] * s[p - 1] - e.a[2] * s[p - 2] - e.a[3] * s[p - 3] - e.a[4] * s[p - 4];
+        ), p = 4, d = h - r * 5; p < n; ++p, d -= r)
+        s[p] = e.b_anticausal[1] * t[d + r] + e.b_anticausal[2] * t[d + u] + e.b_anticausal[3] * t[d + l] + e.b_anticausal[4] * t[d + f] - e.a[1] * s[p - 1] - e.a[2] * s[p - 2] - e.a[3] * s[p - 3] - e.a[4] * s[p - 4];
     if (e.negative)
-        for (p = 0, d = 0; p < n; ++p, d += i)
-            a[d] = r[p] + s[n - p - 1];
+        for (p = 0, d = 0; p < n; ++p, d += r)
+            a[d] = i[p] + s[n - p - 1];
     else
-        for (p = 0, d = 0; p < n; ++p, d += i)
-            a[d] = Math.max(0, r[p] + s[n - p - 1]);
+        for (p = 0, d = 0; p < n; ++p, d += r)
+            a[d] = Math.max(0, i[p] + s[n - p - 1]);
     return a;
 }
 
-function oit(e, t, n, i, r, s, o, a, c, l, u, f = 0.5) {
-    const h = Math.abs(i) * n,
-        d = i < 0 ? h + i : 0;
-    let p, m, g;
-    for (m = 0; m <= a; ++m)
-        for (l[m] = m <= s ? r[m] : 0, g = 1; g <= a && g <= m; ++g)
-            l[m] -= o[g] * l[m - g];
-    for (g = 0; g < a; ++g)
-        for (e[g] = 0, m = 1; m <= g; ++m)
-            p = d + i * m, p >= 0 && p < h && (e[g] += l[g - m] * t[p]);
-    const y = t[d],
-        b = Math.ceil(u * 10);
-    for (m = 0; m < b; ++m) {
-        for (g = 0; g < a; ++g)
-            e[g] += l[g] * y;
-        if (c -= Math.abs(l[0]), c <= f)
-            break;
-        for (l[a] = m + a <= s ? r[m + a] : 0, g = 1; g <= a; ++g)
-            l[a] -= o[g] * l[a - g];
-        for (g = 0; g < a; ++g)
-            l[g] = l[g + 1];
-    }
-}
-
-function ait({
-    random: e = Sf(42)
-} = {}) {
-    return (t, n, i, r, s, o, a) => {
+function dZ(e, t, n, r, i, s, o, a, c, u, l, f = 0.5) {
+    const h = Math.abs(r) * n,
+        d = r < 0 ? h + r : 0;
+    let p, y, m;
+    for (y = 0; y <= a; ++y)
+        for (u[y] = y <= s ? i[y] : 0, m = 1; m <= a && m <= y; ++m)
+            u[y] -= o[m] * u[y - m];
+    for (m = 0; m < a; ++m)
+        for (e[m] = 0, y = 1; y <= m; ++y)
+            p = d + r * y, p >= 0 && p < h && (e[m] += u[m - y] * t[p]);
+    const g = t[d],
+        b = Math.ceil(l * 10);
+    for (y = 0; y < b; ++y) {
+        for (m = 0; m < a; ++m)
+            e[m] += u[m] * g;
+        if (c -= Math.abs(u[0]), c <= f)
+            break;
+        for (u[a] = y + a <= s ? i[y + a] : 0, m = 1; m <= a; ++m)
+            u[a] -= o[m] * u[a - m];
+        for (m = 0; m < a; ++m)
+            u[m] = u[m + 1];
+    }
+}
+const Ii = "density";
+class Vd extends rs {
+    constructor(t, n, r) {
         const {
-            points: c,
-            triangles: l,
-            hull: u
-        } = Ci.from(t, (d) => r[d], (d) => s[d]), f = new Uint8Array(n * i), h = yit(o, e);
-        for (let d = 0; d < l.length; d += 3) {
-            const p = l[d],
-                m = l[d + 1],
-                g = l[d + 2],
-                y = c[2 * p],
-                b = c[2 * m],
-                w = c[2 * g],
-                v = c[2 * p + 1],
-                x = c[2 * m + 1],
-                _ = c[2 * g + 1],
-                I = Math.min(y, b, w),
-                A = Math.max(y, b, w),
-                M = Math.min(v, x, _),
-                N = Math.max(v, x, _),
-                $ = (x - _) * (y - w) + (v - _) * (w - b);
-            if (!$)
-                continue;
-            const B = o[t[p]],
-                R = o[t[m]],
-                S = o[t[g]];
-            for (let T = Math.floor(I); T < A; ++T)
-                for (let D = Math.floor(M); D < N; ++D) {
-                    if (T < 0 || T >= n || D < 0 || D >= i)
-                        continue;
-                    const L = T + 0.5,
-                        k = D + 0.5,
-                        U = ((x - _) * (L - w) + (k - _) * (w - b)) / $;
-                    if (U < 0)
-                        continue;
-                    const C = ((_ - v) * (L - w) + (k - _) * (y - w)) / $;
-                    if (C < 0)
-                        continue;
-                    const z = 1 - U - C;
-                    if (z < 0)
-                        continue;
-                    const P = T + n * D;
-                    a[P] = h(B, U, R, C, S, z, T, D), f[P] = 1;
-                }
-        }
-        return cit(a, f, r, s, o, n, i, u, t, h), a;
-    };
-}
-
-function cit(e, t, n, i, r, s, o, a, c, l) {
-    n = Float64Array.from(a, (d) => n[c[d]]), i = Float64Array.from(a, (d) => i[c[d]]), r = Array.from(a, (d) => r[c[d]]);
-    const u = n.length,
-        f = Array.from({
-            length: u
-        }, (d, p) => uit(p, n, i));
-    let h = 0;
-    for (let d = 0; d < o; ++d) {
-        const p = d + 0.5;
-        for (let m = 0; m < s; ++m) {
-            const g = m + s * d;
-            if (!t[g]) {
-                const y = m + 0.5;
-                for (let b = 0; b < u; ++b) {
-                    const w = (u + h + (b % 2 ? (b + 1) / 2 : -b / 2)) % u;
-                    if (f[w](y, p)) {
-                        const v = lit(n.at(w - 1), i.at(w - 1), n[w], i[w], y, p);
-                        e[g] = l(r.at(w - 1), v, r[w], 1 - v, r[w], 0, m, d), h = w;
-                        break;
-                    }
-                }
-            }
-        }
-    }
-}
-
-function lit(e, t, n, i, r, s) {
-    const o = n - e,
-        a = i - t,
-        c = o * (n - r) + a * (i - s),
-        l = o * (r - e) + a * (s - t);
-    return c > 0 && l > 0 ? c / (c + l) : +(c > l);
-}
-
-function Ol(e, t, n, i) {
-    return e * i - n * t;
-}
-
-function uit(e, t, n) {
-    const i = t.length,
-        r = t.at(e - 2),
-        s = n.at(e - 2),
-        o = t.at(e - 1),
-        a = n.at(e - 1),
-        c = t[e],
-        l = n[e],
-        u = t.at(e + 1 - i),
-        f = n.at(e + 1 - i),
-        h = o - c,
-        d = a - l,
-        p = r - o,
-        m = s - a,
-        g = c - u,
-        y = l - f,
-        b = Math.hypot(h, d),
-        w = Math.hypot(p, m),
-        v = Math.hypot(g, y);
-    return (x, _) => {
-        const I = x - o,
-            A = _ - a,
-            M = x - c,
-            N = _ - l;
-        return Ol(I, A, M, N) > -1e-6 && Ol(I, A, h, d) * w - Ol(I, A, p, m) * b > -1e-6 && Ol(M, N, g, y) * b - Ol(M, N, h, d) * v <= 0;
-    };
-}
-
-function fit(e, t, n, i, r, s, o) {
-    const a = Ci.from(e, (u) => i[u], (u) => r[u]);
-    let c, l;
-    for (let u = 0.5, f = 0; u < n; ++u) {
-        l = c;
-        for (let h = 0.5; h < t; ++h, ++f)
-            l = a.find(h, u, l), h === 0.5 && (c = l), o[f] = s[e[l]];
-    }
-    return o;
-}
-
-function hit({
-    random: e = Sf(42),
-    minDistance: t = 0.5,
-    maxSteps: n = 2
-} = {}) {
-    return (i, r, s, o, a, c, l) => {
-        const u = Ci.from(i, (p) => o[p], (p) => a[p]);
-        let f, h, d;
-        for (let p = 0.5, m = 0; p < s; ++p) {
-            h = f;
-            for (let g = 0.5; g < r; ++g, ++m) {
-                let y = g,
-                    b = p;
-                d = h = u.find(y, b, h), g === 0.5 && (f = h);
-                let w, v = 0;
-                for (;
-                    (w = Math.hypot(o[i[d]] - y, a[i[d]] - b)) > t && v < n;) {
-                    const x = e(g, p, v) * 2 * Math.PI;
-                    y += Math.cos(x) * w, b += Math.sin(x) * w, d = u.find(y, b, d), ++v;
-                }
-                l[m] = c[i[d]];
-            }
-        }
-        return l;
-    };
-}
-
-function dit(e, t, n, i, r, s) {
-    return t * e + i * n + s * r;
-}
-
-function pit(e) {
-    return (t, n, i, r, s, o, a, c) => {
-        const l = e(a, c);
-        return l < n ? t : l < n + r ? i : s;
-    };
-}
-
-function yit(e, t) {
-    return mit(e) || git(e) ? dit : pit(t);
-}
-
-function mit(e) {
-    for (const t of e)
-        if (t != null)
-            return typeof t == "number";
-}
-
-function git(e) {
-    for (const t of e)
-        if (t != null)
-            return t instanceof Date;
-}
-const Fs = "density";
-class W0 extends ha {
-    constructor(t, n, i) {
-        const {
-            bandwidth: r = 0,
+            bandwidth: i = 0,
             interpolate: s = "none",
             pixelSize: o = 1,
             pad: a = 1,
             width: c,
-            height: l,
-            ...u
-        } = i, f = bit(u);
-        super(t, n, u, ON), this.densityMap = f, Kn(this, "bandwidth", r, () => this.grids ? this.convolve().update() : null), Kn(this, "pixelSize", o), Kn(this, "interpolate", s), Kn(this, "pad", a), Kn(this, "width", c), Kn(this, "height", l);
+            height: u,
+            ...l
+        } = r, f = pZ(l);
+        super(t, n, l, S8), this.densityMap = f, this.bandwidth = Ge(i, (h) => (this.bandwidth = h, this.grids ? this.convolve().update() : null)), this.interpolate = Ge(s, (h) => (this.interpolate = h, this.requestUpdate())), this.pixelSize = Ge(o, (h) => (this.pixelSize = h, this.requestUpdate())), this.pad = Ge(a, (h) => (this.pad = h, this.requestUpdate())), this.width = Ge(c, (h) => (this.width = h, this.requestUpdate())), this.height = Ge(u, (h) => (this.height = h, this.requestUpdate()));
     }
+    /**
+     * @param {import('../plot.js').Plot} plot The plot.
+     * @param {number} index
+     */
     setPlot(t, n) {
-        const i = () => {
+        const r = () => {
             this.hasFieldInfo() && this.requestUpdate();
         };
-        return t.addAttributeListener("domainX", i), t.addAttributeListener("domainY", i), super.setPlot(t, n);
+        t.addAttributeListener("xDomain", r), t.addAttributeListener("yDomain", r), super.setPlot(t, n);
     }
     get filterIndexable() {
         const t = this.plot.getAttribute("xDomain"),
             n = this.plot.getAttribute("yDomain");
-        return t && n && !t[Mi] && !n[Mi];
+        return t && n && !t[qn] && !n[qn];
     }
     query(t = []) {
         const {
             interpolate: n,
-            pad: i,
-            channels: r,
+            pad: r,
+            channels: i,
             densityMap: s,
             source: o
-        } = this, [a, c] = this.extentX = Gf(this, t), [l, u] = this.extentY = Xf(this, t), [f, h] = this.bins = this.binDimensions(this), [d, p] = Qs(this, "x", f, [a, c], i), [m, g] = Qs(this, "y", h, [l, u], i), y = i ? [Tn(p, [+a, +c]), Tn(g, [+l, +u])] : [Nu(+a, p), Du(p, +c), Nu(+l, g), Du(g, +u)], b = Lt.from(o.table).where(t.concat(y)), w = this.groupby = [], v = {};
-        for (const _ of r)
+        } = this, [a, c] = this.extentX = Fu(this, t), [u, l] = this.extentY = Bu(this, t), [f, h] = this.bins = this.binDimensions(), [d, p] = Wi(this, "x", f, [a, c], r), [y, m] = Wi(this, "y", h, [u, l], r), g = r ? [$n(p, [+a, +c]), $n(m, [+u, +l])] : [Ac(+a, p), Mc(p, +c), Ac(+u, m), Mc(m, +l)], b = xt.from(o.table).where(t.concat(g)), w = this.groupby = [], v = {};
+        for (const _ of i)
             if (Object.hasOwn(_, "field")) {
                 const {
-                    as: I,
-                    channel: A,
-                    field: M
+                    as: M,
+                    channel: T,
+                    field: $
                 } = _;
-                M.aggregate ? (v[A] = M, s[A] = !0) : A === "weight" ? v[Fs] = oa(M) : A !== "x" && A !== "y" && (b.select({
-                    [I]: M
-                }), w.push(I));
+                $.aggregate ? (v[T] = $, s[T] = !0) : T === "weight" ? v[Ii] = Cs($) : T !== "x" && T !== "y" && (b.select({
+                    [M]: $
+                }), w.push(M));
             }
         const x = this.aggr = Object.keys(v);
         if (v.density && x.length > 1)
             throw new Error("Weight option can not be used with custom aggregates.");
-        if (x.length || (x.push(Fs), v.density = ko()), n === "linear") {
+        if (x.length || (x.push(Ii), v.density = Di()), n === "linear") {
             if (x.length > 1)
                 throw new Error("Linear binning not applicable to multiple aggregates.");
             if (!v.density)
                 throw new Error("Linear binning not applicable to custom aggregates.");
-            return _it(b, d, m, v[Fs], f, w);
+            return gZ(b, d, y, v[Ii], f, w);
         } else
-            return vit(b, d, m, v, f, w);
+            return mZ(b, d, y, v, f, w);
     }
+    /**
+     * @returns {[number, number]} The bin dimensions.
+     */
     binDimensions() {
         const {
             plot: t,
             pixelSize: n,
-            width: i,
-            height: r
+            width: r,
+            height: i
         } = this;
         return [
-            i ?? Math.round(t.innerWidth() / n),
-            r ?? Math.round(t.innerHeight() / n)
+            r ?? Math.round(t.innerWidth() / n),
+            i ?? Math.round(t.innerHeight() / n)
         ];
     }
     queryResult(t) {
-        const [n, i] = this.bins, r = wit(this.interpolate);
-        return this.grids = nit(n, i, t, this.aggr, this.groupby, r), this.convolve();
+        const [n, r] = this.bins, i = yZ(this.interpolate), {
+            columns: s
+        } = ca(t);
+        return this.grids0 = uZ(n, r, s.index, s, this.aggr, this.groupby, i), this.convolve();
     }
     convolve() {
         const {
             aggr: t,
             bandwidth: n,
-            bins: i,
-            grids: r,
+            bins: r,
+            grids0: i,
             plot: s
         } = this;
-        if (this.kde = this.grids, n > 0) {
-            const o = t.length === 1 ? t[0] : t.includes(Fs) ? Fs : null;
+        if (this.grids = i, n > 0) {
+            const o = t.length === 1 ? t[0] : t.includes(Ii) ? Ii : null;
             if (!o)
                 return console.warn("No compatible grid found for smoothing."), this;
-            const a = s.innerWidth(),
-                c = s.innerHeight(),
-                [l, u] = i,
-                f = r.some((p) => p[o].some((m) => m < 0)),
-                h = X1(n * (l - 1) / a, f),
-                d = X1(n * (u - 1) / c, f);
-            this.kde = this.grids.map((p) => {
-                const m = sit(h, d, p[o], i);
-                return {
-                    ...p,
-                    [o]: m
-                };
-            });
+            const a = i.columns[o],
+                c = s.innerWidth(),
+                u = s.innerHeight(),
+                [l, f] = r,
+                h = a.some((y) => y.some((m) => m < 0)),
+                d = Fy(n * (l - 1) / c, h),
+                p = Fy(n * (f - 1) / u, h);
+            this.grids = {
+                numRows: i.numRows,
+                columns: {
+                    ...i.columns,
+                    // @ts-ignore
+                    [o]: a.map((y) => hZ(d, p, y, r))
+                }
+            };
         }
         return this;
     }
-    plotSpecs() {
-        throw new Error("Unimplemented. Use a Grid2D mark subclass.");
-    }
 }
 
-function bit(e) {
+function pZ(e) {
     const t = {};
     for (const n in e)
         e[n] === "density" && (delete e[n], t[n] = !0);
     return t;
 }
 
-function wit(e = "none") {
+function yZ(e = "none") {
     if (typeof e == "function")
         return e;
-    switch (`${e}`.toLowerCase()) {
+    switch (e.toLowerCase()) {
         case "none":
         case "linear":
             return;
         case "nearest":
-            return fit;
+            return a1;
         case "barycentric":
-            return ait();
+            return o1();
         case "random-walk":
-            return hit();
+            return c1();
     }
     throw new Error(`invalid interpolate: ${e}`);
 }
 
-function vit(e, t, n, i, r, s) {
+function mZ(e, t, n, r, i, s) {
     return e.select({
-        index: q`FLOOR(${t})::INTEGER + FLOOR(${n})::INTEGER * ${r}`,
-        ...i
+        index: j`FLOOR(${t})::INTEGER + FLOOR(${n})::INTEGER * ${i}`,
+        ...r
     }).groupby("index", s);
 }
 
-function _it(e, t, n, i, r, s) {
-    const o = i != null && i.column ? `* ${i.column}` : "",
+function gZ(e, t, n, r, i, s) {
+    const o = r != null && r.column ? `* ${r.column}` : "",
         a = (h, d) => e.clone().select({
             xp: t,
             yp: n,
             i: h,
             w: d
         }),
         c = a(
-            q`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${r}`,
-            q`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
-        ),
-        l = a(
-            q`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${r}`,
-            q`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${o}`
+            j`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${i}`,
+            j`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
         ),
         u = a(
-            q`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${r}`,
-            q`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
+            j`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${i}`,
+            j`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${o}`
+        ),
+        l = a(
+            j`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${i}`,
+            j`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
         ),
         f = a(
-            q`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${r}`,
-            q`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${o}`
+            j`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${i}`,
+            j`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${o}`
         );
-    return Lt.from(Lt.unionAll(c, l, u, f)).select({
+    return xt.from(xt.unionAll(c, u, l, f)).select({
         index: "i",
-        density: oa("w")
-    }, s).groupby("index", s).having(Eb("density", 0));
+        density: Cs("w")
+    }, s).groupby("index", s).having(pm("density", 0));
 }
-class xit extends W0 {
+class bZ extends Vd {
     constructor(t, n) {
         const {
-            thresholds: i = 10,
-            ...r
+            thresholds: r = 10,
+            ...i
         } = n;
         super("geo", t, {
             bandwidth: 20,
             interpolate: "linear",
             pixelSize: 2,
-            ...r
-        }), Kn(this, "thresholds", i, () => this.grids ? this.contours().update() : null);
+            ...i
+        }), this.thresholds = Ge(r, (s) => (this.thresholds = s, this.grids ? this.contours().update() : null));
     }
     convolve() {
         return super.convolve().contours();
     }
     contours() {
         const {
             bins: t,
             densityMap: n,
-            kde: i,
-            thresholds: r,
+            grids: r,
+            thresholds: i,
             plot: s
-        } = this;
-        let o = r;
-        if (!Array.isArray(o)) {
-            const [, v] = Uv(i, "density");
-            o = Array.from({
-                length: o - 1
-            }, (x, _) => v * (_ + 1) / o);
+        } = this, {
+            numRows: o,
+            columns: a
+        } = r;
+        let c = i,
+            u;
+        if (Array.isArray(c))
+            u = c;
+        else {
+            const [, A] = x1(a.density);
+            u = Array.from({
+                length: c - 1
+            }, (D, R) => A * (R + 1) / c);
         }
         (n.fill || n.stroke) && this.plot.getAttribute("colorScale") !== "log" && this.plot.setAttribute("colorZero", !0);
-        const [a, c] = t, [l, u] = s.getAttribute("xDomain"), [f, h] = s.getAttribute("yDomain"), d = (u - l) / a, p = (h - f) / c, m = +l, g = +f, y = (v) => m + v * d, b = (v) => g + v * p, w = rp().size(t);
-        return this.data = i.flatMap((v) => o.map((x) => Object.assign(
-            Sit(w.contour(v.density, x), y, b), {
-                ...v,
-                density: x
-            }
-        ))), this;
+        const [l, f] = t, [h, d] = s.getAttribute("xDomain"), [p, y] = s.getAttribute("yDomain"), m = (d - h) / l, g = (y - p) / f, b = +h, w = +p, v = (A) => b + A * m, x = (A) => w + A * g, _ = Df().size(t), M = this.contourData = Array(o * u.length), {
+            density: T,
+            ...$
+        } = a, N = Object.entries($);
+        for (let A = 0, D = 0; A < o; ++A) {
+            const R = T[A],
+                S = N.reduce((I, [E, k]) => (I[E] = k[A], I), {});
+            for (let I = 0; I < u.length; ++I, ++D)
+                M[D] = Object.assign(
+                    wZ(_.contour(R, u[I]), v, x),
+                    S
+                );
+        }
+        return this;
     }
     plotSpecs() {
         const {
             type: t,
             channels: n,
-            densityMap: i,
-            data: r
+            densityMap: r,
+            contourData: i
         } = this, s = {};
         for (const o of n) {
             const {
                 channel: a
             } = o;
-            a !== "x" && a !== "y" && (s[a] = Cs(o));
+            a !== "x" && a !== "y" && (s[a] = gn(o));
         }
-        return i.fill && (s.fill = "density"), i.stroke && (s.stroke = "density"), [{
+        for (const o in r)
+            r[o] && (s[o] = gn({
+                channel: o,
+                as: "value"
+            }));
+        return [{
             type: t,
-            data: r,
+            data: i,
             options: s
         }];
     }
 }
 
-function Sit(e, t, n) {
-    function i(o) {
-        o.forEach(r);
+function wZ(e, t, n) {
+    function r(o) {
+        o.forEach(i);
     }
 
-    function r(o) {
+    function i(o) {
         o.forEach(s);
     }
 
     function s(o) {
         o[0] = t(o[0]), o[1] = n(o[1]);
     }
-    return e.coordinates.forEach(i), e;
+    return e.coordinates.forEach(r), e;
+}
+
+function S1(e) {
+    return Array.from({
+        length: e
+    }, (t, n) => n);
 }
 
-function RN(e, t) {
+function I8(e, t) {
+    const n = t.reduce((i, s, o) => (i[s] = o, i), {}),
+        r = S1(e.length);
+    return r.sort((i, s) => n[e[i]] - n[e[s]]), r;
+}
+
+function T8(e, t) {
     if (typeof document < "u") {
         const n = document.createElement("canvas");
         return n.setAttribute("width", e), n.setAttribute("height", t), n;
     }
     throw new Error("Can not create a canvas instance.");
 }
 
-function Iit(e = 1) {
+function vZ(e = 1) {
     const t = 255 * e | 0;
-    return (n, i, r) => {
-        for (let s = 0, o = 0; s < r; ++s)
-            for (let a = 0; a < i; ++a, o += 4)
+    return (n, r, i) => {
+        for (let s = 0, o = 0; s < i; ++s)
+            for (let a = 0; a < r; ++a, o += 4)
                 n[o + 3] = t;
     };
 }
 
-function Ait(e) {
+function _Z(e) {
     const {
         apply: t
     } = e;
-    return (n, i, r, s) => {
-        for (let o = 0, a = 0; o < r; ++o)
-            for (let c = 0, l = (r - o - 1) * i; c < i; ++c, a += 4)
-                n[a + 3] = 255 * t(s[c + l]) | 0;
+    return (n, r, i, s) => {
+        for (let o = 0, a = 0; o < i; ++o)
+            for (let c = 0, u = (i - o - 1) * r; c < r; ++c, a += 4)
+                n[a + 3] = 255 * t(s[c + u]) | 0;
     };
 }
 
-function Mit(e = {}) {
+function xZ(e = {}) {
     const {
         r: t = 0,
         g: n = 0,
-        b: i = 0,
-        opacity: r = 1
-    } = typeof e == "string" ? Pn(e) : e, s = new Uint8ClampedArray([t, n, i, 255 * r | 0]);
+        b: r = 0,
+        opacity: i = 1
+    } = typeof e == "string" ? un(e) : e, s = new Uint8ClampedArray([t, n, r, 255 * i | 0]);
     return (o, a, c) => {
-        for (let l = 0, u = 0; l < c; ++l)
-            for (let f = 0; f < a; ++f, u += 4)
-                o[u + 0] = s[0], o[u + 1] = s[1], o[u + 2] = s[2], o[u + 3] = s[3];
+        for (let u = 0, l = 0; u < c; ++u)
+            for (let f = 0; f < a; ++f, l += 4)
+                o[l + 0] = s[0], o[l + 1] = s[1], o[l + 2] = s[2], o[l + 3] = s[3];
     };
 }
 
-function $it(e) {
+function SZ(e) {
     const {
         domain: t,
         range: n
-    } = e, i = /* @__PURE__ */ Object.create(null), r = new Uint8ClampedArray(4 * t.length), s = t.length - 1, o = n.length;
+    } = e, r = /* @__PURE__ */ Object.create(null), i = new Uint8ClampedArray(4 * t.length), s = t.length - 1, o = n.length;
     for (let a = 0; a <= s; ++a) {
         const c = n[a % o],
             {
-                r: l,
-                g: u,
+                r: u,
+                g: l,
                 b: f,
                 opacity: h = 1
-            } = typeof c == "string" ? Pn(c) : c,
+            } = typeof c == "string" ? un(c) : c,
             d = a << 2;
-        r[d + 0] = l, r[d + 1] = u, r[d + 2] = f, r[d + 3] = 255 * h | 0, i[t[a]] = d;
+        i[d + 0] = u, i[d + 1] = l, i[d + 2] = f, i[d + 3] = 255 * h | 0, r[t[a]] = d;
     }
-    return (a, c, l, u) => {
-        if (u.map)
-            for (let f = 0, h = 0; f < l; ++f)
-                for (let d = 0, p = (l - f - 1) * c; d < c; ++d, h += 4) {
-                    const m = i[u[d + p]];
-                    a[h + 0] = r[m + 0], a[h + 1] = r[m + 1], a[h + 2] = r[m + 2], a[h + 3] = r[m + 3];
+    return (a, c, u, l) => {
+        if (l.map)
+            for (let f = 0, h = 0; f < u; ++f)
+                for (let d = 0, p = (u - f - 1) * c; d < c; ++d, h += 4) {
+                    const y = r[l[d + p]];
+                    a[h + 0] = i[y + 0], a[h + 1] = i[y + 1], a[h + 2] = i[y + 2], a[h + 3] = i[y + 3];
                 }
         else {
-            const f = i[u];
-            for (let h = 0, d = 0; h < l; ++h)
+            const f = r[l];
+            for (let h = 0, d = 0; h < u; ++h)
                 for (let p = 0; p < c; ++p, d += 4)
-                    a[d + 0] = r[f + 0], a[d + 1] = r[f + 1], a[d + 2] = r[f + 2], a[d + 3] = r[f + 3];
+                    a[d + 0] = i[f + 0], a[d + 1] = i[f + 1], a[d + 2] = i[f + 2], a[d + 3] = i[f + 3];
         }
     };
 }
 
-function Tit(e, t, n) {
+function MZ(e, t, n) {
     const {
-        interpolate: i
-    } = t, r = new Uint8ClampedArray(4 * e), s = e - 1;
+        interpolate: r
+    } = t, i = new Uint8ClampedArray(4 * e), s = e - 1;
     for (let o = 0; o <= s; ++o) {
-        const a = i(o / s),
+        const a = r(o / s),
             {
                 r: c,
-                g: l,
-                b: u,
+                g: u,
+                b: l,
                 opacity: f = 1
-            } = typeof a == "string" ? Pn(a) : a,
+            } = typeof a == "string" ? un(a) : a,
             h = o << 2;
-        r[h + 0] = c, r[h + 1] = l, r[h + 2] = u, r[h + 3] = 255 * f | 0;
+        i[h + 0] = c, i[h + 1] = u, i[h + 2] = l, i[h + 3] = 255 * f | 0;
     }
-    return (o, a, c, l) => {
-        for (let u = 0, f = 0; u < c; ++u)
-            for (let h = 0, d = (c - u - 1) * a; h < a; ++h, f += 4) {
-                const p = s * n(l[h + d]) << 2;
-                o[f + 0] = r[p + 0], o[f + 1] = r[p + 1], o[f + 2] = r[p + 2], o[f + 3] = r[p + 3];
+    return (o, a, c, u) => {
+        for (let l = 0, f = 0; l < c; ++l)
+            for (let h = 0, d = (c - l - 1) * a; h < a; ++h, f += 4) {
+                const p = s * n(u[h + d]) << 2;
+                o[f + 0] = i[p + 0], o[f + 1] = i[p + 1], o[f + 2] = i[p + 2], o[f + 3] = i[p + 3];
             }
     };
 }
-class zv extends W0 {
+class M1 extends Vd {
     constructor(t, n) {
-        super("image", t, n);
+        super("image", t, n), this.image = null;
     }
     setPlot(t, n) {
-        const i = () => {
+        const r = () => {
             this.hasFieldInfo() && this.rasterize();
         };
-        t.addAttributeListener("schemeColor", i), super.setPlot(t, n);
+        t.addAttributeListener("schemeColor", r), super.setPlot(t, n);
     }
     convolve() {
         return super.convolve().rasterize();
     }
     rasterize() {
+        var g;
         const {
             bins: t,
-            kde: n
-        } = this, [i, r] = t, {
-            canvas: s,
-            ctx: o,
-            img: a
-        } = Fit(this, i, r), {
-            alpha: c,
-            alphaProp: l,
-            color: u,
-            colorProp: f
-        } = CN(this);
-        return this.data = n.map((h) => (u == null || u(a.data, i, r, h[f]), c == null || c(a.data, i, r, h[l]), o.putImageData(a, 0, 0), {
-            src: s.toDataURL()
-        })), this;
+            grids: n
+        } = this, [r, i] = t, {
+            numRows: s,
+            columns: o
+        } = n, {
+            canvas: a,
+            ctx: c,
+            img: u
+        } = EZ(this, r, i), {
+            alpha: l,
+            alphaProp: f,
+            color: h,
+            colorProp: d
+        } = E8(this), p = o[f] ?? [], y = o[d] ?? [], m = s > 1 && d && ((g = this.groupby) != null && g.includes(d)) ? I8(y, this.plot.getAttribute("colorDomain")) : S1(s);
+        return this.data = {
+            numRows: s,
+            columns: {
+                src: Array.from({
+                    length: s
+                }, (b, w) => (h == null || h(u.data, r, i, y[m[w]]), l == null || l(u.data, r, i, p[m[w]]), c.putImageData(u, 0, 0), a.toDataURL()))
+            }
+        }, this;
     }
     plotSpecs() {
-        var s;
+        var o;
         const {
             type: t,
             plot: n,
-            data: i
-        } = this, r = {
-            src: "src",
+            data: {
+                numRows: r,
+                columns: i
+            }
+        } = this, s = {
+            src: i.src,
             width: n.innerWidth(),
             height: n.innerHeight(),
             preserveAspectRatio: "none",
-            imageRendering: (s = this.channel("imageRendering")) == null ? void 0 : s.value,
+            imageRendering: (o = this.channel("imageRendering")) == null ? void 0 : o.value,
             frameAnchor: "middle"
         };
         return [{
             type: t,
-            data: i,
-            options: r
+            data: {
+                length: r
+            },
+            options: s
         }];
     }
 }
-class Dit extends zv {
+class AZ extends M1 {
     constructor(t, n) {
         super(t, {
             bandwidth: 20,
             interpolate: "linear",
             pixelSize: 2,
             ...n
         });
     }
 }
 
-function CN(e) {
+function E8(e) {
     const {
         aggr: t,
         densityMap: n,
-        groupby: i,
-        plot: r
-    } = e, s = t.includes(Fs), o = t.includes("fillOpacity"), a = e.channel("fill"), c = e.channel("fillOpacity");
+        groupby: r,
+        plot: i
+    } = e, s = t.includes(Ii), o = t.includes("fillOpacity"), a = e.channel("fill"), c = e.channel("fillOpacity");
     if (t.length > 2 || s && o)
         throw new Error("Invalid raster encodings. Try dropping an aggregate?");
-    if (i.includes(c == null ? void 0 : c.as))
+    if (r.includes(c == null ? void 0 : c.as))
         throw new Error("Raster fillOpacity must be an aggregate or constant.");
-    const l = n.fill || t.includes("fill") ? "grid" : i.includes(a == null ? void 0 : a.as) ? "group" : MN(a == null ? void 0 : a.value) ? a.value : s && r.getAttribute("colorScheme") ? "grid" : void 0,
-        u = n.fillOpacity || t.includes("fillOpacity") ? "grid" : typeof(c == null ? void 0 : c.value) == "number" ? c.value : s && l !== "grid" ? "grid" : void 0;
-    if (l !== "grid" && u !== "grid")
+    const u = n.fill || t.includes("fill") ? "grid" : r.includes(a == null ? void 0 : a.as) ? "group" : b8(a == null ? void 0 : a.value) ? a.value : s && i.getAttribute("colorScheme") ? "grid" : void 0,
+        l = n.fillOpacity || t.includes("fillOpacity") ? "grid" : typeof(c == null ? void 0 : c.value) == "number" ? c.value : s && u !== "grid" ? "grid" : void 0;
+    if (u !== "grid" && l !== "grid")
         throw new Error("Raster mark missing density values.");
-    const f = (a == null ? void 0 : a.as) ?? (l === "grid" ? Fs : null),
-        h = (c == null ? void 0 : c.as) ?? (u === "grid" ? Fs : null),
-        d = l !== "grid" && l !== "group" ? Mit(l) : Bit(e, f),
-        p = u !== "grid" ? Iit(u) : Nit(e, h);
+    const f = (a == null ? void 0 : a.as) ?? (u === "grid" ? Ii : null),
+        h = (c == null ? void 0 : c.as) ?? (l === "grid" ? Ii : null),
+        d = u !== "grid" && u !== "group" ? xZ(u) : IZ(e, f),
+        p = l !== "grid" ? vZ(l) : $Z(e, h);
     return {
         alphaProp: h,
         colorProp: f,
         alpha: p,
         color: d
     };
 }
 
-function Nit(e, t) {
+function $Z(e, t) {
     const {
         plot: n,
-        kde: i
-    } = e, r = n.getAttribute("opacityDomain"), s = r === mf, o = r == null ? void 0 : r[Mi], a = !s && !o && r || Uv(i, t);
-    (s || o) && (o && (a[Mi] = !0), n.setAttribute("colorDomain", a));
-    const c = Vp({
+        grids: r
+    } = e, i = n.getAttribute("opacityDomain"), s = i === ou, o = i == null ? void 0 : i[qn], a = !s && !o && i || x1(r.columns[t]);
+    (s || o || !i) && (s || (a[qn] = !0), n.setAttribute("opacityDomain", a));
+    const c = Xc({
         opacity: {
             type: n.getAttribute("opacityScale"),
             domain: a,
             clamp: n.getAttribute("opacityClamp"),
             nice: n.getAttribute("opacityNice"),
             reverse: n.getAttribute("opacityReverse"),
             zero: n.getAttribute("opacityZero"),
             base: n.getAttribute("opacityBase"),
             exponent: n.getAttribute("opacityExponent"),
             constant: n.getAttribute("opacityConstant")
         }
     });
-    return Ait(c);
+    return _Z(c);
 }
 
-function Bit(e, t) {
-    var f;
+function IZ(e, t) {
+    var h;
     const {
         plot: n,
-        kde: i
-    } = e, r = !((f = i[0][t]) != null && f.map), s = r || Array.isArray(i[0][t]), o = n.getAttribute("colorDomain"), a = o === mf, c = o == null ? void 0 : o[Mi], l = !a && !c && o || (r ? i.map((h) => h[t]).sort(me) : s ? iit(i, t) : Uv(i, t));
-    (a || c) && (c && (l[Mi] = !0), n.setAttribute("colorDomain", l));
-    const u = Vp({
+        grids: r
+    } = e, i = r.columns[t], s = !((h = i[0]) != null && h.map), o = s || Array.isArray(i[0]), a = n.getAttribute("colorDomain"), c = a === ou, u = a == null ? void 0 : a[qn], l = !c && !u && a || (s ? i.slice().sort(zt) : o ? lZ(i) : x1(i));
+    (c || u || !a) && (c || (l[qn] = !0), n.setAttribute("colorDomain", l));
+    const f = Xc({
         color: {
             type: n.getAttribute("colorScale"),
             domain: l,
             range: n.getAttribute("colorRange"),
             clamp: n.getAttribute("colorClamp"),
             n: n.getAttribute("colorN"),
             nice: n.getAttribute("colorNice"),
@@ -38226,1035 +38737,1177 @@
             symmetric: n.getAttribute("colorSymmetric"),
             zero: n.getAttribute("colorZero"),
             base: n.getAttribute("colorBase"),
             exponent: n.getAttribute("colorExponent"),
             constant: n.getAttribute("colorConstant")
         }
     });
-    if (s)
-        return $it(u);
+    if (o)
+        return SZ(f);
     {
-        const h = Vp({
+        const d = Xc({
             x: {
-                type: Oit(u.type),
-                domain: u.domain,
-                reverse: u.reverse,
+                type: TZ(f.type),
+                domain: f.domain,
+                reverse: f.reverse,
                 range: [0, 1],
-                clamp: u.clamp,
-                base: u.base,
-                exponent: u.exponent,
-                constant: u.constant
+                clamp: f.clamp,
+                base: f.base,
+                exponent: f.exponent,
+                constant: f.constant
             }
         });
-        return Tit(1024, u, h.apply);
+        return MZ(1024, f, d.apply);
     }
 }
 
-function Oit(e) {
+function TZ(e) {
     return e.endsWith("symlog") ? "symlog" : e.endsWith("log") ? "log" : e.endsWith("pow") ? "pow" : e.endsWith("sqrt") ? "sqrt" : e === "diverging" ? "linear" : e;
 }
 
-function Fit(e, t, n) {
+function EZ(e, t, n) {
     if (!e.image || e.image.w !== t || e.image.h !== n) {
-        const i = RN(t, n),
-            r = i.getContext("2d", {
+        const r = T8(t, n),
+            i = r.getContext("2d", {
                 willReadFrequently: !0
             }),
-            s = r.getImageData(0, 0, t, n);
+            s = i.getImageData(0, 0, t, n);
         e.image = {
-            canvas: i,
-            ctx: r,
+            canvas: r,
+            ctx: i,
             img: s,
             w: t,
             h: n
         };
     }
     return e.image;
 }
-class Eit extends zv {
+class NZ extends M1 {
     constructor(t, n) {
         const {
-            normalize: i = !0,
-            ...r
+            normalize: r = !0,
+            ...i
         } = n;
-        super(t, r), Kn(this, "normalize", i);
+        super(t, i), this.normalize = Ge(r, (s) => (this.normalize = s, this.requestUpdate()));
     }
     query(t = []) {
         const {
             channels: n,
-            normalize: i,
-            source: r,
-            binPad: s
-        } = this, [o, a] = this.bins = this.binDimensions(this), [c] = Qs(this, "x", o, Gf(this, t), s), [l] = Qs(this, "y", a, Xf(this, t), s), u = Lt.from(r.table).where(Lit(this, t));
+            normalize: r,
+            source: i,
+            pad: s
+        } = this, [o, a] = this.bins = this.binDimensions(), [c] = Wi(this, "x", o, Fu(this, t), s), [u] = Wi(this, "y", a, Bu(this, t), s), l = xt.from(i.table).where(DZ(this, t));
         this.aggr = ["density"];
         const f = this.groupby = [],
             h = [];
         for (const d of n)
             if (Object.hasOwn(d, "field")) {
                 const {
                     channel: p,
-                    field: m
+                    field: y
                 } = d;
-                p === "z" ? (u.select({
-                    [p]: m
-                }), h.push("z")) : p !== "x" && p !== "y" && (u.select({
-                    [p]: m
+                p === "z" ? (l.select({
+                    [p]: y
+                }), h.push("z")) : p !== "x" && p !== "y" && (l.select({
+                    [p]: y
                 }), f.push(p));
             }
-        return Rit(u, c, l, h, o, a, f, i);
+        return OZ(l, c, u, h, o, a, f, r);
     }
 }
 
-function Lit(e, t) {
+function DZ(e, t) {
     if (Array.isArray(t) && !t.length)
         return t;
     const {
         column: n
     } = e.channelField("x"), {
-        column: i
-    } = e.channelField("y"), r = (o) => {
+        column: r
+    } = e.channelField("y"), i = (o) => {
         const a = `${o.field}`;
-        return o.op !== "BETWEEN" || a !== n && a !== i;
-    }, s = (o) => o.op === "AND" ? qs(o.children.filter((a) => r(a))) : o;
-    return Array.isArray(t) ? t.filter((o) => r(o)).map((o) => s(o)) : s(t);
+        return o.op !== "BETWEEN" || a !== n && a !== r;
+    }, s = (o) => o.op === "AND" ? Bi(o.children.filter((a) => i(a))) : o;
+    return Array.isArray(t) ? t.filter((o) => i(o)).map((o) => s(o)) : s(t);
 }
 
-function Rit(e, t, n, i, r, s, o = [], a = !0) {
+function OZ(e, t, n, r, i, s, o = [], a = !0) {
     e.select({
-        x: q`FLOOR(${t})::INTEGER`,
-        y: q`FLOOR(${n})::INTEGER`
+        x: j`FLOOR(${t})::INTEGER`,
+        y: j`FLOOR(${n})::INTEGER`
     });
-    const c = o.concat(i),
-        l = c.length ? `PARTITION BY ${c.join(", ")} ` : "",
-        u = Lt.from(e).select(c, {
+    const c = o.concat(r),
+        u = c.length ? `PARTITION BY ${c.join(", ")} ` : "",
+        l = xt.from(e).select(c, {
             x0: "x",
             y0: "y",
-            dx: q`(lead(x) OVER sw - x)`,
-            dy: q`(lead(y) OVER sw - y)`
+            dx: j`(lead(x) OVER sw - x)`,
+            dy: j`(lead(y) OVER sw - y)`
         }).window({
-            sw: q`${l}ORDER BY x ASC`
-        }).qualify(qs(
-            q`(x0 < ${r} OR x0 + dx < ${r})`,
-            q`(y0 < ${s} OR y0 + dy < ${s})`,
-            q`(x0 > 0 OR x0 + dx > 0)`,
-            q`(y0 > 0 OR y0 + dy > 0)`
+            sw: j`${u}ORDER BY x ASC`
+        }).qualify(Bi(
+            j`(x0 < ${i} OR x0 + dx < ${i})`,
+            j`(y0 < ${s} OR y0 + dy < ${s})`,
+            j`(x0 > 0 OR x0 + dx > 0)`,
+            j`(y0 > 0 OR y0 + dy > 0)`
         )),
-        f = Lt.select({
-            x: q`GREATEST(MAX(ABS(dx)), MAX(ABS(dy)))`
+        f = xt.select({
+            x: j`GREATEST(MAX(ABS(dx)), MAX(ABS(dy)))`
         }).from("pairs"),
-        h = Lt.select({
-            i: q`UNNEST(range((${f})))::INTEGER`
+        h = xt.select({
+            i: j`UNNEST(range((${f})))::INTEGER`
         }),
-        d = Lt.unionAll(
-            Lt.select(c, {
-                x: q`x0 + i`,
-                y: q`y0 + ROUND(i * dy / dx::FLOAT)::INTEGER`
-            }).from("pairs", "indices").where(q`ABS(dy) <= ABS(dx) AND i < ABS(dx)`),
-            Lt.select(c, {
-                x: q`x0 + ROUND(SIGN(dy) * i * dx / dy::FLOAT)::INTEGER`,
-                y: q`y0 + SIGN(dy) * i`
-            }).from("pairs", "indices").where(q`ABS(dy) > ABS(dx) AND i < ABS(dy)`),
-            Lt.select(c, {
+        d = xt.unionAll(
+            xt.select(c, {
+                x: j`x0 + i`,
+                y: j`y0 + ROUND(i * dy / dx::FLOAT)::INTEGER`
+            }).from("pairs", "indices").where(j`ABS(dy) <= ABS(dx) AND i < ABS(dx)`),
+            xt.select(c, {
+                x: j`x0 + ROUND(SIGN(dy) * i * dx / dy::FLOAT)::INTEGER`,
+                y: j`y0 + SIGN(dy) * i`
+            }).from("pairs", "indices").where(j`ABS(dy) > ABS(dx) AND i < ABS(dy)`),
+            xt.select(c, {
                 x: "x0",
                 y: "y0"
-            }).from("pairs").where(Fb("dx"))
+            }).from("pairs").where(dm("dx"))
         ),
         p = ["x"].concat(c).join(", "),
-        m = Lt.from("raster").select(
+        y = xt.from("raster").select(
             c,
             "x",
             "y",
             a ? {
-                w: q`1.0 / COUNT(*) OVER (PARTITION BY ${p})`
+                w: j`1.0 / COUNT(*) OVER (PARTITION BY ${p})`
             } : null
-        ).where(qs(Tn("x", [0, r], !0), Tn("y", [0, s], !0)));
-    return Lt.with({
-        pairs: u,
+        ).where(Bi($n("x", [0, i], !0), $n("y", [0, s], !0)));
+    return xt.with({
+        pairs: l,
         indices: h,
         raster: d,
-        points: m
+        points: y
     }).from("points").select(o, {
-        index: q`x + y * ${r}::INTEGER`,
-        density: a ? oa("w") : ko()
+        index: j`x + y * ${i}::INTEGER`,
+        density: a ? Cs("w") : Di()
     }).groupby("index", o);
 }
-class kN extends ha {
-    constructor(t, n, i) {
+class N8 extends rs {
+    constructor(t, n, r) {
         const {
-            bins: r = 1024,
+            bins: i = 1024,
             bandwidth: s = 20,
             ...o
-        } = i, a = t.endsWith("X") ? "y" : "x";
-        super(t, n, o, a === "x" ? NN : BN), this.dim = a, Kn(this, "bins", r), Kn(this, "bandwidth", s, () => this.grid ? this.convolve().update() : null);
+        } = r, a = t.endsWith("X") ? "y" : "x";
+        super(t, n, o, a === "x" ? _8 : x8), this.dim = a, this.bins = Ge(i, (c) => (this.bins = c, this.requestUpdate())), this.bandwidth = Ge(s, (c) => (this.bandwidth = c, this.grid ? this.convolve().update() : null));
     }
     get filterIndexable() {
         const t = this.dim === "x" ? "xDomain" : "yDomain",
             n = this.plot.getAttribute(t);
-        return n && !n[Mi];
+        return n && !n[qn];
     }
     query(t = []) {
         if (this.hasOwnData())
             throw new Error("Density1DMark requires a data source");
         const {
             bins: n,
-            channels: i,
-            dim: r,
+            channels: r,
+            dim: i,
             source: {
                 table: s
             }
-        } = this, o = this.extent = (r === "x" ? Gf : Xf)(this, t), [a, c] = Qs(this, r, n, o), l = DN(i, s, [r]).where(t.concat(Tn(c, o))), u = this.channelField("weight") ? "weight" : null;
-        return Cit(l, a, u);
+        } = this, o = this.extent = (i === "x" ? Fu : Bu)(this, t), [a, c] = Wi(this, i, n, o), u = _1(r, s, [i]).where(t.concat($n(c, o))), l = this.channelField("weight") ? "weight" : null;
+        return LZ(u, a, l);
     }
     queryResult(t) {
-        return this.grid = eit(this.bins, t), this.convolve();
+        const {
+            columns: {
+                index: n,
+                density: r
+            }
+        } = ca(t);
+        return this.grid = cZ(this.bins, n, r), this.convolve();
     }
     convolve() {
         const {
             bins: t,
             bandwidth: n,
-            dim: i,
-            grid: r,
+            dim: r,
+            grid: i,
             plot: s,
             extent: [o, a]
-        } = this, c = r.some((b) => b < 0), l = i === "x" ? s.innerWidth() : s.innerHeight(), u = X1(n * (t - 1) / l, c), f = H1(u, r, t), h = this.data = [], d = i === "x" ? "y" : "x", p = this.channelField(i).as, m = +o, g = (a - m) / (t - 1), y = 1 / g;
-        for (let b = 0; b < t; ++b)
-            h.push({
-                [p]: m + b * g,
-                [d]: f[b] * y
-            });
-        return this;
+        } = this, c = i.some((w) => w < 0), u = r === "x" ? s.innerWidth() : s.innerHeight(), l = Fy(n * (t - 1) / u, c), f = By(l, i, t), h = r === "x" ? "y" : "x", d = this.channelField(r).as, p = +o, y = (a - p) / (t - 1), m = 1 / y, g = new Float64Array(t), b = new Float64Array(t);
+        for (let w = 0; w < t; ++w)
+            g[w] = p + w * y, b[w] = f[w] * m;
+        return this.data = {
+            numRows: t,
+            columns: {
+                [d]: g,
+                [h]: b
+            }
+        }, this;
     }
     plotSpecs() {
         const {
             type: t,
-            data: n,
+            data: {
+                numRows: n,
+                columns: r
+            },
             channels: i,
-            dim: r
-        } = this, s = r === "x" ? {
-            y: "y"
+            dim: s
+        } = this, o = s === "x" ? {
+            y: r.y
         } : {
-            x: "x"
+            x: r.x
         };
-        for (const o of i)
-            s[o.channel] = Cs(o);
+        for (const a of i)
+            o[a.channel] = gn(a, r);
         return [{
             type: t,
-            data: n,
-            options: s
+            data: {
+                length: n
+            },
+            options: o
         }];
     }
 }
 
-function Cit(e, t, n) {
-    const i = n ? `* ${n}` : "",
-        r = e.clone().select({
+function LZ(e, t, n) {
+    const r = n ? `* ${n}` : "",
+        i = e.clone().select({
             p: t,
-            i: q`FLOOR(p)::INTEGER`,
-            w: q`(FLOOR(p) + 1 - p)${i}`
+            i: j`FLOOR(p)::INTEGER`,
+            w: j`(FLOOR(p) + 1 - p)${r}`
         }),
         s = e.clone().select({
             p: t,
-            i: q`FLOOR(p)::INTEGER + 1`,
-            w: q`(p - FLOOR(p))${i}`
+            i: j`FLOOR(p)::INTEGER + 1`,
+            w: j`(p - FLOOR(p))${r}`
         });
-    return Lt.from(Lt.unionAll(r, s)).select({
+    return xt.from(xt.unionAll(i, s)).select({
         index: "i",
-        density: oa("w")
-    }).groupby("index").having(jM("density", 0));
+        density: Cs("w")
+    }).groupby("index").having(Ex("density", 0));
 }
-class kit extends W0 {
+class kZ extends Vd {
     constructor(t, n) {
         const {
-            type: i = "dot",
-            ...r
+            type: r = "dot",
+            ...i
         } = n;
-        super(i, t, {
+        super(r, t, {
             bandwidth: 20,
             interpolate: "linear",
             pad: 0,
             pixelSize: 2,
-            ...r
+            ...i
         });
     }
     convolve() {
         super.convolve();
         const {
             bins: t,
             pad: n,
-            extentX: i,
-            extentY: r
-        } = this, [s, o] = t, a = ny(this, "x"), c = ny(this, "y"), [l, u] = i.map((g) => a.apply(g)), [f, h] = r.map((g) => c.apply(g)), d = (u - l) / (s - n), p = (h - f) / (o - n), m = n ? 0 : 0.5;
-        return this.data = Uit(
-            this.kde,
+            extentX: r,
+            extentY: i
+        } = this, [s, o] = t, a = Ih(this, "x"), c = Ih(this, "y"), [u, l] = r.map((m) => a.apply(m)), [f, h] = i.map((m) => c.apply(m)), d = (l - u) / (s - n), p = (h - f) / (o - n), y = n ? 0 : 0.5;
+        return this.data = RZ(
+            this.grids,
             t,
-            l,
+            u,
             f,
             d,
             p,
             a.invert,
             c.invert,
-            m
+            y
         ), this;
     }
     plotSpecs() {
         const {
             type: t,
             channels: n,
-            densityMap: i,
-            data: r
-        } = this, s = {};
-        for (const o of n) {
+            densityMap: r,
+            data: {
+                numRows: i,
+                columns: s
+            }
+        } = this, o = {};
+        for (const a of n) {
             const {
-                channel: a
-            } = o;
-            s[a] = a === "x" || a === "y" ? a : Cs(o);
+                channel: c
+            } = a;
+            o[c] = c === "x" || c === "y" ? s[c] : gn(a, s);
         }
-        for (const o in i)
-            i[o] && (s[o] = "density");
+        for (const a in r)
+            r[a] && (o[a] = s.density);
         return [{
             type: t,
-            data: r,
-            options: s
+            data: {
+                length: i
+            },
+            options: o
         }];
     }
 }
 
-function Uit(e, t, n, i, r, s, o, a, c) {
-    const l = 1 / (r * s),
-        [u, f] = t,
-        h = [];
-    for (const d of e) {
-        const p = d.density;
-        for (let m = 0, g = 0; g < f; ++g)
-            for (let y = 0; y < u; ++y, ++m)
-                h.push({
-                    ...d,
-                    x: o(n + (y + c) * r),
-                    y: a(i + (g + c) * s),
-                    density: p[m] * l
-                });
+function RZ(e, t, n, r, i, s, o, a, c) {
+    const u = 1 / (i * s),
+        [l, f] = t,
+        h = l * f,
+        d = h * e.numRows,
+        p = new Float64Array(d),
+        y = new Float64Array(d),
+        m = new Float64Array(d),
+        g = {
+            x: p,
+            y,
+            density: m
+        },
+        {
+            density: b,
+            ...w
+        } = e.columns;
+    for (const x in w)
+        g[x] = new w[x].constructor(d);
+    let v = 0;
+    for (let x = 0; x < e.numRows; ++x) {
+        for (const M in w)
+            g[M].fill(w[M][x], v, v + h);
+        const _ = b[x];
+        for (let M = 0, T = 0; T < f; ++T)
+            for (let $ = 0; $ < l; ++$, ++v, ++M)
+                p[v] = o(n + ($ + c) * i), y[v] = a(r + (T + c) * s), m[v] = _[M] * u;
+    }
+    return {
+        numRows: d,
+        columns: g
+    };
+}
+
+function FZ(e, t, n) {
+    var r = 1e-8,
+        i = t - 1,
+        s = n - 1,
+        o = 0,
+        a, c, u, l, f, h, d, p, y, m, g;
+    if (e <= 0)
+        return 0;
+    if (e >= 1)
+        return 1;
+    for (t >= 1 && n >= 1 ? (u = e < 0.5 ? e : 1 - e, l = Math.sqrt(-2 * Math.log(u)), d = (2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l, e < 0.5 && (d = -d), p = (d * d - 3) / 6, y = 2 / (1 / (2 * t - 1) + 1 / (2 * n - 1)), m = d * Math.sqrt(p + y) / y - (1 / (2 * n - 1) - 1 / (2 * t - 1)) * (p + 5 / 6 - 2 / (3 * y)), d = t / (t + n * Math.exp(2 * m))) : (a = Math.log(t / (t + n)), c = Math.log(n / (t + n)), l = Math.exp(t * a) / t, f = Math.exp(n * c) / n, m = l + f, e < l / m ? d = Math.pow(t * m * e, 1 / t) : d = 1 - Math.pow(n * m * (1 - e), 1 / n)), g = -ko(t) - ko(n) + ko(t + n); o < 10; o++) {
+        if (d === 0 || d === 1)
+            return d;
+        if (h = BZ(d, t, n) - e, l = Math.exp(i * Math.log(d) + s * Math.log(1 - d) + g), f = h / l, d -= l = f / (1 - 0.5 * Math.min(1, f * (i / d - s / (1 - d)))), d <= 0 && (d = 0.5 * (d + l)), d >= 1 && (d = 0.5 * (d + l + 1)), Math.abs(l) < r * d && o > 0)
+            break;
     }
-    return h;
+    return d;
+}
+
+function BZ(e, t, n) {
+    var r = e === 0 || e === 1 ? 0 : Math.exp(ko(t + n) - ko(t) - ko(n) + t * Math.log(e) + n * Math.log(1 - e));
+    return e < 0 || e > 1 ? 0 : e < (t + 1) / (t + n + 2) ? r * fv(e, t, n) / t : 1 - r * fv(1 - e, n, t) / n;
+}
+
+function fv(e, t, n) {
+    var r = 1e-30,
+        i = 1,
+        s = t + n,
+        o = t + 1,
+        a = t - 1,
+        c = 1,
+        u = 1 - s * e / o,
+        l, f, h, d;
+    for (Math.abs(u) < r && (u = r), u = 1 / u, d = u; i <= 100 && (l = 2 * i, f = i * (n - i) * e / ((a + l) * (t + l)), u = 1 + f * u, Math.abs(u) < r && (u = r), c = 1 + f / c, Math.abs(c) < r && (c = r), u = 1 / u, d *= u * c, f = -(t + i) * (s + i) * e / ((t + l) * (o + l)), u = 1 + f * u, Math.abs(u) < r && (u = r), c = 1 + f / c, Math.abs(c) < r && (c = r), u = 1 / u, h = u * c, d *= h, !(Math.abs(h - 1) < 3e-7)); i++)
+    ;
+    return d;
+}
+
+function ko(e) {
+    var t = 0,
+        n = [
+            76.18009172947146,
+            -86.5053203294167,
+            24.01409824083091,
+            -1.231739572450155,
+            0.001208650973866179,
+            -5395239384953e-18
+        ],
+        r = 1.000000000190015,
+        i, s, o;
+    for (o = (s = i = e) + 5.5, o -= (i + 0.5) * Math.log(o); t < 6; t++)
+        r += n[t] / ++s;
+    return Math.log(2.506628274631 * r / i) - o;
+}
+
+function CZ(e, t) {
+    var n = FZ(2 * Math.min(e, 1 - e), 0.5 * t, 0.5);
+    return n = Math.sqrt(t * (1 - n) / n), e > 0.5 ? n : -n;
+}
+
+function PZ(e) {
+    let t = -Math.log((1 - e) * (1 + e)),
+        n;
+    return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = 18673420803405714e-20 + n * t, n = -740702534166267e-18 + n * t, n = -0.006033670871430149 + n * t, n = 0.24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -3550375203628475e-19 + n * t, n = 9532893797373805e-19 + n * t, n = -0.0016882755560235047 + n * t, n = 0.002491442096107851 + n * t, n = -0.003751208507569241 + n * t, n = 0.005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -21503011930044477e-20 + n * t, n = -13871931833623122e-20 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e;
 }
-const zit = "geom";
-class Pit extends ha {
-    constructor(t, n = {}, i) {
-        !G1(t) && !(n != null && n.geometry) && (n.geometry = WM(zit)), super("geo", t, n, i);
+class D8 extends rs {
+    constructor(t, n, r) {
+        const i = t.endsWith("X") ? "y" : "x",
+            {
+                ci: s = 0.95,
+                ...o
+            } = r;
+        super(t, n, o), this.dim = i, this.field = this.channelField(i).field, this.channels = this.channels.filter((a) => a.channel !== i), this.ci = Ge(s, (a) => (this.ci = a, this.update()));
+    }
+    query(t = []) {
+        const {
+            channels: n,
+            field: r,
+            source: {
+                table: i
+            }
+        } = this, s = n.concat([{
+            field: Dx(r),
+            as: "__avg__"
+        }, {
+            field: Di(r),
+            as: "__n__"
+        }, {
+            field: Ox(r),
+            as: "__sd__"
+        }]);
+        return _1(s, i).where(t);
     }
     queryResult(t) {
-        var i;
+        return this.data = ca(t), this;
+    }
+    plotSpecs() {
+        const {
+            type: t,
+            dim: n,
+            detail: r,
+            data: i,
+            ci: s,
+            channels: o
+        } = this, a = Math.SQRT2 * PZ(s), {
+            columns: {
+                __avg__: c,
+                __sd__: u,
+                __n__: l
+            }
+        } = i, f = {
+            [`${n}1`]: c.map((h, d) => h - a * u[d] / Math.sqrt(l[d])),
+            [`${n}2`]: c.map((h, d) => h + a * u[d] / Math.sqrt(l[d]))
+        };
+        return v8(t, r, o, i, f);
+    }
+}
+const UZ = "geom";
+class zZ extends rs {
+    constructor(t, n = {}, r) {
+        !Ry(t) && !(n != null && n.geometry) && (n.geometry = Lx(UZ)), super("geo", t, n, r);
+    }
+    queryResult(t) {
+        var r;
         super.queryResult(t);
-        const n = (i = this.channelField("geometry")) == null ? void 0 : i.as;
-        return n && this.data && this.data.forEach((r) => {
-            typeof r[n] == "string" && (r[n] = JSON.parse(r[n]));
-        }), this;
+        const n = (r = this.channelField("geometry")) == null ? void 0 : r.as;
+        if (n) {
+            const {
+                columns: i
+            } = this.data;
+            typeof i[n][0] == "string" && (i[n] = i[n].map((s) => JSON.parse(s)));
+        }
+        return this;
     }
 }
-class Vit extends ha {
+class qZ extends rs {
     constructor(t, n) {
         const {
-            type: i = "hexagon",
-            binWidth: r = 20,
+            type: r = "hexagon",
+            binWidth: i = 20,
             ...s
         } = n;
-        super(i, t, {
-            r: r / 2,
+        super(r, t, {
+            r: i / 2,
             clip: !0,
             ...s
-        }, ON), this.binWidth = r;
+        }, S8), this.binWidth = Ge(i, (o) => (this.binWidth = o, this.requestUpdate()));
     }
     get filterIndexable() {
         const t = this.plot.getAttribute("xDomain"),
             n = this.plot.getAttribute("yDomain");
-        return t && n && !t[Mi] && !n[Mi];
+        return t && n && !t[qn] && !n[qn];
     }
     query(t = []) {
         if (this.hasOwnData())
             return null;
         const {
             plot: n,
-            binWidth: i,
-            channels: r,
+            binWidth: r,
+            channels: i,
             source: s
-        } = this, [o, a] = Gf(this, t), [c, l] = Xf(this, t), u = 0.5 - n.getAttribute("marginLeft"), f = 0 - n.getAttribute("marginTop"), h = `${i}::DOUBLE`, d = `${i * (1.5 / Math.sqrt(3))}::DOUBLE`, p = `${n.innerWidth() / (a - o)}::DOUBLE`, m = `${n.innerHeight() / (l - c)}::DOUBLE`;
-        let g, y;
+        } = this, [o, a] = Fu(this, t), [c, u] = Bu(this, t), l = 0.5 - n.getAttribute("marginLeft"), f = 0 - n.getAttribute("marginTop"), h = `${r}::DOUBLE`, d = `${r * (1.5 / Math.sqrt(3))}::DOUBLE`, p = `${n.innerWidth() / (a - o)}::DOUBLE`, y = `${n.innerHeight() / (u - c)}::DOUBLE`;
+        let m, g;
         const b = /* @__PURE__ */ new Set(),
             w = {};
-        for (const A of r)
-            A.channel === "orderby" ? v.orderby(A.value) : A.channel === "x" ? g = A : A.channel === "y" ? y = A : Object.hasOwn(A, "field") && (w[A.as] = A.field, A.field.aggregate && A.field.columns.forEach((M) => b.add(M)));
-        const v = Lt.select({
-                [g.as]: q`${o}::DOUBLE + ((x + 0.5 * (y & 1)) * ${h} + ${u})::DOUBLE / ${p}`,
-                [y.as]: q`${l}::DOUBLE - (y * ${d} + ${f})::DOUBLE / ${m}`,
-                ...w
-            }).groupby("x", "y"),
-            x = `${p} * (${g.field} - ${o}::DOUBLE)`,
-            _ = `${m} * (${l}::DOUBLE - ${y.field})`,
-            I = Lt.select({
-                py: q`(${_} - ${f}) / ${d}`,
-                pj: q`ROUND(py)::INTEGER`,
-                px: q`(${x} - ${u}) / ${h} - 0.5 * (pj & 1)`,
-                pi: q`ROUND(px)::INTEGER`,
-                tt: q`ABS(py-pj) * 3 > 1 AND (px-pi)**2 + (py-pj)**2 > (px - pi - 0.5 * CASE WHEN px < pi THEN -1 ELSE 1 END)**2 + (py - pj - CASE WHEN py < pj THEN -1 ELSE 1 END)**2`,
-                x: q`CASE WHEN tt THEN (pi + (CASE WHEN px < pi THEN -0.5 ELSE 0.5 END) + (CASE WHEN pj & 1 <> 0 THEN 0.5 ELSE -0.5 END))::INTEGER ELSE pi END`,
-                y: q`CASE WHEN tt THEN (pj + CASE WHEN py < pj THEN -1 ELSE 1 END)::INTEGER ELSE pj END`
-            }).select(Array.from(b)).from(s.table).where(Tu(g.field), Tu(y.field), t);
-        return v.from(I);
+        let v;
+        for (const $ of i)
+            $.channel === "orderby" ? v = $.value : $.channel === "x" ? m = $ : $.channel === "y" ? g = $ : Object.hasOwn($, "field") && (w[$.as] = $.field, $.field.aggregate && $.field.columns.forEach((N) => b.add(N)));
+        const x = xt.select({
+            [m.as]: j`${o}::DOUBLE + ((x + 0.5 * (y & 1)) * ${h} + ${l})::DOUBLE / ${p}`,
+            [g.as]: j`${u}::DOUBLE - (y * ${d} + ${f})::DOUBLE / ${y}`,
+            ...w
+        }).groupby("x", "y");
+        v && x.orderby(v);
+        const _ = `${p} * (${m.field} - ${o}::DOUBLE)`,
+            M = `${y} * (${u}::DOUBLE - ${g.field})`,
+            T = xt.select({
+                py: j`(${M} - ${f}) / ${d}`,
+                pj: j`ROUND(py)::INTEGER`,
+                px: j`(${_} - ${l}) / ${h} - 0.5 * (pj & 1)`,
+                pi: j`ROUND(px)::INTEGER`,
+                tt: j`ABS(py-pj) * 3 > 1 AND (px-pi)**2 + (py-pj)**2 > (px - pi - 0.5 * CASE WHEN px < pi THEN -1 ELSE 1 END)**2 + (py - pj - CASE WHEN py < pj THEN -1 ELSE 1 END)**2`,
+                x: j`CASE WHEN tt THEN (pi + (CASE WHEN px < pi THEN -0.5 ELSE 0.5 END) + (CASE WHEN pj & 1 <> 0 THEN 0.5 ELSE -0.5 END))::INTEGER ELSE pi END`,
+                y: j`CASE WHEN tt THEN (pj + CASE WHEN py < pj THEN -1 ELSE 1 END)::INTEGER ELSE pj END`
+            }).select(Array.from(b)).from(s.table).where(Sc(m.field), Sc(g.field), t);
+        return x.from(T);
     }
 }
-class jit extends W0 {
+class jZ extends Vd {
     constructor(t, n) {
         const {
-            origin: i = [0, 0],
-            dim: r = "xy",
+            origin: r = [0, 0],
+            dim: i = "xy",
             ...s
         } = n;
-        super("image", t, s), this.origin = i, this.tileX = r.toLowerCase().includes("x"), this.tileY = r.toLowerCase().includes("y");
+        super("image", t, s), this.image = null, this.origin = r, this.tileX = i.toLowerCase().includes("x"), this.tileY = i.toLowerCase().includes("y");
     }
     setPlot(t, n) {
-        const i = () => {
+        const r = () => {
             this.hasFieldInfo() && this.rasterize();
         };
-        t.addAttributeListener("schemeColor", i), super.setPlot(t, n);
+        t.addAttributeListener("schemeColor", r), super.setPlot(t, n);
     }
     requestQuery() {
         return this.requestTiles();
     }
     query(t = []) {
         return this._filter = t, null;
     }
     tileQuery(t) {
         const {
-            binType: n,
-            binPad: i,
-            channels: r,
+            interpolate: n,
+            pad: r,
+            channels: i,
             densityMap: s,
             source: o
         } = this, [
             [a, c],
-            [l, u]
-        ] = t, [f, h] = this.bins, [d, p] = Qs(this, "x", f, [a, c], i), [m, g] = Qs(this, "y", h, [l, u], i), y = i ? [Tn(p, [+a, +c]), Tn(g, [+l, +u])] : [Nu(+a, p), Du(p, +c), Nu(+l, g), Du(g, +u)], b = Lt.from(o.table).where(y), w = this.groupby = [], v = {};
-        for (const _ of r)
+            [u, l]
+        ] = t, [f, h] = this.bins, [d, p] = Wi(this, "x", f, [a, c], r), [y, m] = Wi(this, "y", h, [u, l], r), g = r ? [$n(p, [+a, +c]), $n(m, [+u, +l])] : [Ac(+a, p), Mc(p, +c), Ac(+u, m), Mc(m, +l)], b = xt.from(o.table).where(g), w = this.groupby = [], v = {};
+        for (const _ of i)
             if (Object.hasOwn(_, "field")) {
                 const {
-                    as: I,
-                    channel: A,
-                    field: M
+                    as: M,
+                    channel: T,
+                    field: $
                 } = _;
-                M.aggregate ? (v[A] = M, s[A] = !0) : A === "weight" ? v.density = oa(M) : A !== "x" && A !== "y" && (b.select({
-                    [I]: M
-                }), w.push(I));
+                $.aggregate ? (v[T] = $, s[T] = !0) : T === "weight" ? v.density = Cs($) : T !== "x" && T !== "y" && (b.select({
+                    [M]: $
+                }), w.push(M));
             }
         const x = this.aggr = Object.keys(v);
         if (v.density && x.length > 1)
             throw new Error("Weight option can not be used with custom aggregates.");
-        if (x.length || (x.push("density"), v.density = ko()), n === "linear") {
+        if (x.length || (x.push("density"), v.density = Di()), n === "linear") {
             if (x.length > 1)
                 throw new Error("Linear binning not applicable to multiple aggregates.");
             if (!v.density)
                 throw new Error("Linear binning not applicable to custom aggregates.");
-            return Xit(b, d, m, v.density, f, w);
+            return GZ(b, d, y, v.density, f, w);
         } else
-            return Git(b, d, m, v, f, w);
+            return XZ(b, d, y, v, f, w);
     }
     async requestTiles() {
         const t = Wr();
         this.prefetch && t.cancel(this.prefetch);
         const {
-            binPad: n,
-            tileX: i,
-            tileY: r,
+            pad: n,
+            tileX: r,
+            tileY: i,
             origin: [s, o]
-        } = this, [a, c] = this.bins = this.binDimensions(this), [l, u] = Gf(this, this._filter), [f, h] = Xf(this, this._filter), d = u - l, p = h - f, m = Math.floor((l - s) * (a - n) / d), g = Math.floor((f - o) * (c - n) / p), y = (N, $) => [
-            [s + N * d, s + (N + 1) * d],
-            [o + $ * p, o + ($ + 1) * p]
-        ], b = Math.floor((l - s) / d), w = i ? JS((u - s) / d) : b, v = Math.floor((f - o) / p), x = r ? JS((h - o) / p) : v, _ = [];
-        for (let N = b; N <= w; ++N)
-            for (let $ = v; $ <= x; ++$)
-                _.push([N, $]);
-        const I = _.map(
-                ([N, $]) => t.query(this.tileQuery(y(N, $)))
+        } = this, [a, c] = this.bins = this.binDimensions(), [u, l] = Fu(this, this._filter), [f, h] = Bu(this, this._filter), d = l - u, p = h - f, y = Math.floor((u - s) * (a - n) / d), m = Math.floor((f - o) * (c - n) / p), g = (A, D) => [
+            [s + A * d, s + (A + 1) * d],
+            [o + D * p, o + (D + 1) * p]
+        ], b = Math.floor((u - s) / d), w = r ? hv((l - s) / d) : b, v = Math.floor((f - o) / p), x = i ? hv((h - o) / p) : v, _ = [];
+        for (let A = b; A <= w; ++A)
+            for (let D = v; D <= x; ++D)
+                _.push([A, D]);
+        const M = _.map(
+                ([A, D]) => t.query(this.tileQuery(g(A, D)))
             ),
-            A = [];
-        if (i)
-            for (let N = v; N <= x; ++N)
-                A.push([w + 1, N]), A.push([b - 1, N]);
-        if (r) {
-            const N = i ? b - 1 : b,
-                $ = i ? w + 1 : w;
-            for (let B = N; B <= $; ++B)
-                A.push([B, x + 1]), A.push([B, v - 1]);
+            T = [];
+        if (r)
+            for (let A = v; A <= x; ++A)
+                T.push([w + 1, A]), T.push([b - 1, A]);
+        if (i) {
+            const A = r ? b - 1 : b,
+                D = r ? w + 1 : w;
+            for (let R = A; R <= D; ++R)
+                T.push([R, x + 1]), T.push([R, v - 1]);
         }
-        this.prefetch = A.map(
-            ([N, $]) => t.prefetch(this.tileQuery(y(N, $)))
+        this.prefetch = T.map(
+            ([A, D]) => t.prefetch(this.tileQuery(g(A, D)))
         );
-        const M = await Promise.all(I);
-        this.grids = [{
-            density: qit(a, c, m, g, _, M)
-        }], this.convolve().update();
+        const $ = await Promise.all(M),
+            N = VZ(a, c, y, m, _, $);
+        this.grids0 = {
+            numRows: N.length,
+            columns: {
+                density: [N]
+            }
+        }, this.convolve().update();
     }
     convolve() {
         return super.convolve().rasterize();
     }
     rasterize() {
+        var g;
         const {
             bins: t,
-            kde: n
-        } = this, [i, r] = t, {
-            canvas: s,
-            ctx: o,
-            img: a
-        } = Wit(this, i, r), {
-            alpha: c,
-            alphaProp: l,
-            color: u,
-            colorProp: f
-        } = CN(this);
-        return this.data = n.map((h) => (u == null || u(a.data, i, r, h[f]), c == null || c(a.data, i, r, h[l]), o.putImageData(a, 0, 0), {
-            src: s.toDataURL()
-        })), this;
+            grids: n
+        } = this, [r, i] = t, {
+            numRows: s,
+            columns: o
+        } = n, {
+            canvas: a,
+            ctx: c,
+            img: u
+        } = WZ(this, r, i), {
+            alpha: l,
+            alphaProp: f,
+            color: h,
+            colorProp: d
+        } = E8(this), p = o[f] ?? [], y = o[d] ?? [], m = s > 1 && d && ((g = this.groupby) != null && g.includes(d)) ? I8(y, this.plot.getAttribute("colorDomain")) : S1(s);
+        return this.data = {
+            numRows: s,
+            columns: {
+                src: Array.from({
+                    length: s
+                }, (b, w) => (h == null || h(u.data, r, i, y[m[w]]), l == null || l(u.data, r, i, p[m[w]]), c.putImageData(u, 0, 0), a.toDataURL()))
+            }
+        }, this;
     }
     plotSpecs() {
-        var s;
+        var o;
         const {
             type: t,
-            data: n,
-            plot: i
-        } = this, r = {
-            src: "src",
-            width: i.innerWidth(),
-            height: i.innerHeight(),
+            plot: n,
+            data: {
+                numRows: r,
+                columns: i
+            }
+        } = this, s = {
+            src: i.src,
+            width: n.innerWidth(),
+            height: n.innerHeight(),
             preserveAspectRatio: "none",
-            imageRendering: (s = this.channel("imageRendering")) == null ? void 0 : s.value,
+            imageRendering: (o = this.channel("imageRendering")) == null ? void 0 : o.value,
             frameAnchor: "middle"
         };
         return [{
             type: t,
-            data: n,
-            options: r
+            data: {
+                length: r
+            },
+            options: s
         }];
     }
 }
 
-function qit(e, t, n, i, r, s) {
+function VZ(e, t, n, r, i, s) {
     const o = new Float64Array(e * t);
     return s.forEach((a, c) => {
-        const [l, u] = r[c], f = l * e - n, h = u * t - i;
-        Yit(e, t, o, a, f, h);
+        const [u, l] = i[c], f = u * e - n, h = l * t - r;
+        YZ(e, t, o, a, f, h);
     }), o;
 }
 
-function Yit(e, t, n, i, r, s) {
-    const o = i.numRows;
+function YZ(e, t, n, r, i, s) {
+    const o = r.numRows;
     if (o === 0)
         return;
-    const a = i.getChild("index").toArray(),
-        c = i.getChild("density").toArray();
-    for (let l = 0; l < o; ++l) {
-        const u = a[l],
-            f = r + u % e,
-            h = s + Math.floor(u / e);
-        0 <= f && f < e && 0 <= h && h < t && (n[f + h * e] = c[l]);
+    const a = r.getChild("index").toArray(),
+        c = r.getChild("density").toArray();
+    for (let u = 0; u < o; ++u) {
+        const l = a[u],
+            f = i + l % e,
+            h = s + Math.floor(l / e);
+        0 <= f && f < e && 0 <= h && h < t && (n[f + h * e] = c[u]);
     }
 }
 
-function Wit(e, t, n) {
+function WZ(e, t, n) {
     if (!e.image || e.image.w !== t || e.image.h !== n) {
-        const i = RN(t, n),
-            r = i.getContext("2d", {
+        const r = T8(t, n),
+            i = r.getContext("2d", {
                 willReadFrequently: !0
             }),
-            s = r.getImageData(0, 0, t, n);
+            s = i.getImageData(0, 0, t, n);
         e.image = {
-            canvas: i,
-            ctx: r,
+            canvas: r,
+            ctx: i,
             img: s,
             w: t,
             h: n
         };
     }
     return e.image;
 }
 
-function Git(e, t, n, i, r, s) {
+function XZ(e, t, n, r, i, s) {
     return e.select({
-        index: q`FLOOR(${t})::INTEGER + FLOOR(${n})::INTEGER * ${r}`,
-        ...i
+        index: j`FLOOR(${t})::INTEGER + FLOOR(${n})::INTEGER * ${i}`,
+        ...r
     }).groupby("index", s);
 }
 
-function Xit(e, t, n, i, r, s) {
-    const o = i.column ? `* ${i.column}` : "",
+function GZ(e, t, n, r, i, s) {
+    const o = r.column ? `* ${r.column}` : "",
         a = (h, d) => e.clone().select({
             xp: t,
             yp: n,
             i: h,
             w: d
         }),
         c = a(
-            q`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${r}`,
-            q`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
-        ),
-        l = a(
-            q`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${r}`,
-            q`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${o}`
+            j`FLOOR(xp)::INTEGER + FLOOR(yp)::INTEGER * ${i}`,
+            j`(FLOOR(xp)::INTEGER + 1 - xp) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
         ),
         u = a(
-            q`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${r}`,
-            q`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
+            j`FLOOR(xp)::INTEGER + (FLOOR(yp)::INTEGER + 1) * ${i}`,
+            j`(FLOOR(xp)::INTEGER + 1 - xp) * (yp - FLOOR(yp)::INTEGER)${o}`
+        ),
+        l = a(
+            j`FLOOR(xp)::INTEGER + 1 + FLOOR(yp)::INTEGER * ${i}`,
+            j`(xp - FLOOR(xp)::INTEGER) * (FLOOR(yp)::INTEGER + 1 - yp)${o}`
         ),
         f = a(
-            q`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${r}`,
-            q`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${o}`
+            j`FLOOR(xp)::INTEGER + 1 + (FLOOR(yp)::INTEGER + 1) * ${i}`,
+            j`(xp - FLOOR(xp)::INTEGER) * (yp - FLOOR(yp)::INTEGER)${o}`
         );
-    return Lt.from(Lt.unionAll(c, l, u, f)).select({
+    return xt.from(xt.unionAll(c, u, l, f)).select({
         index: "i",
-        density: oa("w")
-    }, s).groupby("index", s).having(Eb("density", 0));
+        density: Cs("w")
+    }, s).groupby("index", s).having(pm("density", 0));
 }
 
-function JS(e) {
+function hv(e) {
     const t = Math.floor(e);
     return t === e ? t - 1 : t;
 }
-
-function Hit(e, t, n) {
-    var i = 1e-8,
-        r = t - 1,
-        s = n - 1,
-        o = 0,
-        a, c, l, u, f, h, d, p, m, g, y;
-    if (e <= 0)
-        return 0;
-    if (e >= 1)
-        return 1;
-    for (t >= 1 && n >= 1 ? (l = e < 0.5 ? e : 1 - e, u = Math.sqrt(-2 * Math.log(l)), d = (2.30753 + u * 0.27061) / (1 + u * (0.99229 + u * 0.04481)) - u, e < 0.5 && (d = -d), p = (d * d - 3) / 6, m = 2 / (1 / (2 * t - 1) + 1 / (2 * n - 1)), g = d * Math.sqrt(p + m) / m - (1 / (2 * n - 1) - 1 / (2 * t - 1)) * (p + 5 / 6 - 2 / (3 * m)), d = t / (t + n * Math.exp(2 * g))) : (a = Math.log(t / (t + n)), c = Math.log(n / (t + n)), u = Math.exp(t * a) / t, f = Math.exp(n * c) / n, g = u + f, e < u / g ? d = Math.pow(t * g * e, 1 / t) : d = 1 - Math.pow(n * g * (1 - e), 1 / n)), y = -gc(t) - gc(n) + gc(t + n); o < 10; o++) {
-        if (d === 0 || d === 1)
-            return d;
-        if (h = Jit(d, t, n) - e, u = Math.exp(r * Math.log(d) + s * Math.log(1 - d) + y), f = h / u, d -= u = f / (1 - 0.5 * Math.min(1, f * (r / d - s / (1 - d)))), d <= 0 && (d = 0.5 * (d + u)), d >= 1 && (d = 0.5 * (d + u + 1)), Math.abs(u) < i * d && o > 0)
-            break;
-    }
-    return d;
-}
-
-function Jit(e, t, n) {
-    var i = e === 0 || e === 1 ? 0 : Math.exp(gc(t + n) - gc(t) - gc(n) + t * Math.log(e) + n * Math.log(1 - e));
-    return e < 0 || e > 1 ? !1 : e < (t + 1) / (t + n + 2) ? i * KS(e, t, n) / t : 1 - i * KS(1 - e, n, t) / n;
-}
-
-function KS(e, t, n) {
-    var i = 1e-30,
-        r = 1,
-        s = t + n,
-        o = t + 1,
-        a = t - 1,
-        c = 1,
-        l = 1 - s * e / o,
-        u, f, h, d;
-    for (Math.abs(l) < i && (l = i), l = 1 / l, d = l; r <= 100 && (u = 2 * r, f = r * (n - r) * e / ((a + u) * (t + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, d *= l * c, f = -(t + r) * (s + r) * e / ((t + u) * (o + u)), l = 1 + f * l, Math.abs(l) < i && (l = i), c = 1 + f / c, Math.abs(c) < i && (c = i), l = 1 / l, h = l * c, d *= h, !(Math.abs(h - 1) < 3e-7)); r++)
-    ;
-    return d;
-}
-
-function gc(e) {
-    var t = 0,
-        n = [
-            76.18009172947146,
-            -86.5053203294167,
-            24.01409824083091,
-            -1.231739572450155,
-            0.001208650973866179,
-            -5395239384953e-18
-        ],
-        i = 1.000000000190015,
-        r, s, o;
-    for (o = (s = r = e) + 5.5, o -= (r + 0.5) * Math.log(o); t < 6; t++)
-        i += n[t] / ++s;
-    return Math.log(2.506628274631 * i / r) - o;
-}
-
-function Kit(e, t) {
-    var n = Hit(2 * Math.min(e, 1 - e), 0.5 * t, 0.5);
-    return n = Math.sqrt(t * (1 - n) / n), e > 0.5 ? n : -n;
-}
-class Zit extends ha {
+class HZ extends rs {
     constructor(t, n) {
         const {
-            ci: i = 0.95,
-            precision: r = 4,
+            ci: r = 0.95,
+            precision: i = 4,
             ...s
         } = n;
         super("line", t, s);
         const o = () => this.modelFit ? this.confidenceBand().update() : null;
-        Kn(this, "ci", i, o), Kn(this, "precision", r, o);
+        this.ci = Ge(r, (a) => (this.ci = a, o())), this.precision = Ge(i, (a) => (this.precision = a, o()));
     }
     query(t = []) {
         const n = this.channelField("x").as,
-            i = this.channelField("y").as,
-            r = Array.from(new Set(
+            r = this.channelField("y").as,
+            i = Array.from(new Set(
                 ["stroke", "z", "fx", "fy"].flatMap((s) => {
                     var o;
                     return ((o = this.channelField(s)) == null ? void 0 : o.as) || [];
                 })
             ));
-        return Lt.from(super.query(t)).select({
-            intercept: tU(i, n),
-            slope: eU(i, n),
-            n: nU(i, n),
-            ssy: iU(i, n),
-            ssx: rU(i, n),
-            xm: sU(i, n),
-            x0: Bg(Tc(n).where(Tu(i))),
-            x1: Bg($c(n).where(Tu(i)))
-        }).select(r).groupby(r);
+        return xt.from(super.query(t)).select({
+            intercept: tL(r, n),
+            slope: eL(r, n),
+            n: nL(r, n),
+            ssy: rL(r, n),
+            ssx: iL(r, n),
+            xm: sL(r, n),
+            x0: g0(Vo(n).where(Sc(r))),
+            x1: g0(jo(n).where(Sc(r)))
+        }).select(i).groupby(i);
     }
     queryResult(t) {
-        return this.modelFit = $N(t), this.lineData = this.modelFit.flatMap((n) => Qit(n)), this.confidenceBand();
+        return this.modelFit = ca(t), this.lineData = JZ(this.modelFit), this.confidenceBand();
     }
     confidenceBand() {
         const {
             ci: t,
             modelFit: n,
-            precision: i,
-            plot: r
-        } = this, s = r.innerWidth();
-        return this.areaData = t ? n.flatMap((o) => trt(t, i, o, s)) : null, this;
+            precision: r,
+            plot: i
+        } = this, s = i.innerWidth();
+        return this.areaData = t ? ZZ(n, t, r, s) : null, this;
     }
     plotSpecs() {
         const {
             lineData: t,
             areaData: n,
-            channels: i,
-            ci: r
-        } = this, s = {
-            x: "x",
-            y: "y"
-        }, o = {
-            x: "x",
-            y1: "y1",
-            y2: "y2",
+            channels: r,
+            ci: i
+        } = this, s = t.columns, o = i ? n.columns : {}, a = {
+            x: s.x,
+            y: s.y
+        }, c = {
+            x: o.x,
+            y1: o.y1,
+            y2: o.y2,
             fillOpacity: 0.1
         };
-        for (const a of i)
-            switch (a.channel) {
+        for (const u of r)
+            switch (u.channel) {
                 case "x":
                 case "y":
                 case "fill":
                     break;
+                case "tip":
+                    c.tip = gn(u, o);
+                    break;
                 case "stroke":
-                    s.stroke = o.fill = Cs(a);
+                    a.stroke = gn(u, s), c.fill = gn(u, o);
                     break;
                 case "strokeOpacity":
-                    s.strokeOpacity = Cs(a);
+                    a.strokeOpacity = gn(u, s);
                     break;
                 case "fillOpacity":
-                    o.fillOpacity = Cs(a);
+                    c.fillOpacity = gn(u, o);
                     break;
                 default:
-                    s[a.channel] = o[a.channel] = Cs(a);
+                    a[u.channel] = gn(u, s), c[u.channel] = gn(u, o);
                     break;
             }
         return [
-            ...r ? [{
+            ...i ? [{
                 type: "areaY",
-                data: n,
-                options: o
+                data: {
+                    length: n.numRows
+                },
+                options: c
             }] : [], {
                 type: "line",
-                data: t,
-                options: s
+                data: {
+                    length: t.numRows
+                },
+                options: a
             }
         ];
     }
 }
 
-function Qit(e) {
+function Qp(e, t) {
+    if (e.concat)
+        return e.concat(t);
+    const n = new e.constructor(e.length + t.length);
+    return n.set(e, 0), n.set(t, e.length), n;
+}
+
+function JZ(e) {
     const {
         x0: t,
         x1: n,
-        xm: i,
-        intercept: r,
+        xm: r,
+        intercept: i,
         slope: s,
         n: o,
         ssx: a,
         ssy: c,
-        ...l
-    } = e;
-    return [{
-        x: t,
-        y: r + t * s,
-        ...l
-    }, {
-        x: n,
-        y: r + n * s,
-        ...l
-    }];
+        ...u
+    } = e.columns, l = (d, p) => i[p] + d * s[p], f = Qp(t, n), h = Qp(t.map(l), n.map(l));
+    for (const d in u)
+        u[d] = Qp(u[d], u[d]);
+    return {
+        numRows: f.length,
+        columns: {
+            x: f,
+            y: h,
+            ...u
+        }
+    };
 }
 
-function trt(e, t, n, i) {
-    const {
-        x0: r,
-        x1: s,
-        xm: o,
-        intercept: a,
-        slope: c,
-        n: l,
-        ssx: u,
-        ssy: f,
-        ...h
-    } = n, d = t * (s - r) / i, p = Kit((1 - e) / 2, l - 2) * Math.sqrt(f / (l - 2));
-    return Cn(r, s - d / 2, d).concat(s).map((m) => {
-        const g = a + m * c,
-            y = p * Math.sqrt(1 / l + (m - o) ** 2 / u);
-        return {
-            x: m,
-            y1: g - y,
-            y2: g + y,
-            ...h
-        };
-    });
+function ZZ(e, t, n, r) {
+    const i = e.numRows,
+        {
+            x0: s,
+            x1: o,
+            xm: a,
+            intercept: c,
+            slope: u,
+            n: l,
+            ssx: f,
+            ssy: h,
+            ...d
+        } = e.columns,
+        p = Object.keys(d),
+        y = {
+            x: [],
+            y1: [],
+            y2: []
+        };
+    p.forEach((m) => y[m] = []);
+    for (let m = 0; m < i; ++m) {
+        const g = n * (o[m] - s[m]) / r,
+            b = CZ((1 - t) / 2, l[m] - 2) * Math.sqrt(h[m] / (l[m] - 2));
+        sn(s[m], o[m] - g / 2, g).concat(o[m]).forEach((w) => {
+            const v = c[m] + w * u[m],
+                x = b * Math.sqrt(1 / l[m] + (w - a[m]) ** 2 / f[m]);
+            y.x.push(w), y.y1.push(v - x), y.y2.push(v + x), p.forEach((_) => y[_].push(d[_][m]));
+        });
+    }
+    return {
+        numRows: y.x.length,
+        columns: y
+    };
 }
 
-function ert(e) {
+function KZ(e) {
     const t = e.toLowerCase(),
         n = e.length;
-    let i = "";
-    for (let r = 0; r < n; ++r)
-        i += (e[r] !== t[r] ? "-" : "") + t[r];
-    return i;
+    let r = "";
+    for (let i = 0; i < n; ++i)
+        r += (e[i] !== t[i] ? "-" : "") + t[i];
+    return r;
 }
 
-function Pv(e) {
+function A1(e) {
     const t = {};
     for (const n in e)
-        t[ert(n)] = e[n];
+        t[KZ(n)] = e[n];
     return t;
 }
 
-function nrt(e) {
+function QZ(e) {
     const {
         channels: t
     } = e, n = /* @__PURE__ */ new Set();
-    let i = !1,
-        r = !1;
+    let r = !1,
+        i = !1;
     for (const s of t) {
         const {
             channel: o,
             field: a,
             as: c
         } = s;
         if (o === "orderby")
-            i = !0;
+            r = !0;
         else if (a)
             if (a.aggregate)
-                r = !0;
+                i = !0;
             else {
                 if (n.has(c))
                     continue;
                 n.add(c);
             }
     }
-    return !i && r && n.size && e.channels.push({
+    return !r && i && n.size && e.channels.push({
         channel: "orderby",
         value: Array.from(n)
     }), e;
 }
-class irt {
+class tK {
     constructor(t, {
         selection: n,
-        channels: i = {}
+        channels: r = {}
     }) {
-        this.mark = nrt(t), this.selection = n;
-        const r = Object.entries(Pv(i));
-        this.channels = r.length ? r : [
+        this.mark = QZ(t), this.selection = n;
+        const i = Object.entries(A1(r));
+        this.channels = i.length ? i : [
             ["opacity", 0.2]
-        ], this.selection.addEventListener("value", OI(() => this.update()));
+        ], this.selection.addEventListener("value", xv(() => this.update()));
     }
     init(t) {
         this.svg = t;
         const n = this.values = [],
-            i = this.mark.index,
-            r = this.nodes = t.querySelectorAll(`[data-index="${i}"] > *`),
+            r = this.mark.index,
+            i = this.nodes = t.querySelectorAll(`[data-index="${r}"] > *`),
             {
                 channels: s
             } = this;
-        for (let o = 0; o < r.length; ++o) {
-            const a = r[o];
+        for (let o = 0; o < i.length; ++o) {
+            const a = i[o];
             n.push(s.map((c) => a.getAttribute(c[0])));
         }
         return this.update();
     }
     async update() {
         const {
             svg: t,
             nodes: n,
-            channels: i,
-            values: r,
+            channels: r,
+            values: i,
             mark: s,
             selection: o
         } = this;
         if (!t)
             return;
-        const a = await rrt(s, o);
+        const a = await eK(s, o);
         for (let c = 0; c < n.length; ++c) {
-            const l = n[c],
-                u = r[c],
-                f = a(l.__data__);
-            for (let h = 0; h < i.length; ++h) {
-                const [d, p] = i[h];
-                l.setAttribute(d, f ? u[h] : p);
+            const u = n[c],
+                l = i[c],
+                f = u.__data__,
+                h = a(Array.isArray(f) ? f[0] : f);
+            for (let d = 0; d < r.length; ++d) {
+                const [p, y] = r[d];
+                u.setAttribute(p, h ? l[d] : y);
             }
         }
     }
 }
-async function rrt(e, t) {
-    var l, u;
+async function eK(e, t) {
+    var c, u;
     const n = t == null ? void 0 : t.predicate(e);
     if (!n || n.length === 0)
         return () => !0;
-    const i = (l = e.filterBy) == null ? void 0 : l.predicate(e, !0),
-        r = {
-            __: qs(n)
+    const r = (c = e.filterBy) == null ? void 0 : c.predicate(e, !0),
+        i = {
+            __: Bi(n)
         },
-        s = e.query(i),
-        o = s.groupby().length ? s.select(r) : s.$select(r),
-        a = await e.coordinator.query(o),
-        c = (u = a.getChild) == null ? void 0 : u.call(a, "__");
-    return a.numRows || a.length ? c ? (f) => c.get(f) : (f) => a[f].__ : () => !1;
+        s = e.query(r);
+    (s.queries || [s]).forEach((l) => {
+        l.groupby().length ? l.select(i) : l.$select(i);
+    });
+    const o = await e.coordinator.query(s),
+        a = (u = o.getChild) == null ? void 0 : u.call(o, "__");
+    return o.numRows || o.length ? a ? (l) => a.get(l) : (l) => o[l].__ : () => !1;
 }
 
-function Vv(e) {
+function $1(e) {
     const t = e.on;
     let n = !0;
 
-    function i(r) {
-        n = !1, r(), n = !0;
+    function r(i) {
+        n = !1, i(), n = !0;
     }
-    return e.reset = (...r) => {
-        i(() => e.clear(...r));
-    }, e.moveSilent = (...r) => {
-        i(() => e.move(...r));
-    }, e.on = (...r) => {
-        if (r.length > 1 && r[1]) {
-            const s = r[1];
-            r[1] = (...o) => n && s(...o);
+    return e.reset = (...i) => {
+        r(() => e.clear(...i));
+    }, e.moveSilent = (...i) => {
+        r(() => e.move(...i));
+    }, e.on = (...i) => {
+        if (i.length > 1 && i[1]) {
+            const s = i[1];
+            i[1] = (...o) => n && s(...o);
         }
-        return t(...r);
+        return t(...i);
     }, e;
 }
 
-function srt() {
-    return Vv(jq());
+function nK() {
+    return $1(KC());
 }
 
-function ort() {
-    return Vv(Pq());
+function rK() {
+    return $1(JC());
 }
 
-function art() {
-    return Vv(Vq());
+function iK() {
+    return $1(ZC());
 }
-const ZS = 1e-12;
+const dv = 1e-12;
 
-function J1(e, t) {
-    return e === t || e && t && Math.abs(e[0] - t[0]) < ZS && Math.abs(e[1] - t[1]) < ZS || !1;
+function Cy(e, t) {
+    return e === t || e && t && Math.abs(e[0] - t[0]) < dv && Math.abs(e[1] - t[1]) < dv || !1;
 }
 
-function Wc(e, t) {
-    var i;
-    const n = (i = e.channelField(t)) == null ? void 0 : i.field;
+function ua(e, t) {
+    var r;
+    const n = (r = e.channelField(t)) == null ? void 0 : r.field;
     return (n == null ? void 0 : n.basis) || n;
 }
 
-function K1(e, t, n = 1) {
+function Py(e, t, n = 1) {
     return t.invert(n * Math.floor(e / n));
 }
 
-function UN() {
+function O8() {
     const e = this,
         t = e.getScreenCTM;
     let n;
     e.getScreenCTM = () => e.isConnected ? n = t.call(e) : n;
 }
-class zN {
+class I1 {
     constructor(t, {
         channel: n,
-        selection: i,
-        field: r,
+        selection: r,
+        field: i = void 0,
         pixelSize: s = 1,
         peers: o = !0,
         brush: a
     }) {
-        this.mark = t, this.channel = n, this.pixelSize = s || 1, this.selection = i, this.peers = o, this.field = r || Wc(t, n), this.style = a && Pv(a), this.brush = n === "y" ? art() : ort(), this.brush.on("brush end", ({
+        this.mark = t, this.channel = n, this.pixelSize = s || 1, this.selection = r, this.peers = o, this.field = i || ua(t, n), this.style = a && A1(a), this.brush = n === "y" ? iK() : rK(), this.brush.on("brush end", ({
             selection: c
         }) => this.publish(c));
     }
     reset() {
         this.value = void 0, this.g && this.brush.reset(this.g);
     }
     activate() {
         this.selection.activate(this.clause(this.value || [0, 1]));
     }
     publish(t) {
         let n;
-        t && (n = t.map((i) => K1(i, this.scale, this.pixelSize)).sort((i, r) => i - r)), J1(n, this.value) || (this.value = n, this.g.call(this.brush.moveSilent, t), this.selection.update(this.clause(n)));
+        t && (n = t.map((r) => Py(r, this.scale, this.pixelSize)).sort((r, i) => r - i)), Cy(n, this.value) || (this.value = n, this.g.call(this.brush.moveSilent, t), this.selection.update(this.clause(n)));
     }
     clause(t) {
         const {
             mark: n,
-            pixelSize: i,
-            field: r,
+            pixelSize: r,
+            field: i,
             scale: s
         } = this;
-        return {
+        return bm(i, t, {
             source: this,
-            schema: {
-                type: "interval",
-                pixelSize: i,
-                scales: [s]
-            },
             clients: this.peers ? n.plot.markSet : ( /* @__PURE__ */ new Set()).add(n),
-            value: t,
-            predicate: t ? Tn(r, t) : null
-        };
+            scale: s,
+            pixelSize: r
+        });
     }
-    init(t) {
+    init(t, n) {
         var l;
         const {
-            brush: n,
+            brush: r,
             channel: i,
-            style: r
+            style: s
         } = this;
         this.scale = t.scale(i);
-        const s = t.scale("x").range,
-            o = t.scale("y").range;
-        n.extent([
-            [Ye(s), Ye(o)],
-            [De(s), De(o)]
+        const o = t.scale("x").range,
+            a = t.scale("y").range;
+        r.extent([
+            [ve(o), ve(a)],
+            [ae(o), ae(a)]
         ]);
-        const a = ce(t).selectAll('g[aria-label="facet"]'),
-            c = a.size() ? a : ce(t);
-        if (this.g = c.append("g").attr("class", `interval-${i}`).each(UN).call(n).call(n.moveSilent, (l = this.value) == null ? void 0 : l.map(this.scale.apply)), r) {
-            const u = this.g.selectAll("rect.selection");
-            for (const f in r)
-                u.attr(f, r[f]);
+        const c = (l = this.value) == null ? void 0 : l.map(this.scale.apply).sort(zt),
+            u = Wt(t).selectAll('g[aria-label="facet"]');
+        if (n = u.size() ? u : Wt(n ?? t), this.g = n.append("g").attr("class", `interval-${i}`).each(O8).call(r).call(r.moveSilent, c), s) {
+            const f = this.g.selectAll("rect.selection");
+            for (const h in s)
+                f.attr(h, s[h]);
         }
-        t.addEventListener("pointerenter", () => this.activate());
+        t.addEventListener("pointerenter", (f) => {
+            f.buttons || this.activate();
+        });
     }
 }
-const Eh = (e, t) => e - t;
-class crt {
+class sK {
     constructor(t, {
         selection: n,
-        xfield: i,
-        yfield: r,
+        xfield: r,
+        yfield: i,
         pixelSize: s = 1,
         peers: o = !0,
         brush: a
     }) {
-        this.mark = t, this.pixelSize = s || 1, this.selection = n, this.peers = o, this.xfield = i || Wc(t, "x"), this.yfield = r || Wc(t, "y"), this.style = a && Pv(a), this.brush = srt(), this.brush.on("brush end", ({
+        this.mark = t, this.pixelSize = s || 1, this.selection = n, this.peers = o, this.xfield = r || ua(t, "x"), this.yfield = i || ua(t, "y"), this.style = a && A1(a), this.brush = nK(), this.brush.on("brush end", ({
             selection: c
         }) => this.publish(c));
     }
     reset() {
         this.value = void 0, this.g && this.brush.reset(this.g);
     }
     activate() {
@@ -39262,404 +39915,518 @@
             [0, 1],
             [0, 1]
         ]));
     }
     publish(t) {
         const {
             value: n,
-            pixelSize: i,
-            xscale: r,
+            pixelSize: r,
+            xscale: i,
             yscale: s
         } = this;
         let o, a;
         if (t) {
-            const [c, l] = t;
-            o = [c[0], l[0]].map((u) => K1(u, r, i)).sort(Eh), a = [c[1], l[1]].map((u) => K1(u, s, i)).sort(Eh);
+            const [c, u] = t;
+            o = [c[0], u[0]].map((l) => Py(l, i, r)).sort(zt), a = [c[1], u[1]].map((l) => Py(l, s, r)).sort(zt);
         }
-        (!J1(o, n == null ? void 0 : n[0]) || !J1(a, n == null ? void 0 : n[1])) && (this.value = t ? [o, a] : void 0, this.g.call(this.brush.moveSilent, t), this.selection.update(this.clause(this.value)));
+        (!Cy(o, n == null ? void 0 : n[0]) || !Cy(a, n == null ? void 0 : n[1])) && (this.value = t ? [o, a] : void 0, this.g.call(this.brush.moveSilent, t), this.selection.update(this.clause(this.value)));
     }
     clause(t) {
         const {
             mark: n,
-            pixelSize: i,
-            xfield: r,
+            pixelSize: r,
+            xfield: i,
             yfield: s,
             xscale: o,
             yscale: a
         } = this;
-        return {
+        return $k([i, s], t, {
             source: this,
-            schema: {
-                type: "interval",
-                pixelSize: i,
-                scales: [o, a]
-            },
             clients: this.peers ? n.plot.markSet : ( /* @__PURE__ */ new Set()).add(n),
-            value: t,
-            predicate: t ? qs(Tn(r, t[0]), Tn(s, t[1])) : null
-        };
+            scales: [o, a],
+            pixelSize: r
+        });
     }
     init(t) {
         const {
             brush: n,
-            style: i
-        } = this, r = this.xscale = t.scale("x"), s = this.yscale = t.scale("y"), o = r.range, a = s.range;
+            style: r
+        } = this, i = this.xscale = t.scale("x"), s = this.yscale = t.scale("y"), o = i.range, a = s.range;
         n.extent([
-            [Ye(o), Ye(a)],
-            [De(o), De(a)]
+            [ve(o), ve(a)],
+            [ae(o), ae(a)]
         ]);
-        const c = ce(t).selectAll('g[aria-label="facet"]'),
-            l = c.size() ? c : ce(t);
-        if (this.g = l.append("g").attr("class", "interval-xy").each(UN).call(n), i) {
-            const u = this.g.selectAll("rect.selection");
-            for (const f in i)
-                u.attr(f, i[f]);
+        const c = Wt(t).selectAll('g[aria-label="facet"]'),
+            u = c.size() ? c : Wt(t);
+        if (this.g = u.append("g").attr("class", "interval-xy").each(O8).call(n), r) {
+            const l = this.g.selectAll("rect.selection");
+            for (const f in r)
+                l.attr(f, r[f]);
         }
         if (this.value) {
-            const [u, f] = this.value[0].map(r.apply).sort(Eh), [h, d] = this.value[1].map(s.apply).sort(Eh);
+            const [l, f] = this.value[0].map(i.apply).sort(zt), [h, d] = this.value[1].map(s.apply).sort(zt);
             this.g.call(n.moveSilent, [
-                [u, h],
+                [l, h],
                 [f, d]
             ]);
         }
-        t.addEventListener("pointerenter", () => this.activate());
+        t.addEventListener("pointerenter", (l) => {
+            l.buttons || this.activate();
+        });
     }
 }
-class PN {
+class T1 {
     constructor(t, {
         selection: n,
-        channel: i,
-        field: r
+        pointer: r,
+        channels: i,
+        fields: s,
+        maxRadius: o = 40
     }) {
-        this.mark = t, this.selection = n, this.clients = ( /* @__PURE__ */ new Set()).add(t), this.channel = i, this.field = r || Wc(t, [i]);
+        this.mark = t, this.selection = n, this.clients = ( /* @__PURE__ */ new Set()).add(t), this.pointer = r, this.channels = i || (r === "x" ? ["x"] : r === "y" ? ["y"] : ["x", "y"]), this.fields = s || this.channels.map((a) => ua(t, [a])), this.maxRadius = o, this.valueIndex = -1;
     }
     clause(t) {
         const {
             clients: n,
-            field: i
-        } = this, r = t ? jy(i, tl(t)) : null;
-        return {
+            fields: r
+        } = this;
+        return Wx(r, t && [t], {
             source: this,
-            schema: {
-                type: "point"
-            },
-            clients: n,
-            value: t,
-            predicate: r
-        };
+            clients: n
+        });
     }
     init(t) {
         const n = this,
             {
-                mark: i,
-                channel: r,
-                selection: s
+                mark: r,
+                channels: i,
+                selection: s,
+                maxRadius: o
             } = this,
             {
-                data: o
-            } = i,
-            a = i.channelField(r).as,
-            c = ce(t).selectAll('g[aria-label="facet"]'),
-            l = c.size() ? c : ce(t),
-            u = t.scale(r),
-            f = !Xo(s);
-        l.on("pointerdown pointermove", function(h) {
-            const [d, p] = yi(h, this), m = lrt(o, a, u.invert(r === "x" ? d : p));
-            s.update(f ? m : n.clause(m));
-        }), !f && t.addEventListener("pointerenter", () => {
-            this.selection.activate(this.clause(0));
-        });
+                data: {
+                    columns: a
+                }
+            } = r,
+            c = i.map((b) => r.channelField(b).as),
+            u = !dr(s),
+            l = Wt(t).selectAll('g[aria-label="facet"]'),
+            f = l.size() ? l : Wt(t),
+            h = t.scale("x").apply,
+            d = t.scale("y").apply,
+            p = Array.from(a[r.channelField("x").as], h),
+            y = Array.from(a[r.channelField("y").as], d),
+            m = this.pointer === "y" ? 0.01 : 1,
+            g = this.pointer === "x" ? 0.01 : 1;
+        f.on("pointerenter pointerdown pointermove", function(b) {
+            const [w, v] = On(b, this), x = oK(p, y, w, v, m, g, o);
+            if (x !== this.valueIndex) {
+                this.valueIndex = x;
+                const _ = x < 0 ? void 0 : c.map((M) => a[M][x]);
+                u ? x > -1 && s.update(_.length > 1 ? _ : _[0]) : s.update(n.clause(_));
+            }
+        }), !u && (f.on("pointerleave", () => {
+            s.update(n.clause(void 0));
+        }), t.addEventListener("pointerenter", (b) => {
+            if (!b.buttons) {
+                const w = this.channels.map(() => 0);
+                s.activate(this.clause(w));
+            }
+        }));
     }
 }
 
-function lrt(e, t, n) {
-    let i = 1 / 0,
-        r;
-    return e.forEach((s) => {
-        const o = Math.abs(s[t] - n);
-        o < i && (i = o, r = s[t]);
-    }), r;
+function oK(e, t, n, r, i, s, o) {
+    let a = o * o,
+        c = -1;
+    for (let u = 0; u < e.length; ++u) {
+        const l = i * (e[u] - n),
+            f = s * (t[u] - r),
+            h = l * l + f * f;
+        h <= a && (a = h, c = u);
+    }
+    return c;
 }
-const QS = (e, t) => e - t;
-class urt {
+const pv = (e, t) => e - t;
+class aK {
     constructor(t, {
-        x: n = new Xd(),
-        y: i = new Xd(),
-        xfield: r,
+        x: n = new _f(),
+        y: r = new _f(),
+        xfield: i,
         yfield: s,
         zoom: o = !0,
         panx: a = !0,
         pany: c = !0
     }) {
-        this.mark = t, this.xsel = n, this.ysel = i, this.xfield = r || Wc(t, "x"), this.yfield = s || Wc(t, "y"), this.zoom = rg(o, [0, 1 / 0], [1, 1]), this.panx = this.xsel && a, this.pany = this.ysel && c;
+        this.mark = t, this.xsel = n, this.ysel = r, this.xfield = i || ua(t, "x"), this.yfield = s || ua(t, "y"), this.zoom = t0(o, [0, 1 / 0], [1, 1]), this.panx = this.xsel && a, this.pany = this.ysel && c;
         const {
-            plot: l
+            plot: u
         } = t;
-        a && this.xsel.addEventListener("value", (u) => {
-            l.setAttribute("xDomain", u) && l.update();
-        }), c && this.ysel.addEventListener("value", (u) => {
-            l.setAttribute("yDomain", u) && l.update();
+        a && this.xsel.addEventListener("value", (l) => {
+            u.setAttribute("xDomain", l) && u.update();
+        }), c && this.ysel.addEventListener("value", (l) => {
+            u.setAttribute("yDomain", l) && u.update();
         });
     }
     publish(t) {
         if (this.panx) {
-            const n = frt(t, this.xscale);
+            const n = cK(t, this.xscale);
             this.xsel.update(this.clause(n, this.xfield, this.xscale));
         }
         if (this.pany) {
-            const n = hrt(t, this.yscale);
+            const n = uK(t, this.yscale);
             this.ysel.update(this.clause(n, this.yfield, this.yscale));
         }
     }
-    clause(t, n, i) {
-        return {
+    clause(t, n, r) {
+        return bm(n, t, {
             source: this,
-            schema: {
-                type: "interval",
-                scales: [i]
-            },
             clients: this.mark.plot.markSet,
-            value: t,
-            predicate: t ? Tn(n, t) : null
-        };
+            scale: r
+        });
     }
     init(t) {
         if (this.svg = t, this.initialized)
             return;
         this.initialized = !0;
         const {
             panx: n,
-            pany: i,
+            pany: r,
             mark: {
                 plot: {
-                    element: r
+                    element: i
                 }
             },
             xsel: s,
             ysel: o
         } = this;
         this.xscale = t.scale("x"), this.yscale = t.scale("y");
-        const a = this.xscale.range.slice().sort(QS),
-            c = this.yscale.range.slice().sort(QS),
-            l = rg(n, [-1 / 0, 1 / 0], a),
-            u = rg(i, [-1 / 0, 1 / 0], c),
-            f = EH().extent([
+        const a = this.xscale.range.slice().sort(pv),
+            c = this.yscale.range.slice().sort(pv),
+            u = t0(n, [-1 / 0, 1 / 0], a),
+            l = t0(r, [-1 / 0, 1 / 0], c),
+            f = jj().extent([
                 [a[0], c[0]],
                 [a[1], c[1]]
             ]).scaleExtent(this.zoom).translateExtent([
-                [l[0], u[0]],
-                [l[1], u[1]]
+                [u[0], l[0]],
+                [u[1], l[1]]
             ]).on("start", () => {
                 this.xscale = this.svg.scale("x"), this.yscale = this.svg.scale("y");
-            }).on("end", () => r.__zoom = new ir(1, 0, 0)).on("zoom", ({
+            }).on("end", () => i.__zoom = new fr(1, 0, 0)).on("zoom", ({
                 transform: h
             }) => this.publish(h));
-        if (ce(r).call(f), n || i) {
+        if (Wt(i).call(f), n || r) {
             let h = !1;
-            r.addEventListener("mouseenter", () => {
-                if (!h) {
-                    if (h = !0, n) {
+            i.addEventListener("pointerenter", (d) => {
+                if (!h && (h = !0, !d.buttons)) {
+                    if (n) {
                         const {
-                            xscale: d,
-                            xfield: p
+                            xscale: p,
+                            xfield: y
                         } = this;
-                        s.activate(this.clause(d.domain, p, d));
+                        s.activate(this.clause(p.domain, y, p));
                     }
-                    if (i) {
+                    if (r) {
                         const {
-                            yscale: d,
-                            yfield: p
+                            yscale: p,
+                            yfield: y
                         } = this;
-                        o.activate(this.clause(d.domain, p, d));
+                        o.activate(this.clause(p.domain, y, p));
                     }
                 }
-            }), r.addEventListener("mouseleave", () => h = !1);
+            }), i.addEventListener("pointerleave", () => h = !1);
         }
     }
 }
 
-function rg(e, t, n) {
+function t0(e, t, n) {
     return e ? Array.isArray(e) ? e : t : n;
 }
 
-function frt(e, t) {
+function cK(e, t) {
     return t.range.map(e.invertX, e).map(t.invert, t);
 }
 
-function hrt(e, t) {
+function uK(e, t) {
     return t.range.map(e.invertY, e).map(t.invert, t);
 }
-class VN {
+class L8 {
+    /**
+     * @param {*} mark The mark to interact with.
+     * @param {*} options The interactor options.
+     */
     constructor(t, {
         selection: n,
-        channels: i,
-        peers: r = !0
+        channels: r,
+        peers: i = !0
     }) {
-        this.value = null, this.mark = t, this.selection = n, this.peers = r, this.channels = i.map((s) => {
-            var a;
-            const o = s === "color" ? ["fill", "stroke"] : s === "x" ? ["x", "x1", "x2"] : s === "y" ? ["y", "y1", "y2"] : [s];
-            for (let c = 0; c < o.length; ++c) {
-                const l = t.channelField(o[c]);
-                if (l)
-                    return {
-                        field: ((a = l.field) == null ? void 0 : a.basis) || l.field,
-                        as: l.as
-                    };
+        this.value = null, this.mark = t, this.selection = n, this.peers = i;
+        const s = this.fields = [],
+            o = this.as = [];
+        r.forEach((a) => {
+            var u;
+            const c = a === "color" ? ["color", "fill", "stroke"] : a === "x" ? ["x", "x1", "x2"] : a === "y" ? ["y", "y1", "y2"] : [a];
+            for (let l = 0; l < c.length; ++l) {
+                const f = t.channelField(c[l], {
+                    exact: !0
+                });
+                if (f) {
+                    s.push(((u = f.field) == null ? void 0 : u.basis) || f.field), o.push(f.as);
+                    return;
+                }
             }
-            throw new Error(`Missing channel: ${s}`);
+            throw new Error(`Missing channel: ${a}`);
         });
     }
     clause(t) {
         const {
-            channels: n,
-            mark: i
+            fields: n,
+            mark: r
         } = this;
-        let r = null;
-        if (t) {
-            const s = t.map((o) => {
-                const a = o.map((c, l) => qM(n[l].field, tl(c)));
-                return a.length > 1 ? qs(a) : a[0];
-            });
-            r = s.length > 1 ? Ob(s) : s[0];
-        }
-        return {
+        return Wx(n, t, {
             source: this,
-            schema: {
-                type: "point"
-            },
-            clients: this.peers ? i.plot.markSet : ( /* @__PURE__ */ new Set()).add(i),
-            value: t,
-            predicate: r
-        };
+            clients: this.peers ? r.plot.markSet : ( /* @__PURE__ */ new Set()).add(r)
+        });
     }
-    init(t, n, i) {
+    init(t, n, r) {
         const {
-            mark: r,
-            channels: s,
+            mark: i,
+            as: s,
             selection: o
         } = this, {
-            data: a
-        } = r;
-        i = i || ((l) => {
-            const u = a[l.__data__];
-            return s.map((f) => u[f.as]);
-        }), n = n || `[data-index="${r.index}"]`;
+            data: {
+                columns: a = {}
+            } = {}
+        } = i;
+        r ?? (r = (u) => s.map((l) => {
+            const f = u.__data__;
+            return a[l][Array.isArray(f) ? f[0] : f];
+        })), n ?? (n = `[data-index="${i.index}"]`);
         const c = new Set(t.querySelectorAll(n));
-        t.addEventListener("pointerdown", (l) => {
-            const u = o.single ? o.value : this.value,
-                f = l.target;
+        t.addEventListener("pointerdown", (u) => {
+            const l = o.single ? o.value : this.value,
+                f = u.target;
             let h = null;
-            if (drt(c, f)) {
-                const d = i(f);
-                l.shiftKey && (u != null && u.length) ? (h = u.filter((p) => Z1(p, d)), h.length === u.length && h.push(d)) : (u == null ? void 0 : u.length) === 1 && !Z1(u[0], d) ? h = null : h = [d];
+            if (lK(c, f)) {
+                const d = r(f);
+                (u.shiftKey || u.metaKey) && (l != null && l.length) ? (h = l.filter((p) => Uy(p, d)), h.length === l.length && h.push(d)) : (l == null ? void 0 : l.length) === 1 && !Uy(l[0], d) ? h = null : h = [d];
             }
-            this.value = h, prt(u, h) && o.update(this.clause(h));
-        }), t.addEventListener("pointerenter", () => {
-            this.selection.activate(this.clause([this.channels.map(() => 0)]));
+            this.value = h, fK(l, h) && o.update(this.clause(h));
+        }), t.addEventListener("pointerenter", (u) => {
+            u.buttons || this.selection.activate(this.clause([this.fields.map(() => 0)]));
         });
     }
 }
 
-function drt(e, t) {
+function lK(e, t) {
     var n;
     return e.has(t) || e.has(t.parentNode) || e.has((n = t.parentNode) == null ? void 0 : n.parentNode);
 }
 
-function prt(e, t) {
-    return e == null || t == null ? e != null || t != null : e.length !== t.length || e.some((n, i) => Z1(n, t[i]));
+function fK(e, t) {
+    return e == null || t == null ? e != null || t != null : e.length !== t.length || e.some((n, r) => Uy(n, t[r]));
 }
 
-function Z1(e, t) {
+function Uy(e, t) {
     const n = e.length;
     if (t.length !== n)
         return !0;
-    for (let i = 0; i < n; ++i)
-        if (e[i] !== t[i])
+    for (let r = 0; r < n; ++r)
+        if (e[r] !== t[r])
             return !0;
     return !1;
 }
-class tI {
+const k8 = ":scope > div, :scope > span",
+    ql = "swatch",
+    yv = "ramp";
+class mv {
     constructor(t, n) {
         const {
-            as: i,
-            ...r
+            as: r,
+            field: i,
+            ...s
         } = n;
         this.channel = t, this.options = {
             label: null,
-            ...r
-        }, this.selection = i, this.element = document.createElement("div"), this.element.setAttribute("class", "legend"), this.element.value = this;
+            ...s
+        }, this.type = null, this.handler = null, this.selection = r, this.field = i, this.legend = null, this.element = document.createElement("div"), this.element.setAttribute("class", "legend"), Object.defineProperty(this.element, "value", {
+            value: this
+        });
     }
     setPlot(t) {
-        const {
-            channel: n,
-            selection: i
-        } = this, r = yrt(t, n);
-        this.selection && r && (this.handler = new VN(r, {
-            selection: i,
-            channels: [n]
-        }), this.selection.addEventListener("value", () => this.update()));
+        this.plot = t;
     }
     init(t) {
-        const {
-            channel: n,
-            options: i,
-            handler: r
-        } = this, o = t.scale(n).type === "ordinal" ? i : {
-            marginTop: 1,
-            tickSize: 2,
-            height: 28,
-            ...i
-        };
-        return this.legend = t.legend(n, o), r && (r.init(this.legend, ":scope > div", (a) => [a.__data__]), this.update()), this.element.replaceChildren(this.legend), this.element;
+        const n = hK(this, t);
+        return this.element.replaceChildren(n), this.element;
     }
     update() {
         if (!this.legend)
             return;
         const {
-            value: t
-        } = this.selection, n = t && t.length ? new Set(t.map((r) => r[0])) : null, i = this.legend.querySelectorAll(":scope > div");
-        for (const r of i) {
-            const s = n ? n.has(r.__data__) : !0;
-            r.style.opacity = s ? 1 : 0.2;
+            selection: t,
+            handler: n
+        } = this, {
+            single: r,
+            value: i
+        } = t, s = r ? i : t.valueFor(n), o = s && s.length ? new Set(s.map((c) => c[0])) : null, a = this.legend.querySelectorAll(k8);
+        for (const c of a) {
+            const u = o ? o.has(c.__data__) : !0;
+            c.style.opacity = u ? 1 : 0.2;
         }
     }
 }
 
-function yrt({
-    marks: e
-}, t) {
+function hK(e, t) {
+    const {
+        channel: n,
+        options: r,
+        selection: i
+    } = e, s = t.scale(n), o = s.type === "ordinal" ? ql : yv, a = o === ql ? r : r.label ? {
+        tickSize: 2,
+        ...r
+    } : {
+        tickSize: 2,
+        marginTop: 1,
+        height: 29,
+        ...r
+    }, c = t.legend(n, a);
+    e.legend = c;
+    let u = !!i;
+    if (u && o === yv) {
+        const l = a.width ?? 240,
+            f = mK(s, l);
+        f ? c.scale = function(h) {
+            return h === "x" ? {
+                range: [0, l]
+            } : h === "y" ? {
+                range: [-10, 0]
+            } : h === n ? f : void 0;
+        } : u = !1;
+    }
+    if (u) {
+        const l = dK(e, o);
+        o === ql ? (l.init(c, k8, (f) => [f.__data__]), e.update()) : l.init(c, c.querySelector("g:last-of-type"));
+    }
+    return c;
+}
+
+function dK(e, t) {
+    const {
+        channel: n,
+        handler: r,
+        selection: i
+    } = e;
+    if (r)
+        return r;
+    const s = pK(e);
+    return t === ql ? (e.handler = new L8(s, {
+        selection: i,
+        channels: [n],
+        peers: !1
+    }), i.addEventListener("value", () => e.update())) : e.handler = new I1(s, {
+        selection: i,
+        channel: n,
+        brush: {
+            fill: "none",
+            stroke: "currentColor"
+        },
+        peers: !1
+    }), e.handler;
+}
+
+function pK(e) {
+    const {
+        channel: t,
+        plot: n
+    } = e, r = e.field ?? yK(n.marks, t) ?? "value";
+    if (r) {
+        const i = {
+            field: r
+        };
+        return {
+            plot: n,
+            channelField: (s) => t === s ? i : void 0
+        };
+    }
+}
+
+function yK(e, t) {
     const n = t === "color" ? ["fill", "stroke"] : t === "opacity" ? ["opacity", "fillOpacity", "strokeOpacity"] : null;
     if (n == null)
         return null;
-    for (let i = e.length - 1; i > -1; --i)
-        for (const r of n)
-            if (e[i].channelField(r, {
-                    exact: !0
-                }))
-                return e[i];
+    for (let r = e.length - 1; r > -1; --r)
+        for (const i of n) {
+            const s = e[r].channelField(i, {
+                exact: !0
+            });
+            if (s)
+                return s.field;
+        }
     return null;
 }
-const mrt = /* @__PURE__ */ new Set(["rectY-x", "rectX-y", "rect-x", "rect-y"]);
 
-function grt(e, t = {
+function mK(e, t) {
+    const {
+        apply: n,
+        invert: r,
+        interpolate: i,
+        ...s
+    } = e;
+    let o = e.type;
+    o.startsWith("diverging-") && (o = o.slice(11));
+    let a;
+    switch (o) {
+        case "log":
+        case "pow":
+        case "sqrt":
+        case "symlog":
+            a = o;
+            break;
+        case "threshold":
+        case "quantize":
+        case "quantile":
+            return console.warn(`Legends do not yet support ${o} scales.`), null;
+        default:
+            a = "linear";
+    }
+    return Xc({
+        x: {
+            ...s,
+            type: a,
+            range: [0, t]
+        }
+    });
+}
+const gK = /* @__PURE__ */ new Set([
+    "rectY-x",
+    "rectX-y",
+    "rect-x",
+    "rect-y",
+    "ruleY-x",
+    "ruleX-y"
+]);
+
+function bK(e, t = {
     steps: 25
 }) {
-    const n = (i, r) => mrt.has(`${i.type}-${r}`) ? {
-        [`${r}1`]: sg(i, r, e, t),
-        [`${r}2`]: sg(i, r, e, {
+    const n = (r, i) => gK.has(`${r.type}-${i}`) ? {
+        [`${i}1`]: e0(r, i, e, t),
+        [`${i}2`]: e0(r, i, e, {
             ...t,
             offset: 1
         })
     } : {
-        [r]: sg(i, r, e, t)
+        [i]: e0(r, i, e, t)
     };
-    return n[e3] = !0, n;
+    return n[Xx] = !0, n;
 }
 
-function sg(e, t, n, i) {
+function e0(e, t, n, r) {
     return {
         column: n,
         label: n,
         get stats() {
             return {
                 column: n,
                 stats: ["min", "max"]
@@ -39669,2931 +40436,3176 @@
             return [n];
         },
         get basis() {
             return n;
         },
         toString() {
             const {
-                apply: r,
+                apply: i,
                 sqlApply: s,
                 sqlInvert: o
-            } = ny(e, t), {
+            } = Ih(e, t), {
                 min: a,
                 max: c
-            } = e.channelField(t), l = brt(r(a), r(c), i), u = s(n), f = l.min === 0 ? u : `(${u} - ${l.min})`, h = `${(l.max - l.min) / l.steps}::DOUBLE`, d = i.offset ? `${i.offset} + ` : "", p = `${l.min} + ${h} * (${d}FLOOR(${f} / ${h}))`;
+            } = e.channelField(t), u = wK(i(a), i(c), r), l = s(n), f = u.min === 0 ? l : `(${l} - ${u.min})`, h = `${(u.max - u.min) / u.steps}::DOUBLE`, d = r.offset ? `${r.offset} + ` : "", p = `${u.min} + ${h} * (${d}FLOOR(${f} / ${h}))`;
             return `${o(p)}`;
         }
     };
 }
 
-function brt(e, t, n) {
+function wK(e, t, n) {
     let {
-        steps: i = 25,
-        minstep: r = 0,
+        steps: r = 25,
+        minstep: i = 0,
         nice: s = !0
     } = n;
     if (s !== !1) {
         const o = t - e,
-            a = i,
+            a = r,
             c = Math.LN10,
-            l = Math.ceil(Math.log(a) / c);
-        let u = Math.max(
-            r,
-            Math.pow(10, Math.round(Math.log(o) / c) - l)
+            u = Math.ceil(Math.log(a) / c);
+        let l = Math.max(
+            i,
+            Math.pow(10, Math.round(Math.log(o) / c) - u)
         );
-        for (; Math.ceil(o / u) > a;)
-            u *= 10;
+        for (; Math.ceil(o / l) > a;)
+            l *= 10;
         const f = [5, 2];
         let h;
-        for (let m = 0, g = f.length; m < g; ++m)
-            h = u / f[m], h >= r && o / h <= a && (u = h);
-        h = Math.log(u);
+        for (let y = 0, m = f.length; y < m; ++y)
+            h = l / f[y], h >= i && o / h <= a && (l = h);
+        h = Math.log(l);
         const d = h >= 0 ? 0 : ~~(-h / c) + 1,
             p = Math.pow(10, -d - 1);
-        h = Math.floor(e / u + p) * u, e = e < h ? h - u : h, t = Math.ceil(t / u) * u, i = Math.round((t - e) / u);
+        h = Math.floor(e / l + p) * l, e = e < h ? h - l : h, t = Math.ceil(t / l) * l, r = Math.round((t - e) / l);
     }
     return {
         min: e,
         max: t,
-        steps: i
+        steps: r
     };
 }
-const wrt = (e) => e && typeof e == "object" && !Array.isArray(e);
-class vrt extends af {
+const vK = (e) => e && typeof e == "object" && !Array.isArray(e);
+class _K extends Kc {
+    /**
+     * Create a new menu input.
+     * @param {object} [options] Options object
+     * @param {HTMLElement} [options.element] The parent DOM element in which to
+     *  place the menu elements. If undefined, a new `div` element is created.
+     * @param {Selection} [options.filterBy] A selection to filter the database
+     *  table indicated by the *from* option.
+     * @param {Param} [options.as] The output param or selection. A selection
+     *  clause is added for the currently selected menu option.
+     * @param {string} [options.field] The database column name to use within
+     *  generated selection clause predicates. Defaults to the *column* option.
+     * @param {(any | { value: any, label?: string })[]} [options.options] An
+     *  array of menu options, as literal values or option objects. Option
+     *  objects have a `value` property and an optional `label` property. If no
+     *  label or *format* function is provided, the string-coerced value is used.
+     * @param {(value: any) => string} [options.format] A format function that
+     *  takes an option value as input and generates a string label. The format
+     *  function is not applied when an explicit label is provided in an option
+     *  object.
+     * @param {*} [options.value] The initial selected menu value.
+     * @param {string} [options.from] The name of a database table to use as a data
+     *  source for this widget. Used in conjunction with the *column* option.
+     * @param {string} [options.column] The name of a database column from which
+     *  to pull menu options. The unique column values are used as menu options.
+     *  Used in conjunction with the *from* option.
+     * @param {string} [options.label] A text label for this input.
+     */
     constructor({
         element: t,
         filterBy: n,
-        from: i,
-        column: r,
-        label: s = r,
-        format: o = (u) => u,
+        from: r,
+        column: i,
+        label: s = i,
+        format: o = (f) => f,
         // TODO
         options: a,
         value: c,
+        field: u = i,
         as: l
     } = {}) {
-        var f, h, d, p;
-        super(n), this.from = i, this.column = r, this.selection = l, this.format = o, this.element = t ?? document.createElement("div"), this.element.setAttribute("class", "input"), this.element.value = this;
-        const u = document.createElement("label");
-        u.innerText = s || r, this.element.appendChild(u), this.select = document.createElement("select"), a && (this.data = a.map((m) => wrt(m) ? m : {
-            value: m
-        }), this.update()), c = c ?? ((f = this.selection) == null ? void 0 : f.value) ?? ((d = (h = this.data) == null ? void 0 : h[0]) == null ? void 0 : d.value), ((p = this.selection) == null ? void 0 : p.value) === void 0 && this.publish(c), this.element.appendChild(this.select), this.selection && (this.select.addEventListener("input", () => {
-            this.publish(this.selectedValue() ?? null);
-        }), Xo(this.selection) || this.selection.addEventListener("value", (m) => {
-            m !== this.select.value && this.selectedValue(m);
-        }));
+        super(n), this.from = r, this.column = i, this.format = o, this.field = u;
+        const f = this.selection = l;
+        this.element = t ?? document.createElement("div"), this.element.setAttribute("class", "input"), Object.defineProperty(this.element, "value", {
+            value: this
+        });
+        const h = document.createElement("label");
+        if (h.innerText = s || i, this.element.appendChild(h), this.select = document.createElement("select"), this.element.appendChild(this.select), a && (this.data = a.map((d) => vK(d) ? d : {
+                value: d
+            }), this.selectedValue(c ?? ""), this.update()), f) {
+            const d = !dr(f);
+            c != null && (!d || f.value === void 0) && this.publish(c), this.select.addEventListener("input", () => {
+                this.publish(this.selectedValue() ?? null);
+            }), d && this.selection.addEventListener("value", (p) => {
+                p !== this.select.value && this.selectedValue(p);
+            });
+        }
     }
     selectedValue(t) {
         var n;
         if (arguments.length === 0) {
-            const i = this.select.selectedIndex;
-            return this.data[i].value;
+            const r = this.select.selectedIndex;
+            return this.data[r].value;
         } else {
-            const i = (n = this.data) == null ? void 0 : n.findIndex((r) => r.value === t);
-            i >= 0 ? this.select.selectedIndex = i : this.select.value = String(t);
+            const r = (n = this.data) == null ? void 0 : n.findIndex((i) => i.value === t);
+            r >= 0 ? this.select.selectedIndex = r : this.select.value = String(t);
         }
     }
     reset() {
         this.select.selectedIndex = this.from ? 0 : -1;
     }
     publish(t) {
         const {
             selection: n,
-            column: i
+            field: r
         } = this;
-        Xo(n) ? n.update({
-            source: this,
-            schema: {
-                type: "point"
-            },
-            value: t,
-            predicate: t !== "" && t !== void 0 ? jy(i, tl(t)) : null
-        }) : Us(n) && n.update(t);
+        if (dr(n)) {
+            t === "" && (t = void 0);
+            const i = Yx(r, t, {
+                source: this
+            });
+            n.update(i);
+        } else
+            Oi(n) && n.update(t);
     }
     query(t = []) {
         const {
             from: n,
-            column: i
+            column: r
         } = this;
-        return n ? Lt.from(n).select({
-            value: i
-        }).distinct().where(t).orderby(i) : null;
+        return n ? xt.from(n).select({
+            value: r
+        }).distinct().where(t).orderby(r) : null;
     }
     queryResult(t) {
         return this.data = [{
             value: "",
             label: "All"
         }, ...t], this;
     }
     update() {
-        var r;
         const {
             data: t,
             format: n,
-            select: i
+            select: r,
+            selection: i
         } = this;
-        i.replaceChildren();
+        r.replaceChildren();
         for (const {
                 value: s,
                 label: o
             }
             of t) {
             const a = document.createElement("option");
             a.setAttribute("value", s), a.innerText = o ?? n(s), this.select.appendChild(a);
         }
-        return this.selection && this.selectedValue(((r = this.selection) == null ? void 0 : r.value) ?? ""), this;
+        if (i) {
+            const s = dr(i) ? i.valueFor(this) : i.value;
+            this.selectedValue(s ?? "");
+        }
+        return this;
     }
 }
-const _rt = {
-    contains: x9,
-    prefix: S9,
-    suffix: I9,
-    regexp: _9
-};
-let xrt = 0;
-class Srt extends af {
+let xK = 0;
+class SK extends Kc {
+    /**
+     * Create a new text search input.
+     * @param {object} [options] Options object
+     * @param {HTMLElement} [options.element] The parent DOM element in which to
+     *  place the search elements. If undefined, a new `div` element is created.
+     * @param {Selection} [options.filterBy] A selection to filter the database
+     *  table indicated by the *from* option.
+     * @param {Param} [options.as] The output param or selection. A selection
+     *  clause is added based on the current text search query.
+     * @param {string} [options.field] The database column name to use within
+     *  generated selection clause predicates. Defaults to the *column* option.
+     * @param {'contains' | 'prefix' | 'suffix' | 'regexp'} [options.type] The
+     *  type of text search query to perform. One of:
+     *  - `"contains"` (default): the query string may appear anywhere in the text
+     *  - `"prefix"`: the query string must appear at the start of the text
+     *  - `"suffix"`: the query string must appear at the end of the text
+     *  - `"regexp"`: the query string is a regular expression the text must match
+     * @param {string} [options.from] The name of a database table to use as an
+     *  autocomplete data source for this widget. Used in conjunction with the
+     *  *column* option.
+     * @param {string} [options.column] The name of a database column from which
+     *  to pull valid search results. The unique column values are used as search
+     *  autocomplete values. Used in conjunction with the *from* option.
+     * @param {string} [options.label] A text label for this input.
+     */
     constructor({
         element: t,
         filterBy: n,
-        from: i,
-        column: r,
+        from: r,
+        column: i,
         label: s,
         type: o = "contains",
-        as: a
+        field: a = i,
+        as: c
     } = {}) {
-        if (super(n), this.id = "search_" + ++xrt, this.type = o, this.from = i, this.column = r, this.selection = a, this.element = t ?? document.createElement("div"), this.element.setAttribute("class", "input"), this.element.value = this, s) {
-            const c = document.createElement("label");
-            c.setAttribute("for", this.id), c.innerText = s, this.element.appendChild(c);
+        if (super(n), this.id = "search_" + ++xK, this.type = o, this.from = r, this.column = i, this.selection = c, this.field = a, this.element = t ?? document.createElement("div"), this.element.setAttribute("class", "input"), Object.defineProperty(this.element, "value", {
+                value: this
+            }), s) {
+            const u = document.createElement("label");
+            u.setAttribute("for", this.id), u.innerText = s, this.element.appendChild(u);
         }
         this.searchbox = document.createElement("input"), this.searchbox.setAttribute("id", this.id), this.searchbox.setAttribute("type", "text"), this.searchbox.setAttribute("placeholder", "Query"), this.element.appendChild(this.searchbox), this.selection && (this.searchbox.addEventListener("input", () => {
             this.publish(this.searchbox.value || null);
-        }), Xo(this.selection) || this.selection.addEventListener("value", (c) => {
-            c !== this.searchbox.value && (this.searchbox.value = c);
+        }), dr(this.selection) || this.selection.addEventListener("value", (u) => {
+            u !== this.searchbox.value && (this.searchbox.value = u);
         }));
     }
     reset() {
         this.searchbox.value = "";
     }
     publish(t) {
         const {
             selection: n,
-            column: i,
-            type: r
+            field: r,
+            type: i
         } = this;
-        Xo(n) ? n.update({
-            source: this,
-            schema: {
-                type: r
-            },
-            value: t,
-            predicate: t ? _rt[r](i, tl(t)) : null
-        }) : Us(n) && n.update(t);
+        if (dr(n)) {
+            const s = Tk(r, t, {
+                source: this,
+                method: i
+            });
+            n.update(s);
+        } else
+            Oi(n) && n.update(t);
     }
     query(t = []) {
         const {
             from: n,
-            column: i
+            column: r
         } = this;
-        return n ? Lt.from(n).select({
-            list: i
+        return n ? xt.from(n).select({
+            list: r
         }).distinct().where(t) : null;
     }
     queryResult(t) {
         return this.data = t, this;
     }
     update() {
         const t = document.createElement("datalist"),
             n = `${this.id}_list`;
         t.setAttribute("id", n);
-        for (const i of this.data) {
-            const r = document.createElement("option");
-            r.setAttribute("value", i.list), t.append(r);
+        for (const r of this.data) {
+            const i = document.createElement("option");
+            i.setAttribute("value", r.list), t.append(i);
         }
         return this.datalist && this.datalist.remove(), this.element.appendChild(this.datalist = t), this.searchbox.setAttribute("list", n), this;
     }
 }
-let Irt = 0;
-class Art extends af {
+let MK = 0;
+class AK extends Kc {
+    /**
+     * Create a new slider input.
+     * @param {object} [options] Options object
+     * @param {HTMLElement} [options.element] The parent DOM element in which to
+     *  place the slider elements. If undefined, a new `div` element is created.
+     * @param {Selection} [options.filterBy] A selection to filter the database
+     *  table indicated by the *from* option.
+     * @param {Param} [options.as] The output param or selection. A selection
+     *  clause is added based on the currently selected slider option.
+     * @param {string} [options.field] The database column name to use within
+     *  generated selection clause predicates. Defaults to the *column* option.
+     * @param {'point' | 'interval'} [options.select] The type of selection clause
+     *  predicate to generate if the **as** option is a Selection.  If `'point'`
+     *  (the default), the selection predicate is an equality check for the slider
+     *  value. If `'interval'`, the predicate checks an interval from the minimum
+     *  to the current slider value.
+     * @param {number} [options.min] The minimum slider value.
+     * @param {number} [options.max] The maximum slider value.
+     * @param {number} [options.step] The slider step, the amount to increment
+     *  between consecutive values.
+     * @param {number} [options.value] The initial slider value.
+     * @param {string} [options.from] The name of a database table to use as a data
+     *  source for this widget. Used in conjunction with the *column* option.
+     *  The minimum and maximum values of the column determine the slider range.
+     * @param {string} [options.column] The name of a database column whose values
+     *  determine the slider range. Used in conjunction with the *from* option.
+     *  The minimum and maximum values of the column determine the slider range.
+     * @param {string} [options.label] A text label for this input.
+     * @param {number} [options.width] The width of the slider in screen pixels.
+     */
     constructor({
         element: t,
         filterBy: n,
-        as: i,
-        min: r,
+        as: r,
+        min: i,
         max: s,
         step: o,
         from: a,
         column: c,
-        label: l = c,
-        value: u = i == null ? void 0 : i.value,
-        width: f
+        label: u = c,
+        value: l = r == null ? void 0 : r.value,
+        select: f = "point",
+        field: h = c,
+        width: d
     } = {}) {
-        var h;
-        if (super(n), this.id = "slider_" + ++Irt, this.from = a, this.column = c || "value", this.selection = i, this.min = r, this.max = s, this.step = o, this.element = t || document.createElement("div"), this.element.setAttribute("class", "input"), this.element.value = this, l) {
-            const d = document.createElement("label");
-            d.setAttribute("for", this.id), d.innerText = l, this.element.appendChild(d);
-        }
-        this.slider = document.createElement("input"), this.slider.setAttribute("id", this.id), this.slider.setAttribute("type", "range"), f != null && (this.slider.style.width = `${+f}px`), r != null && this.slider.setAttribute("min", r), s != null && this.slider.setAttribute("max", s), o != null && this.slider.setAttribute("step", o), u != null && (this.slider.setAttribute("value", u), ((h = this.selection) == null ? void 0 : h.value) === void 0 && this.publish(u)), this.element.appendChild(this.slider), this.selection && (this.slider.addEventListener("input", () => {
-            this.publish(+this.slider.value);
-        }), Xo(this.selection) || this.selection.addEventListener("value", (d) => {
-            d !== +this.slider.value && (this.slider.value = d);
-        }));
+        var p;
+        if (super(n), this.id = "slider_" + ++MK, this.from = a, this.column = c || "value", this.selection = r, this.selectionType = f, this.field = h, this.min = i, this.max = s, this.step = o, this.element = t || document.createElement("div"), this.element.setAttribute("class", "input"), Object.defineProperty(this.element, "value", {
+                value: this
+            }), u) {
+            const y = document.createElement("label");
+            y.setAttribute("for", this.id), y.innerText = u, this.element.appendChild(y);
+        }
+        this.slider = document.createElement("input"), this.slider.setAttribute("id", this.id), this.slider.setAttribute("type", "range"), d != null && (this.slider.style.width = `${+d}px`), i != null && this.slider.setAttribute("min", `${i}`), s != null && this.slider.setAttribute("max", `${s}`), o != null && this.slider.setAttribute("step", `${o}`), this.element.appendChild(this.slider), this.curval = document.createElement("label"), this.curval.setAttribute("for", this.id), this.curval.setAttribute("class", "value"), this.element.appendChild(this.curval), l != null && (this.slider.setAttribute("value", `${l}`), ((p = this.selection) == null ? void 0 : p.value) === void 0 && this.publish(l)), this.curval.innerText = this.slider.value, this.slider.addEventListener("input", () => {
+            const {
+                value: y
+            } = this.slider;
+            this.curval.innerText = y, this.selection && this.publish(+y);
+        }), this.selection && !dr(this.selection) && this.selection.addEventListener("value", (y) => {
+            y !== +this.slider.value && (this.slider.value = y, this.curval.innerText = y);
+        });
     }
     query(t = []) {
         const {
             from: n,
-            column: i
+            column: r
         } = this;
-        return !n || this.min != null && this.max != null ? null : Lt.select({
-            min: Tc(i),
-            max: $c(i)
+        return !n || this.min != null && this.max != null ? null : xt.select({
+            min: Vo(r),
+            max: jo(r)
         }).from(n).where(t);
     }
     queryResult(t) {
         const {
             min: n,
-            max: i
+            max: r
         } = Array.from(t)[0];
-        return this.min == null && this.slider.setAttribute("min", n), this.max == null && this.slider.setAttribute("max", i), this.step == null && this.slider.setAttribute("step", (i - n) / 500), this;
+        return this.min == null && (this.min = n, this.slider.setAttribute("min", `${n}`)), this.max == null && (this.max = r, this.slider.setAttribute("max", `${r}`)), this.step == null && (this.step = (r - n) / 500, this.slider.setAttribute("step", `${this.step}`)), this;
     }
     publish(t) {
         const {
-            selection: n,
-            column: i
+            field: n,
+            selectionType: r,
+            selection: i
         } = this;
-        Xo(n) ? n.update({
-            source: this,
-            schema: {
-                type: "point"
-            },
-            value: t,
-            predicate: jy(i, tl(t))
-        }) : Us(this.selection) && n.update(t);
+        if (dr(i))
+            if (r === "interval") {
+                const s = [this.min ?? 0, t];
+                i.update(bm(n, s, {
+                    source: this,
+                    bin: "ceil",
+                    scale: {
+                        type: "identity",
+                        domain: s
+                    },
+                    pixelSize: this.step
+                }));
+            } else
+                i.update(Yx(n, t, {
+                    source: this
+                }));
+        else
+            Oi(this.selection) && i.update(t);
     }
 }
-const jN = qv((e) => {
-        const t = jv(e);
-        return (n) => n == null ? "" : typeof n == "number" ? t(n) : n instanceof Date ? qN(n) : `${n}`;
+const R8 = B8((e) => {
+        const t = E1(e);
+        return (n) => n == null ? "" : typeof n == "number" ? t(n) : n instanceof Date ? F8(n) : `${n}`;
     }),
-    jv = qv((e) => (t) => t === 0 ? "0" : t.toLocaleString(e));
-jN();
-jv();
+    E1 = B8((e) => (t) => t === 0 ? "0" : t.toLocaleString(e));
+R8();
+E1();
 
-function qN(e) {
-    return iD(e, "Invalid Date");
+function F8(e) {
+    return HM(e, "Invalid Date");
 }
 
-function qv(e) {
-    let t = qv,
+function B8(e) {
+    let t = null,
         n;
-    return (i = "en") => i === t ? n : n = e(t = i);
+    return (r = "en") => r === t ? n : n = e(t = r);
 }
-let Mrt = -1,
-    $rt = class extends af {
-        constructor({
-            element: t,
-            filterBy: n,
-            from: i,
-            columns: r = ["*"],
-            align: s = {},
-            format: o,
-            width: a,
-            maxWidth: c,
-            height: l = 500,
-            rowBatch: u = 100
-        } = {}) {
-            super(n), this.id = `table-${++Mrt}`, this.from = i, this.columns = r, this.format = o, this.align = s, this.widths = typeof a == "object" ? a : {}, this.offset = 0, this.limit = +u, this.pending = !1, this.sortHeader = null, this.sortColumn = null, this.sortDesc = !1, this.element = t || document.createElement("div"), this.element.setAttribute("id", this.id), this.element.value = this, typeof a == "number" && (this.element.style.width = `${a}px`), c && (this.element.style.maxWidth = `${c}px`), this.element.style.maxHeight = `${l}px`, this.element.style.overflow = "auto";
-            let f = -1;
-            this.element.addEventListener("scroll", (h) => {
-                const {
-                    pending: d,
-                    loaded: p
-                } = this, {
-                    scrollHeight: m,
-                    scrollTop: g,
-                    clientHeight: y
-                } = h.target, b = g < f;
-                f = g, !(b || d || p) && m - g < 2 * y && (this.pending = !0, this.requestData(this.offset + this.limit));
-            }), this.tbl = document.createElement("table"), this.element.appendChild(this.tbl), this.head = document.createElement("thead"), this.tbl.appendChild(this.head), this.body = document.createElement("tbody"), this.tbl.appendChild(this.body), this.style = document.createElement("style"), this.element.appendChild(this.style);
-        }
-        requestData(t = 0) {
-            var i;
-            this.offset = t;
-            const n = this.query((i = this.filterBy) == null ? void 0 : i.predicate(this));
-            this.requestQuery(n), Wr().prefetch(n.clone().offset(t + this.limit));
-        }
-        fields() {
-            return this.columns.map((t) => Py(this.from, t));
-        }
-        fieldInfo(t) {
-            this.schema = t;
-            const n = this.head;
-            n.innerHTML = "";
-            const i = document.createElement("tr");
-            for (const {
-                    column: r
-                }
-                of t) {
-                const s = document.createElement("th");
-                s.addEventListener("click", (o) => this.sort(o, r)), s.appendChild(document.createElement("span")), s.appendChild(document.createTextNode(r)), i.appendChild(s);
-            }
-            return n.appendChild(i), this.formats = Trt(this.format, t), this.style.innerText = Brt(
-                this.id,
-                Drt(this.align, t),
-                Nrt(this.widths, t)
-            ), this;
-        }
-        query(t = []) {
-            const {
-                from: n,
-                limit: i,
-                offset: r,
-                schema: s,
-                sortColumn: o,
-                sortDesc: a
-            } = this;
-            return Lt.from(n).select(s.map((c) => c.column)).where(t).orderby(o ? a ? y9(o) : o : []).limit(i).offset(r);
-        }
-        queryResult(t) {
-            return this.pending || (this.loaded = !1, this.body.replaceChildren()), this.data = t, this;
-        }
-        update() {
+let $K = -1;
+class IK extends Kc {
+    /**
+     * Create a new Table instance.
+     * @param {object} options Options object
+     */
+    constructor({
+        element: t,
+        filterBy: n,
+        from: r,
+        columns: i = ["*"],
+        align: s = {},
+        format: o,
+        width: a,
+        maxWidth: c,
+        height: u = 500,
+        rowBatch: l = 100
+    } = {}) {
+        super(n), this.id = `table-${++$K}`, this.from = r, this.columns = i, this.format = o, this.align = s, this.widths = typeof a == "object" ? a : {}, this.offset = 0, this.limit = +l, this.pending = !1, this.sortHeader = null, this.sortColumn = null, this.sortDesc = !1, this.element = t || document.createElement("div"), this.element.setAttribute("id", this.id), Object.defineProperty(this.element, "value", {
+            value: this
+        }), typeof a == "number" && (this.element.style.width = `${a}px`), c && (this.element.style.maxWidth = `${c}px`), this.element.style.maxHeight = `${u}px`, this.element.style.overflow = "auto";
+        let f = -1;
+        this.element.addEventListener("scroll", (h) => {
             const {
-                body: t,
-                formats: n,
-                data: i,
-                schema: r,
-                limit: s
-            } = this, o = r.length;
-            let a = 0;
-            for (const c of i) {
-                ++a;
-                const l = document.createElement("tr");
-                for (let u = 0; u < o; ++u) {
-                    const f = c[r[u].column],
-                        h = document.createElement("td");
-                    h.innerText = f == null ? "" : n[u](f), l.appendChild(h);
-                }
-                t.appendChild(l);
+                pending: d,
+                loaded: p
+            } = this, {
+                scrollHeight: y,
+                scrollTop: m,
+                clientHeight: g
+            } = h.target, b = m < f;
+            f = m, !(b || d || p) && y - m < 2 * g && (this.pending = !0, this.requestData(this.offset + this.limit));
+        }), this.tbl = document.createElement("table"), this.element.appendChild(this.tbl), this.head = document.createElement("thead"), this.tbl.appendChild(this.head), this.body = document.createElement("tbody"), this.tbl.appendChild(this.body), this.style = document.createElement("style"), this.element.appendChild(this.style);
+    }
+    requestData(t = 0) {
+        var r;
+        this.offset = t;
+        const n = this.query((r = this.filterBy) == null ? void 0 : r.predicate(this));
+        this.requestQuery(n), Wr().prefetch(n.clone().offset(t + this.limit));
+    }
+    fields() {
+        return this.columns.map((t) => Bh(this.from, t));
+    }
+    fieldInfo(t) {
+        this.schema = t;
+        const n = this.head;
+        n.innerHTML = "";
+        const r = document.createElement("tr");
+        for (const {
+                column: i
             }
-            return a < s && (this.loaded = !0), this.pending = !1, this;
-        }
-        sort(t, n) {
-            n === this.sortColumn ? this.sortDesc = !this.sortDesc : (this.sortColumn = n, this.sortDesc = !1);
-            const i = t.currentTarget,
-                r = this.sortHeader;
-            r === i && t.metaKey ? (r.firstChild.textContent = "", this.sortHeader = null, this.sortColumn = null) : (r && (r.firstChild.textContent = ""), this.sortHeader = i, i.firstChild.textContent = this.sortDesc ? "" : ""), this.requestData();
+            of t) {
+            const s = document.createElement("th");
+            s.addEventListener("click", (o) => this.sort(o, i)), s.appendChild(document.createElement("span")), s.appendChild(document.createTextNode(i)), r.appendChild(s);
         }
-    };
+        return n.appendChild(r), this.formats = TK(this.format, t), this.style.innerText = DK(
+            this.id,
+            EK(this.align, t),
+            NK(this.widths, t)
+        ), this;
+    }
+    query(t = []) {
+        const {
+            from: n,
+            limit: r,
+            offset: i,
+            schema: s,
+            sortColumn: o,
+            sortDesc: a
+        } = this;
+        return xt.from(n).select(s.map((c) => c.column)).where(t).orderby(o ? a ? mO(o) : o : []).limit(r).offset(i);
+    }
+    queryResult(t) {
+        return this.pending || (this.loaded = !1, this.body.replaceChildren()), this.data = t, this;
+    }
+    update() {
+        const {
+            body: t,
+            formats: n,
+            data: r,
+            schema: i,
+            limit: s
+        } = this, o = i.length;
+        let a = 0;
+        for (const c of r) {
+            ++a;
+            const u = document.createElement("tr");
+            for (let l = 0; l < o; ++l) {
+                const f = c[i[l].column],
+                    h = document.createElement("td");
+                h.innerText = f == null ? "" : n[l](f), u.appendChild(h);
+            }
+            t.appendChild(u);
+        }
+        return a < s && (this.loaded = !0), this.pending = !1, this;
+    }
+    sort(t, n) {
+        n === this.sortColumn ? this.sortDesc = !this.sortDesc : (this.sortColumn = n, this.sortDesc = !1);
+        const r = t.currentTarget,
+            i = this.sortHeader;
+        i === r && t.metaKey ? (i.firstChild.textContent = "", this.sortHeader = null, this.sortColumn = null) : (i && (i.firstChild.textContent = ""), this.sortHeader = r, r.firstChild.textContent = this.sortDesc ? "" : ""), this.requestData();
+    }
+}
 
-function Trt(e = {}, t, n) {
+function TK(e = {}, t, n) {
     return t.map(({
-        column: i,
-        type: r
+        column: r,
+        type: i
     }) => {
-        if (i in e)
-            return e[i];
-        switch (r) {
+        if (r in e)
+            return e[r];
+        switch (i) {
             case "number":
-                return jv(n);
+                return E1(n);
             case "date":
-                return qN;
+                return F8;
             default:
-                return jN(n);
+                return R8(n);
         }
     });
 }
 
-function Drt(e = {}, t) {
+function EK(e = {}, t) {
     return t.map(({
         column: n,
-        type: i
-    }) => n in e ? e[n] : i === "number" ? "right" : "left");
+        type: r
+    }) => n in e ? e[n] : r === "number" ? "right" : "left");
 }
 
-function Nrt(e = {}, t) {
+function NK(e = {}, t) {
     return t.map(({
         column: n
     }) => e[n]);
 }
 
-function Brt(e, t, n) {
-    const i = [];
-    return t.forEach((r, s) => {
+function DK(e, t, n) {
+    const r = [];
+    return t.forEach((i, s) => {
         const o = +n[s];
-        if (r !== "left" || o) {
-            const a = r !== "left" ? `text-align:${r};` : "",
+        if (i !== "left" || o) {
+            const a = i !== "left" ? `text-align:${i};` : "",
                 c = o ? `width:${o}px;max-width:${o}px;` : "";
-            i.push(`#${e} tr>:nth-child(${s + 1}) {${a}${c}}`);
+            r.push(`#${e} tr>:nth-child(${s + 1}) {${a}${c}}`);
         }
-    }), i.join(" ");
+    }), r.join(" ");
 }
 
-function YN(e, ...t) {
-    var i;
-    const n = ((i = e == null ? void 0 : e.context) == null ? void 0 : i.coordinator) ?? Wr();
-    for (const r of t)
-        n.connect(r);
+function C8(e, ...t) {
+    var r;
+    const n = ((r = e == null ? void 0 : e.context) == null ? void 0 : r.coordinator) ?? Wr();
+    for (const i of t)
+        n.connect(i);
 }
 
-function G0(e, t, n) {
-    const i = new t(n);
-    return YN(e, i), i.element;
+function Yd(e, t, n) {
+    const r = new t(n);
+    return C8(e, r), r.element;
 }
 
-function Ort(e) {
-    return G0(this, vrt, e);
+function OK(e) {
+    return Yd(this, _K, e);
 }
 
-function Frt(e) {
-    return G0(this, Srt, e);
+function LK(e) {
+    return Yd(this, SK, e);
 }
 
-function Ert(e) {
-    return G0(this, Art, e);
+function kK(e) {
+    return Yd(this, AK, e);
 }
 
-function Lrt(e) {
-    return G0(this, $rt, e);
+function RK(e) {
+    return Yd(this, IK, e);
 }
 
-function WN({
+function P8({
     direction: e = "vertical",
     wrap: t = !1
 }, n) {
-    const i = document.createElement("div");
-    return i.style.display = "flex", i.style.flexDirection = e === "vertical" ? "column" : "row", i.style.flexWrap = t ? t === !0 ? "wrap" : t : "nowrap", i.style.justifyContent = "flex-start", i.style.alignItems = "flex-start", n.forEach((r) => i.appendChild(r)), i.value = {
-        element: i
-    }, i;
+    const r = document.createElement("div");
+    return r.style.display = "flex", r.style.flexDirection = e === "vertical" ? "column" : "row", r.style.flexWrap = t ? t === !0 ? "wrap" : t : "nowrap", r.style.justifyContent = "flex-start", r.style.alignItems = "flex-start", n.forEach((i) => r.appendChild(i)), Object.assign(r, {
+        value: {
+            element: r
+        }
+    }), r;
 }
 
-function Rrt(...e) {
-    return WN({
+function FK(...e) {
+    return P8({
         direction: "vertical"
     }, e.flat());
 }
 
-function Crt(...e) {
-    return WN({
+function BK(...e) {
+    return P8({
         direction: "horizontal"
     }, e.flat());
 }
 
-function GN({
+function U8({
     dim: e = "width",
     size: t = 10
 }) {
     const n = document.createElement("span");
-    n.style.display = "inline-block", n.style[e] = Number.isNaN(+t) ? t : `${t}px`;
-    const i = {
-        element: n
-    };
-    return n.value = i, n;
+    return n.style.display = "inline-block", n.style[e] = Number.isNaN(+t) ? t : `${t}px`, Object.assign(n, {
+        value: {
+            element: n
+        }
+    });
 }
 
-function krt(e) {
-    return GN({
+function CK(e) {
+    return U8({
         dim: "height",
         size: e
     });
 }
 
-function Urt(e) {
-    return GN({
+function PK(e) {
+    return U8({
         dim: "width",
         size: e
     });
 }
-class XN extends Map {
+class z8 extends Map {
     request(t, n) {
         if (this.has(t))
             n(this.get(t));
         else {
-            const i = this.waiting || (this.waiting = /* @__PURE__ */ new Map()),
-                r = i.get(t) || [];
-            i.set(t, r.concat(n));
+            const r = this.waiting || (this.waiting = /* @__PURE__ */ new Map()),
+                i = r.get(t) || [];
+            r.set(t, i.concat(n));
         }
     }
     set(t, n) {
         this.has(t) && console.warn(`Overwriting named plot "${t}".`);
         const {
-            waiting: i
+            waiting: r
         } = this;
-        return i != null && i.has(t) && (i.get(t).forEach((r) => r(n)), i.delete(t)), super.set(t, n);
+        return r != null && r.has(t) && (r.get(t).forEach((i) => i(n)), r.delete(t)), super.set(t, n);
+    }
+    clear() {
+        var t;
+        return (t = this.waiting) == null || t.clear(), super.clear();
     }
 }
-const Yv = new XN();
+const N1 = new z8();
 
-function zrt(e, t, n) {
-    var r;
-    (((r = e == null ? void 0 : e.context) == null ? void 0 : r.namedPlots) ?? Yv).request(t, n);
+function UK(e, t, n) {
+    var i;
+    (((i = e == null ? void 0 : e.context) == null ? void 0 : i.namedPlots) ?? N1).request(t, n);
 }
 
-function Prt(e, t, n) {
-    var r;
-    (((r = e == null ? void 0 : e.context) == null ? void 0 : r.namedPlots) ?? Yv).set(t, n);
+function zK(e, t, n) {
+    var i;
+    (((i = e == null ? void 0 : e.context) == null ? void 0 : i.namedPlots) ?? N1).set(t, n);
 }
 
-function HN(e) {
-    return (t) => Prt(this, e, t);
+function q8(e) {
+    return (t) => zK(this, e, t);
 }
 
-function JN(e, t, n) {
-    Us(n) ? (n.addEventListener("value", (i) => {
-        e.setAttribute(t, i), e.update();
+function j8(e, t, n) {
+    Oi(n) ? (n.addEventListener("value", (r) => {
+        e.setAttribute(t, r), e.update();
     }), n.value !== void 0 && e.setAttribute(t, n.value)) : e.setAttribute(t, n);
 }
 
-function Vrt(e, t) {
+function qK(e, t) {
     return (n) => {
-        JN(n, e, t);
+        j8(n, e, t);
     };
 }
 
-function Wv(e) {
+function D1(e) {
     return (t) => {
-        for (const [n, i] of Object.entries(e))
-            JN(t, n, i);
+        for (const [n, r] of Object.entries(e))
+            j8(t, n, r);
     };
 }
 
-function KN(e) {
+function V8(e) {
     const {
         top: t,
         bottom: n,
-        left: i,
-        right: r
+        left: r,
+        right: i
     } = e, s = {};
-    return t !== void 0 && (s.marginTop = t), n !== void 0 && (s.marginBottom = n), i !== void 0 && (s.marginLeft = i), r !== void 0 && (s.marginRight = r), Wv(s);
+    return t !== void 0 && (s.marginTop = t), n !== void 0 && (s.marginBottom = n), r !== void 0 && (s.marginLeft = r), i !== void 0 && (s.marginRight = i), D1(s);
 }
 
-function ZN(e) {
-    return Wv({
+function Y8(e) {
+    return D1({
         marginTop: e,
         marginBottom: e,
         marginLeft: e,
         marginRight: e
     });
 }
 
-function QN(e) {
-    return Wv({
+function W8(e) {
+    return D1({
         xDomain: e,
         yDomain: e
     });
 }
-const O = (e) => (t) => Vrt(e, t),
-    tB = O("style"),
-    eB = O("width"),
-    nB = O("height"),
-    iB = O("marginLeft"),
-    rB = O("marginRight"),
-    sB = O("marginTop"),
-    oB = O("marginBottom"),
-    aB = O("align"),
-    cB = O("aspectRatio"),
-    lB = O("axis"),
-    uB = O("inset"),
-    fB = O("grid"),
-    hB = O("label"),
-    dB = O("padding"),
-    pB = O("round"),
-    yB = O("xScale"),
-    mB = O("xDomain"),
-    gB = O("xRange"),
-    bB = O("xNice"),
-    wB = O("xInset"),
-    vB = O("xInsetLeft"),
-    _B = O("xInsetRight"),
-    xB = O("xClamp"),
-    SB = O("xRound"),
-    IB = O("xAlign"),
-    AB = O("xPadding"),
-    MB = O("xPaddingInner"),
-    $B = O("xPaddingOuter"),
-    TB = O("xAxis"),
-    DB = O("xTicks"),
-    NB = O("xTickSize"),
-    BB = O("xTickSpacing"),
-    OB = O("xTickPadding"),
-    FB = O("xTickFormat"),
-    EB = O("xTickRotate"),
-    LB = O("xGrid"),
-    RB = O("xLine"),
-    CB = O("xLabel"),
-    kB = O("xLabelAnchor"),
-    UB = O("xLabelOffset"),
-    zB = O("xFontVariant"),
-    PB = O("xAriaLabel"),
-    VB = O("xAriaDescription"),
-    jB = O("xReverse"),
-    qB = O("xZero"),
-    YB = O("xBase"),
-    WB = O("xExponent"),
-    GB = O("xConstant"),
-    XB = O("yScale"),
-    HB = O("yDomain"),
-    JB = O("yRange"),
-    KB = O("yNice"),
-    ZB = O("yInset"),
-    QB = O("yInsetTop"),
-    tO = O("yInsetBottom"),
-    eO = O("yClamp"),
-    nO = O("yRound"),
-    iO = O("yAlign"),
-    rO = O("yPadding"),
-    sO = O("yPaddingInner"),
-    oO = O("yPaddingOuter"),
-    aO = O("yAxis"),
-    cO = O("yTicks"),
-    lO = O("yTickSize"),
-    uO = O("yTickSpacing"),
-    fO = O("yTickPadding"),
-    hO = O("yTickFormat"),
-    dO = O("yTickRotate"),
-    pO = O("yGrid"),
-    yO = O("yLine"),
-    mO = O("yLabel"),
-    gO = O("yLabelAnchor"),
-    bO = O("yLabelOffset"),
-    wO = O("yFontVariant"),
-    vO = O("yAriaLabel"),
-    _O = O("yAriaDescription"),
-    xO = O("yReverse"),
-    SO = O("yZero"),
-    IO = O("yBase"),
-    AO = O("yExponent"),
-    MO = O("yConstant"),
-    $O = O("facetMargin"),
-    TO = O("facetMarginTop"),
-    DO = O("facetMarginBottom"),
-    NO = O("facetMarginLeft"),
-    BO = O("facetMarginRight"),
-    OO = O("facetGrid"),
-    FO = O("facetLabel"),
-    EO = O("fxDomain"),
-    LO = O("fxRange"),
-    RO = O("fxNice"),
-    CO = O("fxInset"),
-    kO = O("fxInsetLeft"),
-    UO = O("fxInsetRight"),
-    zO = O("fxRound"),
-    PO = O("fxAlign"),
-    VO = O("fxPadding"),
-    jO = O("fxPaddingInner"),
-    qO = O("fxPaddingOuter"),
-    YO = O("fxAxis"),
-    WO = O("fxTicks"),
-    GO = O("fxTickSize"),
-    XO = O("fxTickSpacing"),
-    HO = O("fxTickPadding"),
-    JO = O("fxTickFormat"),
-    KO = O("fxTickRotate"),
-    ZO = O("fxGrid"),
-    QO = O("fxLine"),
-    tF = O("fxLabel"),
-    eF = O("fxLabelAnchor"),
-    nF = O("fxLabelOffset"),
-    iF = O("fxFontVariant"),
-    rF = O("fxAriaLabel"),
-    sF = O("fxAriaDescription"),
-    oF = O("fxReverse"),
-    aF = O("fyDomain"),
-    cF = O("fyRange"),
-    lF = O("fyNice"),
-    uF = O("fyInset"),
-    fF = O("fyInsetTop"),
-    hF = O("fyInsetBottom"),
-    dF = O("fyRound"),
-    pF = O("fyAlign"),
-    yF = O("fyPadding"),
-    mF = O("fyPaddingInner"),
-    gF = O("fyPaddingOuter"),
-    bF = O("fyAxis"),
-    wF = O("fyTicks"),
-    vF = O("fyTickSize"),
-    _F = O("fyTickSpacing"),
-    xF = O("fyTickPadding"),
-    SF = O("fyTickFormat"),
-    IF = O("fyTickRotate"),
-    AF = O("fyGrid"),
-    MF = O("fyLine"),
-    $F = O("fyLabel"),
-    TF = O("fyLabelAnchor"),
-    DF = O("fyLabelOffset"),
-    NF = O("fyFontVariant"),
-    BF = O("fyAriaLabel"),
-    OF = O("fyAriaDescription"),
-    FF = O("fyReverse"),
-    EF = O("colorScale"),
-    LF = O("colorDomain"),
-    RF = O("colorRange"),
-    CF = O("colorClamp"),
-    kF = O("colorN"),
-    UF = O("colorNice"),
-    zF = O("colorScheme"),
-    PF = O("colorInterpolate"),
-    VF = O("colorPivot"),
-    jF = O("colorSymmetric"),
-    qF = O("colorLabel"),
-    YF = O("colorReverse"),
-    WF = O("colorZero"),
-    GF = O("colorTickFormat"),
-    XF = O("colorBase"),
-    HF = O("colorExponent"),
-    JF = O("colorConstant"),
-    KF = O("opacityScale"),
-    ZF = O("opacityDomain"),
-    QF = O("opacityRange"),
-    tE = O("opacityClamp"),
-    eE = O("opacityNice"),
-    nE = O("opacityLabel"),
-    iE = O("opacityReverse"),
-    rE = O("opacityZero"),
-    sE = O("opacityTickFormat"),
-    oE = O("opacityBase"),
-    aE = O("opacityExponent"),
-    cE = O("opacityConstant"),
-    lE = O("rScale"),
+const O = (e) => (t) => qK(e, t),
+    X8 = O("style"),
+    G8 = O("width"),
+    H8 = O("height"),
+    J8 = O("marginLeft"),
+    Z8 = O("marginRight"),
+    K8 = O("marginTop"),
+    Q8 = O("marginBottom"),
+    t5 = O("align"),
+    e5 = O("aspectRatio"),
+    n5 = O("axis"),
+    r5 = O("inset"),
+    i5 = O("grid"),
+    s5 = O("label"),
+    o5 = O("padding"),
+    a5 = O("xScale"),
+    c5 = O("xDomain"),
+    u5 = O("xRange"),
+    l5 = O("xNice"),
+    f5 = O("xInset"),
+    h5 = O("xInsetLeft"),
+    d5 = O("xInsetRight"),
+    p5 = O("xClamp"),
+    y5 = O("xRound"),
+    m5 = O("xAlign"),
+    g5 = O("xPadding"),
+    b5 = O("xPaddingInner"),
+    w5 = O("xPaddingOuter"),
+    v5 = O("xAxis"),
+    _5 = O("xTicks"),
+    x5 = O("xTickSize"),
+    S5 = O("xTickSpacing"),
+    M5 = O("xTickPadding"),
+    A5 = O("xTickFormat"),
+    $5 = O("xTickRotate"),
+    I5 = O("xGrid"),
+    T5 = O("xLine"),
+    E5 = O("xLabel"),
+    N5 = O("xLabelAnchor"),
+    D5 = O("xLabelArrow"),
+    O5 = O("xLabelOffset"),
+    L5 = O("xFontVariant"),
+    k5 = O("xAriaLabel"),
+    R5 = O("xAriaDescription"),
+    F5 = O("xPercent"),
+    B5 = O("xReverse"),
+    C5 = O("xZero"),
+    P5 = O("xBase"),
+    U5 = O("xExponent"),
+    z5 = O("xConstant"),
+    q5 = O("yScale"),
+    j5 = O("yDomain"),
+    V5 = O("yRange"),
+    Y5 = O("yNice"),
+    W5 = O("yInset"),
+    X5 = O("yInsetTop"),
+    G5 = O("yInsetBottom"),
+    H5 = O("yClamp"),
+    J5 = O("yRound"),
+    Z5 = O("yAlign"),
+    K5 = O("yPadding"),
+    Q5 = O("yPaddingInner"),
+    tI = O("yPaddingOuter"),
+    eI = O("yAxis"),
+    nI = O("yTicks"),
+    rI = O("yTickSize"),
+    iI = O("yTickSpacing"),
+    sI = O("yTickPadding"),
+    oI = O("yTickFormat"),
+    aI = O("yTickRotate"),
+    cI = O("yGrid"),
+    uI = O("yLine"),
+    lI = O("yLabel"),
+    fI = O("yLabelAnchor"),
+    hI = O("yLabelArrow"),
+    dI = O("yLabelOffset"),
+    pI = O("yFontVariant"),
+    yI = O("yAriaLabel"),
+    mI = O("yAriaDescription"),
+    gI = O("yPercent"),
+    bI = O("yReverse"),
+    wI = O("yZero"),
+    vI = O("yBase"),
+    _I = O("yExponent"),
+    xI = O("yConstant"),
+    SI = O("facetMargin"),
+    MI = O("facetMarginTop"),
+    AI = O("facetMarginBottom"),
+    $I = O("facetMarginLeft"),
+    II = O("facetMarginRight"),
+    TI = O("facetGrid"),
+    EI = O("facetLabel"),
+    NI = O("fxDomain"),
+    DI = O("fxRange"),
+    OI = O("fxInset"),
+    LI = O("fxInsetLeft"),
+    kI = O("fxInsetRight"),
+    RI = O("fxRound"),
+    FI = O("fxAlign"),
+    BI = O("fxPadding"),
+    CI = O("fxPaddingInner"),
+    PI = O("fxPaddingOuter"),
+    UI = O("fxAxis"),
+    zI = O("fxTicks"),
+    qI = O("fxTickSize"),
+    jI = O("fxTickSpacing"),
+    VI = O("fxTickPadding"),
+    YI = O("fxTickFormat"),
+    WI = O("fxTickRotate"),
+    XI = O("fxGrid"),
+    GI = O("fxLine"),
+    HI = O("fxLabel"),
+    JI = O("fxLabelAnchor"),
+    ZI = O("fxLabelOffset"),
+    KI = O("fxFontVariant"),
+    QI = O("fxAriaLabel"),
+    tT = O("fxAriaDescription"),
+    eT = O("fxReverse"),
+    nT = O("fyDomain"),
+    rT = O("fyRange"),
+    iT = O("fyInset"),
+    sT = O("fyInsetTop"),
+    oT = O("fyInsetBottom"),
+    aT = O("fyRound"),
+    cT = O("fyAlign"),
+    uT = O("fyPadding"),
+    lT = O("fyPaddingInner"),
+    fT = O("fyPaddingOuter"),
+    hT = O("fyAxis"),
+    dT = O("fyTicks"),
+    pT = O("fyTickSize"),
+    yT = O("fyTickSpacing"),
+    mT = O("fyTickPadding"),
+    gT = O("fyTickFormat"),
+    bT = O("fyTickRotate"),
+    wT = O("fyGrid"),
+    vT = O("fyLine"),
+    _T = O("fyLabel"),
+    xT = O("fyLabelAnchor"),
+    ST = O("fyLabelOffset"),
+    MT = O("fyFontVariant"),
+    AT = O("fyAriaLabel"),
+    $T = O("fyAriaDescription"),
+    IT = O("fyReverse"),
+    TT = O("colorScale"),
+    ET = O("colorDomain"),
+    NT = O("colorRange"),
+    DT = O("colorClamp"),
+    OT = O("colorN"),
+    LT = O("colorNice"),
+    kT = O("colorScheme"),
+    RT = O("colorInterpolate"),
+    FT = O("colorPivot"),
+    BT = O("colorSymmetric"),
+    CT = O("colorLabel"),
+    PT = O("colorPercent"),
+    UT = O("colorReverse"),
+    zT = O("colorZero"),
+    qT = O("colorTickFormat"),
+    jT = O("colorBase"),
+    VT = O("colorExponent"),
+    YT = O("colorConstant"),
+    WT = O("opacityScale"),
+    XT = O("opacityDomain"),
+    GT = O("opacityRange"),
+    HT = O("opacityClamp"),
+    JT = O("opacityNice"),
+    ZT = O("opacityLabel"),
+    KT = O("opacityPercent"),
+    QT = O("opacityReverse"),
+    tE = O("opacityZero"),
+    eE = O("opacityTickFormat"),
+    nE = O("opacityBase"),
+    rE = O("opacityExponent"),
+    iE = O("opacityConstant"),
+    sE = O("symbolScale"),
+    oE = O("symbolDomain"),
+    aE = O("symbolRange"),
+    cE = O("rScale"),
     uE = O("rDomain"),
-    fE = O("rRange"),
-    hE = O("rClamp"),
-    dE = O("rNice"),
+    lE = O("rRange"),
+    fE = O("rClamp"),
+    hE = O("rNice"),
+    dE = O("rPercent"),
     pE = O("rZero"),
     yE = O("rBase"),
     mE = O("rExponent"),
     gE = O("rConstant"),
     bE = O("lengthScale"),
     wE = O("lengthDomain"),
     vE = O("lengthRange"),
     _E = O("lengthClamp"),
     xE = O("lengthNice"),
-    SE = O("lengthZero"),
-    IE = O("lengthBase"),
-    AE = O("lengthExponent"),
-    ME = O("lengthConstant"),
-    $E = O("projectionType"),
-    TE = O("projectionParallels"),
-    DE = O("projectionPrecision"),
-    NE = O("projectionRotate"),
-    BE = O("projectionDomain"),
-    OE = O("projectionInset"),
-    FE = O("projectionInsetLeft"),
-    EE = O("projectionInsetRight"),
-    LE = O("projectionInsetTop"),
-    RE = O("projectionInsetBottom"),
+    SE = O("lengthPercent"),
+    ME = O("lengthZero"),
+    AE = O("lengthBase"),
+    $E = O("lengthExponent"),
+    IE = O("lengthConstant"),
+    TE = O("projectionType"),
+    EE = O("projectionParallels"),
+    NE = O("projectionPrecision"),
+    DE = O("projectionRotate"),
+    OE = O("projectionDomain"),
+    LE = O("projectionInset"),
+    kE = O("projectionInsetLeft"),
+    RE = O("projectionInsetRight"),
+    FE = O("projectionInsetTop"),
+    BE = O("projectionInsetBottom"),
     CE = O("projectionClip"),
-    jrt = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+    jK = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
         __proto__: null,
-        align: aB,
-        aspectRatio: cB,
-        axis: lB,
-        colorBase: XF,
-        colorClamp: CF,
-        colorConstant: JF,
-        colorDomain: LF,
-        colorExponent: HF,
-        colorInterpolate: PF,
-        colorLabel: qF,
-        colorN: kF,
-        colorNice: UF,
-        colorPivot: VF,
-        colorRange: RF,
-        colorReverse: YF,
-        colorScale: EF,
-        colorScheme: zF,
-        colorSymmetric: jF,
-        colorTickFormat: GF,
-        colorZero: WF,
-        facetGrid: OO,
-        facetLabel: FO,
-        facetMargin: $O,
-        facetMarginBottom: DO,
-        facetMarginLeft: NO,
-        facetMarginRight: BO,
-        facetMarginTop: TO,
-        fxAlign: PO,
-        fxAriaDescription: sF,
-        fxAriaLabel: rF,
-        fxAxis: YO,
-        fxDomain: EO,
-        fxFontVariant: iF,
-        fxGrid: ZO,
-        fxInset: CO,
-        fxInsetLeft: kO,
-        fxInsetRight: UO,
-        fxLabel: tF,
-        fxLabelAnchor: eF,
-        fxLabelOffset: nF,
-        fxLine: QO,
-        fxNice: RO,
-        fxPadding: VO,
-        fxPaddingInner: jO,
-        fxPaddingOuter: qO,
-        fxRange: LO,
-        fxReverse: oF,
-        fxRound: zO,
-        fxTickFormat: JO,
-        fxTickPadding: HO,
-        fxTickRotate: KO,
-        fxTickSize: GO,
-        fxTickSpacing: XO,
-        fxTicks: WO,
-        fyAlign: pF,
-        fyAriaDescription: OF,
-        fyAriaLabel: BF,
-        fyAxis: bF,
-        fyDomain: aF,
-        fyFontVariant: NF,
-        fyGrid: AF,
-        fyInset: uF,
-        fyInsetBottom: hF,
-        fyInsetTop: fF,
-        fyLabel: $F,
-        fyLabelAnchor: TF,
-        fyLabelOffset: DF,
-        fyLine: MF,
-        fyNice: lF,
-        fyPadding: yF,
-        fyPaddingInner: mF,
-        fyPaddingOuter: gF,
-        fyRange: cF,
-        fyReverse: FF,
-        fyRound: dF,
-        fyTickFormat: SF,
-        fyTickPadding: xF,
-        fyTickRotate: IF,
-        fyTickSize: vF,
-        fyTickSpacing: _F,
-        fyTicks: wF,
-        grid: fB,
-        height: nB,
-        inset: uB,
-        label: hB,
-        lengthBase: IE,
+        align: t5,
+        aspectRatio: e5,
+        axis: n5,
+        colorBase: jT,
+        colorClamp: DT,
+        colorConstant: YT,
+        colorDomain: ET,
+        colorExponent: VT,
+        colorInterpolate: RT,
+        colorLabel: CT,
+        colorN: OT,
+        colorNice: LT,
+        colorPercent: PT,
+        colorPivot: FT,
+        colorRange: NT,
+        colorReverse: UT,
+        colorScale: TT,
+        colorScheme: kT,
+        colorSymmetric: BT,
+        colorTickFormat: qT,
+        colorZero: zT,
+        facetGrid: TI,
+        facetLabel: EI,
+        facetMargin: SI,
+        facetMarginBottom: AI,
+        facetMarginLeft: $I,
+        facetMarginRight: II,
+        facetMarginTop: MI,
+        fxAlign: FI,
+        fxAriaDescription: tT,
+        fxAriaLabel: QI,
+        fxAxis: UI,
+        fxDomain: NI,
+        fxFontVariant: KI,
+        fxGrid: XI,
+        fxInset: OI,
+        fxInsetLeft: LI,
+        fxInsetRight: kI,
+        fxLabel: HI,
+        fxLabelAnchor: JI,
+        fxLabelOffset: ZI,
+        fxLine: GI,
+        fxPadding: BI,
+        fxPaddingInner: CI,
+        fxPaddingOuter: PI,
+        fxRange: DI,
+        fxReverse: eT,
+        fxRound: RI,
+        fxTickFormat: YI,
+        fxTickPadding: VI,
+        fxTickRotate: WI,
+        fxTickSize: qI,
+        fxTickSpacing: jI,
+        fxTicks: zI,
+        fyAlign: cT,
+        fyAriaDescription: $T,
+        fyAriaLabel: AT,
+        fyAxis: hT,
+        fyDomain: nT,
+        fyFontVariant: MT,
+        fyGrid: wT,
+        fyInset: iT,
+        fyInsetBottom: oT,
+        fyInsetTop: sT,
+        fyLabel: _T,
+        fyLabelAnchor: xT,
+        fyLabelOffset: ST,
+        fyLine: vT,
+        fyPadding: uT,
+        fyPaddingInner: lT,
+        fyPaddingOuter: fT,
+        fyRange: rT,
+        fyReverse: IT,
+        fyRound: aT,
+        fyTickFormat: gT,
+        fyTickPadding: mT,
+        fyTickRotate: bT,
+        fyTickSize: pT,
+        fyTickSpacing: yT,
+        fyTicks: dT,
+        grid: i5,
+        height: H8,
+        inset: r5,
+        label: s5,
+        lengthBase: AE,
         lengthClamp: _E,
-        lengthConstant: ME,
+        lengthConstant: IE,
         lengthDomain: wE,
-        lengthExponent: AE,
+        lengthExponent: $E,
         lengthNice: xE,
+        lengthPercent: SE,
         lengthRange: vE,
         lengthScale: bE,
-        lengthZero: SE,
-        margin: ZN,
-        marginBottom: oB,
-        marginLeft: iB,
-        marginRight: rB,
-        marginTop: sB,
-        margins: KN,
-        name: HN,
-        opacityBase: oE,
-        opacityClamp: tE,
-        opacityConstant: cE,
-        opacityDomain: ZF,
-        opacityExponent: aE,
-        opacityLabel: nE,
-        opacityNice: eE,
-        opacityRange: QF,
-        opacityReverse: iE,
-        opacityScale: KF,
-        opacityTickFormat: sE,
-        opacityZero: rE,
-        padding: dB,
+        lengthZero: ME,
+        margin: Y8,
+        marginBottom: Q8,
+        marginLeft: J8,
+        marginRight: Z8,
+        marginTop: K8,
+        margins: V8,
+        name: q8,
+        opacityBase: nE,
+        opacityClamp: HT,
+        opacityConstant: iE,
+        opacityDomain: XT,
+        opacityExponent: rE,
+        opacityLabel: ZT,
+        opacityNice: JT,
+        opacityPercent: KT,
+        opacityRange: GT,
+        opacityReverse: QT,
+        opacityScale: WT,
+        opacityTickFormat: eE,
+        opacityZero: tE,
+        padding: o5,
         projectionClip: CE,
-        projectionDomain: BE,
-        projectionInset: OE,
-        projectionInsetBottom: RE,
-        projectionInsetLeft: FE,
-        projectionInsetRight: EE,
-        projectionInsetTop: LE,
-        projectionParallels: TE,
-        projectionPrecision: DE,
-        projectionRotate: NE,
-        projectionType: $E,
+        projectionDomain: OE,
+        projectionInset: LE,
+        projectionInsetBottom: BE,
+        projectionInsetLeft: kE,
+        projectionInsetRight: RE,
+        projectionInsetTop: FE,
+        projectionParallels: EE,
+        projectionPrecision: NE,
+        projectionRotate: DE,
+        projectionType: TE,
         rBase: yE,
-        rClamp: hE,
+        rClamp: fE,
         rConstant: gE,
         rDomain: uE,
         rExponent: mE,
-        rNice: dE,
-        rRange: fE,
-        rScale: lE,
+        rNice: hE,
+        rPercent: dE,
+        rRange: lE,
+        rScale: cE,
         rZero: pE,
-        round: pB,
-        style: tB,
-        width: eB,
-        xAlign: IB,
-        xAriaDescription: VB,
-        xAriaLabel: PB,
-        xAxis: TB,
-        xBase: YB,
-        xClamp: xB,
-        xConstant: GB,
-        xDomain: mB,
-        xExponent: WB,
-        xFontVariant: zB,
-        xGrid: LB,
-        xInset: wB,
-        xInsetLeft: vB,
-        xInsetRight: _B,
-        xLabel: CB,
-        xLabelAnchor: kB,
-        xLabelOffset: UB,
-        xLine: RB,
-        xNice: bB,
-        xPadding: AB,
-        xPaddingInner: MB,
-        xPaddingOuter: $B,
-        xRange: gB,
-        xReverse: jB,
-        xRound: SB,
-        xScale: yB,
-        xTickFormat: FB,
-        xTickPadding: OB,
-        xTickRotate: EB,
-        xTickSize: NB,
-        xTickSpacing: BB,
-        xTicks: DB,
-        xZero: qB,
-        xyDomain: QN,
-        yAlign: iO,
-        yAriaDescription: _O,
-        yAriaLabel: vO,
-        yAxis: aO,
-        yBase: IO,
-        yClamp: eO,
-        yConstant: MO,
-        yDomain: HB,
-        yExponent: AO,
-        yFontVariant: wO,
-        yGrid: pO,
-        yInset: ZB,
-        yInsetBottom: tO,
-        yInsetTop: QB,
-        yLabel: mO,
-        yLabelAnchor: gO,
-        yLabelOffset: bO,
-        yLine: yO,
-        yNice: KB,
-        yPadding: rO,
-        yPaddingInner: sO,
-        yPaddingOuter: oO,
-        yRange: JB,
-        yReverse: xO,
-        yRound: nO,
-        yScale: XB,
-        yTickFormat: hO,
-        yTickPadding: fO,
-        yTickRotate: dO,
-        yTickSize: lO,
-        yTickSpacing: uO,
-        yTicks: cO,
-        yZero: SO
+        style: X8,
+        symbolDomain: oE,
+        symbolRange: aE,
+        symbolScale: sE,
+        width: G8,
+        xAlign: m5,
+        xAriaDescription: R5,
+        xAriaLabel: k5,
+        xAxis: v5,
+        xBase: P5,
+        xClamp: p5,
+        xConstant: z5,
+        xDomain: c5,
+        xExponent: U5,
+        xFontVariant: L5,
+        xGrid: I5,
+        xInset: f5,
+        xInsetLeft: h5,
+        xInsetRight: d5,
+        xLabel: E5,
+        xLabelAnchor: N5,
+        xLabelArrow: D5,
+        xLabelOffset: O5,
+        xLine: T5,
+        xNice: l5,
+        xPadding: g5,
+        xPaddingInner: b5,
+        xPaddingOuter: w5,
+        xPercent: F5,
+        xRange: u5,
+        xReverse: B5,
+        xRound: y5,
+        xScale: a5,
+        xTickFormat: A5,
+        xTickPadding: M5,
+        xTickRotate: $5,
+        xTickSize: x5,
+        xTickSpacing: S5,
+        xTicks: _5,
+        xZero: C5,
+        xyDomain: W8,
+        yAlign: Z5,
+        yAriaDescription: mI,
+        yAriaLabel: yI,
+        yAxis: eI,
+        yBase: vI,
+        yClamp: H5,
+        yConstant: xI,
+        yDomain: j5,
+        yExponent: _I,
+        yFontVariant: pI,
+        yGrid: cI,
+        yInset: W5,
+        yInsetBottom: G5,
+        yInsetTop: X5,
+        yLabel: lI,
+        yLabelAnchor: fI,
+        yLabelArrow: hI,
+        yLabelOffset: dI,
+        yLine: uI,
+        yNice: Y5,
+        yPadding: K5,
+        yPaddingInner: Q5,
+        yPaddingOuter: tI,
+        yPercent: gI,
+        yRange: V5,
+        yReverse: bI,
+        yRound: J5,
+        yScale: q5,
+        yTickFormat: oI,
+        yTickPadding: sI,
+        yTickRotate: aI,
+        yTickSize: rI,
+        yTickSpacing: iI,
+        yTicks: nI,
+        yZero: wI
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-function qrt(e, t) {
+function VK(e, t) {
     return {
         table: e,
         options: t
     };
 }
-const Yrt = /* @__PURE__ */ new Set([
+const YK = /* @__PURE__ */ new Set([
     "frame",
     "axisX",
     "axisY",
     "axisFx",
     "axisFy",
     "gridX",
     "gridY",
     "gridFx",
     "gridFy",
     "hexgrid",
     "graticule",
     "sphere"
 ]);
 
-function St(e, t, n = {}) {
-    arguments.length === 2 && !Array.isArray(t) && (n = t, t = Yrt.has(e) ? null : [{}]);
-    const i = e.startsWith("area") || e.startsWith("line") ? Qnt : ha;
-    return Gv(i, e, t, n);
+function dt(e, t, n = {}) {
+    arguments.length === 2 && !Array.isArray(t) && (n = t, t = YK.has(e) ? null : [{}]);
+    const r = e.startsWith("area") || e.startsWith("line") ? oZ : rs;
+    return Wd(r, e, t, n);
 }
 
-function Gv(e, t, n, i) {
-    return (r) => {
-        r.addMark(new e(t, n, i));
+function Wd(e, t, n, r) {
+    return (i) => {
+        i.addMark(new e(t, n, r));
     };
 }
 
-function ps(e, t, n) {
-    return (i) => {
-        i.addMark(new e(t, n));
+function Tr(e, t, n) {
+    return (r) => {
+        r.addMark(new e(t, n));
     };
 }
-const kE = (...e) => St("area", ...e),
-    UE = (...e) => St("areaX", ...e),
-    zE = (...e) => St("areaY", ...e),
-    PE = (...e) => St("line", ...e),
-    VE = (...e) => St("lineX", ...e),
-    jE = (...e) => St("lineY", ...e),
-    qE = (...e) => St("barX", ...e),
-    YE = (...e) => St("barY", ...e),
-    WE = (...e) => St("cell", ...e),
-    GE = (...e) => St("cellX", ...e),
-    XE = (...e) => St("cellY", ...e),
-    HE = (...e) => St("rect", ...e),
-    JE = (...e) => St("rectX", ...e),
-    KE = (...e) => St("rectY", ...e),
-    ZE = (...e) => St("dot", ...e),
-    QE = (...e) => St("dotX", ...e),
-    t5 = (...e) => St("dotY", ...e),
-    e5 = (...e) => St("circle", ...e),
-    n5 = (...e) => St("hexagon", ...e),
-    i5 = (...e) => St("text", ...e),
-    r5 = (...e) => St("textX", ...e),
-    s5 = (...e) => St("textY", ...e),
-    o5 = (...e) => St("ruleX", ...e),
-    a5 = (...e) => St("ruleY", ...e),
-    c5 = (...e) => St("tickX", ...e),
-    l5 = (...e) => St("tickY", ...e),
-    u5 = (...e) => St("vector", ...e),
-    f5 = (...e) => St("vectoX", ...e),
-    h5 = (...e) => St("vectorY", ...e),
-    d5 = (...e) => St("spike", ...e),
-    p5 = (...e) => St("image", ...e),
-    y5 = (...e) => Gv(kN, "areaX", ...e),
-    m5 = (...e) => Gv(kN, "areaY", ...e),
-    g5 = (...e) => ps(kit, ...e),
-    b5 = (...e) => ps(Eit, ...e),
-    w5 = (...e) => ps(xit, ...e),
-    v5 = (...e) => ps(Dit, ...e),
-    _5 = (...e) => ps(zv, ...e),
-    x5 = (...e) => ps(jit, ...e),
-    S5 = (...e) => ps(Vit, ...e),
-    I5 = (...e) => St("hexgrid", ...e),
-    A5 = (...e) => ps(Zit, ...e),
-    M5 = (...e) => St("voronoi", ...e),
-    $5 = (...e) => St("voronoiMesh", ...e),
-    T5 = (...e) => St("delaunayLink", ...e),
-    D5 = (...e) => St("delaunayMesh", ...e),
-    N5 = (...e) => St("hull", ...e),
-    B5 = (...e) => St("arrow", ...e),
-    O5 = (...e) => St("link", ...e),
-    F5 = (...e) => St("frame", ...e),
-    E5 = (...e) => St("axisX", ...e),
-    L5 = (...e) => St("axisY", ...e),
-    R5 = (...e) => St("axisFx", ...e),
-    C5 = (...e) => St("axisFy", ...e),
-    k5 = (...e) => St("gridX", ...e),
-    U5 = (...e) => St("gridY", ...e),
-    z5 = (...e) => St("gridFx", ...e),
-    P5 = (...e) => St("gridFy", ...e),
-    V5 = (...e) => ps(Pit, ...e),
-    j5 = (...e) => St("sphere", ...e),
-    q5 = (...e) => St("graticule", ...e),
-    Wrt = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+const PE = (...e) => dt("area", ...e),
+    UE = (...e) => dt("areaX", ...e),
+    zE = (...e) => dt("areaY", ...e),
+    qE = (...e) => dt("line", ...e),
+    jE = (...e) => dt("lineX", ...e),
+    VE = (...e) => dt("lineY", ...e),
+    YE = (...e) => dt("barX", ...e),
+    WE = (...e) => dt("barY", ...e),
+    XE = (...e) => dt("cell", ...e),
+    GE = (...e) => dt("cellX", ...e),
+    HE = (...e) => dt("cellY", ...e),
+    JE = (...e) => dt("rect", ...e),
+    ZE = (...e) => dt("rectX", ...e),
+    KE = (...e) => dt("rectY", ...e),
+    QE = (...e) => dt("dot", ...e),
+    t7 = (...e) => dt("dotX", ...e),
+    e7 = (...e) => dt("dotY", ...e),
+    n7 = (...e) => dt("circle", ...e),
+    r7 = (...e) => dt("hexagon", ...e),
+    i7 = (...e) => dt("text", ...e),
+    s7 = (...e) => dt("textX", ...e),
+    o7 = (...e) => dt("textY", ...e),
+    a7 = (...e) => dt("ruleX", ...e),
+    c7 = (...e) => dt("ruleY", ...e),
+    u7 = (...e) => dt("tickX", ...e),
+    l7 = (...e) => dt("tickY", ...e),
+    f7 = (...e) => dt("vector", ...e),
+    h7 = (...e) => dt("vectoX", ...e),
+    d7 = (...e) => dt("vectorY", ...e),
+    p7 = (...e) => dt("spike", ...e),
+    y7 = (...e) => dt("image", ...e),
+    m7 = (...e) => Wd(N8, "areaX", ...e),
+    g7 = (...e) => Wd(N8, "areaY", ...e),
+    b7 = (...e) => Tr(kZ, ...e),
+    w7 = (...e) => Tr(NZ, ...e),
+    v7 = (...e) => Tr(bZ, ...e),
+    _7 = (...e) => Tr(AZ, ...e),
+    x7 = (...e) => Tr(M1, ...e),
+    S7 = (...e) => Tr(jZ, ...e),
+    M7 = (...e) => Tr(qZ, ...e),
+    A7 = (...e) => dt("hexgrid", ...e),
+    $7 = (...e) => Tr(HZ, ...e),
+    I7 = (...e) => Wd(D8, "ruleY", ...e),
+    T7 = (...e) => Tr(D8, "ruleX", ...e),
+    E7 = (...e) => dt("voronoi", ...e),
+    N7 = (...e) => dt("voronoiMesh", ...e),
+    D7 = (...e) => dt("delaunayLink", ...e),
+    O7 = (...e) => dt("delaunayMesh", ...e),
+    L7 = (...e) => dt("hull", ...e),
+    k7 = (...e) => dt("arrow", ...e),
+    R7 = (...e) => dt("link", ...e),
+    F7 = (...e) => dt("frame", ...e),
+    B7 = (...e) => dt("axisX", ...e),
+    C7 = (...e) => dt("axisY", ...e),
+    P7 = (...e) => dt("axisFx", ...e),
+    U7 = (...e) => dt("axisFy", ...e),
+    z7 = (...e) => dt("gridX", ...e),
+    q7 = (...e) => dt("gridY", ...e),
+    j7 = (...e) => dt("gridFx", ...e),
+    V7 = (...e) => dt("gridFy", ...e),
+    Y7 = (...e) => Tr(zZ, ...e),
+    W7 = (...e) => dt("sphere", ...e),
+    X7 = (...e) => dt("graticule", ...e),
+    WK = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
         __proto__: null,
-        area: kE,
+        area: PE,
         areaX: UE,
         areaY: zE,
-        arrow: B5,
-        axisFx: R5,
-        axisFy: C5,
-        axisX: E5,
-        axisY: L5,
-        barX: qE,
-        barY: YE,
-        cell: WE,
+        arrow: k7,
+        axisFx: P7,
+        axisFy: U7,
+        axisX: B7,
+        axisY: C7,
+        barX: YE,
+        barY: WE,
+        cell: XE,
         cellX: GE,
-        cellY: XE,
-        circle: e5,
-        contour: w5,
-        delaunayLink: T5,
-        delaunayMesh: D5,
-        denseLine: b5,
-        density: g5,
-        densityX: y5,
-        densityY: m5,
-        dot: ZE,
-        dotX: QE,
-        dotY: t5,
-        frame: F5,
-        geo: V5,
-        graticule: q5,
-        gridFx: z5,
-        gridFy: P5,
-        gridX: k5,
-        gridY: U5,
-        heatmap: v5,
-        hexagon: n5,
-        hexbin: S5,
-        hexgrid: I5,
-        hull: N5,
-        image: p5,
-        line: PE,
-        lineX: VE,
-        lineY: jE,
-        link: O5,
-        raster: _5,
-        rasterTile: x5,
-        rect: HE,
-        rectX: JE,
+        cellY: HE,
+        circle: n7,
+        contour: v7,
+        delaunayLink: D7,
+        delaunayMesh: O7,
+        denseLine: w7,
+        density: b7,
+        densityX: m7,
+        densityY: g7,
+        dot: QE,
+        dotX: t7,
+        dotY: e7,
+        errorbarX: I7,
+        errorbarY: T7,
+        frame: F7,
+        geo: Y7,
+        graticule: X7,
+        gridFx: j7,
+        gridFy: V7,
+        gridX: z7,
+        gridY: q7,
+        heatmap: _7,
+        hexagon: r7,
+        hexbin: M7,
+        hexgrid: A7,
+        hull: L7,
+        image: y7,
+        line: qE,
+        lineX: jE,
+        lineY: VE,
+        link: R7,
+        raster: x7,
+        rasterTile: S7,
+        rect: JE,
+        rectX: ZE,
         rectY: KE,
-        regressionY: A5,
-        ruleX: o5,
-        ruleY: a5,
-        sphere: j5,
-        spike: d5,
-        text: i5,
-        textX: r5,
-        textY: s5,
-        tickX: c5,
-        tickY: l5,
-        vector: u5,
-        vectorX: f5,
-        vectorY: h5,
-        voronoi: M5,
-        voronoiMesh: $5
+        regressionY: $7,
+        ruleX: a7,
+        ruleY: c7,
+        sphere: W7,
+        spike: p7,
+        text: i7,
+        textX: s7,
+        textY: o7,
+        tickX: u7,
+        tickY: l7,
+        vector: f7,
+        vectorX: h7,
+        vectorY: d7,
+        voronoi: E7,
+        voronoiMesh: N7
     }, Symbol.toStringTag, {
         value: "Module"
     }));
 
-function ho(e, t) {
+function hi(e, t) {
     return (n) => {
-        const i = n.marks[n.marks.length - 1];
-        n.addInteractor(new e(i, t));
+        const r = n.marks[n.marks.length - 1];
+        n.addInteractor(new e(r, t));
     };
 }
 
-function Y5({
+function G7({
     by: e,
     ...t
 }) {
-    return ho(irt, {
+    return hi(tK, {
         selection: e,
         channels: t
     });
 }
 
-function Hf({
+function Ia({
     as: e,
     ...t
 }) {
-    return ho(VN, {
+    return hi(L8, {
         ...t,
         selection: e
     });
 }
 
-function W5(e) {
-    return Hf({
+function H7(e) {
+    return Ia({
         ...e,
         channels: ["x"]
     });
 }
 
-function G5(e) {
-    return Hf({
+function J7(e) {
+    return Ia({
         ...e,
         channels: ["y"]
     });
 }
 
-function X5(e) {
-    return Hf({
+function Z7(e) {
+    return Ia({
+        ...e,
+        channels: ["z"]
+    });
+}
+
+function K7(e) {
+    return Ia({
         ...e,
         channels: ["color"]
     });
 }
 
-function H5({
+function Q7({
     as: e,
     ...t
 }) {
-    return ho(PN, {
+    return hi(T1, {
         ...t,
         selection: e,
-        channel: "x"
+        pointer: "xy"
     });
 }
 
-function J5({
+function tN({
     as: e,
     ...t
 }) {
-    return ho(PN, {
+    return hi(T1, {
         ...t,
         selection: e,
-        channel: "y"
+        pointer: "x"
+    });
+}
+
+function eN({
+    as: e,
+    ...t
+}) {
+    return hi(T1, {
+        ...t,
+        selection: e,
+        pointer: "y"
     });
 }
 
-function K5({
+function nN({
     as: e,
     ...t
 }) {
-    return ho(zN, {
+    return hi(I1, {
         ...t,
         selection: e,
         channel: "x"
     });
 }
 
-function Z5({
+function rN({
     as: e,
     ...t
 }) {
-    return ho(zN, {
+    return hi(I1, {
         ...t,
         selection: e,
         channel: "y"
     });
 }
 
-function Q5({
+function iN({
     as: e,
     ...t
 }) {
-    return ho(crt, {
+    return hi(sK, {
         ...t,
         selection: e
     });
 }
 
-function yl(e) {
-    return ho(urt, e);
+function Ta(e) {
+    return hi(aK, e);
 }
 
-function tL(e = {}) {
-    return yl({
+function sN(e = {}) {
+    return Ta({
         ...e,
         zoom: !1
     });
 }
 
-function eL(e = {}) {
-    return yl({
+function oN(e = {}) {
+    return Ta({
         ...e,
         zoom: !1,
         pany: !1
     });
 }
 
-function nL(e = {}) {
-    return yl({
+function aN(e = {}) {
+    return Ta({
         ...e,
         zoom: !1,
         panx: !1
     });
 }
 
-function iL(e = {}) {
-    return yl(e);
+function cN(e = {}) {
+    return Ta(e);
 }
 
-function rL(e = {}) {
-    return yl({
+function uN(e = {}) {
+    return Ta({
         ...e,
         pany: !1
     });
 }
 
-function sL(e = {}) {
-    return yl({
+function lN(e = {}) {
+    return Ta({
         ...e,
         panx: !1
     });
 }
-const Grt = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+const XK = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
-    highlight: Y5,
-    intervalX: K5,
-    intervalXY: Q5,
-    intervalY: Z5,
-    nearestX: H5,
-    nearestY: J5,
-    pan: tL,
-    panX: eL,
-    panY: nL,
-    panZoom: iL,
-    panZoomX: rL,
-    panZoomY: sL,
-    toggle: Hf,
-    toggleColor: X5,
-    toggleX: W5,
-    toggleY: G5
+    highlight: G7,
+    intervalX: nN,
+    intervalXY: iN,
+    intervalY: rN,
+    nearest: Q7,
+    nearestX: tN,
+    nearestY: eN,
+    pan: sN,
+    panX: oN,
+    panY: aN,
+    panZoom: cN,
+    panZoomX: uN,
+    panZoomY: lN,
+    toggle: Ia,
+    toggleColor: K7,
+    toggleX: H7,
+    toggleY: J7,
+    toggleZ: Z7
 }, Symbol.toStringTag, {
     value: "Module"
 }));
 
-function Xv(e, t = {}) {
+function O1(e, t = {}) {
     if (t.for) {
         const {
             for: n,
-            ...i
-        } = t, r = new tI(e, i), s = typeof n, o = (a) => a.addLegend(r, !1);
-        return s === "string" ? zrt(this, n, o) : n.value && o(n.value), r.element;
+            ...r
+        } = t, i = new mv(e, r), s = typeof n, o = (a) => a.addLegend(i, !1);
+        return s === "string" ? UK(this, n, o) : n.value && o(n.value), i.element;
     } else
-        return (n) => n.addLegend(new tI(e, t));
+        return (n) => n.addLegend(new mv(e, t));
 }
 
-function oL(e) {
-    return Xv.call(this, "color", e);
+function fN(e) {
+    return O1.call(this, "color", e);
 }
 
-function aL(e) {
-    return Xv.call(this, "opacity", e);
+function hN(e) {
+    return O1.call(this, "opacity", e);
 }
 
-function cL(e) {
-    return Xv.call(this, "symbol", e);
+function dN(e) {
+    return O1.call(this, "symbol", e);
 }
-const Xrt = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+const GK = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
-    colorLegend: oL,
-    opacityLegend: aL,
-    symbolLegend: cL
+    colorLegend: fN,
+    opacityLegend: hN,
+    symbolLegend: dN
 }, Symbol.toStringTag, {
     value: "Module"
 }));
 
-function Hrt(...e) {
-    const t = new Ynt();
-    return e.flat().forEach((n) => n(t)), YN(this, ...t.marks), t.element;
+function HK(...e) {
+    const t = new JJ();
+    return e.flat().forEach((n) => n(t)), C8(this, ...t.marks), t.update(), t.element;
 }
-const Jrt = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
+const JK = /* @__PURE__ */ Object.freeze( /* @__PURE__ */ Object.defineProperty({
     __proto__: null,
-    Fixed: mf,
-    Param: Uo,
-    Query: Lt,
-    Selection: Xd,
-    agg: R9,
-    align: aB,
-    and: qs,
-    area: kE,
+    Fixed: ou,
+    Param: bs,
+    Query: xt,
+    Selection: _f,
+    agg: Tt,
+    align: t5,
+    and: Bi,
+    area: PE,
     areaX: UE,
     areaY: zE,
-    argmax: Ng,
-    argmin: Dg,
-    arrayAgg: lU,
-    arrow: B5,
-    aspectRatio: cB,
-    avg: U9,
-    axis: lB,
-    axisFx: R5,
-    axisFy: C5,
-    axisX: E5,
-    axisY: L5,
-    barX: qE,
-    barY: YE,
-    bin: grt,
-    cast: Lb,
-    castDouble: Bg,
-    castInteger: uU,
-    cell: WE,
+    argmax: m0,
+    argmin: y0,
+    arrayAgg: uL,
+    arrow: k7,
+    aspectRatio: e5,
+    avg: Dx,
+    axis: n5,
+    axisFx: P7,
+    axisFy: U7,
+    axisX: B7,
+    axisY: C7,
+    barX: YE,
+    barY: WE,
+    bin: bK,
+    cast: mm,
+    castDouble: g0,
+    castInteger: lL,
+    cell: XE,
     cellX: GE,
-    cellY: XE,
-    centroid: Rb,
-    centroidX: gU,
-    centroidY: bU,
-    circle: e5,
-    colorBase: XF,
-    colorClamp: CF,
-    colorConstant: JF,
-    colorDomain: LF,
-    colorExponent: HF,
-    colorInterpolate: PF,
-    colorLabel: qF,
-    colorLegend: oL,
-    colorN: kF,
-    colorNice: UF,
-    colorPivot: VF,
-    colorRange: RF,
-    colorReverse: YF,
-    colorScale: EF,
-    colorScheme: zF,
-    colorSymmetric: jF,
-    colorTickFormat: GF,
-    colorZero: WF,
-    column: Py,
-    contour: w5,
+    cellY: HE,
+    centroid: gm,
+    centroidX: gL,
+    centroidY: bL,
+    circle: n7,
+    colorBase: jT,
+    colorClamp: DT,
+    colorConstant: YT,
+    colorDomain: ET,
+    colorExponent: VT,
+    colorInterpolate: RT,
+    colorLabel: CT,
+    colorLegend: fN,
+    colorN: OT,
+    colorNice: LT,
+    colorPercent: PT,
+    colorPivot: FT,
+    colorRange: NT,
+    colorReverse: UT,
+    colorScale: TT,
+    colorScheme: kT,
+    colorSymmetric: BT,
+    colorTickFormat: qT,
+    colorZero: zT,
+    column: Bh,
+    contour: v7,
     coordinator: Wr,
-    corr: Z9,
-    count: ko,
-    covarPop: Q9,
-    create: yf,
-    cume_dist: D9,
-    dateDay: pU,
-    dateMonth: hU,
-    dateMonthDay: dU,
-    delaunayLink: T5,
-    delaunayMesh: D5,
-    denseLine: b5,
-    dense_rank: $9,
-    density: g5,
-    densityX: y5,
-    densityY: m5,
-    dot: ZE,
-    dotX: QE,
-    dotY: t5,
-    entropy: H9,
-    eq: jy,
-    facetGrid: OO,
-    facetLabel: FO,
-    facetMargin: $O,
-    facetMarginBottom: DO,
-    facetMarginLeft: NO,
-    facetMarginRight: BO,
-    facetMarginTop: TO,
-    first: oU,
-    first_value: F9,
-    frame: F5,
-    from: qrt,
-    fxAlign: PO,
-    fxAriaDescription: sF,
-    fxAriaLabel: rF,
-    fxAxis: YO,
-    fxDomain: EO,
-    fxFontVariant: iF,
-    fxGrid: ZO,
-    fxInset: CO,
-    fxInsetLeft: kO,
-    fxInsetRight: UO,
-    fxLabel: tF,
-    fxLabelAnchor: eF,
-    fxLabelOffset: nF,
-    fxLine: QO,
-    fxNice: RO,
-    fxPadding: VO,
-    fxPaddingInner: jO,
-    fxPaddingOuter: qO,
-    fxRange: LO,
-    fxReverse: oF,
-    fxRound: zO,
-    fxTickFormat: JO,
-    fxTickPadding: HO,
-    fxTickRotate: KO,
-    fxTickSize: GO,
-    fxTickSpacing: XO,
-    fxTicks: WO,
-    fyAlign: pF,
-    fyAriaDescription: OF,
-    fyAriaLabel: BF,
-    fyAxis: bF,
-    fyDomain: aF,
-    fyFontVariant: NF,
-    fyGrid: AF,
-    fyInset: uF,
-    fyInsetBottom: hF,
-    fyInsetTop: fF,
-    fyLabel: $F,
-    fyLabelAnchor: TF,
-    fyLabelOffset: DF,
-    fyLine: MF,
-    fyNice: lF,
-    fyPadding: yF,
-    fyPaddingInner: mF,
-    fyPaddingOuter: gF,
-    fyRange: cF,
-    fyReverse: FF,
-    fyRound: dF,
-    fyTickFormat: SF,
-    fyTickPadding: xF,
-    fyTickRotate: IF,
-    fyTickSize: vF,
-    fyTickSpacing: _F,
-    fyTicks: wF,
-    geo: V5,
-    geojson: WM,
-    graticule: q5,
-    grid: fB,
-    gridFx: z5,
-    gridFy: P5,
-    gridX: k5,
-    gridY: U5,
-    gt: jM,
-    gte: b9,
-    hconcat: Crt,
-    heatmap: v5,
-    height: nB,
-    hexagon: n5,
-    hexbin: S5,
-    hexgrid: I5,
-    highlight: Y5,
-    hspace: Urt,
-    hull: N5,
-    image: p5,
-    inset: uB,
-    intervalX: K5,
-    intervalXY: Q5,
-    intervalY: Z5,
-    isBetween: Tn,
-    isDistinct: w9,
-    isNotBetween: v9,
-    isNotDistinct: qM,
-    isNotNull: Tu,
-    isNull: Fb,
-    kurtosis: X9,
-    label: hB,
-    lag: B9,
-    last: aU,
-    last_value: E9,
-    lead: O9,
-    lengthBase: IE,
+    corr: ZO,
+    count: Di,
+    covarPop: QO,
+    covariance: KO,
+    create: su,
+    cume_dist: DO,
+    dateDay: pL,
+    dateMonth: hL,
+    dateMonthDay: dL,
+    delaunayLink: D7,
+    delaunayMesh: O7,
+    denseLine: w7,
+    dense_rank: EO,
+    density: b7,
+    densityX: m7,
+    densityY: g7,
+    dot: QE,
+    dotX: t7,
+    dotY: e7,
+    entropy: GO,
+    eq: wO,
+    errorbarX: I7,
+    errorbarY: T7,
+    facetGrid: TI,
+    facetLabel: EI,
+    facetMargin: SI,
+    facetMarginBottom: AI,
+    facetMarginLeft: $I,
+    facetMarginRight: II,
+    facetMarginTop: MI,
+    first: oL,
+    first_value: RO,
+    frame: F7,
+    from: VK,
+    fxAlign: FI,
+    fxAriaDescription: tT,
+    fxAriaLabel: QI,
+    fxAxis: UI,
+    fxDomain: NI,
+    fxFontVariant: KI,
+    fxGrid: XI,
+    fxInset: OI,
+    fxInsetLeft: LI,
+    fxInsetRight: kI,
+    fxLabel: HI,
+    fxLabelAnchor: JI,
+    fxLabelOffset: ZI,
+    fxLine: GI,
+    fxPadding: BI,
+    fxPaddingInner: CI,
+    fxPaddingOuter: PI,
+    fxRange: DI,
+    fxReverse: eT,
+    fxRound: RI,
+    fxTickFormat: YI,
+    fxTickPadding: VI,
+    fxTickRotate: WI,
+    fxTickSize: qI,
+    fxTickSpacing: jI,
+    fxTicks: zI,
+    fyAlign: cT,
+    fyAriaDescription: $T,
+    fyAriaLabel: AT,
+    fyAxis: hT,
+    fyDomain: nT,
+    fyFontVariant: MT,
+    fyGrid: wT,
+    fyInset: iT,
+    fyInsetBottom: oT,
+    fyInsetTop: sT,
+    fyLabel: _T,
+    fyLabelAnchor: xT,
+    fyLabelOffset: ST,
+    fyLine: vT,
+    fyPadding: uT,
+    fyPaddingInner: lT,
+    fyPaddingOuter: fT,
+    fyRange: rT,
+    fyReverse: IT,
+    fyRound: aT,
+    fyTickFormat: gT,
+    fyTickPadding: mT,
+    fyTickRotate: bT,
+    fyTickSize: pT,
+    fyTickSpacing: yT,
+    fyTicks: dT,
+    geo: Y7,
+    geojson: Lx,
+    graticule: X7,
+    grid: i5,
+    gridFx: j7,
+    gridFy: V7,
+    gridX: z7,
+    gridY: q7,
+    gt: Ex,
+    gte: vO,
+    hconcat: BK,
+    heatmap: _7,
+    height: H8,
+    hexagon: r7,
+    hexbin: M7,
+    hexgrid: A7,
+    highlight: G7,
+    hspace: PK,
+    hull: L7,
+    image: y7,
+    inset: r5,
+    intervalX: nN,
+    intervalXY: iN,
+    intervalY: rN,
+    isBetween: $n,
+    isDistinct: _O,
+    isNotBetween: xO,
+    isNotDistinct: ym,
+    isNotNull: Sc,
+    isNull: dm,
+    kurtosis: XO,
+    label: s5,
+    lag: LO,
+    last: aL,
+    last_value: FO,
+    lead: kO,
+    lengthBase: AE,
     lengthClamp: _E,
-    lengthConstant: ME,
+    lengthConstant: IE,
     lengthDomain: wE,
-    lengthExponent: AE,
+    lengthExponent: $E,
     lengthNice: xE,
+    lengthPercent: SE,
     lengthRange: vE,
     lengthScale: bE,
-    lengthZero: SE,
-    line: PE,
-    lineX: VE,
-    lineY: jE,
-    link: O5,
-    literal: tl,
-    loadCSV: TU,
-    loadExtension: XM,
-    loadJSON: DU,
-    loadObjects: OU,
-    loadParquet: NU,
-    loadSpatial: BU,
-    lt: Du,
-    lte: Nu,
-    mad: z9,
-    margin: ZN,
-    marginBottom: oB,
-    marginLeft: iB,
-    marginRight: rB,
-    marginTop: sB,
-    margins: KN,
-    max: $c,
-    median: V9,
-    menu: Ort,
-    min: Tc,
-    mode: q9,
-    name: HN,
-    nearestX: H5,
-    nearestY: J5,
-    neq: Eb,
-    not: g9,
-    nth_value: L9,
-    ntile: N9,
-    opacityBase: oE,
-    opacityClamp: tE,
-    opacityConstant: cE,
-    opacityDomain: ZF,
-    opacityExponent: aE,
-    opacityLabel: nE,
-    opacityLegend: aL,
-    opacityNice: eE,
-    opacityRange: QF,
-    opacityReverse: iE,
-    opacityScale: KF,
-    opacityTickFormat: sE,
-    opacityZero: rE,
-    or: Ob,
-    padding: dB,
-    pan: tL,
-    panX: eL,
-    panY: nL,
-    panZoom: iL,
-    panZoomX: rL,
-    panZoomY: sL,
-    percent_rank: T9,
-    plot: Hrt,
-    product: P9,
+    lengthZero: ME,
+    line: qE,
+    lineX: jE,
+    lineY: VE,
+    link: R7,
+    literal: Ph,
+    loadCSV: IL,
+    loadExtension: Rx,
+    loadJSON: TL,
+    loadObjects: DL,
+    loadParquet: EL,
+    loadSpatial: NL,
+    lt: Mc,
+    lte: Ac,
+    mad: UO,
+    margin: Y8,
+    marginBottom: Q8,
+    marginLeft: J8,
+    marginRight: Z8,
+    marginTop: K8,
+    margins: V8,
+    max: jo,
+    median: qO,
+    menu: OK,
+    min: Vo,
+    mode: VO,
+    name: q8,
+    nearest: Q7,
+    nearestX: tN,
+    nearestY: eN,
+    neq: pm,
+    not: bO,
+    nth_value: BO,
+    ntile: OO,
+    opacityBase: nE,
+    opacityClamp: HT,
+    opacityConstant: iE,
+    opacityDomain: XT,
+    opacityExponent: rE,
+    opacityLabel: ZT,
+    opacityLegend: hN,
+    opacityNice: JT,
+    opacityPercent: KT,
+    opacityRange: GT,
+    opacityReverse: QT,
+    opacityScale: WT,
+    opacityTickFormat: eE,
+    opacityZero: tE,
+    or: hm,
+    padding: o5,
+    pan: sN,
+    panX: oN,
+    panY: aN,
+    panZoom: cN,
+    panZoomX: uN,
+    panZoomY: lN,
+    percent_rank: NO,
+    plot: HK,
+    product: zO,
     projectionClip: CE,
-    projectionDomain: BE,
-    projectionInset: OE,
-    projectionInsetBottom: RE,
-    projectionInsetLeft: FE,
-    projectionInsetRight: EE,
-    projectionInsetTop: LE,
-    projectionParallels: TE,
-    projectionPrecision: DE,
-    projectionRotate: NE,
-    projectionType: $E,
-    quantile: j9,
+    projectionDomain: OE,
+    projectionInset: LE,
+    projectionInsetBottom: BE,
+    projectionInsetLeft: kE,
+    projectionInsetRight: RE,
+    projectionInsetTop: FE,
+    projectionParallels: EE,
+    projectionPrecision: NE,
+    projectionRotate: DE,
+    projectionType: TE,
+    quantile: jO,
     rBase: yE,
-    rClamp: hE,
+    rClamp: fE,
     rConstant: gE,
     rDomain: uE,
     rExponent: mE,
-    rNice: dE,
-    rRange: fE,
-    rScale: lE,
+    rNice: hE,
+    rPercent: dE,
+    rRange: lE,
+    rScale: cE,
     rZero: pE,
-    rank: M9,
-    raster: _5,
-    rasterTile: x5,
-    rect: HE,
-    rectX: JE,
+    rank: TO,
+    raster: x7,
+    rasterTile: S7,
+    rect: JE,
+    rectX: ZE,
     rectY: KE,
-    regressionY: A5,
-    round: pB,
-    row_number: A9,
-    ruleX: o5,
-    ruleY: a5,
-    search: Frt,
-    skewness: G9,
-    slider: Ert,
-    sphere: j5,
-    spike: d5,
-    sql: q,
-    stddev: W9,
-    stddevPop: K9,
-    stringAgg: cU,
-    style: tB,
-    sum: oa,
-    symbolLegend: cL,
-    table: Lrt,
-    text: i5,
-    textX: r5,
-    textY: s5,
-    tickX: c5,
-    tickY: l5,
-    toggle: Hf,
-    toggleColor: X5,
-    toggleX: W5,
-    toggleY: G5,
-    varPop: J9,
-    variance: Y9,
-    vconcat: Rrt,
-    vector: u5,
-    vectorX: f5,
-    vectorY: h5,
-    voronoi: M5,
-    voronoiMesh: $5,
-    vspace: krt,
-    width: eB,
-    xAlign: IB,
-    xAriaDescription: VB,
-    xAriaLabel: PB,
-    xAxis: TB,
-    xBase: YB,
-    xClamp: xB,
-    xConstant: GB,
-    xDomain: mB,
-    xExponent: WB,
-    xFontVariant: zB,
-    xGrid: LB,
-    xInset: wB,
-    xInsetLeft: vB,
-    xInsetRight: _B,
-    xLabel: CB,
-    xLabelAnchor: kB,
-    xLabelOffset: UB,
-    xLine: RB,
-    xNice: bB,
-    xPadding: AB,
-    xPaddingInner: MB,
-    xPaddingOuter: $B,
-    xRange: gB,
-    xReverse: jB,
-    xRound: SB,
-    xScale: yB,
-    xTickFormat: FB,
-    xTickPadding: OB,
-    xTickRotate: EB,
-    xTickSize: NB,
-    xTickSpacing: BB,
-    xTicks: DB,
-    xZero: qB,
-    xyDomain: QN,
-    yAlign: iO,
-    yAriaDescription: _O,
-    yAriaLabel: vO,
-    yAxis: aO,
-    yBase: IO,
-    yClamp: eO,
-    yConstant: MO,
-    yDomain: HB,
-    yExponent: AO,
-    yFontVariant: wO,
-    yGrid: pO,
-    yInset: ZB,
-    yInsetBottom: tO,
-    yInsetTop: QB,
-    yLabel: mO,
-    yLabelAnchor: gO,
-    yLabelOffset: bO,
-    yLine: yO,
-    yNice: KB,
-    yPadding: rO,
-    yPaddingInner: sO,
-    yPaddingOuter: oO,
-    yRange: JB,
-    yReverse: xO,
-    yRound: nO,
-    yScale: XB,
-    yTickFormat: hO,
-    yTickPadding: fO,
-    yTickRotate: dO,
-    yTickSize: lO,
-    yTickSpacing: uO,
-    yTicks: cO,
-    yZero: SO
+    regressionY: $7,
+    row_number: IO,
+    ruleX: a7,
+    ruleY: c7,
+    search: LK,
+    skewness: WO,
+    slider: kK,
+    sphere: W7,
+    spike: p7,
+    sql: j,
+    stddev: Ox,
+    stddevPop: JO,
+    stringAgg: cL,
+    style: X8,
+    sum: Cs,
+    symbolDomain: oE,
+    symbolLegend: dN,
+    symbolRange: aE,
+    symbolScale: sE,
+    table: RK,
+    text: i7,
+    textX: s7,
+    textY: o7,
+    tickX: u7,
+    tickY: l7,
+    toggle: Ia,
+    toggleColor: K7,
+    toggleX: H7,
+    toggleY: J7,
+    toggleZ: Z7,
+    varPop: HO,
+    variance: YO,
+    vconcat: FK,
+    vector: f7,
+    vectorX: h7,
+    vectorY: d7,
+    voronoi: E7,
+    voronoiMesh: N7,
+    vspace: CK,
+    width: G8,
+    xAlign: m5,
+    xAriaDescription: R5,
+    xAriaLabel: k5,
+    xAxis: v5,
+    xBase: P5,
+    xClamp: p5,
+    xConstant: z5,
+    xDomain: c5,
+    xExponent: U5,
+    xFontVariant: L5,
+    xGrid: I5,
+    xInset: f5,
+    xInsetLeft: h5,
+    xInsetRight: d5,
+    xLabel: E5,
+    xLabelAnchor: N5,
+    xLabelArrow: D5,
+    xLabelOffset: O5,
+    xLine: T5,
+    xNice: l5,
+    xPadding: g5,
+    xPaddingInner: b5,
+    xPaddingOuter: w5,
+    xPercent: F5,
+    xRange: u5,
+    xReverse: B5,
+    xRound: y5,
+    xScale: a5,
+    xTickFormat: A5,
+    xTickPadding: M5,
+    xTickRotate: $5,
+    xTickSize: x5,
+    xTickSpacing: S5,
+    xTicks: _5,
+    xZero: C5,
+    xyDomain: W8,
+    yAlign: Z5,
+    yAriaDescription: mI,
+    yAriaLabel: yI,
+    yAxis: eI,
+    yBase: vI,
+    yClamp: H5,
+    yConstant: xI,
+    yDomain: j5,
+    yExponent: _I,
+    yFontVariant: pI,
+    yGrid: cI,
+    yInset: W5,
+    yInsetBottom: G5,
+    yInsetTop: X5,
+    yLabel: lI,
+    yLabelAnchor: fI,
+    yLabelArrow: hI,
+    yLabelOffset: dI,
+    yLine: uI,
+    yNice: Y5,
+    yPadding: K5,
+    yPaddingInner: Q5,
+    yPaddingOuter: tI,
+    yPercent: gI,
+    yRange: V5,
+    yReverse: bI,
+    yRound: J5,
+    yScale: q5,
+    yTickFormat: oI,
+    yTickPadding: sI,
+    yTickRotate: aI,
+    yTickSize: rI,
+    yTickSpacing: iI,
+    yTicks: nI,
+    yZero: wI
 }, Symbol.toStringTag, {
     value: "Module"
 }));
 
-function Krt({
+function ZK({
     coordinator: e = Wr(),
-    namedPlots: t = new XN(),
+    namedPlots: t = new z8(),
     extensions: n = null,
-    ...i
+    ...r
 } = {}) {
     return {
-        ...Jrt,
+        ...JK,
         ...n,
         context: {
             coordinator: e,
             namedPlots: t,
-            ...i
+            ...r
         }
     };
 }
-const Zrt = "spec",
-    lL = "literal",
-    Qrt = "options",
-    tst = "selection",
-    est = "paramref",
-    nst = "param",
-    uL = "select",
-    Q1 = "value",
-    ist = "crossfilter",
-    fL = "intersect",
-    rst = "union",
-    sst = "single",
-    ost = "data",
-    ast = "expression",
-    bc = "sql",
-    Wo = "agg",
-    Hv = "input",
-    iy = "hconcat",
-    ry = "vconcat",
-    sy = "hspace",
-    oy = "vspace",
-    hL = "mark",
-    eI = "from",
-    ay = "plot",
-    Jv = "legend",
-    cst = "attribute",
-    lst = "transform",
-    ust = "interactor",
-    cd = "Fixed";
-class Oe {
+const KK = "spec",
+    pN = "literal",
+    QK = "options",
+    tQ = "selection",
+    eQ = "paramref",
+    nQ = "param",
+    yN = "select",
+    zy = "value",
+    rQ = "crossfilter",
+    mN = "intersect",
+    iQ = "union",
+    sQ = "single",
+    oQ = "data",
+    aQ = "expression",
+    Ro = "sql",
+    As = "agg",
+    L1 = "input",
+    Th = "hconcat",
+    Eh = "vconcat",
+    Nh = "hspace",
+    Dh = "vspace",
+    gN = "mark",
+    gv = "from",
+    Oh = "plot",
+    k1 = "legend",
+    cQ = "attribute",
+    uQ = "transform",
+    lQ = "interactor",
+    jl = "Fixed";
+class le {
     constructor(t, n = null) {
         this.type = t, this.children = n;
     }
-    instantiate() {
+    /**
+     * Instantiate this AST node to use in a live web application.
+     * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
+     * @returns {*} The instantiated value of this node.
+     */
+    instantiate(t) {
         throw Error("instantiate not implemented");
     }
-    codegen() {
+    /**
+     * Generate ESM code for this AST node.
+     * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
+     * @returns {string|void} The generated ESM code for the node.
+     */
+    codegen(t) {
         return Error("codegen not implemented");
     }
+    /**
+     * @returns {*} This AST node in JSON specification format.
+     */
     toJSON() {
         return Error("toJSON not implemented");
     }
 }
-class fst extends Oe {
-    constructor(t, n, i, r, s, o) {
-        super(Zrt, [t]), this.root = t, this.meta = n, this.config = i, this.data = r, this.params = s, this.plotDefaults = o;
+class fQ extends le {
+    constructor(t, n, r, i, s, o) {
+        super(KK, [t]), this.root = t, this.meta = n, this.config = r, this.data = i, this.params = s, this.plotDefaults = o;
     }
     toJSON() {
         const {
             root: t,
             meta: n,
-            config: i,
-            plotDefaults: r
+            config: r,
+            plotDefaults: i
         } = this, s = new Map(Object.entries(this.data)), o = new Map(Object.entries(this.params)), a = {};
         if (n && (a.meta = {
                 ...n
-            }), i && (a.config = {
-                ...i
+            }), r && (a.config = {
+                ...r
             }), s != null && s.size) {
             const c = a.data = {};
-            for (const [l, u] of s)
-                c[l] = u.toJSON();
+            for (const [u, l] of s)
+                c[u] = l.toJSON();
         }
         if (o != null && o.size) {
             const c = a.params = {};
-            for (const [l, u] of o)
-                c[l] = u.toJSON();
+            for (const [u, l] of o)
+                c[u] = l.toJSON();
         }
-        if (r != null && r.length) {
+        if (i != null && i.length) {
             const c = a.plotDefaults = {};
-            for (const l of r)
-                Object.assign(c, l.toJSON());
+            for (const u of i)
+                Object.assign(c, u.toJSON());
         }
         return Object.assign(a, t.toJSON());
     }
 }
 
-function hst(e) {
+function hQ(e) {
     const t = typeof e;
-    return t === "object" ? e == null ? void 0 : e.param : t === "string" ? dst(e) : null;
+    return t === "object" ? e == null ? void 0 : e.param : t === "string" ? dQ(e) : null;
 }
 
-function dst(e) {
+function dQ(e) {
     return (e == null ? void 0 : e[0]) === "$" ? e.slice(1) : null;
 }
 
-function nI(e) {
+function bv(e) {
     return `$${e}`;
 }
 
-function pst(e) {
+function pQ(e) {
     return [e].flat();
 }
 
-function Go(e) {
+function $s(e) {
     return Array.isArray(e);
 }
 
-function dL(e) {
-    return e !== null && typeof e == "object" && !Go(e);
+function bN(e) {
+    return e !== null && typeof e == "object" && !$s(e);
 }
 
-function bu(e) {
+function Vl(e) {
     return typeof e == "string";
 }
 
-function pL(e, t) {
+function wN(e, t) {
     throw Object.assign(Error(e), {
         data: t
     });
 }
+const yQ = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
+
+function mQ(e, t) {
+    return yQ.test(e += "") ? new Date(e) : t;
+}
 
-function ys(e, t) {
+function di(e, t) {
     const n = {};
-    for (const i in e)
-        n[i] = t.maybeSelection(e[i]);
-    return new X0(n);
+    for (const r in e)
+        n[r] = t.maybeSelection(e[r]);
+    return new Xd(n);
 }
-class X0 extends Oe {
+class Xd extends le {
     constructor(t) {
-        super(Qrt), this.options = t;
+        super(QK), this.options = t;
     }
     filter(t) {
         const n = Object.fromEntries(
-            Object.entries(this.options).filter(([i, r]) => t(i, r))
+            Object.entries(this.options).filter(([r, i]) => t(r, i))
         );
-        return new X0(n);
+        return new Xd(n);
     }
     instantiate(t) {
         const {
             options: n
-        } = this, i = {};
-        for (const r in n)
-            i[r] = n[r].instantiate(t);
-        return i;
+        } = this, r = {};
+        for (const i in n)
+            r[i] = n[i].instantiate(t);
+        return r;
     }
     codegen(t) {
         const {
             options: n
-        } = this, i = [];
-        for (const r in n)
-            i.push(`${r}: ${n[r].codegen(t)}`);
-        return i.length ? `{${t.maybeLineWrap(i)}}` : "";
+        } = this, r = [];
+        for (const i in n)
+            r.push(`${i}: ${n[i].codegen(t)}`);
+        return r.length ? `{${t.maybeLineWrap(r)}}` : "";
     }
     toJSON() {
         const {
             options: t
         } = this, n = {};
-        for (const i in t)
-            n[i] = t[i].toJSON();
+        for (const r in t)
+            n[r] = t[r].toJSON();
         return n;
     }
 }
-const yL = "table",
-    mL = "parquet",
-    gL = "csv",
-    Kv = "json",
-    Zv = "spatial",
-    iI = /* @__PURE__ */ new Map([
-        [yL, mst],
-        [mL, gst],
-        [gL, bst],
-        [Kv, wst],
-        [Zv, vst]
+const vN = "table",
+    _N = "parquet",
+    xN = "csv",
+    R1 = "json",
+    F1 = "spatial",
+    wv = /* @__PURE__ */ new Map([
+        [vN, _Q],
+        [_N, xQ],
+        [xN, SQ],
+        [R1, MQ],
+        [F1, AQ]
     ]);
 
-function yst(e, t, n) {
-    if (t = _st(t), iI.has(t.type))
-        return iI.get(t.type)(e, t, n);
+function gQ(e, t, n) {
+    const r = bQ(t);
+    if (wv.has(r.type))
+        return wv.get(r.type)(e, r, n);
     n.error("Unrecognized data format type.", t);
 }
 
-function mst(e, t, n) {
+function bQ(e) {
+    return $s(e) && (e = {
+        type: "json",
+        data: e
+    }), Vl(e) && (e = {
+        type: "table",
+        query: e
+    }), {
+        ...e,
+        type: wQ(e)
+    };
+}
+
+function wQ(e) {
+    return e.type || vQ(e.file) || "table";
+}
+
+function vQ(e) {
+    const t = e == null ? void 0 : e.lastIndexOf(".");
+    return t > 0 ? e.slice(t + 1) : null;
+}
+
+function _Q(e, t, n) {
     const {
-        query: i,
-        type: r,
+        query: r,
+        type: i,
         ...s
     } = t;
-    return new Mst(e, i, ys(s, n));
+    return new TQ(e, r, di(s, n));
 }
 
-function gst(e, t, n) {
+function xQ(e, t, n) {
     const {
-        file: i,
-        type: r,
+        file: r,
+        type: i,
         ...s
     } = t;
-    return new Tst(e, i, ys(s, n));
+    return new NQ(e, r, di(s, n));
 }
 
-function bst(e, t, n) {
+function SQ(e, t, n) {
     const {
-        file: i,
-        type: r,
+        file: r,
+        type: i,
         ...s
     } = t;
-    return new Dst(e, i, ys(s, n));
+    return new DQ(e, r, di(s, n));
 }
 
-function wst(e, t, n) {
+function MQ(e, t, n) {
     const {
-        data: i,
-        file: r,
+        data: r,
+        file: i,
         type: s,
         ...o
-    } = t, a = ys(o, n);
-    return i ? new Bst(e, i, a) : new Nst(e, r, a);
+    } = t, a = di(o, n);
+    return r ? new LQ(e, r, a) : new OQ(e, i, a);
 }
 
-function vst(e, t, n) {
+function AQ(e, t, n) {
     const {
-        file: i,
-        type: r,
+        file: r,
+        type: i,
         ...s
     } = t;
-    return new $st(e, i, ys(s, n));
-}
-
-function _st(e) {
-    return Go(e) && (e = {
-        type: "json",
-        data: e
-    }), bu(e) && (e = {
-        type: "table",
-        query: e
-    }), {
-        ...e,
-        type: xst(e)
-    };
-}
-
-function xst(e) {
-    return e.type || Sst(e.file) || "table";
-}
-
-function Sst(e) {
-    const t = e == null ? void 0 : e.lastIndexOf(".");
-    return t > 0 ? e.slice(t + 1) : null;
+    return new EQ(e, r, di(s, n));
 }
 
-function rI(e, t) {
+function vv(e, t) {
     return t ? new URL(e, t).toString() : e;
 }
 
-function Ist(e, t) {
+function $Q(e, t) {
     const n = e == null ? void 0 : e.codegen(t);
     return n ? `, ${n}` : "";
 }
-class Ast extends Oe {
+class IQ extends le {
     constructor(t, n) {
-        super(ost), this.name = t, this.format = n;
+        super(oQ), this.name = t, this.format = n;
     }
 }
-class Qv extends Ast {
+class B1 extends IQ {
     constructor(t, n) {
         super(t, n);
     }
+    /**
+     * Instantiate a table creation query.
+     * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
+     * @returns {string|void} The instantiated query.
+     */
     instantiateQuery(t) {
         t.error("instantiateQuery not implemented");
     }
+    /**
+     * Code generate a table creation query.
+     * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
+     * @returns {string|void} The generated query code.
+     */
     codegenQuery(t) {
         t.error("codegenQuery not implemented");
     }
+    /**
+     * Instantiate this AST node to use in a live web application.
+     * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
+     * @returns {*} The instantiated value of this node.
+     */
     instantiate(t) {
         const n = this.instantiateQuery(t);
         if (n)
             return n;
     }
+    /**
+     * Generate ESM code for this AST node.
+     * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
+     * @returns {string|void} The generated ESM code for the node.
+     */
     codegen(t) {
         const n = this.codegenQuery(t);
         if (n)
             return n;
     }
 }
-class Mst extends Qv {
-    constructor(t, n, i) {
-        super(t, yL), this.query = n == null ? void 0 : n.trim(), this.options = i;
+class TQ extends B1 {
+    constructor(t, n, r) {
+        super(t, vN), this.query = n == null ? void 0 : n.trim(), this.options = r;
     }
+    /**
+     * Instantiate a table creation query.
+     * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
+     * @returns {string|void} The instantiated query.
+     */
     instantiateQuery(t) {
         const {
             name: n,
-            query: i,
-            options: r
+            query: r,
+            options: i
         } = this;
-        if (i)
-            return t.api.create(n, i, r.instantiate(t));
+        if (r)
+            return t.api.create(n, r, i.instantiate(t));
     }
+    /**
+     * Code generate a table creation query.
+     * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
+     * @returns {string|void} The generated query code.
+     */
     codegenQuery(t) {
         const {
             name: n,
-            query: i,
-            options: r
+            query: r,
+            options: i
         } = this;
-        if (i)
-            return `\`${yf(n, i, r.instantiate(t))}\``;
+        if (r)
+            return `\`${su(n, r, i.instantiate(t))}\``;
     }
     toJSON() {
         const {
             format: t,
             query: n,
-            options: i
+            options: r
         } = this;
         return {
             type: t,
             query: n,
-            ...i.toJSON()
+            ...r.toJSON()
         };
     }
 }
-class H0 extends Qv {
-    constructor(t, n, i, r, s) {
-        super(t, n), this.file = r, this.method = i, this.options = s;
+class Gd extends B1 {
+    constructor(t, n, r, i, s) {
+        super(t, n), this.file = i, this.method = r, this.options = s;
     }
+    /**
+     * Instantiate a table creation query.
+     * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
+     * @returns {string|void} The instantiated query.
+     */
     instantiateQuery(t) {
         const {
             name: n,
-            method: i,
-            file: r,
+            method: r,
+            file: i,
             options: s
-        } = this, o = rI(r, t.baseURL), a = s == null ? void 0 : s.instantiate(t);
-        return t.api[i](n, o, a);
+        } = this, o = vv(i, t.baseURL), a = s == null ? void 0 : s.instantiate(t);
+        return t.api[r](n, o, a);
     }
+    /**
+     * Code generate a table creation query.
+     * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
+     * @returns {string|void} The generated query code.
+     */
     codegenQuery(t) {
         const {
             name: n,
-            method: i,
-            file: r,
+            method: r,
+            file: i,
             options: s
-        } = this, o = rI(r, t.baseURL), a = Ist(s, t);
-        return `${t.ns()}${i}("${n}", "${o}"${a})`;
+        } = this, o = vv(i, t.baseURL), a = $Q(s, t);
+        return `${t.ns()}${r}("${n}", "${o}"${a})`;
     }
     toJSON() {
         const {
             format: t,
             file: n,
-            options: i
+            options: r
         } = this;
         return {
             type: t,
             file: n,
-            ...i.toJSON()
+            ...r.toJSON()
         };
     }
 }
-class $st extends H0 {
-    constructor(t, n, i) {
-        super(t, Zv, "loadSpatial", n, i);
+class EQ extends Gd {
+    constructor(t, n, r) {
+        super(t, F1, "loadSpatial", n, r);
     }
 }
-class Tst extends H0 {
-    constructor(t, n, i) {
-        super(t, mL, "loadParquet", n, i);
+class NQ extends Gd {
+    constructor(t, n, r) {
+        super(t, _N, "loadParquet", n, r);
     }
 }
-class Dst extends H0 {
-    constructor(t, n, i) {
-        super(t, gL, "loadCSV", n, i);
+class DQ extends Gd {
+    constructor(t, n, r) {
+        super(t, xN, "loadCSV", n, r);
     }
 }
-class Nst extends H0 {
-    constructor(t, n, i) {
-        super(t, Kv, "loadJSON", n, i);
+class OQ extends Gd {
+    constructor(t, n, r) {
+        super(t, R1, "loadJSON", n, r);
     }
 }
-class Bst extends Qv {
-    constructor(t, n, i) {
-        super(t, Kv), this.data = n, this.options = i;
+class LQ extends B1 {
+    constructor(t, n, r) {
+        super(t, R1), this.data = n, this.options = r;
     }
+    /**
+     * Instantiate a table creation query.
+     * @param {import('../ast-to-dom.js').InstantiateContext} ctx The instantiation context.
+     * @returns {string|void} The instantiated query.
+     */
     instantiateQuery(t) {
         const {
             name: n,
-            data: i,
-            options: r
+            data: r,
+            options: i
         } = this;
-        return t.api.loadObjects(n, i, r.instantiate(t));
+        return t.api.loadObjects(n, r, i.instantiate(t));
     }
+    /**
+     * Code generate a table creation query.
+     * @param {import('../ast-to-esm.js').CodegenContext} ctx The code generator context.
+     * @returns {string|void} The generated query code.
+     */
     codegenQuery(t) {
         const {
             name: n,
-            data: i,
-            options: r
-        } = this, s = r ? "," + r.codegen(t) : "", o = `[
-    ` + i.map((a) => JSON.stringify(a)).join(`,
+            data: r,
+            options: i
+        } = this, s = i ? "," + i.codegen(t) : "", o = `[
+    ` + r.map((a) => JSON.stringify(a)).join(`,
     `) + `
   ]`;
         return `${t.ns()}loadObjects("${n}", ${o}${s})`;
     }
     toJSON() {
         const {
             format: t,
             data: n,
-            options: i
+            options: r
         } = this;
         return {
             type: t,
             data: n,
-            ...i.toJSON()
+            ...r.toJSON()
         };
     }
 }
 
-function Ost(e) {
-    var i;
-    const t = (i = e.config) == null ? void 0 : i.extensions,
-        n = new Set(t ? pst(t) : []);
-    for (const r of Object.values(e.data))
-        r.format === Zv && n.add("spatial");
+function kQ(e) {
+    var r;
+    const t = (r = e.config) == null ? void 0 : r.extensions,
+        n = new Set(t ? pQ(t) : []);
+    for (const i of Object.values(e.data))
+        i.format === F1 && n.add("spatial");
     return n;
 }
-async function Fst(e, t) {
+async function RQ(e, t) {
     const {
         data: n,
-        params: i,
-        plotDefaults: r
-    } = e, s = new Est({
-        plotDefaults: r,
+        params: r,
+        plotDefaults: i
+    } = e, s = new FQ({
+        plotDefaults: i,
         ...t
-    }), o = [], a = Ost(e);
-    o.push(...Array.from(a).map((c) => XM(c)));
+    }), o = [], a = kQ(e);
+    o.push(...Array.from(a).map((c) => Rx(c)));
     for (const c of Object.values(n)) {
-        const l = c.instantiate(s);
-        l && o.push(l);
+        const u = c.instantiate(s);
+        u && o.push(u);
     }
     o.length > 0 && await s.coordinator.exec(o);
-    for (const [c, l] of Object.entries(i))
+    for (const [c, u] of Object.entries(r))
         if (!s.activeParams.has(c)) {
-            const u = l.instantiate(s);
-            s.activeParams.set(c, u);
+            const l = u.instantiate(s);
+            s.activeParams.set(c, l);
         }
     return {
         element: e.root.instantiate(s),
         params: s.activeParams
     };
 }
-class Est {
+class FQ {
     constructor({
-        api: t = Krt(),
+        api: t = ZK(),
         plotDefaults: n = [],
-        params: i = /* @__PURE__ */ new Map(),
-        baseURL: r = null
+        params: r = /* @__PURE__ */ new Map(),
+        baseURL: i = null
     } = {}) {
-        this.api = t, this.plotDefaults = n, this.activeParams = i, this.baseURL = r, this.coordinator = t.context.coordinator;
+        this.api = t, this.plotDefaults = n, this.activeParams = r, this.baseURL = i, this.coordinator = t.context.coordinator;
     }
     error(t, n) {
-        pL(t, n);
+        wN(t, n);
     }
 }
-class bL extends Oe {
+class SN extends le {
     constructor(t) {
-        super(lL), this.value = t;
+        super(pN), this.value = t;
     }
     instantiate() {
         return this.value;
     }
     codegen(t) {
         return t.stringify(this.value);
     }
     toJSON() {
         return this.value;
     }
 }
-class wL extends Oe {
-    constructor(t = fL, n) {
-        super(tst), this.select = t, this.cross = n;
+class MN extends le {
+    constructor(t = mN, n) {
+        super(tQ), this.select = t, this.cross = n;
     }
     instantiate(t) {
         const {
             select: n,
-            cross: i
+            cross: r
         } = this;
         return t.api.Selection[n]({
-            cross: i
+            cross: r
         });
     }
     codegen(t) {
         const {
             select: n,
-            cross: i
-        } = this, r = i != null ? `{ cross: ${i} }` : "";
-        return `${t.ns()}Selection.${n}(${r})`;
+            cross: r
+        } = this, i = r != null ? `{ cross: ${r} }` : "";
+        return `${t.ns()}Selection.${n}(${i})`;
     }
     toJSON() {
         const {
             select: t,
             cross: n
         } = this;
         return {
             select: t,
             cross: n
         };
     }
 }
-const Lst = /* @__PURE__ */ new Set([Q1, sst, ist, fL, rst]);
+const BQ = /* @__PURE__ */ new Set([zy, sQ, rQ, mN, iQ]);
 
-function Rst(e, t) {
-    const n = dL(e) ? e : {
+function CQ(e, t) {
+    const n = bN(e) ? e : {
             value: e
         },
         {
-            select: i = Q1,
-            cross: r,
+            select: r = zy,
+            cross: i,
             date: s,
             value: o
         } = n;
-    return Lst.has(i) || t.error(`Unrecognized param type: ${i}`, n), i !== Q1 ? new wL(i, r) : Go(o) ? new tb(o.map((a) => t.maybeParam(a))) : new tb(o, s);
+    return BQ.has(r) || t.error(`Unrecognized param type: ${r}`, n), r !== zy ? new MN(r, i) : $s(o) ? new qy(o.map((a) => t.maybeParam(a))) : new qy(o, s);
 }
-class tb extends Oe {
+class qy extends le {
     constructor(t, n) {
-        super(nst), this.value = t, this.date = n;
+        super(nQ), this.value = t, this.date = n;
     }
     instantiate(t) {
         const {
             date: n,
-            value: i
+            value: r
         } = this, {
-            Param: r
+            Param: i
         } = t.api;
-        return Go(i) ? r.array(i.map((s) => s.instantiate(t))) : r.value(_w(n, i));
+        return $s(r) ? i.array(r.map((s) => s.instantiate(t))) : i.value(mQ(n, r));
     }
     codegen(t) {
         const {
             value: n,
-            date: i
-        } = this, r = `${t.ns()}Param.`;
-        return Go(n) ? `${r}array([${n.map((s) => s.codegen(t)).join(", ")}])` : i ? `${r}value(new Date(${JSON.stringify(i)}))` : `${r}value(${JSON.stringify(n)})`;
+            date: r
+        } = this, i = `${t.ns()}Param.`;
+        return $s(n) ? `${i}array([${n.map((s) => s.codegen(t)).join(", ")}])` : r ? `${i}value(new Date(${JSON.stringify(r)}))` : `${i}value(${JSON.stringify(n)})`;
     }
     toJSON() {
         const {
             date: t,
             value: n
         } = this;
-        return Go(n) ? n.map((i) => i.toJSON()) : t ? {
+        return $s(n) ? n.map((r) => r.toJSON()) : t ? {
             date: t
         } : n;
     }
 }
-class Cst extends Oe {
+class PQ extends le {
     constructor(t) {
-        super(est), this.name = t;
+        super(eQ), this.name = t;
     }
     instantiate(t) {
         var n;
         return (n = t.activeParams) == null ? void 0 : n.get(this.name);
     }
     codegen() {
-        return nI(this.name);
+        return bv(this.name);
     }
     toJSON() {
-        return nI(this.name);
+        return bv(this.name);
     }
 }
 
-function vL(e, t, n) {
-    var i, r;
-    return (r = (i = n.plot) == null ? void 0 : i.attributes) != null && r.has(e) || n.error(`Unrecognized attribute: ${e}`), new kst(
+function AN(e, t, n) {
+    var r, i;
+    return (i = (r = n.plot) == null ? void 0 : r.attributes) != null && i.has(e) || n.error(`Unrecognized attribute: ${e}`), new UQ(
         e,
-        t === cd ? new Ust() : n.maybeParam(t)
+        t === jl ? new zQ() : n.maybeParam(t)
     );
 }
-class kst extends Oe {
+class UQ extends le {
     constructor(t, n) {
-        super(cst), this.name = t, this.value = n;
+        super(cQ), this.name = t, this.value = n;
     }
     instantiate(t) {
         const {
             name: n,
-            value: i
-        } = this, r = t.api[n];
-        return r(i.instantiate(t));
+            value: r
+        } = this;
+        return t.api[n](r.instantiate(t));
     }
     codegen(t) {
         const {
             name: n,
-            value: i
+            value: r
         } = this;
-        return `${t.tab()}${t.ns()}${n}(${i.codegen(t)})`;
+        return `${t.tab()}${t.ns()}${n}(${r.codegen(t)})`;
     }
     toJSON() {
         const {
             name: t,
             value: n
         } = this;
         return {
             [t]: n.toJSON()
         };
     }
 }
-class Ust extends Oe {
+class zQ extends le {
     constructor() {
-        super(lL), this.value = cd;
+        super(pN), this.value = jl;
     }
     instantiate(t) {
-        return t.api[cd];
+        return t.api[jl];
     }
     codegen(t) {
-        return `${t.ns()}${cd}`;
+        return `${t.ns()}${jl}`;
     }
     toJSON() {
         return this.value;
     }
 }
 
-function zst(e, t) {
-    const n = e[iy].map((i) => t.parseComponent(i));
-    return new Pst(n);
+function qQ(e, t) {
+    const n = e[Th].map((r) => t.parseComponent(r));
+    return new jQ(n);
 }
-class Pst extends Oe {
+class jQ extends le {
     constructor(t) {
-        super(iy, t);
+        super(Th, t);
     }
     instantiate(t) {
-        return t.api[iy](this.children.map((n) => n.instantiate(t)));
+        return t.api[Th](this.children.map((n) => n.instantiate(t)));
     }
     codegen(t) {
         t.indent();
-        const n = this.children.map((i) => i.codegen(t));
+        const n = this.children.map((r) => r.codegen(t));
         return t.undent(), `${t.tab()}${t.ns()}${this.type}(
 ${n.join(`,
 `)}
 ${t.tab()})`;
     }
     toJSON() {
         return {
             [this.type]: this.children.map((t) => t.toJSON())
         };
     }
 }
 
-function Vst(e) {
-    return new jst(e[sy]);
+function VQ(e) {
+    return new YQ(e[Nh]);
 }
-class jst extends Oe {
+class YQ extends le {
     constructor(t) {
-        super(sy), this.value = t;
+        super(Nh), this.value = t;
     }
     instantiate(t) {
-        return t.api[sy](this.value);
+        return t.api[Nh](this.value);
     }
     codegen(t) {
-        return `${t.tab()}${t.ns()}${this.type}(${this.value})`;
+        return `${t.tab()}${t.ns()}${this.type}(${t.stringify(this.value)})`;
     }
     toJSON() {
         return {
             [this.type]: this.value
         };
     }
 }
 
-function qst(e, t) {
-    var r;
+function WQ(e, t) {
+    var i;
     const {
-        [Hv]: n, ...i
+        [L1]: n, ...r
     } = e;
-    return (r = t.inputs) != null && r.has(n) || t.error(`Unrecognized input type: ${n}`, e), new Yst(n, ys(i, t));
+    return (i = t.inputs) != null && i.has(n) || t.error(`Unrecognized input type: ${n}`, e), new XQ(n, di(r, t));
 }
-class Yst extends Oe {
+class XQ extends le {
     constructor(t, n) {
-        super(Hv), this.name = t, this.options = n;
+        super(L1), this.name = t, this.options = n;
     }
     instantiate(t) {
-        const n = t.api[this.name];
-        return n(this.options.instantiate(t));
+        return t.api[this.name](this.options.instantiate(t));
     }
     codegen(t) {
         const n = this.options.codegen(t);
         return `${t.tab()}${t.ns()}${this.name}(${n})`;
     }
     toJSON() {
         const {
             type: t,
             name: n,
-            options: i
+            options: r
         } = this;
         return {
             [t]: n,
-            ...i.toJSON()
+            ...r.toJSON()
         };
     }
 }
 
-function _L(e, t) {
+function $N(e, t) {
     var s, o;
     const {
-        [Jv]: n, ...i
-    } = e, r = `${n}Legend`;
-    return (o = (s = t.plot) == null ? void 0 : s.legends) != null && o.has(r) || t.error(`Unrecognized legend type: ${n}`, e), new Wst(r, n, ys(i, t));
-}
-class Wst extends Oe {
-    constructor(t, n, i) {
-        super(Jv), this.key = t, this.name = n, this.options = i;
+        [k1]: n, ...r
+    } = e, i = `${n}Legend`;
+    return (o = (s = t.plot) == null ? void 0 : s.legends) != null && o.has(i) || t.error(`Unrecognized legend type: ${n}`, e), new GQ(i, n, di(r, t));
+}
+class GQ extends le {
+    constructor(t, n, r) {
+        super(k1), this.key = t, this.name = n, this.options = r;
     }
     instantiate(t) {
-        const n = t.api[this.key];
-        return n(this.options.instantiate(t));
+        return t.api[this.key](this.options.instantiate(t));
     }
     codegen(t) {
         const n = this.options.codegen(t);
         return `${t.tab()}${t.ns()}${this.key}(${n})`;
     }
     toJSON() {
         const {
             type: t,
             name: n,
-            options: i
+            options: r
         } = this;
         return {
             [t]: n,
-            ...i.toJSON()
+            ...r.toJSON()
         };
     }
 }
 
-function Gst(e, t) {
-    var r, s;
+function HQ(e, t) {
+    var i, s;
     const {
-        [uL]: n, ...i
+        [yN]: n, ...r
     } = e;
-    return (s = (r = t.plot) == null ? void 0 : r.interactors) != null && s.has(n) || t.error(`Unrecognized interactor type: ${n}`, e), new Xst(n, ys(i, t));
+    return (s = (i = t.plot) == null ? void 0 : i.interactors) != null && s.has(n) || t.error(`Unrecognized interactor type: ${n}`, e), new JQ(n, di(r, t));
 }
-class Xst extends Oe {
+class JQ extends le {
     constructor(t, n) {
-        super(ust), this.name = t, this.options = n;
+        super(lQ), this.name = t, this.options = n;
     }
     instantiate(t) {
-        const n = t.api[this.name];
-        return n(this.options.instantiate(t));
+        return t.api[this.name](this.options.instantiate(t));
     }
     codegen(t) {
         const n = this.options.codegen(t);
         return `${t.tab()}${t.ns()}${this.name}(${n})`;
     }
     toJSON() {
         const {
             name: t,
             options: n
         } = this;
         return {
-            [uL]: t,
+            [yN]: t,
             ...n.toJSON()
         };
     }
 }
 
-function Hst(e, t) {
+function ZQ(e, t) {
     const {
         label: n
-    } = e, i = e[bc] ? bc : e[Wo] ? Wo : t.error("Unrecognized expression type", e), r = e[i], s = r.split(/(\\'|\\"|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|\$\w+)/g), o = [""], a = [];
-    for (let c = 0, l = 0; c < s.length; ++c) {
-        const u = s[c];
-        u.startsWith("$") ? (a[l] = t.maybeParam(u), o[++l] = "") : o[l] += u;
-    }
-    return new Jst(r, o, a, n, i === Wo);
-}
-class Jst extends Oe {
-    constructor(t, n, i, r, s) {
-        super(ast), this.value = t, this.spans = n, this.params = i, this.label = r, this.aggregate = s;
+    } = e, r = e[Ro] ? Ro : e[As] ? As : t.error("Unrecognized expression type", e), i = e[r], s = i.split(/(\\'|\\"|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|\$\w+)/g), o = [""], a = [];
+    for (let c = 0, u = 0; c < s.length; ++c) {
+        const l = s[c];
+        l.startsWith("$") ? (a[u] = t.maybeParam(l), o[++u] = "") : o[u] += l;
+    }
+    return new KQ(i, o, a, n, r === As);
+}
+class KQ extends le {
+    constructor(t, n, r, i, s) {
+        super(aQ), this.value = t, this.spans = n, this.params = r, this.label = i, this.aggregate = s;
     }
     instantiate(t) {
         const {
             spans: n,
-            params: i,
-            label: r,
+            params: r,
+            label: i,
             aggregate: s
-        } = this, o = t.api[s ? Wo : bc], a = i.map((c) => c.instantiate(t));
+        } = this, o = t.api[s ? As : Ro], a = r.map((c) => c.instantiate(t));
         return o(n, ...a).annotate({
-            label: r
+            label: i
         });
     }
     codegen(t) {
         const {
             spans: n,
-            params: i,
-            label: r,
+            params: r,
+            label: i,
             aggregate: s
-        } = this, o = s ? Wo : bc;
+        } = this, o = s ? As : Ro;
         let a = "";
-        const c = i.length;
-        for (let l = 0; l < c; ++l)
-            a += n[l] + "${" + i[l].codegen(t) + "}";
-        return a += n[c], `${t.ns()}${o}\`${a}\`` + (r ? `.annotate({ label: ${JSON.stringify(r)} })` : "");
+        const c = r.length;
+        for (let u = 0; u < c; ++u)
+            a += n[u] + "${" + r[u].codegen(t) + "}";
+        return a += n[c], `${t.ns()}${o}\`${a}\`` + (i ? `.annotate({ label: ${JSON.stringify(i)} })` : "");
     }
     toJSON() {
         return {
-            [this.aggregate ? Wo : bc]: this.value
+            [this.aggregate ? As : Ro]: this.value
         };
     }
 }
 
-function Kst(e, t) {
+function QQ(e, t) {
     if (!e)
         return null;
-    if (Go(e))
-        return new bL(e);
+    if ($s(e))
+        return new SN(e);
     const {
         from: n,
-        ...i
+        ...r
     } = e;
-    return new Zst(n, ys(i, t));
+    return new ttt(n, di(r, t));
 }
-class Zst extends Oe {
+class ttt extends le {
     constructor(t, n) {
-        super(eI), this.table = t, this.options = n;
+        super(gv), this.table = t, this.options = n;
     }
     instantiate(t) {
         const {
             table: n,
-            options: i
+            options: r
         } = this;
-        return t.api[eI](n, i.instantiate(t));
+        return t.api[gv](n, r.instantiate(t));
     }
     codegen(t) {
         const {
             type: n,
-            table: i,
-            options: r
-        } = this, s = r.codegen(t);
-        return `${t.ns()}${n}("${i}"${s ? ", " + s : ""})`;
+            table: r,
+            options: i
+        } = this, s = i.codegen(t);
+        return `${t.ns()}${n}("${r}"${s ? ", " + s : ""})`;
     }
     toJSON() {
         const {
             type: t,
             table: n,
-            options: i
+            options: r
         } = this;
         return {
             [t]: n,
-            ...i.toJSON()
+            ...r.toJSON()
         };
     }
 }
 
-function og(e) {
+function n0(e) {
     return e == null ? [] : [e].flat();
 }
 
-function Qst(e, t) {
+function ett(e, t) {
     let n;
     for (const s in e)
         t.transforms.has(s) && (n = s);
     if (!n)
         return;
-    const i = n === "count" || n == null ? [] : og(e[n]),
-        r = {
+    const r = n === "count" || n == null ? [] : n0(e[n]),
+        i = {
             distinct: e.distinct,
-            orderby: og(e.orderby).map((s) => t.maybeParam(s)),
-            partitionby: og(e.partitionby).map((s) => t.maybeParam(s)),
+            orderby: n0(e.orderby).map((s) => t.maybeParam(s)),
+            partitionby: n0(e.partitionby).map((s) => t.maybeParam(s)),
             rows: e.rows ? t.maybeParam(e.rows) : null,
             range: e.range ? t.maybeParam(e.range) : null
         };
-    return new tot(n, i, r);
+    return new ntt(n, r, i);
 }
-class tot extends Oe {
-    constructor(t, n, i) {
-        super(lst), this.name = t, this.args = n, this.options = i;
+class ntt extends le {
+    constructor(t, n, r) {
+        super(uQ), this.name = t, this.args = n, this.options = r;
     }
     instantiate(t) {
         const {
             name: n,
-            args: i,
-            options: r
+            args: r,
+            options: i
         } = this, {
             distinct: s,
             orderby: o,
             partitionby: a,
             rows: c,
-            range: l
-        } = r, u = t.api[n];
-        let f = u(...i);
-        return s && (f = f.distinct()), o.length && (f = f.orderby(o.map((h) => h.instantiate(t)))), a.length && (f = f.partitionby(a.map((h) => h.instantiate(t)))), c != null ? f = f.rows(c.instantiate(t)) : l != null && (f = f.range(l.instantiate(t))), f;
+            range: u
+        } = i;
+        let l = t.api[n](...r);
+        return s && (l = l.distinct()), o.length && (l = l.orderby(o.map((f) => f.instantiate(t)))), a.length && (l = l.partitionby(a.map((f) => f.instantiate(t)))), c != null ? l = l.rows(c.instantiate(t)) : u != null && (l = l.range(u.instantiate(t))), l;
     }
     codegen(t) {
         const {
             name: n,
-            args: i,
-            options: r
+            args: r,
+            options: i
         } = this, {
             distinct: s,
             orderby: o,
             partitionby: a,
             rows: c,
-            range: l
-        } = r;
-        let u = `${t.ns()}${n}(` + i.map((f) => JSON.stringify(f)).join(", ") + ")";
-        if (s && (u += ".distinct()"), o.length) {
+            range: u
+        } = i;
+        let l = `${t.ns()}${n}(` + r.map((f) => JSON.stringify(f)).join(", ") + ")";
+        if (s && (l += ".distinct()"), o.length) {
             const f = o.map((h) => h.codegen(t));
-            u += `.orderby(${f.join(", ")})`;
+            l += `.orderby(${f.join(", ")})`;
         }
         if (a.length) {
             const f = a.map((h) => h.codegen(t));
-            u += `.partitionby(${f.join(", ")})`;
+            l += `.partitionby(${f.join(", ")})`;
         }
-        return c ? u += `.rows(${c.codegen(t)})` : l && (u += `.range(${l.codegen(t)})`), u;
+        return c ? l += `.rows(${c.codegen(t)})` : u && (l += `.range(${u.codegen(t)})`), l;
     }
     toJSON() {
         const {
             name: t,
             args: n,
-            options: i
+            options: r
         } = this, {
-            distinct: r,
+            distinct: i,
             orderby: s,
             partitionby: o,
             rows: a,
             range: c
-        } = i, l = {
-            [t]: ag(n)
+        } = r, u = {
+            [t]: r0(n)
         };
-        return r && (l.distinct = !0), s.length && (l.orderby = ag(s.map((u) => u.toJSON()))), o.length && (l.partitionby = ag(o.map((u) => u.toJSON()))), a ? l.rows = a.toJSON() : c && (l.range = c.toJSON()), l;
+        return i && (u.distinct = !0), s.length && (u.orderby = r0(s.map((l) => l.toJSON()))), o.length && (u.partitionby = r0(o.map((l) => l.toJSON()))), a ? u.rows = a.toJSON() : c && (u.range = c.toJSON()), u;
     }
 }
 
-function ag(e) {
+function r0(e) {
     return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
 }
 
-function eot(e, t) {
-    if (dL(e))
-        return e[bc] || e[Wo] ? Hst(e, t) : Qst(e, t);
+function rtt(e, t) {
+    if (bN(e))
+        return e[Ro] || e[As] ? ZQ(e, t) : ett(e, t);
 }
 
-function not(e, t) {
+function itt(e, t) {
     var a, c;
     const {
         mark: n,
-        data: i,
-        ...r
+        data: r,
+        ...i
     } = e;
     (c = (a = t.plot) == null ? void 0 : a.marks) != null && c.has(n) || t.error(`Unrecognized mark type: ${n}`, e);
-    const s = Kst(i, t),
+    const s = QQ(r, t),
         o = {};
-    for (const l in r) {
-        const u = r[l];
-        o[l] = eot(u, t) || t.maybeParam(u);
-    }
-    return new iot(n, s, new X0(o));
-}
-class iot extends Oe {
-    constructor(t, n, i) {
-        super(hL), this.name = t, this.data = n, this.options = i;
+    for (const u in i) {
+        const l = i[u];
+        o[u] = rtt(l, t) || t.maybeParam(l);
+    }
+    return new stt(n, s, new Xd(o));
+}
+class stt extends le {
+    constructor(t, n, r) {
+        super(gN), this.name = t, this.data = n, this.options = r;
     }
     instantiate(t) {
         const {
             name: n,
-            data: i,
-            options: r
-        } = this, s = t.api[n], o = r.instantiate(t);
-        return i ? s(i.instantiate(t), o) : s(o);
+            data: r,
+            options: i
+        } = this, s = i.instantiate(t);
+        return r ? t.api[n](r.instantiate(t), s) : t.api[n](s);
     }
     codegen(t) {
         const {
             name: n,
-            data: i,
-            options: r
-        } = this, s = i ? i.codegen(t) : "", o = r.codegen(t);
+            data: r,
+            options: i
+        } = this, s = r ? r.codegen(t) : "", o = i.codegen(t);
         let a;
         if (s && o) {
             t.indent();
-            const c = r.codegen(t);
+            const c = i.codegen(t);
             a = `
 ${t.tab()}${s},
 ${t.tab()}${c}
 `, t.undent(), a += t.tab();
         } else
             a = `${s}${o}`;
         return `${t.tab()}${t.ns()}${n}(${a})`;
     }
     toJSON() {
         const {
             type: t,
             name: n,
-            data: i,
-            options: r
+            data: r,
+            options: i
         } = this;
         return {
             [t]: n,
-            ...i ? {
-                data: i.toJSON()
+            ...r ? {
+                data: r.toJSON()
             } : {},
-            ...r.toJSON()
+            ...i.toJSON()
         };
     }
 }
 
-function rot(e, t) {
-    return xL({
+function ott(e, t) {
+    return IN({
         plot: [e]
     }, t);
 }
 
-function xL(e, t) {
+function IN(e, t) {
     const {
-        [ay]: n, ...i
-    } = e, r = Object.entries(i).map(([o, a]) => vL(o, a, t)), s = n.map((o) => bu(o.mark) ? not(o, t) : bu(o.legend) ? _L(o, t) : bu(o.select) ? Gst(o, t) : t.error("Invalid plot entry.", o));
-    return new sot(s, r);
+        [Oh]: n, ...r
+    } = e, i = Object.entries(r).map(([o, a]) => AN(o, a, t)), s = n.map((o) => Vl(o.mark) ? itt(o, t) : Vl(o.legend) ? $N(o, t) : Vl(o.select) ? HQ(o, t) : t.error("Invalid plot entry.", o));
+    return new att(s, i);
 }
-class sot extends Oe {
+class att extends le {
     constructor(t, n) {
-        super(ay, t), this.attributes = n;
+        super(Oh, t), this.attributes = n;
     }
     instantiate(t) {
         const n = [
             ...t.plotDefaults || [],
             ...this.attributes || []
         ];
-        return t.api[ay](
-            this.children.map((i) => i.instantiate(t)),
-            n.map((i) => i.instantiate(t))
+        return t.api[Oh](
+            this.children.map((r) => r.instantiate(t)),
+            n.map((r) => r.instantiate(t))
         );
     }
     codegen(t) {
         var o;
         const {
             type: n,
-            children: i,
-            attributes: r
+            children: r,
+            attributes: i
         } = this;
         t.indent();
         const s = [
-            ...i.map((a) => a.codegen(t)),
+            ...r.map((a) => a.codegen(t)),
             ...(o = t.plotDefaults) != null && o.length ? [`${t.tab()}...defaultAttributes`] : [],
-            ...r.map((a) => a.codegen(t))
+            ...i.map((a) => a.codegen(t))
         ].join(`,
 `);
         return t.undent(), `${t.tab()}${t.ns()}${n}(
 ${s}
 ${t.tab()})`;
     }
     toJSON() {
         const {
             type: t,
             children: n,
-            attributes: i
-        } = this, r = {
+            attributes: r
+        } = this, i = {
             [t]: n.map((s) => s.toJSON())
         };
-        for (const s of i)
-            Object.assign(r, s.toJSON());
-        return r;
+        for (const s of r)
+            Object.assign(i, s.toJSON());
+        return i;
     }
 }
 
-function oot(e, t) {
-    const n = e[ry].map((i) => t.parseComponent(i));
-    return new aot(n);
+function ctt(e, t) {
+    const n = e[Eh].map((r) => t.parseComponent(r));
+    return new utt(n);
 }
-class aot extends Oe {
+class utt extends le {
     constructor(t) {
-        super(ry, t);
+        super(Eh, t);
     }
     instantiate(t) {
-        return t.api[ry](this.children.map((n) => n.instantiate(t)));
+        return t.api[Eh](this.children.map((n) => n.instantiate(t)));
     }
     codegen(t) {
         t.indent();
-        const n = this.children.map((i) => i.codegen(t));
+        const n = this.children.map((r) => r.codegen(t));
         return t.undent(), `${t.tab()}${t.ns()}${this.type}(
 ${n.join(`,
 `)}
 ${t.tab()})`;
     }
     toJSON() {
         return {
             [this.type]: this.children.map((t) => t.toJSON())
         };
     }
 }
 
-function cot(e) {
-    return new lot(e[oy]);
+function ltt(e) {
+    return new ftt(e[Dh]);
 }
-class lot extends Oe {
+class ftt extends le {
     constructor(t) {
-        super(oy), this.value = t;
+        super(Dh), this.value = t;
     }
     instantiate(t) {
-        return t.api[oy](this.value);
+        return t.api[Dh](this.value);
     }
     codegen(t) {
-        return `${t.tab()}${t.ns()}${this.type}(${this.value})`;
+        return `${t.tab()}${t.ns()}${this.type}(${t.stringify(this.value)})`;
     }
     toJSON() {
         return {
             [this.type]: this.value
         };
     }
 }
 
-function uot(e = []) {
+function htt(e = []) {
     return new Map([
-        [ay, xL],
-        [hL, rot],
-        [Jv, _L],
-        [Hv, qst],
-        [iy, zst],
-        [ry, oot],
-        [sy, Vst],
-        [oy, cot],
+        [Oh, IN],
+        [gN, ott],
+        [k1, $N],
+        [L1, WQ],
+        [Th, qQ],
+        [Eh, ctt],
+        [Nh, VQ],
+        [Dh, ltt],
         ...e
     ]);
 }
 
-function fot(e = []) {
+function dtt(e = []) {
     return /* @__PURE__ */ new Set([
         "menu",
         "search",
         "slider",
         "table",
         ...e
     ]);
 }
 
-function hot({
-    attributes: e = dot(),
-    interactors: t = pot(),
-    legends: n = yot(),
-    marks: i = mot()
+function ptt({
+    attributes: e = ytt(),
+    interactors: t = mtt(),
+    legends: n = gtt(),
+    marks: r = btt()
 } = {}) {
     return {
         attributes: e,
         interactors: t,
         legends: n,
-        marks: i
+        marks: r
     };
 }
 
-function dot(e = []) {
+function ytt(e = []) {
     return /* @__PURE__ */ new Set([
-        ...Object.keys(jrt),
+        ...Object.keys(jK),
         ...e
     ]);
 }
 
-function pot(e = []) {
+function mtt(e = []) {
     return /* @__PURE__ */ new Set([
-        ...Object.keys(Grt),
+        ...Object.keys(XK),
         ...e
     ]);
 }
 
-function yot(e = []) {
+function gtt(e = []) {
     return /* @__PURE__ */ new Set([
-        ...Object.keys(Xrt),
+        ...Object.keys(GK),
         ...e
     ]);
 }
 
-function mot(e = []) {
+function btt(e = []) {
     return /* @__PURE__ */ new Set([
-        ...Object.keys(Wrt),
+        ...Object.keys(WK),
         ...e
     ]);
 }
 
-function got(e = []) {
+function wtt(e = []) {
     return /* @__PURE__ */ new Set([
         "argmin",
         "argmax",
         "avg",
         "bin",
         "centroid",
         "centroidX",
         "centroidY",
         "count",
+        "covariance",
+        "covarPop",
         "dateMonth",
         "dateMonthDay",
         "dateDay",
         "first",
         "geojson",
         "last",
         "max",
         "median",
         "min",
         "mode",
         "product",
         "quantile",
+        "stddev",
+        "stddevPop",
         "sum",
+        "variance",
+        "varPop",
         "row_number",
         "rank",
         "dense_rank",
         "percent_rank",
         "cume_dist",
         "ntile",
         "lag",
@@ -42601,8155 +43613,228 @@
         "first_value",
         "last_value",
         "nth_value",
         ...e
     ]);
 }
 
-function bot(e, t) {
-    return e = bu(e) ? JSON.parse(e) : e, new wot(t).parse(e);
+function vtt(e, t) {
+    return new _tt(t).parse(e);
 }
-class wot {
+class _tt {
+    /**
+     * Create a new parser context.
+     * @param {object} [options]
+     * @param {Map<string, Function>} [options.components] Map of component names to parse functions.
+     * @param {Set<string>} [options.transforms] The names of allowed transform functions.
+     * @param {Set<string>} [options.inputs] The names of supported input widgets.
+     * @param {PlotNames} [options.plot] The names of supported plot elements.
+     * @param {any[]} [options.params] An array of [name, node] pairs of pre-parsed
+     *  Param or Selection AST nodes.
+     * @param {any[]} [options.datasets] An array of [name, node] pairs of pre-parsed
+     *  dataset definition AST nodes.
+     */
     constructor({
-        components: t = uot(),
-        transforms: n = got(),
-        inputs: i = fot(),
-        plot: r = hot(),
+        components: t = htt(),
+        transforms: n = wtt(),
+        inputs: r = dtt(),
+        plot: i = ptt(),
         params: s = [],
         datasets: o = []
     } = {}) {
-        this.components = t, this.transforms = n, this.inputs = i, this.plot = r, this.params = new Map(s), this.datasets = new Map(o);
+        this.components = t, this.transforms = n, this.inputs = r, this.plot = i, this.params = new Map(s), this.datasets = new Map(o);
     }
     parse(t) {
         const {
             meta: n,
-            config: i,
-            data: r = {},
+            config: r,
+            data: i = {},
             params: s,
             plotDefaults: o = {},
             ...a
         } = t;
-        for (const c in r)
-            this.datasets.set(c, yst(c, r[c], this));
-        this.plotDefaults = Object.entries(o).map(([c, l]) => vL(c, l, this));
+        for (const c in i)
+            this.datasets.set(c, gQ(c, i[c], this));
+        this.plotDefaults = Object.entries(o).map(([c, u]) => AN(c, u, this));
         for (const c in s)
-            this.params.set(c, Rst(s[c], this));
-        return new fst(
+            this.params.set(c, CQ(s[c], this));
+        return new fQ(
             this.parseComponent(a),
             n ? {
                 ...n
             } : void 0,
-            i ? {
-                ...i
+            r ? {
+                ...r
             } : void 0,
             Object.fromEntries(this.datasets),
             Object.fromEntries(this.params),
             this.plotDefaults
         );
     }
     parseComponent(t) {
-        for (const [n, i] of this.components)
+        for (const [n, r] of this.components)
             if (t[n] != null)
-                return i(t, this);
+                return r(t, this);
         this.error("Invalid specification.", t);
     }
-    maybeParam(t, n = () => new tb()) {
+    /**
+     * Test if a value is param reference, if so, generate a paramter definition
+     * as needed and return a new ParamRefNode. Otherwise, return a LiteralNode.
+     * @param {*} value The value to test.
+     * @param {() => ParamNode | SelectionNode} [makeNode] A Param of Selection AST
+     *  node constructor.
+     * @returns {ParamRefNode|LiteralNode} An AST node for the input value.
+     */
+    maybeParam(t, n = () => new qy()) {
         const {
-            params: i
-        } = this, r = hst(t);
-        if (r) {
-            if (!i.has(r)) {
+            params: r
+        } = this, i = hQ(t);
+        if (i) {
+            if (!r.has(i)) {
                 const s = n();
-                i.set(r, s);
+                r.set(i, s);
             }
-            return new Cst(r);
+            return new PQ(i);
         }
-        return new bL(t);
+        return new SN(t);
     }
     maybeSelection(t) {
-        return this.maybeParam(t, () => new wL());
+        return this.maybeParam(t, () => new MN());
     }
     error(t, n) {
-        pL(t, n);
-    }
-}
-const vot = new TextDecoder("utf-8"),
-    eb = (e) => vot.decode(e),
-    _ot = new TextEncoder(),
-    t_ = (e) => _ot.encode(e),
-    xot = (e) => typeof e == "number",
-    Sot = (e) => typeof e == "boolean",
-    an = (e) => typeof e == "function",
-    Bi = (e) => e != null && Object(e) === e,
-    Qu = (e) => Bi(e) && an(e.then),
-    J0 = (e) => Bi(e) && an(e[Symbol.iterator]),
-    e_ = (e) => Bi(e) && an(e[Symbol.asyncIterator]),
-    nb = (e) => Bi(e) && Bi(e.schema),
-    SL = (e) => Bi(e) && "done" in e && "value" in e,
-    IL = (e) => Bi(e) && an(e.stat) && xot(e.fd),
-    AL = (e) => Bi(e) && n_(e.body),
-    ML = (e) => "_getDOMStream" in e && "_getNodeStream" in e,
-    n_ = (e) => Bi(e) && an(e.cancel) && an(e.getReader) && !ML(e),
-    $L = (e) => Bi(e) && an(e.read) && an(e.pipe) && Sot(e.readable) && !ML(e),
-    Iot = (e) => Bi(e) && an(e.clear) && an(e.bytes) && an(e.position) && an(e.setPosition) && an(e.capacity) && an(e.getBufferIdentifier) && an(e.createLong),
-    i_ = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
-
-function Aot(e) {
-    const t = e[0] ? [e[0]] : [];
-    let n, i, r, s;
-    for (let o, a, c = 0, l = 0, u = e.length; ++c < u;) {
-        if (o = t[l], a = e[c], !o || !a || o.buffer !== a.buffer || a.byteOffset < o.byteOffset) {
-            a && (t[++l] = a);
-            continue;
-        }
-        if ({
-                byteOffset: n,
-                byteLength: r
-            } = o, {
-                byteOffset: i,
-                byteLength: s
-            } = a, n + r < i || i + s < n) {
-            a && (t[++l] = a);
-            continue;
-        }
-        t[l] = new Uint8Array(o.buffer, n, i - n + s);
-    }
-    return t;
-}
-
-function sI(e, t, n = 0, i = t.byteLength) {
-    const r = e.byteLength,
-        s = new Uint8Array(e.buffer, e.byteOffset, r),
-        o = new Uint8Array(t.buffer, t.byteOffset, Math.min(i, r));
-    return s.set(o, n), e;
-}
-
-function yr(e, t) {
-    const n = Aot(e),
-        i = n.reduce((u, f) => u + f.byteLength, 0);
-    let r, s, o, a = 0,
-        c = -1;
-    const l = Math.min(t || Number.POSITIVE_INFINITY, i);
-    for (const u = n.length; ++c < u;) {
-        if (r = n[c], s = r.subarray(0, Math.min(r.length, l - a)), l <= a + s.length) {
-            s.length < r.length ? n[c] = r.subarray(s.length) : s.length === r.length && c++, o ? sI(o, s, a) : o = s;
-            break;
-        }
-        sI(o || (o = new Uint8Array(l)), s, a), a += s.length;
-    }
-    return [o || new Uint8Array(0), n.slice(c), i - (o ? o.byteLength : 0)];
-}
-
-function se(e, t) {
-    let n = SL(t) ? t.value : t;
-    return n instanceof e ? e === Uint8Array ? new e(n.buffer, n.byteOffset, n.byteLength) : n : n ? (typeof n == "string" && (n = t_(n)), n instanceof ArrayBuffer ? new e(n) : n instanceof i_ ? new e(n) : Iot(n) ? se(e, n.bytes()) : ArrayBuffer.isView(n) ? n.byteLength <= 0 ? new e(0) : new e(n.buffer, n.byteOffset, n.byteLength / e.BYTES_PER_ELEMENT) : e.from(n)) : new e(0);
-}
-const Fl = (e) => se(Int32Array, e),
-    oI = (e) => se(BigInt64Array, e),
-    Wt = (e) => se(Uint8Array, e),
-    ib = (e) => (e.next(), e);
-
-function* Mot(e, t) {
-    const n = function*(r) {
-            yield r;
-        },
-        i = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof i_ ? n(t) : J0(t) ? t : n(t);
-    return yield* ib(function*(r) {
-        let s = null;
-        do
-            s = r.next(yield se(e, s));
-        while (!s.done);
-    }(i[Symbol.iterator]())), new e();
-}
-const $ot = (e) => Mot(Uint8Array, e);
-
-function TL(e, t) {
-    return Re(this, arguments, function*() {
-        if (Qu(t))
-            return yield H(yield H(yield* ks(ai(TL(e, yield H(t))))));
-        const i = function(o) {
-                return Re(this, arguments, function*() {
-                    yield yield H(yield H(o));
-                });
-            },
-            r = function(o) {
-                return Re(this, arguments, function*() {
-                    yield H(yield* ks(ai(ib(function*(a) {
-                        let c = null;
-                        do
-                            c = a.next(yield c == null ? void 0 : c.value);
-                        while (!c.done);
-                    }(o[Symbol.iterator]())))));
-                });
-            },
-            s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof i_ ? i(t) : J0(t) ? r(t) : e_(t) ? t : i(t);
-        return yield H(
-            // otherwise if AsyncIterable, use it
-            yield* ks(ai(ib(function(o) {
-                return Re(this, arguments, function*() {
-                    let a = null;
-                    do
-                        a = yield H(o.next(yield yield H(se(e, a))));
-                    while (!a.done);
-                });
-            }(s[Symbol.asyncIterator]()))))
-        ), yield H(new e());
-    });
-}
-const Tot = (e) => TL(Uint8Array, e);
-
-function Dot(e, t) {
-    let n = 0;
-    const i = e.length;
-    if (i !== t.length)
-        return !1;
-    if (i > 0)
-        do
-            if (e[n] !== t[n])
-                return !1;
-        while (++n < i);
-    return !0;
-}
-const Jn = {
-        fromIterable(e) {
-            return Lh(Not(e));
-        },
-        fromAsyncIterable(e) {
-            return Lh(Bot(e));
-        },
-        fromDOMStream(e) {
-            return Lh(Oot(e));
-        },
-        fromNodeStream(e) {
-            return Lh(Eot(e));
-        },
-        // @ts-ignore
-        toDOMStream(e, t) {
-            throw new Error('"toDOMStream" not available in this environment');
-        },
-        // @ts-ignore
-        toNodeStream(e, t) {
-            throw new Error('"toNodeStream" not available in this environment');
-        }
-    },
-    Lh = (e) => (e.next(), e);
-
-function* Not(e) {
-    let t, n = !1,
-        i = [],
-        r, s, o, a = 0;
-
-    function c() {
-        return s === "peek" ? yr(i, o)[0] : ([r, i, a] = yr(i, o), r);
-    }
-    ({
-        cmd: s,
-        size: o
-    } = (yield null) || {
-        cmd: "read",
-        size: 0
-    });
-    const l = $ot(e)[Symbol.iterator]();
-    try {
-        do
-            if ({
-                    done: t,
-                    value: r
-                } = Number.isNaN(o - a) ? l.next() : l.next(o - a), !t && r.byteLength > 0 && (i.push(r), a += r.byteLength), t || o <= a)
-                do
-                    ({
-                        cmd: s,
-                        size: o
-                    } = yield c());
-                while (o < a);
-        while (!t);
-    } catch (u) {
-        (n = !0) && typeof l.throw == "function" && l.throw(u);
-    } finally {
-        n === !1 && typeof l.return == "function" && l.return(null);
-    }
-    return null;
-}
-
-function Bot(e) {
-    return Re(this, arguments, function*() {
-        let n, i = !1,
-            r = [],
-            s, o, a, c = 0;
-
-        function l() {
-            return o === "peek" ? yr(r, a)[0] : ([s, r, c] = yr(r, a), s);
-        }
-        ({
-            cmd: o,
-            size: a
-        } = (yield yield H(null)) || {
-            cmd: "read",
-            size: 0
-        });
-        const u = Tot(e)[Symbol.asyncIterator]();
-        try {
-            do
-                if ({
-                        done: n,
-                        value: s
-                    } = Number.isNaN(a - c) ? yield H(u.next()): yield H(u.next(a - c)), !n && s.byteLength > 0 && (r.push(s), c += s.byteLength), n || a <= c)
-                    do
-                        ({
-                            cmd: o,
-                            size: a
-                        } = yield yield H(l()));
-                    while (a < c);
-            while (!n);
-        } catch (f) {
-            (i = !0) && typeof u.throw == "function" && (yield H(u.throw(f)));
-        } finally {
-            i === !1 && typeof u.return == "function" && (yield H(u.return(new Uint8Array(0))));
-        }
-        return yield H(null);
-    });
-}
-
-function Oot(e) {
-    return Re(this, arguments, function*() {
-        let n = !1,
-            i = !1,
-            r = [],
-            s, o, a, c = 0;
-
-        function l() {
-            return o === "peek" ? yr(r, a)[0] : ([s, r, c] = yr(r, a), s);
-        }
-        ({
-            cmd: o,
-            size: a
-        } = (yield yield H(null)) || {
-            cmd: "read",
-            size: 0
-        });
-        const u = new Fot(e);
-        try {
-            do
-                if ({
-                        done: n,
-                        value: s
-                    } = Number.isNaN(a - c) ? yield H(u.read()): yield H(u.read(a - c)), !n && s.byteLength > 0 && (r.push(Wt(s)), c += s.byteLength), n || a <= c)
-                    do
-                        ({
-                            cmd: o,
-                            size: a
-                        } = yield yield H(l()));
-                    while (a < c);
-            while (!n);
-        } catch (f) {
-            (i = !0) && (yield H(u.cancel(f)));
-        } finally {
-            i === !1 ? yield H(u.cancel()): e.locked && u.releaseLock();
-        }
-        return yield H(null);
-    });
-}
-class Fot {
-    constructor(t) {
-        this.source = t, this.reader = null, this.reader = this.source.getReader(), this.reader.closed.catch(() => {});
-    }
-    get closed() {
-        return this.reader ? this.reader.closed.catch(() => {}) : Promise.resolve();
-    }
-    releaseLock() {
-        this.reader && this.reader.releaseLock(), this.reader = null;
-    }
-    cancel(t) {
-        return W(this, void 0, void 0, function*() {
-            const {
-                reader: n,
-                source: i
-            } = this;
-            n && (yield n.cancel(t).catch(() => {})), i && i.locked && this.releaseLock();
-        });
-    }
-    read(t) {
-        return W(this, void 0, void 0, function*() {
-            if (t === 0)
-                return {
-                    done: this.reader == null,
-                    value: new Uint8Array(0)
-                };
-            const n = yield this.reader.read();
-            return !n.done && (n.value = Wt(n)), n;
-        });
-    }
-}
-const cg = (e, t) => {
-    const n = (r) => i([t, r]);
-    let i;
-    return [t, n, new Promise((r) => (i = r) && e.once(t, n))];
-};
-
-function Eot(e) {
-    return Re(this, arguments, function*() {
-        const n = [];
-        let i = "error",
-            r = !1,
-            s = null,
-            o, a, c = 0,
-            l = [],
-            u;
-
-        function f() {
-            return o === "peek" ? yr(l, a)[0] : ([u, l, c] = yr(l, a), u);
-        }
-        if ({
-                cmd: o,
-                size: a
-            } = (yield yield H(null)) || {
-                cmd: "read",
-                size: 0
-            }, e.isTTY)
-            return yield yield H(new Uint8Array(0)), yield H(null);
-        try {
-            n[0] = cg(e, "end"), n[1] = cg(e, "error");
-            do {
-                if (n[2] = cg(e, "readable"), [i, s] = yield H(Promise.race(n.map((d) => d[2]))), i === "error")
-                    break;
-                if ((r = i === "end") || (Number.isFinite(a - c) ? (u = Wt(e.read(a - c)), u.byteLength < a - c && (u = Wt(e.read()))) : u = Wt(e.read()), u.byteLength > 0 && (l.push(u), c += u.byteLength)), r || a <= c)
-                    do
-                        ({
-                            cmd: o,
-                            size: a
-                        } = yield yield H(f()));
-                    while (a < c);
-            } while (!r);
-        } finally {
-            yield H(h(n, i === "error" ? s : null));
-        }
-        return yield H(null);
-
-        function h(d, p) {
-            return u = l = null, new Promise((m, g) => {
-                for (const [y, b] of d)
-                    e.off(y, b);
-                try {
-                    const y = e.destroy;
-                    y && y.call(e, p), p = void 0;
-                } catch (y) {
-                    p = y || p;
-                } finally {
-                    p != null ? g(p) : m();
-                }
-            });
-        }
-    });
-}
-var Le;
-(function(e) {
-    e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5";
-})(Le || (Le = {}));
-var On;
-(function(e) {
-    e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense";
-})(On || (On = {}));
-var rn;
-(function(e) {
-    e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE";
-})(rn || (rn = {}));
-var Oi;
-(function(e) {
-    e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND";
-})(Oi || (Oi = {}));
-var bt;
-(function(e) {
-    e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND";
-})(bt || (bt = {}));
-var mr;
-(function(e) {
-    e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO";
-})(mr || (mr = {}));
-var cy;
-(function(e) {
-    e[e.BUFFER = 0] = "BUFFER";
-})(cy || (cy = {}));
-var ly;
-(function(e) {
-    e[e.LZ4_FRAME = 0] = "LZ4_FRAME", e[e.ZSTD = 1] = "ZSTD";
-})(ly || (ly = {}));
-class Ts {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsBodyCompression(t, n) {
-        return (n || new Ts()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsBodyCompression(t, n) {
-        return t.setPosition(t.position() + nt), (n || new Ts()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    /**
-     * Compressor library.
-     * For LZ4_FRAME, each compressed buffer must consist of a single frame.
-     */
-    codec() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt8(this.bb_pos + t) : ly.LZ4_FRAME;
-    }
-    /**
-     * Indicates the way the record batch body was compressed
-     */
-    method() {
-        const t = this.bb.__offset(this.bb_pos, 6);
-        return t ? this.bb.readInt8(this.bb_pos + t) : cy.BUFFER;
-    }
-    static startBodyCompression(t) {
-        t.startObject(2);
-    }
-    static addCodec(t, n) {
-        t.addFieldInt8(0, n, ly.LZ4_FRAME);
-    }
-    static addMethod(t, n) {
-        t.addFieldInt8(1, n, cy.BUFFER);
-    }
-    static endBodyCompression(t) {
-        return t.endObject();
-    }
-    static createBodyCompression(t, n, i) {
-        return Ts.startBodyCompression(t), Ts.addCodec(t, n), Ts.addMethod(t, i), Ts.endBodyCompression(t);
-    }
-}
-class DL {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    /**
-     * The relative offset into the shared memory page where the bytes for this
-     * buffer starts
-     */
-    offset() {
-        return this.bb.readInt64(this.bb_pos);
-    }
-    /**
-     * The absolute length (in bytes) of the memory buffer. The memory is found
-     * from offset (inclusive) to offset + length (non-inclusive). When building
-     * messages using the encapsulated IPC message, padding bytes may be written
-     * after a buffer, but such padding bytes do not need to be accounted for in
-     * the size here.
-     */
-    length() {
-        return this.bb.readInt64(this.bb_pos + 8);
-    }
-    static sizeOf() {
-        return 16;
-    }
-    static createBuffer(t, n, i) {
-        return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
-    }
-}
-let NL = class {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        /**
-         * The number of value slots in the Arrow array at this level of a nested
-         * tree
-         */
-        length() {
-            return this.bb.readInt64(this.bb_pos);
-        }
-        /**
-         * The number of observed nulls. Fields with null_count == 0 may choose not
-         * to write their physical validity bitmap out as a materialized buffer,
-         * instead setting the length of the bitmap buffer to 0.
-         */
-        nullCount() {
-            return this.bb.readInt64(this.bb_pos + 8);
-        }
-        static sizeOf() {
-            return 16;
-        }
-        static createFieldNode(t, n, i) {
-            return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(n ?? 0)), t.offset();
-        }
-    },
-    kr = class rb {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsRecordBatch(t, n) {
-            return (n || new rb()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsRecordBatch(t, n) {
-            return t.setPosition(t.position() + nt), (n || new rb()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * number of records / rows. The arrays in the batch should all have this
-         * length
-         */
-        length() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
-        }
-        /**
-         * Nodes correspond to the pre-ordered flattened logical schema
-         */
-        nodes(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 6);
-            return i ? (n || new NL()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
-        }
-        nodesLength() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        /**
-         * Buffers correspond to the pre-ordered flattened buffer tree
-         *
-         * The number of buffers appended to this list depends on the schema. For
-         * example, most primitive arrays will have 2 buffers, 1 for the validity
-         * bitmap and 1 for the values. For struct arrays, there will only be a
-         * single buffer for the validity (nulls) bitmap
-         */
-        buffers(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 8);
-            return i ? (n || new DL()).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null;
-        }
-        buffersLength() {
-            const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        /**
-         * Optional compression of the message body
-         */
-        compression(t) {
-            const n = this.bb.__offset(this.bb_pos, 10);
-            return n ? (t || new Ts()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
-        }
-        static startRecordBatch(t) {
-            t.startObject(4);
-        }
-        static addLength(t, n) {
-            t.addFieldInt64(0, n, BigInt("0"));
-        }
-        static addNodes(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static startNodesVector(t, n) {
-            t.startVector(16, n, 8);
-        }
-        static addBuffers(t, n) {
-            t.addFieldOffset(2, n, 0);
-        }
-        static startBuffersVector(t, n) {
-            t.startVector(16, n, 8);
-        }
-        static addCompression(t, n) {
-            t.addFieldOffset(3, n, 0);
-        }
-        static endRecordBatch(t) {
-            return t.endObject();
-        }
-    },
-    Va = class sb {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsDictionaryBatch(t, n) {
-            return (n || new sb()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsDictionaryBatch(t, n) {
-            return t.setPosition(t.position() + nt), (n || new sb()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        id() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
-        }
-        data(t) {
-            const n = this.bb.__offset(this.bb_pos, 6);
-            return n ? (t || new kr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
-        }
-        /**
-         * If isDelta is true the values in the dictionary are to be appended to a
-         * dictionary with the indicated id. If isDelta is false this dictionary
-         * should replace the existing dictionary.
-         */
-        isDelta() {
-            const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
-        }
-        static startDictionaryBatch(t) {
-            t.startObject(3);
-        }
-        static addId(t, n) {
-            t.addFieldInt64(0, n, BigInt("0"));
-        }
-        static addData(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static addIsDelta(t, n) {
-            t.addFieldInt8(2, +n, 0);
-        }
-        static endDictionaryBatch(t) {
-            return t.endObject();
-        }
-    };
-var Gc;
-(function(e) {
-    e[e.Little = 0] = "Little", e[e.Big = 1] = "Big";
-})(Gc || (Gc = {}));
-var uy;
-(function(e) {
-    e[e.DenseArray = 0] = "DenseArray";
-})(uy || (uy = {}));
-class Rn {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsInt(t, n) {
-        return (n || new Rn()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsInt(t, n) {
-        return t.setPosition(t.position() + nt), (n || new Rn()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    bitWidth() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt32(this.bb_pos + t) : 0;
-    }
-    isSigned() {
-        const t = this.bb.__offset(this.bb_pos, 6);
-        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
-    }
-    static startInt(t) {
-        t.startObject(2);
-    }
-    static addBitWidth(t, n) {
-        t.addFieldInt32(0, n, 0);
-    }
-    static addIsSigned(t, n) {
-        t.addFieldInt8(1, +n, 0);
-    }
-    static endInt(t) {
-        return t.endObject();
-    }
-    static createInt(t, n, i) {
-        return Rn.startInt(t), Rn.addBitWidth(t, n), Rn.addIsSigned(t, i), Rn.endInt(t);
-    }
-}
-class qr {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsDictionaryEncoding(t, n) {
-        return (n || new qr()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsDictionaryEncoding(t, n) {
-        return t.setPosition(t.position() + nt), (n || new qr()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    /**
-     * The known dictionary id in the application where this data is used. In
-     * the file or streaming formats, the dictionary ids are found in the
-     * DictionaryBatch messages
-     */
-    id() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
-    }
-    /**
-     * The dictionary indices are constrained to be non-negative integers. If
-     * this field is null, the indices must be signed int32. To maximize
-     * cross-language compatibility and performance, implementations are
-     * recommended to prefer signed integer types over unsigned integer types
-     * and to avoid uint64 indices unless they are required by an application.
-     */
-    indexType(t) {
-        const n = this.bb.__offset(this.bb_pos, 6);
-        return n ? (t || new Rn()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
-    }
-    /**
-     * By default, dictionaries are not ordered, or the order does not have
-     * semantic meaning. In some statistical, applications, dictionary-encoding
-     * is used to represent ordered categorical data, and we provide a way to
-     * preserve that metadata here
-     */
-    isOrdered() {
-        const t = this.bb.__offset(this.bb_pos, 8);
-        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
-    }
-    dictionaryKind() {
-        const t = this.bb.__offset(this.bb_pos, 10);
-        return t ? this.bb.readInt16(this.bb_pos + t) : uy.DenseArray;
-    }
-    static startDictionaryEncoding(t) {
-        t.startObject(4);
-    }
-    static addId(t, n) {
-        t.addFieldInt64(0, n, BigInt("0"));
-    }
-    static addIndexType(t, n) {
-        t.addFieldOffset(1, n, 0);
-    }
-    static addIsOrdered(t, n) {
-        t.addFieldInt8(2, +n, 0);
-    }
-    static addDictionaryKind(t, n) {
-        t.addFieldInt16(3, n, uy.DenseArray);
-    }
-    static endDictionaryEncoding(t) {
-        return t.endObject();
-    }
-}
-class Ce {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsKeyValue(t, n) {
-        return (n || new Ce()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsKeyValue(t, n) {
-        return t.setPosition(t.position() + nt), (n || new Ce()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    key(t) {
-        const n = this.bb.__offset(this.bb_pos, 4);
-        return n ? this.bb.__string(this.bb_pos + n, t) : null;
-    }
-    value(t) {
-        const n = this.bb.__offset(this.bb_pos, 6);
-        return n ? this.bb.__string(this.bb_pos + n, t) : null;
-    }
-    static startKeyValue(t) {
-        t.startObject(2);
-    }
-    static addKey(t, n) {
-        t.addFieldOffset(0, n, 0);
-    }
-    static addValue(t, n) {
-        t.addFieldOffset(1, n, 0);
-    }
-    static endKeyValue(t) {
-        return t.endObject();
-    }
-    static createKeyValue(t, n, i) {
-        return Ce.startKeyValue(t), Ce.addKey(t, n), Ce.addValue(t, i), Ce.endKeyValue(t);
-    }
-}
-let aI = class tu {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsBinary(t, n) {
-            return (n || new tu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsBinary(t, n) {
-            return t.setPosition(t.position() + nt), (n || new tu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startBinary(t) {
-            t.startObject(0);
-        }
-        static endBinary(t) {
-            return t.endObject();
-        }
-        static createBinary(t) {
-            return tu.startBinary(t), tu.endBinary(t);
-        }
-    },
-    cI = class eu {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsBool(t, n) {
-            return (n || new eu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsBool(t, n) {
-            return t.setPosition(t.position() + nt), (n || new eu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startBool(t) {
-            t.startObject(0);
-        }
-        static endBool(t) {
-            return t.endObject();
-        }
-        static createBool(t) {
-            return eu.startBool(t), eu.endBool(t);
-        }
-    },
-    ld = class ja {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsDate(t, n) {
-            return (n || new ja()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsDate(t, n) {
-            return t.setPosition(t.position() + nt), (n || new ja()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        unit() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : Oi.MILLISECOND;
-        }
-        static startDate(t) {
-            t.startObject(1);
-        }
-        static addUnit(t, n) {
-            t.addFieldInt16(0, n, Oi.MILLISECOND);
-        }
-        static endDate(t) {
-            return t.endObject();
-        }
-        static createDate(t, n) {
-            return ja.startDate(t), ja.addUnit(t, n), ja.endDate(t);
-        }
-    },
-    qa = class Is {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsDecimal(t, n) {
-            return (n || new Is()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsDecimal(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Is()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * Total number of decimal digits
-         */
-        precision() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt32(this.bb_pos + t) : 0;
-        }
-        /**
-         * Number of digits after the decimal point "."
-         */
-        scale() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? this.bb.readInt32(this.bb_pos + t) : 0;
-        }
-        /**
-         * Number of bits per value. The only accepted widths are 128 and 256.
-         * We use bitWidth for consistency with Int::bitWidth.
-         */
-        bitWidth() {
-            const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? this.bb.readInt32(this.bb_pos + t) : 128;
-        }
-        static startDecimal(t) {
-            t.startObject(3);
-        }
-        static addPrecision(t, n) {
-            t.addFieldInt32(0, n, 0);
-        }
-        static addScale(t, n) {
-            t.addFieldInt32(1, n, 0);
-        }
-        static addBitWidth(t, n) {
-            t.addFieldInt32(2, n, 128);
-        }
-        static endDecimal(t) {
-            return t.endObject();
-        }
-        static createDecimal(t, n, i, r) {
-            return Is.startDecimal(t), Is.addPrecision(t, n), Is.addScale(t, i), Is.addBitWidth(t, r), Is.endDecimal(t);
-        }
-    },
-    ud = class Ya {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsDuration(t, n) {
-            return (n || new Ya()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsDuration(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ya()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        unit() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : bt.MILLISECOND;
-        }
-        static startDuration(t) {
-            t.startObject(1);
-        }
-        static addUnit(t, n) {
-            t.addFieldInt16(0, n, bt.MILLISECOND);
-        }
-        static endDuration(t) {
-            return t.endObject();
-        }
-        static createDuration(t, n) {
-            return Ya.startDuration(t), Ya.addUnit(t, n), Ya.endDuration(t);
-        }
-    },
-    fd = class Wa {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsFixedSizeBinary(t, n) {
-            return (n || new Wa()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsFixedSizeBinary(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Wa()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * Number of bytes per value
-         */
-        byteWidth() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt32(this.bb_pos + t) : 0;
-        }
-        static startFixedSizeBinary(t) {
-            t.startObject(1);
-        }
-        static addByteWidth(t, n) {
-            t.addFieldInt32(0, n, 0);
-        }
-        static endFixedSizeBinary(t) {
-            return t.endObject();
-        }
-        static createFixedSizeBinary(t, n) {
-            return Wa.startFixedSizeBinary(t), Wa.addByteWidth(t, n), Wa.endFixedSizeBinary(t);
-        }
-    },
-    hd = class Ga {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsFixedSizeList(t, n) {
-            return (n || new Ga()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsFixedSizeList(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Ga()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * Number of list items per value
-         */
-        listSize() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt32(this.bb_pos + t) : 0;
-        }
-        static startFixedSizeList(t) {
-            t.startObject(1);
-        }
-        static addListSize(t, n) {
-            t.addFieldInt32(0, n, 0);
-        }
-        static endFixedSizeList(t) {
-            return t.endObject();
-        }
-        static createFixedSizeList(t, n) {
-            return Ga.startFixedSizeList(t), Ga.addListSize(t, n), Ga.endFixedSizeList(t);
-        }
-    };
-class tr {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsFloatingPoint(t, n) {
-        return (n || new tr()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsFloatingPoint(t, n) {
-        return t.setPosition(t.position() + nt), (n || new tr()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    precision() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt16(this.bb_pos + t) : rn.HALF;
-    }
-    static startFloatingPoint(t) {
-        t.startObject(1);
-    }
-    static addPrecision(t, n) {
-        t.addFieldInt16(0, n, rn.HALF);
-    }
-    static endFloatingPoint(t) {
-        return t.endObject();
-    }
-    static createFloatingPoint(t, n) {
-        return tr.startFloatingPoint(t), tr.addPrecision(t, n), tr.endFloatingPoint(t);
-    }
-}
-class er {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsInterval(t, n) {
-        return (n || new er()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsInterval(t, n) {
-        return t.setPosition(t.position() + nt), (n || new er()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    unit() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt16(this.bb_pos + t) : mr.YEAR_MONTH;
-    }
-    static startInterval(t) {
-        t.startObject(1);
-    }
-    static addUnit(t, n) {
-        t.addFieldInt16(0, n, mr.YEAR_MONTH);
-    }
-    static endInterval(t) {
-        return t.endObject();
-    }
-    static createInterval(t, n) {
-        return er.startInterval(t), er.addUnit(t, n), er.endInterval(t);
-    }
-}
-let lI = class nu {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsLargeBinary(t, n) {
-            return (n || new nu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsLargeBinary(t, n) {
-            return t.setPosition(t.position() + nt), (n || new nu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startLargeBinary(t) {
-            t.startObject(0);
-        }
-        static endLargeBinary(t) {
-            return t.endObject();
-        }
-        static createLargeBinary(t) {
-            return nu.startLargeBinary(t), nu.endLargeBinary(t);
-        }
-    },
-    uI = class iu {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsLargeUtf8(t, n) {
-            return (n || new iu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsLargeUtf8(t, n) {
-            return t.setPosition(t.position() + nt), (n || new iu()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startLargeUtf8(t) {
-            t.startObject(0);
-        }
-        static endLargeUtf8(t) {
-            return t.endObject();
-        }
-        static createLargeUtf8(t) {
-            return iu.startLargeUtf8(t), iu.endLargeUtf8(t);
-        }
-    },
-    fI = class ru {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsList(t, n) {
-            return (n || new ru()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsList(t, n) {
-            return t.setPosition(t.position() + nt), (n || new ru()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startList(t) {
-            t.startObject(0);
-        }
-        static endList(t) {
-            return t.endObject();
-        }
-        static createList(t) {
-            return ru.startList(t), ru.endList(t);
-        }
-    },
-    dd = class Xa {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsMap(t, n) {
-            return (n || new Xa()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsMap(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Xa()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * Set to true if the keys within each value are sorted
-         */
-        keysSorted() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
-        }
-        static startMap(t) {
-            t.startObject(1);
-        }
-        static addKeysSorted(t, n) {
-            t.addFieldInt8(0, +n, 0);
-        }
-        static endMap(t) {
-            return t.endObject();
-        }
-        static createMap(t, n) {
-            return Xa.startMap(t), Xa.addKeysSorted(t, n), Xa.endMap(t);
-        }
-    },
-    hI = class su {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsNull(t, n) {
-            return (n || new su()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsNull(t, n) {
-            return t.setPosition(t.position() + nt), (n || new su()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static startNull(t) {
-            t.startObject(0);
-        }
-        static endNull(t) {
-            return t.endObject();
-        }
-        static createNull(t) {
-            return su.startNull(t), su.endNull(t);
-        }
-    };
-class Co {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsStruct_(t, n) {
-        return (n || new Co()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsStruct_(t, n) {
-        return t.setPosition(t.position() + nt), (n || new Co()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static startStruct_(t) {
-        t.startObject(0);
-    }
-    static endStruct_(t) {
-        return t.endObject();
-    }
-    static createStruct_(t) {
-        return Co.startStruct_(t), Co.endStruct_(t);
-    }
-}
-class Zn {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsTime(t, n) {
-        return (n || new Zn()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsTime(t, n) {
-        return t.setPosition(t.position() + nt), (n || new Zn()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    unit() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt16(this.bb_pos + t) : bt.MILLISECOND;
-    }
-    bitWidth() {
-        const t = this.bb.__offset(this.bb_pos, 6);
-        return t ? this.bb.readInt32(this.bb_pos + t) : 32;
-    }
-    static startTime(t) {
-        t.startObject(2);
-    }
-    static addUnit(t, n) {
-        t.addFieldInt16(0, n, bt.MILLISECOND);
-    }
-    static addBitWidth(t, n) {
-        t.addFieldInt32(1, n, 32);
-    }
-    static endTime(t) {
-        return t.endObject();
-    }
-    static createTime(t, n, i) {
-        return Zn.startTime(t), Zn.addUnit(t, n), Zn.addBitWidth(t, i), Zn.endTime(t);
-    }
-}
-class Qn {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsTimestamp(t, n) {
-        return (n || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsTimestamp(t, n) {
-        return t.setPosition(t.position() + nt), (n || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    unit() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt16(this.bb_pos + t) : bt.SECOND;
-    }
-    timezone(t) {
-        const n = this.bb.__offset(this.bb_pos, 6);
-        return n ? this.bb.__string(this.bb_pos + n, t) : null;
-    }
-    static startTimestamp(t) {
-        t.startObject(2);
-    }
-    static addUnit(t, n) {
-        t.addFieldInt16(0, n, bt.SECOND);
-    }
-    static addTimezone(t, n) {
-        t.addFieldOffset(1, n, 0);
-    }
-    static endTimestamp(t) {
-        return t.endObject();
-    }
-    static createTimestamp(t, n, i) {
-        return Qn.startTimestamp(t), Qn.addUnit(t, n), Qn.addTimezone(t, i), Qn.endTimestamp(t);
-    }
-}
-class In {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsUnion(t, n) {
-        return (n || new In()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsUnion(t, n) {
-        return t.setPosition(t.position() + nt), (n || new In()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    mode() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt16(this.bb_pos + t) : On.Sparse;
-    }
-    typeIds(t) {
-        const n = this.bb.__offset(this.bb_pos, 6);
-        return n ? this.bb.readInt32(this.bb.__vector(this.bb_pos + n) + t * 4) : 0;
-    }
-    typeIdsLength() {
-        const t = this.bb.__offset(this.bb_pos, 6);
-        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-    }
-    typeIdsArray() {
-        const t = this.bb.__offset(this.bb_pos, 6);
-        return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
-    }
-    static startUnion(t) {
-        t.startObject(2);
-    }
-    static addMode(t, n) {
-        t.addFieldInt16(0, n, On.Sparse);
-    }
-    static addTypeIds(t, n) {
-        t.addFieldOffset(1, n, 0);
-    }
-    static createTypeIdsVector(t, n) {
-        t.startVector(4, n.length, 4);
-        for (let i = n.length - 1; i >= 0; i--)
-            t.addInt32(n[i]);
-        return t.endVector();
-    }
-    static startTypeIdsVector(t, n) {
-        t.startVector(4, n, 4);
-    }
-    static endUnion(t) {
-        return t.endObject();
-    }
-    static createUnion(t, n, i) {
-        return In.startUnion(t), In.addMode(t, n), In.addTypeIds(t, i), In.endUnion(t);
-    }
-}
-let dI = class ou {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsUtf8(t, n) {
-        return (n || new ou()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsUtf8(t, n) {
-        return t.setPosition(t.position() + nt), (n || new ou()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static startUtf8(t) {
-        t.startObject(0);
-    }
-    static endUtf8(t) {
-        return t.endObject();
-    }
-    static createUtf8(t) {
-        return ou.startUtf8(t), ou.endUtf8(t);
-    }
-};
-var pe;
-(function(e) {
-    e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.FloatingPoint = 3] = "FloatingPoint", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct_ = 13] = "Struct_", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.LargeList = 21] = "LargeList", e[e.RunEndEncoded = 22] = "RunEndEncoded";
-})(pe || (pe = {}));
-let Xn = class pd {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsField(t, n) {
-            return (n || new pd()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsField(t, n) {
-            return t.setPosition(t.position() + nt), (n || new pd()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        name(t) {
-            const n = this.bb.__offset(this.bb_pos, 4);
-            return n ? this.bb.__string(this.bb_pos + n, t) : null;
-        }
-        /**
-         * Whether or not this field can contain nulls. Should be true in general.
-         */
-        nullable() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
-        }
-        typeType() {
-            const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? this.bb.readUint8(this.bb_pos + t) : pe.NONE;
-        }
-        /**
-         * This is the type of the decoded value if the field is dictionary encoded.
-         */
-        type(t) {
-            const n = this.bb.__offset(this.bb_pos, 10);
-            return n ? this.bb.__union(t, this.bb_pos + n) : null;
-        }
-        /**
-         * Present only if the field is dictionary encoded.
-         */
-        dictionary(t) {
-            const n = this.bb.__offset(this.bb_pos, 12);
-            return n ? (t || new qr()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
-        }
-        /**
-         * children apply only to nested data types like Struct, List and Union. For
-         * primitive types children will have length 0.
-         */
-        children(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 14);
-            return i ? (n || new pd()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-        }
-        childrenLength() {
-            const t = this.bb.__offset(this.bb_pos, 14);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        /**
-         * User-defined metadata
-         */
-        customMetadata(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 16);
-            return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-        }
-        customMetadataLength() {
-            const t = this.bb.__offset(this.bb_pos, 16);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        static startField(t) {
-            t.startObject(7);
-        }
-        static addName(t, n) {
-            t.addFieldOffset(0, n, 0);
-        }
-        static addNullable(t, n) {
-            t.addFieldInt8(1, +n, 0);
-        }
-        static addTypeType(t, n) {
-            t.addFieldInt8(2, n, pe.NONE);
-        }
-        static addType(t, n) {
-            t.addFieldOffset(3, n, 0);
-        }
-        static addDictionary(t, n) {
-            t.addFieldOffset(4, n, 0);
-        }
-        static addChildren(t, n) {
-            t.addFieldOffset(5, n, 0);
-        }
-        static createChildrenVector(t, n) {
-            t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
-            return t.endVector();
-        }
-        static startChildrenVector(t, n) {
-            t.startVector(4, n, 4);
-        }
-        static addCustomMetadata(t, n) {
-            t.addFieldOffset(6, n, 0);
-        }
-        static createCustomMetadataVector(t, n) {
-            t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
-            return t.endVector();
-        }
-        static startCustomMetadataVector(t, n) {
-            t.startVector(4, n, 4);
-        }
-        static endField(t) {
-            return t.endObject();
-        }
-    },
-    Gi = class Er {
-        constructor() {
-            this.bb = null, this.bb_pos = 0;
-        }
-        __init(t, n) {
-            return this.bb_pos = t, this.bb = n, this;
-        }
-        static getRootAsSchema(t, n) {
-            return (n || new Er()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        static getSizePrefixedRootAsSchema(t, n) {
-            return t.setPosition(t.position() + nt), (n || new Er()).__init(t.readInt32(t.position()) + t.position(), t);
-        }
-        /**
-         * endianness of the buffer
-         * it is Little Endian by default
-         * if endianness doesn't match the underlying system then the vectors need to be converted
-         */
-        endianness() {
-            const t = this.bb.__offset(this.bb_pos, 4);
-            return t ? this.bb.readInt16(this.bb_pos + t) : Gc.Little;
-        }
-        fields(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 6);
-            return i ? (n || new Xn()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-        }
-        fieldsLength() {
-            const t = this.bb.__offset(this.bb_pos, 6);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        customMetadata(t, n) {
-            const i = this.bb.__offset(this.bb_pos, 8);
-            return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-        }
-        customMetadataLength() {
-            const t = this.bb.__offset(this.bb_pos, 8);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        /**
-         * Features used in the stream/file.
-         */
-        features(t) {
-            const n = this.bb.__offset(this.bb_pos, 10);
-            return n ? this.bb.readInt64(this.bb.__vector(this.bb_pos + n) + t * 8) : BigInt(0);
-        }
-        featuresLength() {
-            const t = this.bb.__offset(this.bb_pos, 10);
-            return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-        }
-        static startSchema(t) {
-            t.startObject(4);
-        }
-        static addEndianness(t, n) {
-            t.addFieldInt16(0, n, Gc.Little);
-        }
-        static addFields(t, n) {
-            t.addFieldOffset(1, n, 0);
-        }
-        static createFieldsVector(t, n) {
-            t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
-            return t.endVector();
-        }
-        static startFieldsVector(t, n) {
-            t.startVector(4, n, 4);
-        }
-        static addCustomMetadata(t, n) {
-            t.addFieldOffset(2, n, 0);
-        }
-        static createCustomMetadataVector(t, n) {
-            t.startVector(4, n.length, 4);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addOffset(n[i]);
-            return t.endVector();
-        }
-        static startCustomMetadataVector(t, n) {
-            t.startVector(4, n, 4);
-        }
-        static addFeatures(t, n) {
-            t.addFieldOffset(3, n, 0);
-        }
-        static createFeaturesVector(t, n) {
-            t.startVector(8, n.length, 8);
-            for (let i = n.length - 1; i >= 0; i--)
-                t.addInt64(n[i]);
-            return t.endVector();
-        }
-        static startFeaturesVector(t, n) {
-            t.startVector(8, n, 8);
-        }
-        static endSchema(t) {
-            return t.endObject();
-        }
-        static finishSchemaBuffer(t, n) {
-            t.finish(n);
-        }
-        static finishSizePrefixedSchemaBuffer(t, n) {
-            t.finish(n, void 0, !0);
-        }
-        static createSchema(t, n, i, r, s) {
-            return Er.startSchema(t), Er.addEndianness(t, n), Er.addFields(t, i), Er.addCustomMetadata(t, r), Er.addFeatures(t, s), Er.endSchema(t);
-        }
-    };
-var te;
-(function(e) {
-    e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor";
-})(te || (te = {}));
-var E;
-(function(e) {
-    e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth", e[e.DurationSecond = -27] = "DurationSecond", e[e.DurationMillisecond = -28] = "DurationMillisecond", e[e.DurationMicrosecond = -29] = "DurationMicrosecond", e[e.DurationNanosecond = -30] = "DurationNanosecond";
-})(E || (E = {}));
-var Ur;
-(function(e) {
-    e[e.OFFSET = 0] = "OFFSET", e[e.DATA = 1] = "DATA", e[e.VALIDITY = 2] = "VALIDITY", e[e.TYPE = 3] = "TYPE";
-})(Ur || (Ur = {}));
-const Lot = void 0;
-
-function tf(e) {
-    if (e === null)
-        return "null";
-    if (e === Lot)
-        return "undefined";
-    switch (typeof e) {
-        case "number":
-            return `${e}`;
-        case "bigint":
-            return `${e}`;
-        case "string":
-            return `"${e}"`;
-    }
-    return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map((t) => tf(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, n) => typeof n == "bigint" ? `${n}` : n);
-}
-const Rot = Symbol.for("isArrowBigNum");
-
-function Ui(e, ...t) {
-    return t.length === 0 ? Object.setPrototypeOf(se(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype);
-}
-Ui.prototype[Rot] = !0;
-Ui.prototype.toJSON = function() {
-    return `"${nf(this)}"`;
-};
-Ui.prototype.valueOf = function() {
-    return BL(this);
-};
-Ui.prototype.toString = function() {
-    return nf(this);
-};
-Ui.prototype[Symbol.toPrimitive] = function(e = "default") {
-    switch (e) {
-        case "number":
-            return BL(this);
-        case "string":
-            return nf(this);
-        case "default":
-            return Cot(this);
-    }
-    return nf(this);
-};
-
-function wc(...e) {
-    return Ui.apply(this, e);
-}
-
-function vc(...e) {
-    return Ui.apply(this, e);
-}
-
-function ef(...e) {
-    return Ui.apply(this, e);
-}
-Object.setPrototypeOf(wc.prototype, Object.create(Int32Array.prototype));
-Object.setPrototypeOf(vc.prototype, Object.create(Uint32Array.prototype));
-Object.setPrototypeOf(ef.prototype, Object.create(Uint32Array.prototype));
-Object.assign(wc.prototype, Ui.prototype, {
-    constructor: wc,
-    signed: !0,
-    TypedArray: Int32Array,
-    BigIntArray: BigInt64Array
-});
-Object.assign(vc.prototype, Ui.prototype, {
-    constructor: vc,
-    signed: !1,
-    TypedArray: Uint32Array,
-    BigIntArray: BigUint64Array
-});
-Object.assign(ef.prototype, Ui.prototype, {
-    constructor: ef,
-    signed: !0,
-    TypedArray: Uint32Array,
-    BigIntArray: BigUint64Array
-});
-
-function BL(e) {
-    const {
-        buffer: t,
-        byteOffset: n,
-        length: i,
-        signed: r
-    } = e, s = new BigUint64Array(t, n, i), o = r && s.at(-1) & BigInt(1) << BigInt(63);
-    let a = BigInt(o ? 1 : 0),
-        c = BigInt(0);
-    if (o) {
-        for (const l of s)
-            a += ~l * (BigInt(1) << BigInt(32) * c++);
-        a *= BigInt(-1);
-    } else
-        for (const l of s)
-            a += l * (BigInt(1) << BigInt(32) * c++);
-    return a;
-}
-const nf = (e) => {
-        if (e.byteLength === 8)
-            return `${new e.BigIntArray(e.buffer, e.byteOffset, 1)[0]}`;
-        if (!e.signed)
-            return lg(e);
-        let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
-        if (new Int16Array([t.at(-1)])[0] >= 0)
-            return lg(e);
-        t = t.slice();
-        let i = 1;
-        for (let s = 0; s < t.length; s++) {
-            const o = t[s],
-                a = ~o + i;
-            t[s] = a, i &= o === 0 ? 1 : 0;
-        }
-        return `-${lg(t)}`;
-    },
-    Cot = (e) => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : nf(e);
-
-function lg(e) {
-    let t = "";
-    const n = new Uint32Array(2);
-    let i = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
-    const r = new Uint32Array((i = new Uint16Array(i).reverse()).buffer);
-    let s = -1;
-    const o = i.length - 1;
-    do {
-        for (n[0] = i[s = 0]; s < o;)
-            i[s++] = n[1] = n[0] / 10, n[0] = (n[0] - n[1] * 10 << 16) + i[s];
-        i[s] = n[1] = n[0] / 10, n[0] = n[0] - n[1] * 10, t = `${n[0]}${t}`;
-    } while (r[0] || r[1] || r[2] || r[3]);
-    return t ?? "0";
-}
-class r_ {
-    /** @nocollapse */
-    static new(t, n) {
-        switch (n) {
-            case !0:
-                return new wc(t);
-            case !1:
-                return new vc(t);
-        }
-        switch (t.constructor) {
-            case Int8Array:
-            case Int16Array:
-            case Int32Array:
-            case BigInt64Array:
-                return new wc(t);
-        }
-        return t.byteLength === 16 ? new ef(t) : new vc(t);
-    }
-    /** @nocollapse */
-    static signed(t) {
-        return new wc(t);
-    }
-    /** @nocollapse */
-    static unsigned(t) {
-        return new vc(t);
-    }
-    /** @nocollapse */
-    static decimal(t) {
-        return new ef(t);
-    }
-    constructor(t, n) {
-        return r_.new(t, n);
-    }
-}
-
-function bn(e) {
-    if (typeof e == "bigint" && (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER))
-        throw new TypeError(`${e} is not safe to convert to a number.`);
-    return Number(e);
-}
-var OL, FL, EL, LL, RL, CL, kL, UL, zL, PL, VL, jL, qL, YL, WL, GL, XL, HL, JL, KL, ZL, QL;
-class st {
-    /** @nocollapse */
-    static isNull(t) {
-        return (t == null ? void 0 : t.typeId) === E.Null;
-    }
-    /** @nocollapse */
-    static isInt(t) {
-        return (t == null ? void 0 : t.typeId) === E.Int;
-    }
-    /** @nocollapse */
-    static isFloat(t) {
-        return (t == null ? void 0 : t.typeId) === E.Float;
-    }
-    /** @nocollapse */
-    static isBinary(t) {
-        return (t == null ? void 0 : t.typeId) === E.Binary;
-    }
-    /** @nocollapse */
-    static isLargeBinary(t) {
-        return (t == null ? void 0 : t.typeId) === E.LargeBinary;
-    }
-    /** @nocollapse */
-    static isUtf8(t) {
-        return (t == null ? void 0 : t.typeId) === E.Utf8;
-    }
-    /** @nocollapse */
-    static isLargeUtf8(t) {
-        return (t == null ? void 0 : t.typeId) === E.LargeUtf8;
-    }
-    /** @nocollapse */
-    static isBool(t) {
-        return (t == null ? void 0 : t.typeId) === E.Bool;
-    }
-    /** @nocollapse */
-    static isDecimal(t) {
-        return (t == null ? void 0 : t.typeId) === E.Decimal;
-    }
-    /** @nocollapse */
-    static isDate(t) {
-        return (t == null ? void 0 : t.typeId) === E.Date;
-    }
-    /** @nocollapse */
-    static isTime(t) {
-        return (t == null ? void 0 : t.typeId) === E.Time;
-    }
-    /** @nocollapse */
-    static isTimestamp(t) {
-        return (t == null ? void 0 : t.typeId) === E.Timestamp;
-    }
-    /** @nocollapse */
-    static isInterval(t) {
-        return (t == null ? void 0 : t.typeId) === E.Interval;
-    }
-    /** @nocollapse */
-    static isDuration(t) {
-        return (t == null ? void 0 : t.typeId) === E.Duration;
-    }
-    /** @nocollapse */
-    static isList(t) {
-        return (t == null ? void 0 : t.typeId) === E.List;
-    }
-    /** @nocollapse */
-    static isStruct(t) {
-        return (t == null ? void 0 : t.typeId) === E.Struct;
-    }
-    /** @nocollapse */
-    static isUnion(t) {
-        return (t == null ? void 0 : t.typeId) === E.Union;
-    }
-    /** @nocollapse */
-    static isFixedSizeBinary(t) {
-        return (t == null ? void 0 : t.typeId) === E.FixedSizeBinary;
-    }
-    /** @nocollapse */
-    static isFixedSizeList(t) {
-        return (t == null ? void 0 : t.typeId) === E.FixedSizeList;
-    }
-    /** @nocollapse */
-    static isMap(t) {
-        return (t == null ? void 0 : t.typeId) === E.Map;
-    }
-    /** @nocollapse */
-    static isDictionary(t) {
-        return (t == null ? void 0 : t.typeId) === E.Dictionary;
-    }
-    /** @nocollapse */
-    static isDenseUnion(t) {
-        return st.isUnion(t) && t.mode === On.Dense;
-    }
-    /** @nocollapse */
-    static isSparseUnion(t) {
-        return st.isUnion(t) && t.mode === On.Sparse;
-    }
-    constructor(t) {
-        this.typeId = t;
-    }
-}
-OL = Symbol.toStringTag;
-st[OL] = ((e) => (e.children = null, e.ArrayType = Array, e.OffsetArrayType = Int32Array, e[Symbol.toStringTag] = "DataType"))(st.prototype);
-class to extends st {
-    constructor() {
-        super(E.Null);
-    }
-    toString() {
-        return "Null";
-    }
-}
-FL = Symbol.toStringTag;
-to[FL] = ((e) => e[Symbol.toStringTag] = "Null")(to.prototype);
-class eo extends st {
-    constructor(t, n) {
-        super(E.Int), this.isSigned = t, this.bitWidth = n;
-    }
-    get ArrayType() {
-        switch (this.bitWidth) {
-            case 8:
-                return this.isSigned ? Int8Array : Uint8Array;
-            case 16:
-                return this.isSigned ? Int16Array : Uint16Array;
-            case 32:
-                return this.isSigned ? Int32Array : Uint32Array;
-            case 64:
-                return this.isSigned ? BigInt64Array : BigUint64Array;
-        }
-        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
-    }
-    toString() {
-        return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
-    }
-}
-EL = Symbol.toStringTag;
-eo[EL] = ((e) => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(eo.prototype);
-class rf extends eo {
-    constructor() {
-        super(!0, 32);
-    }
-    get ArrayType() {
-        return Int32Array;
-    }
-}
-Object.defineProperty(rf.prototype, "ArrayType", {
-    value: Int32Array
-});
-class sf extends st {
-    constructor(t) {
-        super(E.Float), this.precision = t;
-    }
-    get ArrayType() {
-        switch (this.precision) {
-            case rn.HALF:
-                return Uint16Array;
-            case rn.SINGLE:
-                return Float32Array;
-            case rn.DOUBLE:
-                return Float64Array;
-        }
-        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
-    }
-    toString() {
-        return `Float${this.precision << 5 || 16}`;
-    }
-}
-LL = Symbol.toStringTag;
-sf[LL] = ((e) => (e.precision = null, e[Symbol.toStringTag] = "Float"))(sf.prototype);
-class fy extends st {
-    constructor() {
-        super(E.Binary);
-    }
-    toString() {
-        return "Binary";
-    }
-}
-RL = Symbol.toStringTag;
-fy[RL] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))(fy.prototype);
-class hy extends st {
-    constructor() {
-        super(E.LargeBinary);
-    }
-    toString() {
-        return "LargeBinary";
-    }
-}
-CL = Symbol.toStringTag;
-hy[CL] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeBinary"))(hy.prototype);
-class dy extends st {
-    constructor() {
-        super(E.Utf8);
-    }
-    toString() {
-        return "Utf8";
-    }
-}
-kL = Symbol.toStringTag;
-dy[kL] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(dy.prototype);
-class py extends st {
-    constructor() {
-        super(E.LargeUtf8);
-    }
-    toString() {
-        return "LargeUtf8";
-    }
-}
-UL = Symbol.toStringTag;
-py[UL] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeUtf8"))(py.prototype);
-class yy extends st {
-    constructor() {
-        super(E.Bool);
-    }
-    toString() {
-        return "Bool";
-    }
-}
-zL = Symbol.toStringTag;
-yy[zL] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(yy.prototype);
-class my extends st {
-    constructor(t, n, i = 128) {
-        super(E.Decimal), this.scale = t, this.precision = n, this.bitWidth = i;
-    }
-    toString() {
-        return `Decimal[${this.precision}e${this.scale > 0 ? "+" : ""}${this.scale}]`;
-    }
-}
-PL = Symbol.toStringTag;
-my[PL] = ((e) => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(my.prototype);
-class gy extends st {
-    constructor(t) {
-        super(E.Date), this.unit = t;
-    }
-    toString() {
-        return `Date${(this.unit + 1) * 32}<${Oi[this.unit]}>`;
-    }
-}
-VL = Symbol.toStringTag;
-gy[VL] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))(gy.prototype);
-class of extends st {
-    constructor(t, n) {
-        super(E.Time), this.unit = t, this.bitWidth = n;
-    }
-    toString() {
-        return `Time${this.bitWidth}<${bt[this.unit]}>`;
-    }
-    get ArrayType() {
-        switch (this.bitWidth) {
-            case 32:
-                return Int32Array;
-            case 64:
-                return BigInt64Array;
-        }
-        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
-    }
-}
-jL = Symbol.toStringTag;
-of [jL] = ((e) => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(of.prototype);
-class by extends st {
-    constructor(t, n) {
-        super(E.Timestamp), this.unit = t, this.timezone = n;
-    }
-    toString() {
-        return `Timestamp<${bt[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
-    }
-}
-qL = Symbol.toStringTag;
-by[qL] = ((e) => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))(by.prototype);
-class wy extends st {
-    constructor(t) {
-        super(E.Interval), this.unit = t;
-    }
-    toString() {
-        return `Interval<${mr[this.unit]}>`;
-    }
-}
-YL = Symbol.toStringTag;
-wy[YL] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(wy.prototype);
-class vy extends st {
-    constructor(t) {
-        super(E.Duration), this.unit = t;
-    }
-    toString() {
-        return `Duration<${bt[this.unit]}>`;
-    }
-}
-WL = Symbol.toStringTag;
-vy[WL] = ((e) => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))(vy.prototype);
-class _y extends st {
-    constructor(t) {
-        super(E.List), this.children = [t];
-    }
-    toString() {
-        return `List<${this.valueType}>`;
-    }
-    get valueType() {
-        return this.children[0].type;
-    }
-    get valueField() {
-        return this.children[0];
-    }
-    get ArrayType() {
-        return this.valueType.ArrayType;
-    }
-}
-GL = Symbol.toStringTag;
-_y[GL] = ((e) => (e.children = null, e[Symbol.toStringTag] = "List"))(_y.prototype);
-class hn extends st {
-    constructor(t) {
-        super(E.Struct), this.children = t;
-    }
-    toString() {
-        return `Struct<{${this.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
-    }
-}
-XL = Symbol.toStringTag;
-hn[XL] = ((e) => (e.children = null, e[Symbol.toStringTag] = "Struct"))(hn.prototype);
-class xy extends st {
-    constructor(t, n, i) {
-        super(E.Union), this.mode = t, this.children = i, this.typeIds = n = Int32Array.from(n), this.typeIdToChildIndex = n.reduce((r, s, o) => (r[s] = o) && r || r, /* @__PURE__ */ Object.create(null));
-    }
-    toString() {
-        return `${this[Symbol.toStringTag]}<${this.children.map((t) => `${t.type}`).join(" | ")}>`;
-    }
-}
-HL = Symbol.toStringTag;
-xy[HL] = ((e) => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(xy.prototype);
-class Sy extends st {
-    constructor(t) {
-        super(E.FixedSizeBinary), this.byteWidth = t;
-    }
-    toString() {
-        return `FixedSizeBinary[${this.byteWidth}]`;
-    }
-}
-JL = Symbol.toStringTag;
-Sy[JL] = ((e) => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(Sy.prototype);
-class Iy extends st {
-    constructor(t, n) {
-        super(E.FixedSizeList), this.listSize = t, this.children = [n];
-    }
-    get valueType() {
-        return this.children[0].type;
-    }
-    get valueField() {
-        return this.children[0];
-    }
-    get ArrayType() {
-        return this.valueType.ArrayType;
-    }
-    toString() {
-        return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
-    }
-}
-KL = Symbol.toStringTag;
-Iy[KL] = ((e) => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(Iy.prototype);
-class Ay extends st {
-    constructor(t, n = !1) {
-        var i, r, s;
-        if (super(E.Map), this.children = [t], this.keysSorted = n, t && (t.name = "entries", !((i = t == null ? void 0 : t.type) === null || i === void 0) && i.children)) {
-            const o = (r = t == null ? void 0 : t.type) === null || r === void 0 ? void 0 : r.children[0];
-            o && (o.name = "key");
-            const a = (s = t == null ? void 0 : t.type) === null || s === void 0 ? void 0 : s.children[1];
-            a && (a.name = "value");
-        }
-    }
-    get keyType() {
-        return this.children[0].type.children[0].type;
-    }
-    get valueType() {
-        return this.children[0].type.children[1].type;
-    }
-    get childType() {
-        return this.children[0].type;
-    }
-    toString() {
-        return `Map<{${this.children[0].type.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
-    }
-}
-ZL = Symbol.toStringTag;
-Ay[ZL] = ((e) => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))(Ay.prototype);
-const kot = /* @__PURE__ */ ((e) => () => ++e)(-1);
-class Xc extends st {
-    constructor(t, n, i, r) {
-        super(E.Dictionary), this.indices = n, this.dictionary = t, this.isOrdered = r || !1, this.id = i == null ? kot() : bn(i);
-    }
-    get children() {
-        return this.dictionary.children;
-    }
-    get valueType() {
-        return this.dictionary;
-    }
-    get ArrayType() {
-        return this.dictionary.ArrayType;
-    }
-    toString() {
-        return `Dictionary<${this.indices}, ${this.dictionary}>`;
-    }
-}
-QL = Symbol.toStringTag;
-Xc[QL] = ((e) => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Xc.prototype);
-
-function zr(e) {
-    const t = e;
-    switch (e.typeId) {
-        case E.Decimal:
-            return e.bitWidth / 32;
-        case E.Timestamp:
-            return 2;
-        case E.Date:
-            return 1 + t.unit;
-        case E.Interval:
-            return 1 + t.unit;
-        case E.FixedSizeList:
-            return t.listSize;
-        case E.FixedSizeBinary:
-            return t.byteWidth;
-        default:
-            return 1;
-    }
-}
-class zt {
-    visitMany(t, ...n) {
-        return t.map((i, r) => this.visit(i, ...n.map((s) => s[r])));
-    }
-    visit(...t) {
-        return this.getVisitFn(t[0], !1).apply(this, t);
-    }
-    getVisitFn(t, n = !0) {
-        return Uot(this, t, n);
-    }
-    getVisitFnByTypeId(t, n = !0) {
-        return Ha(this, t, n);
-    }
-    visitNull(t, ...n) {
-        return null;
-    }
-    visitBool(t, ...n) {
-        return null;
-    }
-    visitInt(t, ...n) {
-        return null;
-    }
-    visitFloat(t, ...n) {
-        return null;
-    }
-    visitUtf8(t, ...n) {
-        return null;
-    }
-    visitLargeUtf8(t, ...n) {
-        return null;
-    }
-    visitBinary(t, ...n) {
-        return null;
-    }
-    visitLargeBinary(t, ...n) {
-        return null;
-    }
-    visitFixedSizeBinary(t, ...n) {
-        return null;
-    }
-    visitDate(t, ...n) {
-        return null;
-    }
-    visitTimestamp(t, ...n) {
-        return null;
-    }
-    visitTime(t, ...n) {
-        return null;
-    }
-    visitDecimal(t, ...n) {
-        return null;
-    }
-    visitList(t, ...n) {
-        return null;
-    }
-    visitStruct(t, ...n) {
-        return null;
-    }
-    visitUnion(t, ...n) {
-        return null;
-    }
-    visitDictionary(t, ...n) {
-        return null;
-    }
-    visitInterval(t, ...n) {
-        return null;
-    }
-    visitDuration(t, ...n) {
-        return null;
-    }
-    visitFixedSizeList(t, ...n) {
-        return null;
-    }
-    visitMap(t, ...n) {
-        return null;
-    }
-}
-
-function Uot(e, t, n = !0) {
-    return typeof t == "number" ? Ha(e, t, n) : typeof t == "string" && t in E ? Ha(e, E[t], n) : t && t instanceof st ? Ha(e, pI(t), n) : t != null && t.type && t.type instanceof st ? Ha(e, pI(t.type), n) : Ha(e, E.NONE, n);
-}
-
-function Ha(e, t, n = !0) {
-    let i = null;
-    switch (t) {
-        case E.Null:
-            i = e.visitNull;
-            break;
-        case E.Bool:
-            i = e.visitBool;
-            break;
-        case E.Int:
-            i = e.visitInt;
-            break;
-        case E.Int8:
-            i = e.visitInt8 || e.visitInt;
-            break;
-        case E.Int16:
-            i = e.visitInt16 || e.visitInt;
-            break;
-        case E.Int32:
-            i = e.visitInt32 || e.visitInt;
-            break;
-        case E.Int64:
-            i = e.visitInt64 || e.visitInt;
-            break;
-        case E.Uint8:
-            i = e.visitUint8 || e.visitInt;
-            break;
-        case E.Uint16:
-            i = e.visitUint16 || e.visitInt;
-            break;
-        case E.Uint32:
-            i = e.visitUint32 || e.visitInt;
-            break;
-        case E.Uint64:
-            i = e.visitUint64 || e.visitInt;
-            break;
-        case E.Float:
-            i = e.visitFloat;
-            break;
-        case E.Float16:
-            i = e.visitFloat16 || e.visitFloat;
-            break;
-        case E.Float32:
-            i = e.visitFloat32 || e.visitFloat;
-            break;
-        case E.Float64:
-            i = e.visitFloat64 || e.visitFloat;
-            break;
-        case E.Utf8:
-            i = e.visitUtf8;
-            break;
-        case E.LargeUtf8:
-            i = e.visitLargeUtf8;
-            break;
-        case E.Binary:
-            i = e.visitBinary;
-            break;
-        case E.LargeBinary:
-            i = e.visitLargeBinary;
-            break;
-        case E.FixedSizeBinary:
-            i = e.visitFixedSizeBinary;
-            break;
-        case E.Date:
-            i = e.visitDate;
-            break;
-        case E.DateDay:
-            i = e.visitDateDay || e.visitDate;
-            break;
-        case E.DateMillisecond:
-            i = e.visitDateMillisecond || e.visitDate;
-            break;
-        case E.Timestamp:
-            i = e.visitTimestamp;
-            break;
-        case E.TimestampSecond:
-            i = e.visitTimestampSecond || e.visitTimestamp;
-            break;
-        case E.TimestampMillisecond:
-            i = e.visitTimestampMillisecond || e.visitTimestamp;
-            break;
-        case E.TimestampMicrosecond:
-            i = e.visitTimestampMicrosecond || e.visitTimestamp;
-            break;
-        case E.TimestampNanosecond:
-            i = e.visitTimestampNanosecond || e.visitTimestamp;
-            break;
-        case E.Time:
-            i = e.visitTime;
-            break;
-        case E.TimeSecond:
-            i = e.visitTimeSecond || e.visitTime;
-            break;
-        case E.TimeMillisecond:
-            i = e.visitTimeMillisecond || e.visitTime;
-            break;
-        case E.TimeMicrosecond:
-            i = e.visitTimeMicrosecond || e.visitTime;
-            break;
-        case E.TimeNanosecond:
-            i = e.visitTimeNanosecond || e.visitTime;
-            break;
-        case E.Decimal:
-            i = e.visitDecimal;
-            break;
-        case E.List:
-            i = e.visitList;
-            break;
-        case E.Struct:
-            i = e.visitStruct;
-            break;
-        case E.Union:
-            i = e.visitUnion;
-            break;
-        case E.DenseUnion:
-            i = e.visitDenseUnion || e.visitUnion;
-            break;
-        case E.SparseUnion:
-            i = e.visitSparseUnion || e.visitUnion;
-            break;
-        case E.Dictionary:
-            i = e.visitDictionary;
-            break;
-        case E.Interval:
-            i = e.visitInterval;
-            break;
-        case E.IntervalDayTime:
-            i = e.visitIntervalDayTime || e.visitInterval;
-            break;
-        case E.IntervalYearMonth:
-            i = e.visitIntervalYearMonth || e.visitInterval;
-            break;
-        case E.Duration:
-            i = e.visitDuration;
-            break;
-        case E.DurationSecond:
-            i = e.visitDurationSecond || e.visitDuration;
-            break;
-        case E.DurationMillisecond:
-            i = e.visitDurationMillisecond || e.visitDuration;
-            break;
-        case E.DurationMicrosecond:
-            i = e.visitDurationMicrosecond || e.visitDuration;
-            break;
-        case E.DurationNanosecond:
-            i = e.visitDurationNanosecond || e.visitDuration;
-            break;
-        case E.FixedSizeList:
-            i = e.visitFixedSizeList;
-            break;
-        case E.Map:
-            i = e.visitMap;
-            break;
-    }
-    if (typeof i == "function")
-        return i;
-    if (!n)
-        return () => null;
-    throw new Error(`Unrecognized type '${E[t]}'`);
-}
-
-function pI(e) {
-    switch (e.typeId) {
-        case E.Null:
-            return E.Null;
-        case E.Int: {
-            const {
-                bitWidth: t,
-                isSigned: n
-            } = e;
-            switch (t) {
-                case 8:
-                    return n ? E.Int8 : E.Uint8;
-                case 16:
-                    return n ? E.Int16 : E.Uint16;
-                case 32:
-                    return n ? E.Int32 : E.Uint32;
-                case 64:
-                    return n ? E.Int64 : E.Uint64;
-            }
-            return E.Int;
-        }
-        case E.Float:
-            switch (e.precision) {
-                case rn.HALF:
-                    return E.Float16;
-                case rn.SINGLE:
-                    return E.Float32;
-                case rn.DOUBLE:
-                    return E.Float64;
-            }
-            return E.Float;
-        case E.Binary:
-            return E.Binary;
-        case E.LargeBinary:
-            return E.LargeBinary;
-        case E.Utf8:
-            return E.Utf8;
-        case E.LargeUtf8:
-            return E.LargeUtf8;
-        case E.Bool:
-            return E.Bool;
-        case E.Decimal:
-            return E.Decimal;
-        case E.Time:
-            switch (e.unit) {
-                case bt.SECOND:
-                    return E.TimeSecond;
-                case bt.MILLISECOND:
-                    return E.TimeMillisecond;
-                case bt.MICROSECOND:
-                    return E.TimeMicrosecond;
-                case bt.NANOSECOND:
-                    return E.TimeNanosecond;
-            }
-            return E.Time;
-        case E.Timestamp:
-            switch (e.unit) {
-                case bt.SECOND:
-                    return E.TimestampSecond;
-                case bt.MILLISECOND:
-                    return E.TimestampMillisecond;
-                case bt.MICROSECOND:
-                    return E.TimestampMicrosecond;
-                case bt.NANOSECOND:
-                    return E.TimestampNanosecond;
-            }
-            return E.Timestamp;
-        case E.Date:
-            switch (e.unit) {
-                case Oi.DAY:
-                    return E.DateDay;
-                case Oi.MILLISECOND:
-                    return E.DateMillisecond;
-            }
-            return E.Date;
-        case E.Interval:
-            switch (e.unit) {
-                case mr.DAY_TIME:
-                    return E.IntervalDayTime;
-                case mr.YEAR_MONTH:
-                    return E.IntervalYearMonth;
-            }
-            return E.Interval;
-        case E.Duration:
-            switch (e.unit) {
-                case bt.SECOND:
-                    return E.DurationSecond;
-                case bt.MILLISECOND:
-                    return E.DurationMillisecond;
-                case bt.MICROSECOND:
-                    return E.DurationMicrosecond;
-                case bt.NANOSECOND:
-                    return E.DurationNanosecond;
-            }
-            return E.Duration;
-        case E.Map:
-            return E.Map;
-        case E.List:
-            return E.List;
-        case E.Struct:
-            return E.Struct;
-        case E.Union:
-            switch (e.mode) {
-                case On.Dense:
-                    return E.DenseUnion;
-                case On.Sparse:
-                    return E.SparseUnion;
-            }
-            return E.Union;
-        case E.FixedSizeBinary:
-            return E.FixedSizeBinary;
-        case E.FixedSizeList:
-            return E.FixedSizeList;
-        case E.Dictionary:
-            return E.Dictionary;
-    }
-    throw new Error(`Unrecognized type '${E[e.typeId]}'`);
-}
-zt.prototype.visitInt8 = null;
-zt.prototype.visitInt16 = null;
-zt.prototype.visitInt32 = null;
-zt.prototype.visitInt64 = null;
-zt.prototype.visitUint8 = null;
-zt.prototype.visitUint16 = null;
-zt.prototype.visitUint32 = null;
-zt.prototype.visitUint64 = null;
-zt.prototype.visitFloat16 = null;
-zt.prototype.visitFloat32 = null;
-zt.prototype.visitFloat64 = null;
-zt.prototype.visitDateDay = null;
-zt.prototype.visitDateMillisecond = null;
-zt.prototype.visitTimestampSecond = null;
-zt.prototype.visitTimestampMillisecond = null;
-zt.prototype.visitTimestampMicrosecond = null;
-zt.prototype.visitTimestampNanosecond = null;
-zt.prototype.visitTimeSecond = null;
-zt.prototype.visitTimeMillisecond = null;
-zt.prototype.visitTimeMicrosecond = null;
-zt.prototype.visitTimeNanosecond = null;
-zt.prototype.visitDenseUnion = null;
-zt.prototype.visitSparseUnion = null;
-zt.prototype.visitIntervalDayTime = null;
-zt.prototype.visitIntervalYearMonth = null;
-zt.prototype.visitDuration = null;
-zt.prototype.visitDurationSecond = null;
-zt.prototype.visitDurationMillisecond = null;
-zt.prototype.visitDurationMicrosecond = null;
-zt.prototype.visitDurationNanosecond = null;
-const tR = new Float64Array(1),
-    Ta = new Uint32Array(tR.buffer);
-
-function eR(e) {
-    const t = (e & 31744) >> 10,
-        n = (e & 1023) / 1024,
-        i = Math.pow(-1, (e & 32768) >> 15);
-    switch (t) {
-        case 31:
-            return i * (n ? Number.NaN : 1 / 0);
-        case 0:
-            return i * (n ? 6103515625e-14 * n : 0);
-    }
-    return i * Math.pow(2, t - 15) * (1 + n);
-}
-
-function zot(e) {
-    if (e !== e)
-        return 32256;
-    tR[0] = e;
-    const t = (Ta[1] & 2147483648) >> 16 & 65535;
-    let n = Ta[1] & 2146435072,
-        i = 0;
-    return n >= 1089470464 ? Ta[0] > 0 ? n = 31744 : (n = (n & 2080374784) >> 16, i = (Ta[1] & 1048575) >> 10) : n <= 1056964608 ? (i = 1048576 + (Ta[1] & 1048575), i = 1048576 + (i << (n >> 20) - 998) >> 21, n = 0) : (n = n - 1056964608 >> 10, i = (Ta[1] & 1048575) + 512 >> 10), t | n | i & 65535;
-}
-class It extends zt {}
-
-function Nt(e) {
-    return (t, n, i) => {
-        if (t.setValid(n, i != null))
-            return e(t, n, i);
-    };
-}
-const Pot = (e, t, n) => {
-        e[t] = Math.trunc(n / 864e5);
-    },
-    s_ = (e, t, n) => {
-        e[t] = Math.trunc(n % 4294967296), e[t + 1] = Math.trunc(n / 4294967296);
-    },
-    Vot = (e, t, n) => {
-        e[t] = Math.trunc(n * 1e3 % 4294967296), e[t + 1] = Math.trunc(n * 1e3 / 4294967296);
-    },
-    jot = (e, t, n) => {
-        e[t] = Math.trunc(n * 1e6 % 4294967296), e[t + 1] = Math.trunc(n * 1e6 / 4294967296);
-    },
-    nR = (e, t, n, i) => {
-        if (n + 1 < t.length) {
-            const r = bn(t[n]),
-                s = bn(t[n + 1]);
-            e.set(i.subarray(0, s - r), r);
-        }
-    },
-    qot = ({
-        offset: e,
-        values: t
-    }, n, i) => {
-        const r = e + n;
-        i ? t[r >> 3] |= 1 << r % 8 : t[r >> 3] &= ~(1 << r % 8);
-    },
-    ms = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    o_ = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    iR = ({
-        values: e
-    }, t, n) => {
-        e[t] = zot(n);
-    },
-    Yot = (e, t, n) => {
-        switch (e.type.precision) {
-            case rn.HALF:
-                return iR(e, t, n);
-            case rn.SINGLE:
-            case rn.DOUBLE:
-                return o_(e, t, n);
-        }
-    },
-    rR = ({
-        values: e
-    }, t, n) => {
-        Pot(e, t, n.valueOf());
-    },
-    sR = ({
-        values: e
-    }, t, n) => {
-        s_(e, t * 2, n.valueOf());
-    },
-    Wot = ({
-        stride: e,
-        values: t
-    }, n, i) => {
-        t.set(i.subarray(0, e), e * n);
-    },
-    oR = ({
-        values: e,
-        valueOffsets: t
-    }, n, i) => nR(e, t, n, i),
-    aR = ({
-        values: e,
-        valueOffsets: t
-    }, n, i) => nR(e, t, n, t_(i)),
-    Got = (e, t, n) => {
-        e.type.unit === Oi.DAY ? rR(e, t, n) : sR(e, t, n);
-    },
-    cR = ({
-        values: e
-    }, t, n) => s_(e, t * 2, n / 1e3),
-    lR = ({
-        values: e
-    }, t, n) => s_(e, t * 2, n),
-    uR = ({
-        values: e
-    }, t, n) => Vot(e, t * 2, n),
-    fR = ({
-        values: e
-    }, t, n) => jot(e, t * 2, n),
-    Xot = (e, t, n) => {
-        switch (e.type.unit) {
-            case bt.SECOND:
-                return cR(e, t, n);
-            case bt.MILLISECOND:
-                return lR(e, t, n);
-            case bt.MICROSECOND:
-                return uR(e, t, n);
-            case bt.NANOSECOND:
-                return fR(e, t, n);
-        }
-    },
-    hR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    dR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    pR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    yR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    Hot = (e, t, n) => {
-        switch (e.type.unit) {
-            case bt.SECOND:
-                return hR(e, t, n);
-            case bt.MILLISECOND:
-                return dR(e, t, n);
-            case bt.MICROSECOND:
-                return pR(e, t, n);
-            case bt.NANOSECOND:
-                return yR(e, t, n);
-        }
-    },
-    Jot = ({
-        values: e,
-        stride: t
-    }, n, i) => {
-        e.set(i.subarray(0, t), t * n);
-    },
-    Kot = (e, t, n) => {
-        const i = e.children[0],
-            r = e.valueOffsets,
-            s = fi.getVisitFn(i);
-        if (Array.isArray(n))
-            for (let o = -1, a = r[t], c = r[t + 1]; a < c;)
-                s(i, a++, n[++o]);
-        else
-            for (let o = -1, a = r[t], c = r[t + 1]; a < c;)
-                s(i, a++, n.get(++o));
-    },
-    Zot = (e, t, n) => {
-        const i = e.children[0],
-            {
-                valueOffsets: r
-            } = e,
-            s = fi.getVisitFn(i);
-        let {
-            [t]: o, [t + 1]: a
-        } = r;
-        const c = n instanceof Map ? n.entries() : Object.entries(n);
-        for (const l of c)
-            if (s(i, o, l), ++o >= a)
-                break;
-    },
-    Qot = (e, t) => (n, i, r, s) => i && n(i, e, t[s]),
-    tat = (e, t) => (n, i, r, s) => i && n(i, e, t.get(s)),
-    eat = (e, t) => (n, i, r, s) => i && n(i, e, t.get(r.name)),
-    nat = (e, t) => (n, i, r, s) => i && n(i, e, t[r.name]),
-    iat = (e, t, n) => {
-        const i = e.type.children.map((s) => fi.getVisitFn(s.type)),
-            r = n instanceof Map ? eat(t, n) : n instanceof ae ? tat(t, n) : Array.isArray(n) ? Qot(t, n) : nat(t, n);
-        e.type.children.forEach((s, o) => r(i[o], e.children[o], s, o));
-    },
-    rat = (e, t, n) => {
-        e.type.mode === On.Dense ? mR(e, t, n) : gR(e, t, n);
-    },
-    mR = (e, t, n) => {
-        const i = e.type.typeIdToChildIndex[e.typeIds[t]],
-            r = e.children[i];
-        fi.visit(r, e.valueOffsets[t], n);
-    },
-    gR = (e, t, n) => {
-        const i = e.type.typeIdToChildIndex[e.typeIds[t]],
-            r = e.children[i];
-        fi.visit(r, t, n);
-    },
-    sat = (e, t, n) => {
-        var i;
-        (i = e.dictionary) === null || i === void 0 || i.set(e.values[t], n);
-    },
-    oat = (e, t, n) => {
-        e.type.unit === mr.DAY_TIME ? bR(e, t, n) : wR(e, t, n);
-    },
-    bR = ({
-        values: e
-    }, t, n) => {
-        e.set(n.subarray(0, 2), 2 * t);
-    },
-    wR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n[0] * 12 + n[1] % 12;
-    },
-    vR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    _R = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    xR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    SR = ({
-        values: e
-    }, t, n) => {
-        e[t] = n;
-    },
-    aat = (e, t, n) => {
-        switch (e.type.unit) {
-            case bt.SECOND:
-                return vR(e, t, n);
-            case bt.MILLISECOND:
-                return _R(e, t, n);
-            case bt.MICROSECOND:
-                return xR(e, t, n);
-            case bt.NANOSECOND:
-                return SR(e, t, n);
-        }
-    },
-    cat = (e, t, n) => {
-        const {
-            stride: i
-        } = e, r = e.children[0], s = fi.getVisitFn(r);
-        if (Array.isArray(n))
-            for (let o = -1, a = t * i; ++o < i;)
-                s(r, a + o, n[o]);
-        else
-            for (let o = -1, a = t * i; ++o < i;)
-                s(r, a + o, n.get(o));
-    };
-It.prototype.visitBool = Nt(qot);
-It.prototype.visitInt = Nt(ms);
-It.prototype.visitInt8 = Nt(ms);
-It.prototype.visitInt16 = Nt(ms);
-It.prototype.visitInt32 = Nt(ms);
-It.prototype.visitInt64 = Nt(ms);
-It.prototype.visitUint8 = Nt(ms);
-It.prototype.visitUint16 = Nt(ms);
-It.prototype.visitUint32 = Nt(ms);
-It.prototype.visitUint64 = Nt(ms);
-It.prototype.visitFloat = Nt(Yot);
-It.prototype.visitFloat16 = Nt(iR);
-It.prototype.visitFloat32 = Nt(o_);
-It.prototype.visitFloat64 = Nt(o_);
-It.prototype.visitUtf8 = Nt(aR);
-It.prototype.visitLargeUtf8 = Nt(aR);
-It.prototype.visitBinary = Nt(oR);
-It.prototype.visitLargeBinary = Nt(oR);
-It.prototype.visitFixedSizeBinary = Nt(Wot);
-It.prototype.visitDate = Nt(Got);
-It.prototype.visitDateDay = Nt(rR);
-It.prototype.visitDateMillisecond = Nt(sR);
-It.prototype.visitTimestamp = Nt(Xot);
-It.prototype.visitTimestampSecond = Nt(cR);
-It.prototype.visitTimestampMillisecond = Nt(lR);
-It.prototype.visitTimestampMicrosecond = Nt(uR);
-It.prototype.visitTimestampNanosecond = Nt(fR);
-It.prototype.visitTime = Nt(Hot);
-It.prototype.visitTimeSecond = Nt(hR);
-It.prototype.visitTimeMillisecond = Nt(dR);
-It.prototype.visitTimeMicrosecond = Nt(pR);
-It.prototype.visitTimeNanosecond = Nt(yR);
-It.prototype.visitDecimal = Nt(Jot);
-It.prototype.visitList = Nt(Kot);
-It.prototype.visitStruct = Nt(iat);
-It.prototype.visitUnion = Nt(rat);
-It.prototype.visitDenseUnion = Nt(mR);
-It.prototype.visitSparseUnion = Nt(gR);
-It.prototype.visitDictionary = Nt(sat);
-It.prototype.visitInterval = Nt(oat);
-It.prototype.visitIntervalDayTime = Nt(bR);
-It.prototype.visitIntervalYearMonth = Nt(wR);
-It.prototype.visitDuration = Nt(aat);
-It.prototype.visitDurationSecond = Nt(vR);
-It.prototype.visitDurationMillisecond = Nt(_R);
-It.prototype.visitDurationMicrosecond = Nt(xR);
-It.prototype.visitDurationNanosecond = Nt(SR);
-It.prototype.visitFixedSizeList = Nt(cat);
-It.prototype.visitMap = Nt(Zot);
-const fi = new It(),
-    mi = Symbol.for("parent"),
-    _c = Symbol.for("rowIndex");
-class a_ {
-    constructor(t, n) {
-        return this[mi] = t, this[_c] = n, new Proxy(this, new uat());
-    }
-    toArray() {
-        return Object.values(this.toJSON());
-    }
-    toJSON() {
-        const t = this[_c],
-            n = this[mi],
-            i = n.type.children,
-            r = {};
-        for (let s = -1, o = i.length; ++s < o;)
-            r[i[s].name] = Fn.visit(n.children[s], t);
-        return r;
-    }
-    toString() {
-            return `{${[...this].map(([t, n]) => `${tf(t)}: ${tf(n)}`).join(", ")}}`;
-        }
-        [Symbol.for("nodejs.util.inspect.custom")]() {
-            return this.toString();
-        }
-        [Symbol.iterator]() {
-            return new lat(this[mi], this[_c]);
-        }
-}
-class lat {
-    constructor(t, n) {
-            this.childIndex = 0, this.children = t.children, this.rowIndex = n, this.childFields = t.type.children, this.numChildren = this.childFields.length;
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-    next() {
-        const t = this.childIndex;
-        return t < this.numChildren ? (this.childIndex = t + 1, {
-            done: !1,
-            value: [
-                this.childFields[t].name,
-                Fn.visit(this.children[t], this.rowIndex)
-            ]
-        }) : {
-            done: !0,
-            value: null
-        };
-    }
-}
-Object.defineProperties(a_.prototype, {
-    [Symbol.toStringTag]: {
-        enumerable: !1,
-        configurable: !1,
-        value: "Row"
-    },
-    [mi]: {
-        writable: !0,
-        enumerable: !1,
-        configurable: !1,
-        value: null
-    },
-    [_c]: {
-        writable: !0,
-        enumerable: !1,
-        configurable: !1,
-        value: -1
-    }
-});
-class uat {
-    isExtensible() {
-        return !1;
-    }
-    deleteProperty() {
-        return !1;
-    }
-    preventExtensions() {
-        return !0;
-    }
-    ownKeys(t) {
-        return t[mi].type.children.map((n) => n.name);
-    }
-    has(t, n) {
-        return t[mi].type.children.findIndex((i) => i.name === n) !== -1;
-    }
-    getOwnPropertyDescriptor(t, n) {
-        if (t[mi].type.children.findIndex((i) => i.name === n) !== -1)
-            return {
-                writable: !0,
-                enumerable: !0,
-                configurable: !0
-            };
-    }
-    get(t, n) {
-        if (Reflect.has(t, n))
-            return t[n];
-        const i = t[mi].type.children.findIndex((r) => r.name === n);
-        if (i !== -1) {
-            const r = Fn.visit(t[mi].children[i], t[_c]);
-            return Reflect.set(t, n, r), r;
-        }
-    }
-    set(t, n, i) {
-        const r = t[mi].type.children.findIndex((s) => s.name === n);
-        return r !== -1 ? (fi.visit(t[mi].children[r], t[_c], i), Reflect.set(t, n, i)) : Reflect.has(t, n) || typeof n == "symbol" ? Reflect.set(t, n, i) : !1;
-    }
-}
-class ft extends zt {}
-
-function At(e) {
-    return (t, n) => t.getValid(n) ? e(t, n) : null;
-}
-const fat = (e, t) => 864e5 * e[t],
-    c_ = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0),
-    hat = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3,
-    dat = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6,
-    IR = (e) => new Date(e),
-    pat = (e, t) => IR(fat(e, t)),
-    yat = (e, t) => IR(c_(e, t)),
-    mat = (e, t) => null,
-    AR = (e, t, n) => {
-        if (n + 1 >= t.length)
-            return null;
-        const i = bn(t[n]),
-            r = bn(t[n + 1]);
-        return e.subarray(i, r);
-    },
-    gat = ({
-        offset: e,
-        values: t
-    }, n) => {
-        const i = e + n;
-        return (t[i >> 3] & 1 << i % 8) !== 0;
-    },
-    MR = ({
-        values: e
-    }, t) => pat(e, t),
-    $R = ({
-        values: e
-    }, t) => yat(e, t * 2),
-    po = ({
-        stride: e,
-        values: t
-    }, n) => t[e * n],
-    bat = ({
-        stride: e,
-        values: t
-    }, n) => eR(t[e * n]),
-    TR = ({
-        values: e
-    }, t) => e[t],
-    wat = ({
-        stride: e,
-        values: t
-    }, n) => t.subarray(e * n, e * (n + 1)),
-    DR = ({
-        values: e,
-        valueOffsets: t
-    }, n) => AR(e, t, n),
-    NR = ({
-        values: e,
-        valueOffsets: t
-    }, n) => {
-        const i = AR(e, t, n);
-        return i !== null ? eb(i) : null;
-    },
-    vat = ({
-        values: e
-    }, t) => e[t],
-    _at = ({
-        type: e,
-        values: t
-    }, n) => e.precision !== rn.HALF ? t[n] : eR(t[n]),
-    xat = (e, t) => e.type.unit === Oi.DAY ? MR(e, t) : $R(e, t),
-    BR = ({
-        values: e
-    }, t) => 1e3 * c_(e, t * 2),
-    OR = ({
-        values: e
-    }, t) => c_(e, t * 2),
-    FR = ({
-        values: e
-    }, t) => hat(e, t * 2),
-    ER = ({
-        values: e
-    }, t) => dat(e, t * 2),
-    Sat = (e, t) => {
-        switch (e.type.unit) {
-            case bt.SECOND:
-                return BR(e, t);
-            case bt.MILLISECOND:
-                return OR(e, t);
-            case bt.MICROSECOND:
-                return FR(e, t);
-            case bt.NANOSECOND:
-                return ER(e, t);
-        }
-    },
-    LR = ({
-        values: e
-    }, t) => e[t],
-    RR = ({
-        values: e
-    }, t) => e[t],
-    CR = ({
-        values: e
-    }, t) => e[t],
-    kR = ({
-        values: e
-    }, t) => e[t],
-    Iat = (e, t) => {
-        switch (e.type.unit) {
-            case bt.SECOND:
-                return LR(e, t);
-            case bt.MILLISECOND:
-                return RR(e, t);
-            case bt.MICROSECOND:
-                return CR(e, t);
-            case bt.NANOSECOND:
-                return kR(e, t);
-        }
-    },
-    Aat = ({
-        values: e,
-        stride: t
-    }, n) => r_.decimal(e.subarray(t * n, t * (n + 1))),
-    Mat = (e, t) => {
-        const {
-            valueOffsets: n,
-            stride: i,
-            children: r
-        } = e, {
-            [t * i]: s,
-            [t * i + 1]: o
-        } = n, c = r[0].slice(s, o - s);
-        return new ae([c]);
-    },
-    $at = (e, t) => {
-        const {
-            valueOffsets: n,
-            children: i
-        } = e, {
-            [t]: r,
-            [t + 1]: s
-        } = n, o = i[0];
-        return new l_(o.slice(r, s - r));
-    },
-    Tat = (e, t) => new a_(e, t),
-    Dat = (e, t) => e.type.mode === On.Dense ? UR(e, t) : zR(e, t),
-    UR = (e, t) => {
-        const n = e.type.typeIdToChildIndex[e.typeIds[t]],
-            i = e.children[n];
-        return Fn.visit(i, e.valueOffsets[t]);
-    },
-    zR = (e, t) => {
-        const n = e.type.typeIdToChildIndex[e.typeIds[t]],
-            i = e.children[n];
-        return Fn.visit(i, t);
-    },
-    Nat = (e, t) => {
-        var n;
-        return (n = e.dictionary) === null || n === void 0 ? void 0 : n.get(e.values[t]);
-    },
-    Bat = (e, t) => e.type.unit === mr.DAY_TIME ? PR(e, t) : VR(e, t),
-    PR = ({
-        values: e
-    }, t) => e.subarray(2 * t, 2 * (t + 1)),
-    VR = ({
-        values: e
-    }, t) => {
-        const n = e[t],
-            i = new Int32Array(2);
-        return i[0] = Math.trunc(n / 12), i[1] = Math.trunc(n % 12), i;
-    },
-    jR = ({
-        values: e
-    }, t) => e[t],
-    qR = ({
-        values: e
-    }, t) => e[t],
-    YR = ({
-        values: e
-    }, t) => e[t],
-    WR = ({
-        values: e
-    }, t) => e[t],
-    Oat = (e, t) => {
-        switch (e.type.unit) {
-            case bt.SECOND:
-                return jR(e, t);
-            case bt.MILLISECOND:
-                return qR(e, t);
-            case bt.MICROSECOND:
-                return YR(e, t);
-            case bt.NANOSECOND:
-                return WR(e, t);
-        }
-    },
-    Fat = (e, t) => {
-        const {
-            stride: n,
-            children: i
-        } = e, s = i[0].slice(t * n, n);
-        return new ae([s]);
-    };
-ft.prototype.visitNull = At(mat);
-ft.prototype.visitBool = At(gat);
-ft.prototype.visitInt = At(vat);
-ft.prototype.visitInt8 = At(po);
-ft.prototype.visitInt16 = At(po);
-ft.prototype.visitInt32 = At(po);
-ft.prototype.visitInt64 = At(TR);
-ft.prototype.visitUint8 = At(po);
-ft.prototype.visitUint16 = At(po);
-ft.prototype.visitUint32 = At(po);
-ft.prototype.visitUint64 = At(TR);
-ft.prototype.visitFloat = At(_at);
-ft.prototype.visitFloat16 = At(bat);
-ft.prototype.visitFloat32 = At(po);
-ft.prototype.visitFloat64 = At(po);
-ft.prototype.visitUtf8 = At(NR);
-ft.prototype.visitLargeUtf8 = At(NR);
-ft.prototype.visitBinary = At(DR);
-ft.prototype.visitLargeBinary = At(DR);
-ft.prototype.visitFixedSizeBinary = At(wat);
-ft.prototype.visitDate = At(xat);
-ft.prototype.visitDateDay = At(MR);
-ft.prototype.visitDateMillisecond = At($R);
-ft.prototype.visitTimestamp = At(Sat);
-ft.prototype.visitTimestampSecond = At(BR);
-ft.prototype.visitTimestampMillisecond = At(OR);
-ft.prototype.visitTimestampMicrosecond = At(FR);
-ft.prototype.visitTimestampNanosecond = At(ER);
-ft.prototype.visitTime = At(Iat);
-ft.prototype.visitTimeSecond = At(LR);
-ft.prototype.visitTimeMillisecond = At(RR);
-ft.prototype.visitTimeMicrosecond = At(CR);
-ft.prototype.visitTimeNanosecond = At(kR);
-ft.prototype.visitDecimal = At(Aat);
-ft.prototype.visitList = At(Mat);
-ft.prototype.visitStruct = At(Tat);
-ft.prototype.visitUnion = At(Dat);
-ft.prototype.visitDenseUnion = At(UR);
-ft.prototype.visitSparseUnion = At(zR);
-ft.prototype.visitDictionary = At(Nat);
-ft.prototype.visitInterval = At(Bat);
-ft.prototype.visitIntervalDayTime = At(PR);
-ft.prototype.visitIntervalYearMonth = At(VR);
-ft.prototype.visitDuration = At(Oat);
-ft.prototype.visitDurationSecond = At(jR);
-ft.prototype.visitDurationMillisecond = At(qR);
-ft.prototype.visitDurationMicrosecond = At(YR);
-ft.prototype.visitDurationNanosecond = At(WR);
-ft.prototype.visitFixedSizeList = At(Fat);
-ft.prototype.visitMap = At($at);
-const Fn = new ft(),
-    nr = Symbol.for("keys"),
-    xc = Symbol.for("vals");
-class l_ {
-    constructor(t) {
-            return this[nr] = new ae([t.children[0]]).memoize(), this[xc] = t.children[1], new Proxy(this, new Lat());
-        }
-        [Symbol.iterator]() {
-            return new Eat(this[nr], this[xc]);
-        }
-    get size() {
-        return this[nr].length;
-    }
-    toArray() {
-        return Object.values(this.toJSON());
-    }
-    toJSON() {
-        const t = this[nr],
-            n = this[xc],
-            i = {};
-        for (let r = -1, s = t.length; ++r < s;)
-            i[t.get(r)] = Fn.visit(n, r);
-        return i;
-    }
-    toString() {
-            return `{${[...this].map(([t, n]) => `${tf(t)}: ${tf(n)}`).join(", ")}}`;
-        }
-        [Symbol.for("nodejs.util.inspect.custom")]() {
-            return this.toString();
-        }
-}
-class Eat {
-    constructor(t, n) {
-            this.keys = t, this.vals = n, this.keyIndex = 0, this.numKeys = t.length;
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-    next() {
-        const t = this.keyIndex;
-        return t === this.numKeys ? {
-            done: !0,
-            value: null
-        } : (this.keyIndex++, {
-            done: !1,
-            value: [
-                this.keys.get(t),
-                Fn.visit(this.vals, t)
-            ]
-        });
-    }
-}
-class Lat {
-    isExtensible() {
-        return !1;
-    }
-    deleteProperty() {
-        return !1;
-    }
-    preventExtensions() {
-        return !0;
-    }
-    ownKeys(t) {
-        return t[nr].toArray().map(String);
-    }
-    has(t, n) {
-        return t[nr].includes(n);
-    }
-    getOwnPropertyDescriptor(t, n) {
-        if (t[nr].indexOf(n) !== -1)
-            return {
-                writable: !0,
-                enumerable: !0,
-                configurable: !0
-            };
-    }
-    get(t, n) {
-        if (Reflect.has(t, n))
-            return t[n];
-        const i = t[nr].indexOf(n);
-        if (i !== -1) {
-            const r = Fn.visit(Reflect.get(t, xc), i);
-            return Reflect.set(t, n, r), r;
-        }
-    }
-    set(t, n, i) {
-        const r = t[nr].indexOf(n);
-        return r !== -1 ? (fi.visit(Reflect.get(t, xc), r, i), Reflect.set(t, n, i)) : Reflect.has(t, n) ? Reflect.set(t, n, i) : !1;
-    }
-}
-Object.defineProperties(l_.prototype, {
-    [Symbol.toStringTag]: {
-        enumerable: !1,
-        configurable: !1,
-        value: "Row"
-    },
-    [nr]: {
-        writable: !0,
-        enumerable: !1,
-        configurable: !1,
-        value: null
-    },
-    [xc]: {
-        writable: !0,
-        enumerable: !1,
-        configurable: !1,
-        value: null
-    }
-});
-let yI;
-
-function GR(e, t, n, i) {
-    const {
-        length: r = 0
-    } = e;
-    let s = typeof t != "number" ? 0 : t,
-        o = typeof n != "number" ? r : n;
-    return s < 0 && (s = (s % r + r) % r), o < 0 && (o = (o % r + r) % r), o < s && (yI = s, s = o, o = yI), o > r && (o = r), i ? i(e, s, o) : [s, o];
-}
-const mI = (e) => e !== e;
-
-function ml(e) {
-    if (typeof e !== "object" || e === null)
-        return mI(e) ? mI : (n) => n === e;
-    if (e instanceof Date) {
-        const n = e.valueOf();
-        return (i) => i instanceof Date ? i.valueOf() === n : !1;
-    }
-    return ArrayBuffer.isView(e) ? (n) => n ? Dot(e, n) : !1 : e instanceof Map ? Cat(e) : Array.isArray(e) ? Rat(e) : e instanceof ae ? kat(e) : Uat(e, !0);
-}
-
-function Rat(e) {
-    const t = [];
-    for (let n = -1, i = e.length; ++n < i;)
-        t[n] = ml(e[n]);
-    return K0(t);
-}
-
-function Cat(e) {
-    let t = -1;
-    const n = [];
-    for (const i of e.values())
-        n[++t] = ml(i);
-    return K0(n);
-}
-
-function kat(e) {
-    const t = [];
-    for (let n = -1, i = e.length; ++n < i;)
-        t[n] = ml(e.get(n));
-    return K0(t);
-}
-
-function Uat(e, t = !1) {
-    const n = Object.keys(e);
-    if (!t && n.length === 0)
-        return () => !1;
-    const i = [];
-    for (let r = -1, s = n.length; ++r < s;)
-        i[r] = ml(e[n[r]]);
-    return K0(i, n);
-}
-
-function K0(e, t) {
-    return (n) => {
-        if (!n || typeof n != "object")
-            return !1;
-        switch (n.constructor) {
-            case Array:
-                return zat(e, n);
-            case Map:
-                return gI(e, n, n.keys());
-            case l_:
-            case a_:
-            case Object:
-            case void 0:
-                return gI(e, n, t || Object.keys(n));
-        }
-        return n instanceof ae ? Pat(e, n) : !1;
-    };
-}
-
-function zat(e, t) {
-    const n = e.length;
-    if (t.length !== n)
-        return !1;
-    for (let i = -1; ++i < n;)
-        if (!e[i](t[i]))
-            return !1;
-    return !0;
-}
-
-function Pat(e, t) {
-    const n = e.length;
-    if (t.length !== n)
-        return !1;
-    for (let i = -1; ++i < n;)
-        if (!e[i](t.get(i)))
-            return !1;
-    return !0;
-}
-
-function gI(e, t, n) {
-    const i = n[Symbol.iterator](),
-        r = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](),
-        s = t instanceof Map ? t.values() : Object.values(t)[Symbol.iterator]();
-    let o = 0;
-    const a = e.length;
-    let c = s.next(),
-        l = i.next(),
-        u = r.next();
-    for (; o < a && !l.done && !u.done && !c.done && !(l.value !== u.value || !e[o](c.value)); ++o, l = i.next(), u = r.next(), c = s.next())
-    ;
-    return o === a && l.done && u.done && c.done ? !0 : (i.return && i.return(), r.return && r.return(), s.return && s.return(), !1);
-}
-
-function XR(e, t, n, i) {
-    return (n & 1 << i) !== 0;
-}
-
-function Vat(e, t, n, i) {
-    return (n & 1 << i) >> i;
-}
-
-function bI(e, t, n) {
-    const i = n.byteLength + 7 & -8;
-    if (e > 0 || n.byteLength < i) {
-        const r = new Uint8Array(i);
-        return r.set(e % 8 === 0 ? n.subarray(e >> 3) : (
-            // Otherwise iterate each bit from the offset and return a new one
-            ob(new u_(n, e, t, null, XR)).subarray(0, i)
-        )), r;
-    }
-    return n;
-}
-
-function ob(e) {
-    const t = [];
-    let n = 0,
-        i = 0,
-        r = 0;
-    for (const o of e)
-        o && (r |= 1 << i), ++i === 8 && (t[n++] = r, r = i = 0);
-    (n === 0 || i > 0) && (t[n++] = r);
-    const s = new Uint8Array(t.length + 7 & -8);
-    return s.set(t), s;
-}
-class u_ {
-    constructor(t, n, i, r, s) {
-        this.bytes = t, this.length = i, this.context = r, this.get = s, this.bit = n % 8, this.byteIndex = n >> 3, this.byte = t[this.byteIndex++], this.index = 0;
-    }
-    next() {
-            return this.index < this.length ? (this.bit === 8 && (this.bit = 0, this.byte = this.bytes[this.byteIndex++]), {
-                value: this.get(this.context, this.index++, this.byte, this.bit++)
-            }) : {
-                done: !0,
-                value: null
-            };
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-}
-
-function ab(e, t, n) {
-    if (n - t <= 0)
-        return 0;
-    if (n - t < 8) {
-        let s = 0;
-        for (const o of new u_(e, t, n - t, e, Vat))
-            s += o;
-        return s;
+        wN(t, n);
     }
-    const i = n >> 3 << 3,
-        r = t + (t % 8 === 0 ? 0 : 8 - t % 8);
-    return (
-        // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
-        ab(e, t, r) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
-        ab(e, i, n) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
-        jat(e, r >> 3, i - r >> 3)
-    );
-}
-
-function jat(e, t, n) {
-    let i = 0,
-        r = Math.trunc(t);
-    const s = new DataView(e.buffer, e.byteOffset, e.byteLength),
-        o = n === void 0 ? e.byteLength : r + n;
-    for (; o - r >= 4;)
-        i += ug(s.getUint32(r)), r += 4;
-    for (; o - r >= 2;)
-        i += ug(s.getUint16(r)), r += 2;
-    for (; o - r >= 1;)
-        i += ug(s.getUint8(r)), r += 1;
-    return i;
 }
+let wl;
+const xtt = new Uint8Array(16);
 
-function ug(e) {
-    let t = Math.trunc(e);
-    return t = t - (t >>> 1 & 1431655765), t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
-}
-const qat = -1;
-class ne {
-    get typeId() {
-        return this.type.typeId;
-    }
-    get ArrayType() {
-        return this.type.ArrayType;
-    }
-    get buffers() {
-        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
-    }
-    get nullable() {
-        if (this._nullCount !== 0) {
-            const {
-                type: t
-            } = this;
-            return st.isSparseUnion(t) ? this.children.some((n) => n.nullable) : st.isDenseUnion(t) ? this.children.some((n) => n.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0;
-        }
-        return !0;
-    }
-    get byteLength() {
-        let t = 0;
-        const {
-            valueOffsets: n,
-            values: i,
-            nullBitmap: r,
-            typeIds: s
-        } = this;
-        return n && (t += n.byteLength), i && (t += i.byteLength), r && (t += r.byteLength), s && (t += s.byteLength), this.children.reduce((o, a) => o + a.byteLength, t);
-    }
-    get nullCount() {
-        if (st.isUnion(this.type))
-            return this.children.reduce((i, r) => i + r.nullCount, 0);
-        let t = this._nullCount,
-            n;
-        return t <= qat && (n = this.nullBitmap) && (this._nullCount = t = this.length - ab(n, this.offset, this.offset + this.length)), t;
-    }
-    constructor(t, n, i, r, s, o = [], a) {
-        this.type = t, this.children = o, this.dictionary = a, this.offset = Math.floor(Math.max(n || 0, 0)), this.length = Math.floor(Math.max(i || 0, 0)), this._nullCount = Math.floor(Math.max(r || 0, -1));
-        let c;
-        s instanceof ne ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = zr(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)));
-    }
-    getValid(t) {
-        const {
-            type: n
-        } = this;
-        if (st.isUnion(n)) {
-            const i = n,
-                r = this.children[i.typeIdToChildIndex[this.typeIds[t]]],
-                s = i.mode === On.Dense ? this.valueOffsets[t] : t;
-            return r.getValid(s);
-        }
-        if (this.nullable && this.nullCount > 0) {
-            const i = this.offset + t;
-            return (this.nullBitmap[i >> 3] & 1 << i % 8) !== 0;
-        }
-        return !0;
-    }
-    setValid(t, n) {
-        let i;
-        const {
-            type: r
-        } = this;
-        if (st.isUnion(r)) {
-            const s = r,
-                o = this.children[s.typeIdToChildIndex[this.typeIds[t]]],
-                a = s.mode === On.Dense ? this.valueOffsets[t] : t;
-            i = o.getValid(a), o.setValid(a, n);
-        } else {
-            let {
-                nullBitmap: s
-            } = this;
-            const {
-                offset: o,
-                length: a
-            } = this, c = o + t, l = 1 << c % 8, u = c >> 3;
-            (!s || s.byteLength <= u) && (s = new Uint8Array((o + a + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(bI(o, a, this.nullBitmap), 0), Object.assign(this, {
-                nullBitmap: s,
-                _nullCount: -1
-            }));
-            const f = s[u];
-            i = (f & l) !== 0, n ? s[u] = f | l : s[u] = f & ~l;
-        }
-        return i !== !!n && (this._nullCount = this.nullCount + (n ? -1 : 1)), n;
-    }
-    clone(t = this.type, n = this.offset, i = this.length, r = this._nullCount, s = this, o = this.children) {
-        return new ne(t, n, i, r, s, o, this.dictionary);
-    }
-    slice(t, n) {
-        const {
-            stride: i,
-            typeId: r,
-            children: s
-        } = this, o = +(this._nullCount === 0) - 1, a = r === 16 ? i : 1, c = this._sliceBuffers(t, n, i, r);
-        return this.clone(
-            this.type,
-            this.offset + t,
-            n,
-            o,
-            c,
-            // Don't slice children if we have value offsets (the variable-width types)
-            s.length === 0 || this.valueOffsets ? s : this._sliceChildren(s, a * t, a * n)
-        );
-    }
-    _changeLengthAndBackfillNullBitmap(t) {
-        if (this.typeId === E.Null)
-            return this.clone(this.type, 0, t, 0);
-        const {
-            length: n,
-            nullCount: i
-        } = this, r = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, n >> 3);
-        r[n >> 3] = (1 << n - (n & -8)) - 1, i > 0 && r.set(bI(this.offset, n, this.nullBitmap), 0);
-        const s = this.buffers;
-        return s[Ur.VALIDITY] = r, this.clone(this.type, 0, t, i + (t - n), s);
-    }
-    _sliceBuffers(t, n, i, r) {
-        let s;
-        const {
-            buffers: o
-        } = this;
-        return (s = o[Ur.TYPE]) && (o[Ur.TYPE] = s.subarray(t, t + n)), (s = o[Ur.OFFSET]) && (o[Ur.OFFSET] = s.subarray(t, t + n + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
-            (s = o[Ur.DATA]) && (o[Ur.DATA] = r === 6 ? s : s.subarray(i * t, i * (t + n))), o;
-    }
-    _sliceChildren(t, n, i) {
-        return t.map((r) => r.slice(n, i));
-    }
-}
-ne.prototype.children = Object.freeze([]);
-class wu extends zt {
-    visit(t) {
-        return this.getVisitFn(t.type).call(this, t);
-    }
-    visitNull(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0, ["length"]: r = 0
-        } = t;
-        return new ne(n, i, r, r);
-    }
-    visitBool(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length >> 3,
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitInt(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length,
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitFloat(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length,
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitUtf8(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = Fl(t.valueOffsets), {
-            ["length"]: a = o.length - 1,
-            ["nullCount"]: c = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, a, c, [o, r, s]);
-    }
-    visitLargeUtf8(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = oI(t.valueOffsets), {
-            ["length"]: a = o.length - 1,
-            ["nullCount"]: c = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, a, c, [o, r, s]);
-    }
-    visitBinary(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = Fl(t.valueOffsets), {
-            ["length"]: a = o.length - 1,
-            ["nullCount"]: c = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, a, c, [o, r, s]);
-    }
-    visitLargeBinary(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.data), s = Wt(t.nullBitmap), o = oI(t.valueOffsets), {
-            ["length"]: a = o.length - 1,
-            ["nullCount"]: c = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, a, c, [o, r, s]);
-    }
-    visitFixedSizeBinary(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length / zr(n),
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitDate(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length / zr(n),
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitTimestamp(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length / zr(n),
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitTime(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length / zr(n),
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitDecimal(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length / zr(n),
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitList(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0, ["child"]: r
-        } = t, s = Wt(t.nullBitmap), o = Fl(t.valueOffsets), {
-            ["length"]: a = o.length - 1,
-            ["nullCount"]: c = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, a, c, [o, void 0, s], [r]);
-    }
-    visitStruct(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0, ["children"]: r = []
-        } = t, s = Wt(t.nullBitmap), {
-            length: o = r.reduce((c, {
-                length: l
-            }) => Math.max(c, l), 0),
-            nullCount: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, void 0, s], r);
-    }
-    visitUnion(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0, ["children"]: r = []
-        } = t, s = se(n.ArrayType, t.typeIds), {
-            ["length"]: o = s.length,
-            ["nullCount"]: a = -1
-        } = t;
-        if (st.isSparseUnion(n))
-            return new ne(n, i, o, a, [void 0, void 0, void 0, s], r);
-        const c = Fl(t.valueOffsets);
-        return new ne(n, i, o, a, [c, void 0, void 0, s], r);
-    }
-    visitDictionary(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.indices.ArrayType, t.data), {
-            ["dictionary"]: o = new ae([new wu().visit({
-                type: n.dictionary
-            })])
-        } = t, {
-            ["length"]: a = s.length,
-            ["nullCount"]: c = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, a, c, [void 0, s, r], [], o);
-    }
-    visitInterval(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length / zr(n),
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitDuration(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0
-        } = t, r = Wt(t.nullBitmap), s = se(n.ArrayType, t.data), {
-            ["length"]: o = s.length,
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, s, r]);
-    }
-    visitFixedSizeList(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0, ["child"]: r = new wu().visit({
-                type: n.valueType
-            })
-        } = t, s = Wt(t.nullBitmap), {
-            ["length"]: o = r.length / zr(n),
-            ["nullCount"]: a = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, o, a, [void 0, void 0, s], [r]);
-    }
-    visitMap(t) {
-        const {
-            ["type"]: n, ["offset"]: i = 0, ["child"]: r = new wu().visit({
-                type: n.childType
-            })
-        } = t, s = Wt(t.nullBitmap), o = Fl(t.valueOffsets), {
-            ["length"]: a = o.length - 1,
-            ["nullCount"]: c = t.nullBitmap ? -1 : 0
-        } = t;
-        return new ne(n, i, a, c, [o, void 0, s], [r]);
-    }
-}
-const Yat = new wu();
-
-function Ct(e) {
-    return Yat.visit(e);
-}
-class wI {
-    constructor(t = 0, n) {
-        this.numChunks = t, this.getChunkIterator = n, this.chunkIndex = 0, this.chunkIterator = this.getChunkIterator(0);
-    }
-    next() {
-            for (; this.chunkIndex < this.numChunks;) {
-                const t = this.chunkIterator.next();
-                if (!t.done)
-                    return t;
-                ++this.chunkIndex < this.numChunks && (this.chunkIterator = this.getChunkIterator(this.chunkIndex));
-            }
-            return {
-                done: !0,
-                value: null
-            };
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-}
-
-function Wat(e) {
-    return e.some((t) => t.nullable);
-}
-
-function HR(e) {
-    return e.reduce((t, n) => t + n.nullCount, 0);
-}
-
-function JR(e) {
-    return e.reduce((t, n, i) => (t[i + 1] = t[i] + n.length, t), new Uint32Array(e.length + 1));
-}
-
-function KR(e, t, n, i) {
-    const r = [];
-    for (let s = -1, o = e.length; ++s < o;) {
-        const a = e[s],
-            c = t[s],
-            {
-                length: l
-            } = a;
-        if (c >= i)
-            break;
-        if (n >= c + l)
-            continue;
-        if (c >= n && c + l <= i) {
-            r.push(a);
-            continue;
-        }
-        const u = Math.max(0, n - c),
-            f = Math.min(i - c, l);
-        r.push(a.slice(u, f - u));
-    }
-    return r.length === 0 && r.push(e[0].slice(0, 0)), r;
-}
-
-function f_(e, t, n, i) {
-    let r = 0,
-        s = 0,
-        o = t.length - 1;
-    do {
-        if (r >= o - 1)
-            return n < t[o] ? i(e, r, n - t[r]) : null;
-        s = r + Math.trunc((o - r) * 0.5), n < t[s] ? o = s : r = s;
-    } while (r < o);
-}
-
-function h_(e, t) {
-    return e.getValid(t);
-}
-
-function My(e) {
-    function t(n, i, r) {
-        return e(n[i], r);
-    }
-    return function(n) {
-        const i = this.data;
-        return f_(i, this._offsets, n, t);
-    };
-}
-
-function ZR(e) {
-    let t;
-
-    function n(i, r, s) {
-        return e(i[r], s, t);
-    }
-    return function(i, r) {
-        const s = this.data;
-        t = r;
-        const o = f_(s, this._offsets, i, n);
-        return t = void 0, o;
-    };
-}
-
-function QR(e) {
-    let t;
-
-    function n(i, r, s) {
-        let o = s,
-            a = 0,
-            c = 0;
-        for (let l = r - 1, u = i.length; ++l < u;) {
-            const f = i[l];
-            if (~(a = e(f, t, o)))
-                return c + a;
-            o = 0, c += f.length;
-        }
-        return -1;
-    }
-    return function(i, r) {
-        t = i;
-        const s = this.data,
-            o = typeof r != "number" ? n(s, 0, 0) : f_(s, this._offsets, r, n);
-        return t = void 0, o;
-    };
-}
-class ht extends zt {}
-
-function Gat(e, t) {
-    return t === null && e.length > 0 ? 0 : -1;
-}
-
-function Xat(e, t) {
-    const {
-        nullBitmap: n
-    } = e;
-    if (!n || e.nullCount <= 0)
-        return -1;
-    let i = 0;
-    for (const r of new u_(n, e.offset + (t || 0), e.length, n, XR)) {
-        if (!r)
-            return i;
-        ++i;
-    }
-    return -1;
-}
-
-function Ot(e, t, n) {
-    if (t === void 0)
-        return -1;
-    if (t === null)
-        switch (e.typeId) {
-            case E.Union:
-                break;
-            case E.Dictionary:
-                break;
-            default:
-                return Xat(e, n);
-        }
-    const i = Fn.getVisitFn(e),
-        r = ml(t);
-    for (let s = (n || 0) - 1, o = e.length; ++s < o;)
-        if (r(i(e, s)))
-            return s;
-    return -1;
-}
-
-function tC(e, t, n) {
-    const i = Fn.getVisitFn(e),
-        r = ml(t);
-    for (let s = (n || 0) - 1, o = e.length; ++s < o;)
-        if (r(i(e, s)))
-            return s;
-    return -1;
-}
-ht.prototype.visitNull = Gat;
-ht.prototype.visitBool = Ot;
-ht.prototype.visitInt = Ot;
-ht.prototype.visitInt8 = Ot;
-ht.prototype.visitInt16 = Ot;
-ht.prototype.visitInt32 = Ot;
-ht.prototype.visitInt64 = Ot;
-ht.prototype.visitUint8 = Ot;
-ht.prototype.visitUint16 = Ot;
-ht.prototype.visitUint32 = Ot;
-ht.prototype.visitUint64 = Ot;
-ht.prototype.visitFloat = Ot;
-ht.prototype.visitFloat16 = Ot;
-ht.prototype.visitFloat32 = Ot;
-ht.prototype.visitFloat64 = Ot;
-ht.prototype.visitUtf8 = Ot;
-ht.prototype.visitLargeUtf8 = Ot;
-ht.prototype.visitBinary = Ot;
-ht.prototype.visitLargeBinary = Ot;
-ht.prototype.visitFixedSizeBinary = Ot;
-ht.prototype.visitDate = Ot;
-ht.prototype.visitDateDay = Ot;
-ht.prototype.visitDateMillisecond = Ot;
-ht.prototype.visitTimestamp = Ot;
-ht.prototype.visitTimestampSecond = Ot;
-ht.prototype.visitTimestampMillisecond = Ot;
-ht.prototype.visitTimestampMicrosecond = Ot;
-ht.prototype.visitTimestampNanosecond = Ot;
-ht.prototype.visitTime = Ot;
-ht.prototype.visitTimeSecond = Ot;
-ht.prototype.visitTimeMillisecond = Ot;
-ht.prototype.visitTimeMicrosecond = Ot;
-ht.prototype.visitTimeNanosecond = Ot;
-ht.prototype.visitDecimal = Ot;
-ht.prototype.visitList = Ot;
-ht.prototype.visitStruct = Ot;
-ht.prototype.visitUnion = Ot;
-ht.prototype.visitDenseUnion = tC;
-ht.prototype.visitSparseUnion = tC;
-ht.prototype.visitDictionary = Ot;
-ht.prototype.visitInterval = Ot;
-ht.prototype.visitIntervalDayTime = Ot;
-ht.prototype.visitIntervalYearMonth = Ot;
-ht.prototype.visitDuration = Ot;
-ht.prototype.visitDurationSecond = Ot;
-ht.prototype.visitDurationMillisecond = Ot;
-ht.prototype.visitDurationMicrosecond = Ot;
-ht.prototype.visitDurationNanosecond = Ot;
-ht.prototype.visitFixedSizeList = Ot;
-ht.prototype.visitMap = Ot;
-const $y = new ht();
-class dt extends zt {}
-
-function Mt(e) {
-    const {
-        type: t
-    } = e;
-    if (e.nullCount === 0 && e.stride === 1 && (t.typeId === E.Timestamp || t instanceof eo && t.bitWidth !== 64 || t instanceof of && t.bitWidth !== 64 || t instanceof sf && t.precision !== rn.HALF))
-        return new wI(e.data.length, (i) => {
-            const r = e.data[i];
-            return r.values.subarray(0, r.length)[Symbol.iterator]();
-        });
-    let n = 0;
-    return new wI(e.data.length, (i) => {
-        const s = e.data[i].length,
-            o = e.slice(n, n + s);
-        return n += s, new Hat(o);
-    });
-}
-class Hat {
-    constructor(t) {
-        this.vector = t, this.index = 0;
-    }
-    next() {
-            return this.index < this.vector.length ? {
-                value: this.vector.get(this.index++)
-            } : {
-                done: !0,
-                value: null
-            };
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-}
-dt.prototype.visitNull = Mt;
-dt.prototype.visitBool = Mt;
-dt.prototype.visitInt = Mt;
-dt.prototype.visitInt8 = Mt;
-dt.prototype.visitInt16 = Mt;
-dt.prototype.visitInt32 = Mt;
-dt.prototype.visitInt64 = Mt;
-dt.prototype.visitUint8 = Mt;
-dt.prototype.visitUint16 = Mt;
-dt.prototype.visitUint32 = Mt;
-dt.prototype.visitUint64 = Mt;
-dt.prototype.visitFloat = Mt;
-dt.prototype.visitFloat16 = Mt;
-dt.prototype.visitFloat32 = Mt;
-dt.prototype.visitFloat64 = Mt;
-dt.prototype.visitUtf8 = Mt;
-dt.prototype.visitLargeUtf8 = Mt;
-dt.prototype.visitBinary = Mt;
-dt.prototype.visitLargeBinary = Mt;
-dt.prototype.visitFixedSizeBinary = Mt;
-dt.prototype.visitDate = Mt;
-dt.prototype.visitDateDay = Mt;
-dt.prototype.visitDateMillisecond = Mt;
-dt.prototype.visitTimestamp = Mt;
-dt.prototype.visitTimestampSecond = Mt;
-dt.prototype.visitTimestampMillisecond = Mt;
-dt.prototype.visitTimestampMicrosecond = Mt;
-dt.prototype.visitTimestampNanosecond = Mt;
-dt.prototype.visitTime = Mt;
-dt.prototype.visitTimeSecond = Mt;
-dt.prototype.visitTimeMillisecond = Mt;
-dt.prototype.visitTimeMicrosecond = Mt;
-dt.prototype.visitTimeNanosecond = Mt;
-dt.prototype.visitDecimal = Mt;
-dt.prototype.visitList = Mt;
-dt.prototype.visitStruct = Mt;
-dt.prototype.visitUnion = Mt;
-dt.prototype.visitDenseUnion = Mt;
-dt.prototype.visitSparseUnion = Mt;
-dt.prototype.visitDictionary = Mt;
-dt.prototype.visitInterval = Mt;
-dt.prototype.visitIntervalDayTime = Mt;
-dt.prototype.visitIntervalYearMonth = Mt;
-dt.prototype.visitDuration = Mt;
-dt.prototype.visitDurationSecond = Mt;
-dt.prototype.visitDurationMillisecond = Mt;
-dt.prototype.visitDurationMicrosecond = Mt;
-dt.prototype.visitDurationNanosecond = Mt;
-dt.prototype.visitFixedSizeList = Mt;
-dt.prototype.visitMap = Mt;
-const d_ = new dt();
-var eC;
-const nC = {},
-    iC = {};
-class ae {
-    constructor(t) {
-        var n, i, r;
-        const s = t[0] instanceof ae ? t.flatMap((a) => a.data) : t;
-        if (s.length === 0 || s.some((a) => !(a instanceof ne)))
-            throw new TypeError("Vector constructor expects an Array of Data instances.");
-        const o = (n = s[0]) === null || n === void 0 ? void 0 : n.type;
-        switch (s.length) {
-            case 0:
-                this._offsets = [0];
-                break;
-            case 1: {
-                const {
-                    get: a,
-                    set: c,
-                    indexOf: l
-                } = nC[o.typeId], u = s[0];
-                this.isValid = (f) => h_(u, f), this.get = (f) => a(u, f), this.set = (f, h) => c(u, f, h), this.indexOf = (f) => l(u, f), this._offsets = [0, u.length];
-                break;
-            }
-            default:
-                Object.setPrototypeOf(this, iC[o.typeId]), this._offsets = JR(s);
-                break;
-        }
-        this.data = s, this.type = o, this.stride = zr(o), this.numChildren = (r = (i = o.children) === null || i === void 0 ? void 0 : i.length) !== null && r !== void 0 ? r : 0, this.length = this._offsets.at(-1);
-    }
-    /**
-     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
-     */
-    get byteLength() {
-        return this.data.reduce((t, n) => t + n.byteLength, 0);
-    }
-    /**
-     * Whether this Vector's elements can contain null values.
-     */
-    get nullable() {
-        return Wat(this.data);
-    }
-    /**
-     * The number of null elements in this Vector.
-     */
-    get nullCount() {
-        return HR(this.data);
-    }
-    /**
-     * The Array or TypedArray constructor used for the JS representation
-     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
-     */
-    get ArrayType() {
-        return this.type.ArrayType;
-    }
-    /**
-     * The name that should be printed when the Vector is logged in a message.
-     */
-    get[Symbol.toStringTag]() {
-        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
-    }
-    /**
-     * The name of this Vector.
-     */
-    get VectorName() {
-        return `${E[this.type.typeId]}Vector`;
-    }
-    /**
-     * Check whether an element is null.
-     * @param index The index at which to read the validity bitmap.
-     */
-    // @ts-ignore
-    isValid(t) {
-        return !1;
-    }
-    /**
-     * Get an element value by position.
-     * @param index The index of the element to read.
-     */
-    // @ts-ignore
-    get(t) {
-        return null;
-    }
-    /**
-     * Set an element value by position.
-     * @param index The index of the element to write.
-     * @param value The value to set.
-     */
-    // @ts-ignore
-    set(t, n) {}
-    /**
-     * Retrieve the index of the first occurrence of a value in an Vector.
-     * @param element The value to locate in the Vector.
-     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
-     */
-    // @ts-ignore
-    indexOf(t, n) {
-        return -1;
-    }
-    includes(t, n) {
-        return this.indexOf(t, n) > -1;
-    }
-    /**
-     * Iterator for the Vector's elements.
-     */
-    [Symbol.iterator]() {
-        return d_.visit(this);
-    }
-    /**
-     * Combines two or more Vectors of the same type.
-     * @param others Additional Vectors to add to the end of this Vector.
-     */
-    concat(...t) {
-        return new ae(this.data.concat(t.flatMap((n) => n.data).flat(Number.POSITIVE_INFINITY)));
-    }
-    /**
-     * Return a zero-copy sub-section of this Vector.
-     * @param start The beginning of the specified portion of the Vector.
-     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
-     */
-    slice(t, n) {
-        return new ae(GR(this, t, n, ({
-            data: i,
-            _offsets: r
-        }, s, o) => KR(i, r, s, o)));
-    }
-    toJSON() {
-        return [...this];
-    }
-    /**
-     * Return a JavaScript Array or TypedArray of the Vector's elements.
-     *
-     * @note If this Vector contains a single Data chunk and the Vector's type is a
-     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
-     *  method returns a zero-copy slice of the underlying TypedArray values. If there's
-     *  more than one chunk, the resulting TypedArray will be a copy of the data from each
-     *  chunk's underlying TypedArray values.
-     *
-     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
-     */
-    toArray() {
-        const {
-            type: t,
-            data: n,
-            length: i,
-            stride: r,
-            ArrayType: s
-        } = this;
-        switch (t.typeId) {
-            case E.Int:
-            case E.Float:
-            case E.Decimal:
-            case E.Time:
-            case E.Timestamp:
-                switch (n.length) {
-                    case 0:
-                        return new s();
-                    case 1:
-                        return n[0].values.subarray(0, i * r);
-                    default:
-                        return n.reduce((o, {
-                            values: a,
-                            length: c
-                        }) => (o.array.set(a.subarray(0, c * r), o.offset), o.offset += c * r, o), {
-                            array: new s(i * r),
-                            offset: 0
-                        }).array;
-                }
-        }
-        return [...this];
-    }
-    /**
-     * Returns a string representation of the Vector.
-     *
-     * @returns A string representation of the Vector.
-     */
-    toString() {
-        return `[${[...this].join(",")}]`;
-    }
-    /**
-     * Returns a child Vector by name, or null if this Vector has no child with the given name.
-     * @param name The name of the child to retrieve.
-     */
-    getChild(t) {
-        var n;
-        return this.getChildAt((n = this.type.children) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
-    }
-    /**
-     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
-     * @param index The index of the child to retrieve.
-     */
-    getChildAt(t) {
-        return t > -1 && t < this.numChildren ? new ae(this.data.map(({
-            children: n
-        }) => n[t])) : null;
-    }
-    get isMemoized() {
-        return st.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1;
-    }
-    /**
-     * Adds memoization to the Vector's {@link get} method. For dictionary
-     * vectors, this method return a vector that memoizes only the dictionary
-     * values.
-     *
-     * Memoization is very useful when decoding a value is expensive such as
-     * Utf8. The memoization creates a cache of the size of the Vector and
-     * therefore increases memory usage.
-     *
-     * @returns A new vector that memoizes calls to {@link get}.
-     */
-    memoize() {
-        if (st.isDictionary(this.type)) {
-            const t = new Ty(this.data[0].dictionary),
-                n = this.data.map((i) => {
-                    const r = i.clone();
-                    return r.dictionary = t, r;
-                });
-            return new ae(n);
-        }
-        return new Ty(this);
-    }
-    /**
-     * Returns a vector without memoization of the {@link get} method. If this
-     * vector is not memoized, this method returns this vector.
-     *
-     * @returns A new vector without memoization.
-     */
-    unmemoize() {
-        if (st.isDictionary(this.type) && this.isMemoized) {
-            const t = this.data[0].dictionary.unmemoize(),
-                n = this.data.map((i) => {
-                    const r = i.clone();
-                    return r.dictionary = t, r;
-                });
-            return new ae(n);
-        }
-        return this;
-    }
-}
-eC = Symbol.toStringTag;
-ae[eC] = ((e) => {
-    e.type = st.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
-    const t = Object.keys(E).map((n) => E[n]).filter((n) => typeof n == "number" && n !== E.NONE);
-    for (const n of t) {
-        const i = Fn.getVisitFnByTypeId(n),
-            r = fi.getVisitFnByTypeId(n),
-            s = $y.getVisitFnByTypeId(n);
-        nC[n] = {
-            get: i,
-            set: r,
-            indexOf: s
-        }, iC[n] = Object.create(e, {
-            isValid: {
-                value: My(h_)
-            },
-            get: {
-                value: My(Fn.getVisitFnByTypeId(n))
-            },
-            set: {
-                value: ZR(fi.getVisitFnByTypeId(n))
-            },
-            indexOf: {
-                value: QR($y.getVisitFnByTypeId(n))
-            }
-        });
-    }
-    return "Vector";
-})(ae.prototype);
-class Ty extends ae {
-    constructor(t) {
-        super(t.data);
-        const n = this.get,
-            i = this.set,
-            r = this.slice,
-            s = new Array(this.length);
-        Object.defineProperty(this, "get", {
-            value(o) {
-                const a = s[o];
-                if (a !== void 0)
-                    return a;
-                const c = n.call(this, o);
-                return s[o] = c, c;
-            }
-        }), Object.defineProperty(this, "set", {
-            value(o, a) {
-                i.call(this, o, a), s[o] = a;
-            }
-        }), Object.defineProperty(this, "slice", {
-            value: (o, a) => new Ty(r.call(this, o, a))
-        }), Object.defineProperty(this, "isMemoized", {
-            value: !0
-        }), Object.defineProperty(this, "unmemoize", {
-            value: () => new ae(this.data)
-        }), Object.defineProperty(this, "memoize", {
-            value: () => this
-        });
-    }
-}
-class cb {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    /**
-     * Index to the start of the RecordBlock (note this is past the Message header)
-     */
-    offset() {
-        return this.bb.readInt64(this.bb_pos);
-    }
-    /**
-     * Length of the metadata
-     */
-    metaDataLength() {
-        return this.bb.readInt32(this.bb_pos + 8);
-    }
-    /**
-     * Length of the data (this is aligned so there can be a gap between this and
-     * the metadata).
-     */
-    bodyLength() {
-        return this.bb.readInt64(this.bb_pos + 16);
-    }
-    static sizeOf() {
-        return 24;
-    }
-    static createBlock(t, n, i, r) {
-        return t.prep(8, 24), t.writeInt64(BigInt(r ?? 0)), t.pad(4), t.writeInt32(i), t.writeInt64(BigInt(n ?? 0)), t.offset();
-    }
-}
-class Ln {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsFooter(t, n) {
-        return (n || new Ln()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsFooter(t, n) {
-        return t.setPosition(t.position() + nt), (n || new Ln()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    version() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt16(this.bb_pos + t) : Le.V1;
-    }
-    schema(t) {
-        const n = this.bb.__offset(this.bb_pos, 6);
-        return n ? (t || new Gi()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
-    }
-    dictionaries(t, n) {
-        const i = this.bb.__offset(this.bb_pos, 8);
-        return i ? (n || new cb()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
-    }
-    dictionariesLength() {
-        const t = this.bb.__offset(this.bb_pos, 8);
-        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-    }
-    recordBatches(t, n) {
-        const i = this.bb.__offset(this.bb_pos, 10);
-        return i ? (n || new cb()).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null;
-    }
-    recordBatchesLength() {
-        const t = this.bb.__offset(this.bb_pos, 10);
-        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-    }
-    /**
-     * User-defined metadata
-     */
-    customMetadata(t, n) {
-        const i = this.bb.__offset(this.bb_pos, 12);
-        return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-    }
-    customMetadataLength() {
-        const t = this.bb.__offset(this.bb_pos, 12);
-        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-    }
-    static startFooter(t) {
-        t.startObject(5);
-    }
-    static addVersion(t, n) {
-        t.addFieldInt16(0, n, Le.V1);
-    }
-    static addSchema(t, n) {
-        t.addFieldOffset(1, n, 0);
-    }
-    static addDictionaries(t, n) {
-        t.addFieldOffset(2, n, 0);
-    }
-    static startDictionariesVector(t, n) {
-        t.startVector(24, n, 8);
-    }
-    static addRecordBatches(t, n) {
-        t.addFieldOffset(3, n, 0);
-    }
-    static startRecordBatchesVector(t, n) {
-        t.startVector(24, n, 8);
-    }
-    static addCustomMetadata(t, n) {
-        t.addFieldOffset(4, n, 0);
-    }
-    static createCustomMetadataVector(t, n) {
-        t.startVector(4, n.length, 4);
-        for (let i = n.length - 1; i >= 0; i--)
-            t.addOffset(n[i]);
-        return t.endVector();
-    }
-    static startCustomMetadataVector(t, n) {
-        t.startVector(4, n, 4);
-    }
-    static endFooter(t) {
-        return t.endObject();
-    }
-    static finishFooterBuffer(t, n) {
-        t.finish(n);
-    }
-    static finishSizePrefixedFooterBuffer(t, n) {
-        t.finish(n, void 0, !0);
-    }
-}
-class ee {
-    constructor(t = [], n, i, r = Le.V5) {
-        this.fields = t || [], this.metadata = n || /* @__PURE__ */ new Map(), i || (i = lb(t)), this.dictionaries = i, this.metadataVersion = r;
-    }
-    get[Symbol.toStringTag]() {
-        return "Schema";
-    }
-    get names() {
-        return this.fields.map((t) => t.name);
-    }
-    toString() {
-        return `Schema<{ ${this.fields.map((t, n) => `${n}: ${t}`).join(", ")} }>`;
-    }
-    /**
-     * Construct a new Schema containing only specified fields.
-     *
-     * @param fieldNames Names of fields to keep.
-     * @returns A new Schema of fields matching the specified names.
-     */
-    select(t) {
-        const n = new Set(t),
-            i = this.fields.filter((r) => n.has(r.name));
-        return new ee(i, this.metadata);
-    }
-    /**
-     * Construct a new Schema containing only fields at the specified indices.
-     *
-     * @param fieldIndices Indices of fields to keep.
-     * @returns A new Schema of fields at the specified indices.
-     */
-    selectAt(t) {
-        const n = t.map((i) => this.fields[i]).filter(Boolean);
-        return new ee(n, this.metadata);
-    }
-    assign(...t) {
-        const n = t[0] instanceof ee ? t[0] : Array.isArray(t[0]) ? new ee(t[0]) : new ee(t),
-            i = [...this.fields],
-            r = Rh(Rh( /* @__PURE__ */ new Map(), this.metadata), n.metadata),
-            s = n.fields.filter((a) => {
-                const c = i.findIndex((l) => l.name === a.name);
-                return ~c ? (i[c] = a.clone({
-                    metadata: Rh(Rh( /* @__PURE__ */ new Map(), i[c].metadata), a.metadata)
-                })) && !1 : !0;
-            }),
-            o = lb(s, /* @__PURE__ */ new Map());
-        return new ee([...i, ...s], r, new Map([...this.dictionaries, ...o]));
-    }
-}
-ee.prototype.fields = null;
-ee.prototype.metadata = null;
-ee.prototype.dictionaries = null;
-class ge {
-    /** @nocollapse */
-    static new(...t) {
-        let [n, i, r, s] = t;
-        return t[0] && typeof t[0] == "object" && ({
-            name: n
-        } = t[0], i === void 0 && (i = t[0].type), r === void 0 && (r = t[0].nullable), s === void 0 && (s = t[0].metadata)), new ge(`${n}`, i, r, s);
-    }
-    constructor(t, n, i = !1, r) {
-        this.name = t, this.type = n, this.nullable = i, this.metadata = r || /* @__PURE__ */ new Map();
-    }
-    get typeId() {
-        return this.type.typeId;
-    }
-    get[Symbol.toStringTag]() {
-        return "Field";
-    }
-    toString() {
-        return `${this.name}: ${this.type}`;
-    }
-    clone(...t) {
-        let [n, i, r, s] = t;
-        return !t[0] || typeof t[0] != "object" ? [n = this.name, i = this.type, r = this.nullable, s = this.metadata] = t : {
-            name: n = this.name,
-            type: i = this.type,
-            nullable: r = this.nullable,
-            metadata: s = this.metadata
-        } = t[0], ge.new(n, i, r, s);
-    }
-}
-ge.prototype.type = null;
-ge.prototype.name = null;
-ge.prototype.nullable = null;
-ge.prototype.metadata = null;
-
-function Rh(e, t) {
-    return new Map([...e || /* @__PURE__ */ new Map(), ...t || /* @__PURE__ */ new Map()]);
-}
-
-function lb(e, t = /* @__PURE__ */ new Map()) {
-    for (let n = -1, i = e.length; ++n < i;) {
-        const s = e[n].type;
-        if (st.isDictionary(s)) {
-            if (!t.has(s.id))
-                t.set(s.id, s.dictionary);
-            else if (t.get(s.id) !== s.dictionary)
-                throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
-        }
-        s.children && s.children.length > 0 && lb(s.children, t);
-    }
-    return t;
-}
-var Jat = Cy,
-    Kat = ur;
-class p_ {
-    /** @nocollapse */
-    static decode(t) {
-        t = new Kat(Wt(t));
-        const n = Ln.getRootAsFooter(t),
-            i = ee.decode(n.schema(), /* @__PURE__ */ new Map(), n.version());
-        return new Zat(i, n);
-    }
-    /** @nocollapse */
-    static encode(t) {
-        const n = new Jat(),
-            i = ee.encode(n, t.schema);
-        Ln.startRecordBatchesVector(n, t.numRecordBatches);
-        for (const o of [...t.recordBatches()].slice().reverse())
-            Hc.encode(n, o);
-        const r = n.endVector();
-        Ln.startDictionariesVector(n, t.numDictionaries);
-        for (const o of [...t.dictionaryBatches()].slice().reverse())
-            Hc.encode(n, o);
-        const s = n.endVector();
-        return Ln.startFooter(n), Ln.addSchema(n, i), Ln.addVersion(n, Le.V5), Ln.addRecordBatches(n, r), Ln.addDictionaries(n, s), Ln.finishFooterBuffer(n, Ln.endFooter(n)), n.asUint8Array();
-    }
-    get numRecordBatches() {
-        return this._recordBatches.length;
-    }
-    get numDictionaries() {
-        return this._dictionaryBatches.length;
-    }
-    constructor(t, n = Le.V5, i, r) {
-            this.schema = t, this.version = n, i && (this._recordBatches = i), r && (this._dictionaryBatches = r);
-        }
-        * recordBatches() {
-            for (let t, n = -1, i = this.numRecordBatches; ++n < i;)
-                (t = this.getRecordBatch(n)) && (yield t);
-        }
-        * dictionaryBatches() {
-            for (let t, n = -1, i = this.numDictionaries; ++n < i;)
-                (t = this.getDictionaryBatch(n)) && (yield t);
-        }
-    getRecordBatch(t) {
-        return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null;
-    }
-    getDictionaryBatch(t) {
-        return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null;
-    }
-}
-class Zat extends p_ {
-    get numRecordBatches() {
-        return this._footer.recordBatchesLength();
-    }
-    get numDictionaries() {
-        return this._footer.dictionariesLength();
-    }
-    constructor(t, n) {
-        super(t, n.version()), this._footer = n;
-    }
-    getRecordBatch(t) {
-        if (t >= 0 && t < this.numRecordBatches) {
-            const n = this._footer.recordBatches(t);
-            if (n)
-                return Hc.decode(n);
-        }
-        return null;
-    }
-    getDictionaryBatch(t) {
-        if (t >= 0 && t < this.numDictionaries) {
-            const n = this._footer.dictionaries(t);
-            if (n)
-                return Hc.decode(n);
-        }
-        return null;
-    }
-}
-class Hc {
-    /** @nocollapse */
-    static decode(t) {
-        return new Hc(t.metaDataLength(), t.bodyLength(), t.offset());
-    }
-    /** @nocollapse */
-    static encode(t, n) {
-        const {
-            metaDataLength: i
-        } = n, r = BigInt(n.offset), s = BigInt(n.bodyLength);
-        return cb.createBlock(t, r, i, s);
-    }
-    constructor(t, n, i) {
-        this.metaDataLength = t, this.offset = bn(i), this.bodyLength = bn(n);
-    }
-}
-const Ie = Object.freeze({
-    done: !0,
-    value: void 0
-});
-class vI {
-    constructor(t) {
-        this._json = t;
-    }
-    get schema() {
-        return this._json.schema;
-    }
-    get batches() {
-        return this._json.batches || [];
-    }
-    get dictionaries() {
-        return this._json.dictionaries || [];
-    }
-}
-class rC {
-    tee() {
-        return this._getDOMStream().tee();
-    }
-    pipe(t, n) {
-        return this._getNodeStream().pipe(t, n);
-    }
-    pipeTo(t, n) {
-        return this._getDOMStream().pipeTo(t, n);
-    }
-    pipeThrough(t, n) {
-        return this._getDOMStream().pipeThrough(t, n);
-    }
-    _getDOMStream() {
-        return this._DOMStream || (this._DOMStream = this.toDOMStream());
-    }
-    _getNodeStream() {
-        return this._nodeStream || (this._nodeStream = this.toNodeStream());
-    }
-}
-class Qat extends rC {
-    constructor() {
-        super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise((t) => this._closedPromiseResolve = t);
-    }
-    get closed() {
-        return this._closedPromise;
-    }
-    cancel(t) {
-        return W(this, void 0, void 0, function*() {
-            yield this.return(t);
-        });
-    }
-    write(t) {
-        this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({
-            done: !1,
-            value: t
-        }));
-    }
-    abort(t) {
-        this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = {
-            error: t
-        } : this.resolvers.shift().reject({
-            done: !0,
-            value: t
-        }));
-    }
-    close() {
-            if (this._closedPromiseResolve) {
-                const {
-                    resolvers: t
-                } = this;
-                for (; t.length > 0;)
-                    t.shift().resolve(Ie);
-                this._closedPromiseResolve(), this._closedPromiseResolve = void 0;
-            }
-        }
-        [Symbol.asyncIterator]() {
-            return this;
-        }
-    toDOMStream(t) {
-        return Jn.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t);
-    }
-    toNodeStream(t) {
-        return Jn.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t);
-    }
-    throw (t) {
-        return W(this, void 0, void 0, function*() {
-            return yield this.abort(t), Ie;
-        });
-    }
-    return (t) {
-        return W(this, void 0, void 0, function*() {
-            return yield this.close(), Ie;
-        });
-    }
-    read(t) {
-        return W(this, void 0, void 0, function*() {
-            return (yield this.next(t, "read")).value;
-        });
-    }
-    peek(t) {
-        return W(this, void 0, void 0, function*() {
-            return (yield this.next(t, "peek")).value;
-        });
-    }
-    next(...t) {
-        return this._values.length > 0 ? Promise.resolve({
-            done: !1,
-            value: this._values.shift()
-        }) : this._error ? Promise.reject({
-            done: !0,
-            value: this._error.error
-        }) : this._closedPromiseResolve ? new Promise((n, i) => {
-            this.resolvers.push({
-                resolve: n,
-                reject: i
-            });
-        }) : Promise.resolve(Ie);
-    }
-    _ensureOpen() {
-        if (this._closedPromiseResolve)
-            return !0;
-        throw new Error("AsyncQueue is closed");
-    }
-}
-class tct extends Qat {
-    write(t) {
-        if ((t = Wt(t)).byteLength > 0)
-            return super.write(t);
-    }
-    toString(t = !1) {
-        return t ? eb(this.toUint8Array(!0)) : this.toUint8Array(!1).then(eb);
-    }
-    toUint8Array(t = !1) {
-        return t ? yr(this._values)[0] : W(this, void 0, void 0, function*() {
-            var n, i, r, s;
-            const o = [];
-            let a = 0;
-            try {
-                for (var c = !0, l = ai(this), u; u = yield l.next(), n = u.done, !n; c = !0) {
-                    s = u.value, c = !1;
-                    const f = s;
-                    o.push(f), a += f.byteLength;
-                }
-            } catch (f) {
-                i = {
-                    error: f
-                };
-            } finally {
-                try {
-                    !c && !n && (r = l.return) && (yield r.call(l));
-                } finally {
-                    if (i)
-                        throw i.error;
-                }
-            }
-            return yr(o, a)[0];
-        });
-    }
-}
-class Dy {
-    constructor(t) {
-            t && (this.source = new ect(Jn.fromIterable(t)));
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-    next(t) {
-        return this.source.next(t);
-    }
-    throw (t) {
-        return this.source.throw(t);
-    }
-    return (t) {
-        return this.source.return(t);
-    }
-    peek(t) {
-        return this.source.peek(t);
-    }
-    read(t) {
-        return this.source.read(t);
-    }
-}
-class Jc {
-    constructor(t) {
-            t instanceof Jc ? this.source = t.source : t instanceof tct ? this.source = new go(Jn.fromAsyncIterable(t)) : $L(t) ? this.source = new go(Jn.fromNodeStream(t)) : n_(t) ? this.source = new go(Jn.fromDOMStream(t)) : AL(t) ? this.source = new go(Jn.fromDOMStream(t.body)) : J0(t) ? this.source = new go(Jn.fromIterable(t)) : Qu(t) ? this.source = new go(Jn.fromAsyncIterable(t)) : e_(t) && (this.source = new go(Jn.fromAsyncIterable(t)));
-        }
-        [Symbol.asyncIterator]() {
-            return this;
-        }
-    next(t) {
-        return this.source.next(t);
-    }
-    throw (t) {
-        return this.source.throw(t);
-    }
-    return (t) {
-        return this.source.return(t);
-    }
-    get closed() {
-        return this.source.closed;
-    }
-    cancel(t) {
-        return this.source.cancel(t);
-    }
-    peek(t) {
-        return this.source.peek(t);
-    }
-    read(t) {
-        return this.source.read(t);
-    }
-}
-class ect {
-    constructor(t) {
-        this.source = t;
-    }
-    cancel(t) {
-        this.return(t);
-    }
-    peek(t) {
-        return this.next(t, "peek").value;
-    }
-    read(t) {
-        return this.next(t, "read").value;
-    }
-    next(t, n = "read") {
-        return this.source.next({
-            cmd: n,
-            size: t
-        });
-    }
-    throw (t) {
-        return Object.create(this.source.throw && this.source.throw(t) || Ie);
-    }
-    return (t) {
-        return Object.create(this.source.return && this.source.return(t) || Ie);
-    }
-}
-class go {
-    constructor(t) {
-        this.source = t, this._closedPromise = new Promise((n) => this._closedPromiseResolve = n);
-    }
-    cancel(t) {
-        return W(this, void 0, void 0, function*() {
-            yield this.return(t);
-        });
-    }
-    get closed() {
-        return this._closedPromise;
-    }
-    read(t) {
-        return W(this, void 0, void 0, function*() {
-            return (yield this.next(t, "read")).value;
-        });
-    }
-    peek(t) {
-        return W(this, void 0, void 0, function*() {
-            return (yield this.next(t, "peek")).value;
-        });
-    }
-    next(t, n = "read") {
-        return W(this, void 0, void 0, function*() {
-            return yield this.source.next({
-                cmd: n,
-                size: t
-            });
-        });
-    }
-    throw (t) {
-        return W(this, void 0, void 0, function*() {
-            const n = this.source.throw && (yield this.source.throw(t)) || Ie;
-            return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
-        });
-    }
-    return (t) {
-        return W(this, void 0, void 0, function*() {
-            const n = this.source.return && (yield this.source.return(t)) || Ie;
-            return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(n);
-        });
-    }
-}
-class _I extends Dy {
-    constructor(t, n) {
-        super(), this.position = 0, this.buffer = Wt(t), this.size = n === void 0 ? this.buffer.byteLength : n;
-    }
-    readInt32(t) {
-        const {
-            buffer: n,
-            byteOffset: i
-        } = this.readAt(t, 4);
-        return new DataView(n, i).getInt32(0, !0);
-    }
-    seek(t) {
-        return this.position = Math.min(t, this.size), t < this.size;
-    }
-    read(t) {
-        const {
-            buffer: n,
-            size: i,
-            position: r
-        } = this;
-        return n && r < i ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(i, r + Math.min(i - r, t)), n.subarray(r, this.position)) : null;
-    }
-    readAt(t, n) {
-        const i = this.buffer,
-            r = Math.min(this.size, t + n);
-        return i ? i.subarray(t, r) : new Uint8Array(n);
-    }
-    close() {
-        this.buffer && (this.buffer = null);
-    }
-    throw (t) {
-        return this.close(), {
-            done: !0,
-            value: t
-        };
-    }
-    return (t) {
-        return this.close(), {
-            done: !0,
-            value: t
-        };
-    }
-}
-class Ny extends Jc {
-    constructor(t, n) {
-        super(), this.position = 0, this._handle = t, typeof n == "number" ? this.size = n : this._pending = W(this, void 0, void 0, function*() {
-            this.size = (yield t.stat()).size, delete this._pending;
-        });
-    }
-    readInt32(t) {
-        return W(this, void 0, void 0, function*() {
-            const {
-                buffer: n,
-                byteOffset: i
-            } = yield this.readAt(t, 4);
-            return new DataView(n, i).getInt32(0, !0);
-        });
-    }
-    seek(t) {
-        return W(this, void 0, void 0, function*() {
-            return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size;
-        });
-    }
-    read(t) {
-        return W(this, void 0, void 0, function*() {
-            this._pending && (yield this._pending);
-            const {
-                _handle: n,
-                size: i,
-                position: r
-            } = this;
-            if (n && r < i) {
-                typeof t != "number" && (t = Number.POSITIVE_INFINITY);
-                let s = r,
-                    o = 0,
-                    a = 0;
-                const c = Math.min(i, s + Math.min(i - s, t)),
-                    l = new Uint8Array(Math.max(0, (this.position = c) - s));
-                for (;
-                    (s += a) < c && (o += a) < l.byteLength;)
-                    ({
-                        bytesRead: a
-                    } = yield n.read(l, o, l.byteLength - o, s));
-                return l;
-            }
-            return null;
-        });
-    }
-    readAt(t, n) {
-        return W(this, void 0, void 0, function*() {
-            this._pending && (yield this._pending);
-            const {
-                _handle: i,
-                size: r
-            } = this;
-            if (i && t + n < r) {
-                const s = Math.min(r, t + n),
-                    o = new Uint8Array(s - t);
-                return (yield i.read(o, 0, n, t)).buffer;
-            }
-            return new Uint8Array(n);
-        });
-    }
-    close() {
-        return W(this, void 0, void 0, function*() {
-            const t = this._handle;
-            this._handle = null, t && (yield t.close());
-        });
-    }
-    throw (t) {
-        return W(this, void 0, void 0, function*() {
-            return yield this.close(), {
-                done: !0,
-                value: t
-            };
-        });
-    }
-    return (t) {
-        return W(this, void 0, void 0, function*() {
-            return yield this.close(), {
-                done: !0,
-                value: t
-            };
-        });
-    }
-}
-const nct = 65536;
-
-function sc(e) {
-    return e < 0 && (e = 4294967295 + e + 1), `0x${e.toString(16)}`;
-}
-const Kc = 8,
-    y_ = [
-        1,
-        10,
-        100,
-        1e3,
-        1e4,
-        1e5,
-        1e6,
-        1e7,
-        1e8
-    ];
-class sC {
-    constructor(t) {
-        this.buffer = t;
-    }
-    high() {
-        return this.buffer[1];
-    }
-    low() {
-        return this.buffer[0];
-    }
-    _times(t) {
-        const n = new Uint32Array([
-                this.buffer[1] >>> 16,
-                this.buffer[1] & 65535,
-                this.buffer[0] >>> 16,
-                this.buffer[0] & 65535
-            ]),
-            i = new Uint32Array([
-                t.buffer[1] >>> 16,
-                t.buffer[1] & 65535,
-                t.buffer[0] >>> 16,
-                t.buffer[0] & 65535
-            ]);
-        let r = n[3] * i[3];
-        this.buffer[0] = r & 65535;
-        let s = r >>> 16;
-        return r = n[2] * i[3], s += r, r = n[3] * i[2] >>> 0, s += r, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < r ? nct : 0, this.buffer[1] += s >>> 16, this.buffer[1] += n[1] * i[3] + n[2] * i[2] + n[3] * i[1], this.buffer[1] += n[0] * i[3] + n[1] * i[2] + n[2] * i[1] + n[3] * i[0] << 16, this;
-    }
-    _plus(t) {
-        const n = this.buffer[0] + t.buffer[0] >>> 0;
-        this.buffer[1] += t.buffer[1], n < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = n;
-    }
-    lessThan(t) {
-        return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0];
-    }
-    equals(t) {
-        return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0];
-    }
-    greaterThan(t) {
-        return t.lessThan(this);
-    }
-    hex() {
-        return `${sc(this.buffer[1])} ${sc(this.buffer[0])}`;
-    }
-}
-class ie extends sC {
-    times(t) {
-        return this._times(t), this;
-    }
-    plus(t) {
-        return this._plus(t), this;
-    }
-    /** @nocollapse */
-    static from(t, n = new Uint32Array(2)) {
-        return ie.fromString(typeof t == "string" ? t : t.toString(), n);
-    }
-    /** @nocollapse */
-    static fromNumber(t, n = new Uint32Array(2)) {
-        return ie.fromString(t.toString(), n);
-    }
-    /** @nocollapse */
-    static fromString(t, n = new Uint32Array(2)) {
-        const i = t.length,
-            r = new ie(n);
-        for (let s = 0; s < i;) {
-            const o = Kc < i - s ? Kc : i - s,
-                a = new ie(new Uint32Array([Number.parseInt(t.slice(s, s + o), 10), 0])),
-                c = new ie(new Uint32Array([y_[o], 0]));
-            r.times(c), r.plus(a), s += o;
-        }
-        return r;
-    }
-    /** @nocollapse */
-    static convertArray(t) {
-        const n = new Uint32Array(t.length * 2);
-        for (let i = -1, r = t.length; ++i < r;)
-            ie.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
-        return n;
-    }
-    /** @nocollapse */
-    static multiply(t, n) {
-        return new ie(new Uint32Array(t.buffer)).times(n);
-    }
-    /** @nocollapse */
-    static add(t, n) {
-        return new ie(new Uint32Array(t.buffer)).plus(n);
-    }
-}
-class Sn extends sC {
-    negate() {
-        return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this;
-    }
-    times(t) {
-        return this._times(t), this;
-    }
-    plus(t) {
-        return this._plus(t), this;
-    }
-    lessThan(t) {
-        const n = this.buffer[1] << 0,
-            i = t.buffer[1] << 0;
-        return n < i || n === i && this.buffer[0] < t.buffer[0];
-    }
-    /** @nocollapse */
-    static from(t, n = new Uint32Array(2)) {
-        return Sn.fromString(typeof t == "string" ? t : t.toString(), n);
-    }
-    /** @nocollapse */
-    static fromNumber(t, n = new Uint32Array(2)) {
-        return Sn.fromString(t.toString(), n);
-    }
-    /** @nocollapse */
-    static fromString(t, n = new Uint32Array(2)) {
-        const i = t.startsWith("-"),
-            r = t.length,
-            s = new Sn(n);
-        for (let o = i ? 1 : 0; o < r;) {
-            const a = Kc < r - o ? Kc : r - o,
-                c = new Sn(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0])),
-                l = new Sn(new Uint32Array([y_[a], 0]));
-            s.times(l), s.plus(c), o += a;
-        }
-        return i ? s.negate() : s;
-    }
-    /** @nocollapse */
-    static convertArray(t) {
-        const n = new Uint32Array(t.length * 2);
-        for (let i = -1, r = t.length; ++i < r;)
-            Sn.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 2 * i * 4, 2));
-        return n;
-    }
-    /** @nocollapse */
-    static multiply(t, n) {
-        return new Sn(new Uint32Array(t.buffer)).times(n);
-    }
-    /** @nocollapse */
-    static add(t, n) {
-        return new Sn(new Uint32Array(t.buffer)).plus(n);
-    }
-}
-class Xi {
-    constructor(t) {
-        this.buffer = t;
-    }
-    high() {
-        return new Sn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
-    }
-    low() {
-        return new Sn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
-    }
-    negate() {
-        return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this;
-    }
-    times(t) {
-        const n = new ie(new Uint32Array([this.buffer[3], 0])),
-            i = new ie(new Uint32Array([this.buffer[2], 0])),
-            r = new ie(new Uint32Array([this.buffer[1], 0])),
-            s = new ie(new Uint32Array([this.buffer[0], 0])),
-            o = new ie(new Uint32Array([t.buffer[3], 0])),
-            a = new ie(new Uint32Array([t.buffer[2], 0])),
-            c = new ie(new Uint32Array([t.buffer[1], 0])),
-            l = new ie(new Uint32Array([t.buffer[0], 0]));
-        let u = ie.multiply(s, l);
-        this.buffer[0] = u.low();
-        const f = new ie(new Uint32Array([u.high(), 0]));
-        return u = ie.multiply(r, l), f.plus(u), u = ie.multiply(s, c), f.plus(u), this.buffer[1] = f.low(), this.buffer[3] = f.lessThan(u) ? 1 : 0, this.buffer[2] = f.high(), new ie(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(ie.multiply(i, l)).plus(ie.multiply(r, c)).plus(ie.multiply(s, a)), this.buffer[3] += ie.multiply(n, l).plus(ie.multiply(i, c)).plus(ie.multiply(r, a)).plus(ie.multiply(s, o)).low(), this;
-    }
-    plus(t) {
-        const n = new Uint32Array(4);
-        return n[3] = this.buffer[3] + t.buffer[3] >>> 0, n[2] = this.buffer[2] + t.buffer[2] >>> 0, n[1] = this.buffer[1] + t.buffer[1] >>> 0, n[0] = this.buffer[0] + t.buffer[0] >>> 0, n[0] < this.buffer[0] >>> 0 && ++n[1], n[1] < this.buffer[1] >>> 0 && ++n[2], n[2] < this.buffer[2] >>> 0 && ++n[3], this.buffer[3] = n[3], this.buffer[2] = n[2], this.buffer[1] = n[1], this.buffer[0] = n[0], this;
-    }
-    hex() {
-        return `${sc(this.buffer[3])} ${sc(this.buffer[2])} ${sc(this.buffer[1])} ${sc(this.buffer[0])}`;
-    }
-    /** @nocollapse */
-    static multiply(t, n) {
-        return new Xi(new Uint32Array(t.buffer)).times(n);
-    }
-    /** @nocollapse */
-    static add(t, n) {
-        return new Xi(new Uint32Array(t.buffer)).plus(n);
-    }
-    /** @nocollapse */
-    static from(t, n = new Uint32Array(4)) {
-        return Xi.fromString(typeof t == "string" ? t : t.toString(), n);
-    }
-    /** @nocollapse */
-    static fromNumber(t, n = new Uint32Array(4)) {
-        return Xi.fromString(t.toString(), n);
-    }
-    /** @nocollapse */
-    static fromString(t, n = new Uint32Array(4)) {
-        const i = t.startsWith("-"),
-            r = t.length,
-            s = new Xi(n);
-        for (let o = i ? 1 : 0; o < r;) {
-            const a = Kc < r - o ? Kc : r - o,
-                c = new Xi(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0, 0, 0])),
-                l = new Xi(new Uint32Array([y_[a], 0, 0, 0]));
-            s.times(l), s.plus(c), o += a;
-        }
-        return i ? s.negate() : s;
-    }
-    /** @nocollapse */
-    static convertArray(t) {
-        const n = new Uint32Array(t.length * 4);
-        for (let i = -1, r = t.length; ++i < r;)
-            Xi.from(t[i], new Uint32Array(n.buffer, n.byteOffset + 4 * 4 * i, 4));
-        return n;
-    }
-}
-class oC extends zt {
-    constructor(t, n, i, r, s = Le.V5) {
-        super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = n, this.buffers = i, this.dictionaries = r, this.metadataVersion = s;
-    }
-    visit(t) {
-        return super.visit(t instanceof ge ? t.type : t);
-    }
-    visitNull(t, {
-        length: n
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n
-        });
-    }
-    visitBool(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitInt(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitFloat(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitUtf8(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            valueOffsets: this.readOffsets(t),
-            data: this.readData(t)
-        });
-    }
-    visitLargeUtf8(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            valueOffsets: this.readOffsets(t),
-            data: this.readData(t)
-        });
-    }
-    visitBinary(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            valueOffsets: this.readOffsets(t),
-            data: this.readData(t)
-        });
-    }
-    visitLargeBinary(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            valueOffsets: this.readOffsets(t),
-            data: this.readData(t)
-        });
-    }
-    visitFixedSizeBinary(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitDate(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitTimestamp(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitTime(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitDecimal(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitList(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            valueOffsets: this.readOffsets(t),
-            child: this.visit(t.children[0])
-        });
-    }
-    visitStruct(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            children: this.visitMany(t.children)
-        });
-    }
-    visitUnion(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return this.metadataVersion < Le.V5 && this.readNullBitmap(t, i), t.mode === On.Sparse ? this.visitSparseUnion(t, {
-            length: n,
-            nullCount: i
-        }) : this.visitDenseUnion(t, {
-            length: n,
-            nullCount: i
-        });
-    }
-    visitDenseUnion(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            typeIds: this.readTypeIds(t),
-            valueOffsets: this.readOffsets(t),
-            children: this.visitMany(t.children)
-        });
-    }
-    visitSparseUnion(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            typeIds: this.readTypeIds(t),
-            children: this.visitMany(t.children)
-        });
-    }
-    visitDictionary(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t.indices),
-            dictionary: this.readDictionary(t)
-        });
-    }
-    visitInterval(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitDuration(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            data: this.readData(t)
-        });
-    }
-    visitFixedSizeList(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            child: this.visit(t.children[0])
-        });
-    }
-    visitMap(t, {
-        length: n,
-        nullCount: i
-    } = this.nextFieldNode()) {
-        return Ct({
-            type: t,
-            length: n,
-            nullCount: i,
-            nullBitmap: this.readNullBitmap(t, i),
-            valueOffsets: this.readOffsets(t),
-            child: this.visit(t.children[0])
-        });
-    }
-    nextFieldNode() {
-        return this.nodes[++this.nodesIndex];
-    }
-    nextBufferRange() {
-        return this.buffers[++this.buffersIndex];
-    }
-    readNullBitmap(t, n, i = this.nextBufferRange()) {
-        return n > 0 && this.readData(t, i) || new Uint8Array(0);
-    }
-    readOffsets(t, n) {
-        return this.readData(t, n);
-    }
-    readTypeIds(t, n) {
-        return this.readData(t, n);
-    }
-    readData(t, {
-        length: n,
-        offset: i
-    } = this.nextBufferRange()) {
-        return this.bytes.subarray(i, i + n);
-    }
-    readDictionary(t) {
-        return this.dictionaries.get(t.id);
-    }
-}
-class ict extends oC {
-    constructor(t, n, i, r, s) {
-        super(new Uint8Array(0), n, i, r, s), this.sources = t;
-    }
-    readNullBitmap(t, n, {
-        offset: i
-    } = this.nextBufferRange()) {
-        return n <= 0 ? new Uint8Array(0) : ob(this.sources[i]);
-    }
-    readOffsets(t, {
-        offset: n
-    } = this.nextBufferRange()) {
-        return se(Uint8Array, se(t.OffsetArrayType, this.sources[n]));
-    }
-    readTypeIds(t, {
-        offset: n
-    } = this.nextBufferRange()) {
-        return se(Uint8Array, se(t.ArrayType, this.sources[n]));
-    }
-    readData(t, {
-        offset: n
-    } = this.nextBufferRange()) {
-        const {
-            sources: i
-        } = this;
-        return st.isTimestamp(t) || (st.isInt(t) || st.isTime(t)) && t.bitWidth === 64 || st.isDuration(t) || st.isDate(t) && t.unit === Oi.MILLISECOND ? se(Uint8Array, Sn.convertArray(i[n])) : st.isDecimal(t) ? se(Uint8Array, Xi.convertArray(i[n])) : st.isBinary(t) || st.isLargeBinary(t) || st.isFixedSizeBinary(t) ? rct(i[n]) : st.isBool(t) ? ob(i[n]) : st.isUtf8(t) || st.isLargeUtf8(t) ? t_(i[n].join("")) : se(Uint8Array, se(t.ArrayType, i[n].map((r) => +r)));
-    }
-}
-
-function rct(e) {
-    const t = e.join(""),
-        n = new Uint8Array(t.length / 2);
-    for (let i = 0; i < t.length; i += 2)
-        n[i >> 1] = Number.parseInt(t.slice(i, i + 2), 16);
-    return n;
-}
-class pt extends zt {
-    compareSchemas(t, n) {
-        return t === n || n instanceof t.constructor && this.compareManyFields(t.fields, n.fields);
-    }
-    compareManyFields(t, n) {
-        return t === n || Array.isArray(t) && Array.isArray(n) && t.length === n.length && t.every((i, r) => this.compareFields(i, n[r]));
-    }
-    compareFields(t, n) {
-        return t === n || n instanceof t.constructor && t.name === n.name && t.nullable === n.nullable && this.visit(t.type, n.type);
-    }
-}
-
-function _n(e, t) {
-    return t instanceof e.constructor;
-}
-
-function da(e, t) {
-    return e === t || _n(e, t);
-}
-
-function gs(e, t) {
-    return e === t || _n(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned;
-}
-
-function Z0(e, t) {
-    return e === t || _n(e, t) && e.precision === t.precision;
-}
-
-function sct(e, t) {
-    return e === t || _n(e, t) && e.byteWidth === t.byteWidth;
-}
-
-function m_(e, t) {
-    return e === t || _n(e, t) && e.unit === t.unit;
-}
-
-function Jf(e, t) {
-    return e === t || _n(e, t) && e.unit === t.unit && e.timezone === t.timezone;
-}
-
-function Kf(e, t) {
-    return e === t || _n(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth;
-}
-
-function oct(e, t) {
-    return e === t || _n(e, t) && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
-}
-
-function act(e, t) {
-    return e === t || _n(e, t) && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
-}
-
-function g_(e, t) {
-    return e === t || _n(e, t) && e.mode === t.mode && e.typeIds.every((n, i) => n === t.typeIds[i]) && no.compareManyFields(e.children, t.children);
-}
-
-function cct(e, t) {
-    return e === t || _n(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && no.visit(e.indices, t.indices) && no.visit(e.dictionary, t.dictionary);
-}
-
-function b_(e, t) {
-    return e === t || _n(e, t) && e.unit === t.unit;
-}
-
-function Zf(e, t) {
-    return e === t || _n(e, t) && e.unit === t.unit;
-}
-
-function lct(e, t) {
-    return e === t || _n(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
-}
-
-function uct(e, t) {
-    return e === t || _n(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && no.compareManyFields(e.children, t.children);
-}
-pt.prototype.visitNull = da;
-pt.prototype.visitBool = da;
-pt.prototype.visitInt = gs;
-pt.prototype.visitInt8 = gs;
-pt.prototype.visitInt16 = gs;
-pt.prototype.visitInt32 = gs;
-pt.prototype.visitInt64 = gs;
-pt.prototype.visitUint8 = gs;
-pt.prototype.visitUint16 = gs;
-pt.prototype.visitUint32 = gs;
-pt.prototype.visitUint64 = gs;
-pt.prototype.visitFloat = Z0;
-pt.prototype.visitFloat16 = Z0;
-pt.prototype.visitFloat32 = Z0;
-pt.prototype.visitFloat64 = Z0;
-pt.prototype.visitUtf8 = da;
-pt.prototype.visitLargeUtf8 = da;
-pt.prototype.visitBinary = da;
-pt.prototype.visitLargeBinary = da;
-pt.prototype.visitFixedSizeBinary = sct;
-pt.prototype.visitDate = m_;
-pt.prototype.visitDateDay = m_;
-pt.prototype.visitDateMillisecond = m_;
-pt.prototype.visitTimestamp = Jf;
-pt.prototype.visitTimestampSecond = Jf;
-pt.prototype.visitTimestampMillisecond = Jf;
-pt.prototype.visitTimestampMicrosecond = Jf;
-pt.prototype.visitTimestampNanosecond = Jf;
-pt.prototype.visitTime = Kf;
-pt.prototype.visitTimeSecond = Kf;
-pt.prototype.visitTimeMillisecond = Kf;
-pt.prototype.visitTimeMicrosecond = Kf;
-pt.prototype.visitTimeNanosecond = Kf;
-pt.prototype.visitDecimal = da;
-pt.prototype.visitList = oct;
-pt.prototype.visitStruct = act;
-pt.prototype.visitUnion = g_;
-pt.prototype.visitDenseUnion = g_;
-pt.prototype.visitSparseUnion = g_;
-pt.prototype.visitDictionary = cct;
-pt.prototype.visitInterval = b_;
-pt.prototype.visitIntervalDayTime = b_;
-pt.prototype.visitIntervalYearMonth = b_;
-pt.prototype.visitDuration = Zf;
-pt.prototype.visitDurationSecond = Zf;
-pt.prototype.visitDurationMillisecond = Zf;
-pt.prototype.visitDurationMicrosecond = Zf;
-pt.prototype.visitDurationNanosecond = Zf;
-pt.prototype.visitFixedSizeList = lct;
-pt.prototype.visitMap = uct;
-const no = new pt();
-
-function fct(e, t) {
-    return no.compareSchemas(e, t);
-}
-
-function fg(e, t) {
-    return hct(e, t.map((n) => n.data.concat()));
-}
-
-function hct(e, t) {
-    const n = [...e.fields],
-        i = [],
-        r = {
-            numBatches: t.reduce((f, h) => Math.max(f, h.length), 0)
-        };
-    let s = 0,
-        o = 0,
-        a = -1;
-    const c = t.length;
-    let l, u = [];
-    for (; r.numBatches-- > 0;) {
-        for (o = Number.POSITIVE_INFINITY, a = -1; ++a < c;)
-            u[a] = l = t[a].shift(), o = Math.min(o, l ? l.length : o);
-        Number.isFinite(o) && (u = dct(n, o, u, t, r), o > 0 && (i[s++] = Ct({
-            type: new hn(n),
-            length: o,
-            nullCount: 0,
-            children: u.slice()
-        })));
-    }
-    return [
-        e = e.assign(n),
-        i.map((f) => new bi(e, f))
-    ];
-}
-
-function dct(e, t, n, i, r) {
-    var s;
-    const o = (t + 63 & -64) >> 3;
-    for (let a = -1, c = i.length; ++a < c;) {
-        const l = n[a],
-            u = l == null ? void 0 : l.length;
-        if (u >= t)
-            u === t ? n[a] = l : (n[a] = l.slice(0, t), r.numBatches = Math.max(r.numBatches, i[a].unshift(l.slice(t, u - t))));
-        else {
-            const f = e[a];
-            e[a] = f.clone({
-                nullable: !0
-            }), n[a] = (s = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : Ct({
-                type: f.type,
-                length: t,
-                nullCount: t,
-                nullBitmap: new Uint8Array(o)
-            });
-        }
-    }
-    return n;
-}
-var aC;
-class ti {
-    constructor(...t) {
-        var n, i;
-        if (t.length === 0)
-            return this.batches = [], this.schema = new ee([]), this._offsets = [0], this;
-        let r, s;
-        t[0] instanceof ee && (r = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
-        const o = (c) => {
-                if (c) {
-                    if (c instanceof bi)
-                        return [c];
-                    if (c instanceof ti)
-                        return c.batches;
-                    if (c instanceof ne) {
-                        if (c.type instanceof hn)
-                            return [new bi(new ee(c.type.children), c)];
-                    } else {
-                        if (Array.isArray(c))
-                            return c.flatMap((l) => o(l));
-                        if (typeof c[Symbol.iterator] == "function")
-                            return [...c].flatMap((l) => o(l));
-                        if (typeof c == "object") {
-                            const l = Object.keys(c),
-                                u = l.map((d) => new ae([c[d]])),
-                                f = r ?? new ee(l.map((d, p) => new ge(String(d), u[p].type, u[p].nullable))),
-                                [, h] = fg(f, u);
-                            return h.length === 0 ? [new bi(c)] : h;
-                        }
-                    }
-                }
-                return [];
-            },
-            a = t.flatMap((c) => o(c));
-        if (r = (i = r ?? ((n = a[0]) === null || n === void 0 ? void 0 : n.schema)) !== null && i !== void 0 ? i : new ee([]), !(r instanceof ee))
-            throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
-        for (const c of a) {
-            if (!(c instanceof bi))
-                throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
-            if (!fct(r, c.schema))
-                throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
-        }
-        this.schema = r, this.batches = a, this._offsets = s ?? JR(this.data);
-    }
-    /**
-     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
-     */
-    get data() {
-        return this.batches.map(({
-            data: t
-        }) => t);
-    }
-    /**
-     * The number of columns in this Table.
-     */
-    get numCols() {
-        return this.schema.fields.length;
-    }
-    /**
-     * The number of rows in this Table.
-     */
-    get numRows() {
-        return this.data.reduce((t, n) => t + n.length, 0);
-    }
-    /**
-     * The number of null rows in this Table.
-     */
-    get nullCount() {
-        return this._nullCount === -1 && (this._nullCount = HR(this.data)), this._nullCount;
-    }
-    /**
-     * Check whether an element is null.
-     *
-     * @param index The index at which to read the validity bitmap.
-     */
-    // @ts-ignore
-    isValid(t) {
-        return !1;
-    }
-    /**
-     * Get an element value by position.
-     *
-     * @param index The index of the element to read.
-     */
-    // @ts-ignore
-    get(t) {
-        return null;
-    }
-    /**
-     * Set an element value by position.
-     *
-     * @param index The index of the element to write.
-     * @param value The value to set.
-     */
-    // @ts-ignore
-    set(t, n) {}
-    /**
-     * Retrieve the index of the first occurrence of a value in an Vector.
-     *
-     * @param element The value to locate in the Vector.
-     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
-     */
-    // @ts-ignore
-    indexOf(t, n) {
-        return -1;
-    }
-    /**
-     * Iterator for rows in this Table.
-     */
-    [Symbol.iterator]() {
-        return this.batches.length > 0 ? d_.visit(new ae(this.data)) : new Array(0)[Symbol.iterator]();
-    }
-    /**
-     * Return a JavaScript Array of the Table rows.
-     *
-     * @returns An Array of Table rows.
-     */
-    toArray() {
-        return [...this];
-    }
-    /**
-     * Returns a string representation of the Table rows.
-     *
-     * @returns A string representation of the Table rows.
-     */
-    toString() {
-        return `[
-  ${this.toArray().join(`,
-  `)}
-]`;
-    }
-    /**
-     * Combines two or more Tables of the same schema.
-     *
-     * @param others Additional Tables to add to the end of this Tables.
-     */
-    concat(...t) {
-        const n = this.schema,
-            i = this.data.concat(t.flatMap(({
-                data: r
-            }) => r));
-        return new ti(n, i.map((r) => new bi(n, r)));
-    }
-    /**
-     * Return a zero-copy sub-section of this Table.
-     *
-     * @param begin The beginning of the specified portion of the Table.
-     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
-     */
-    slice(t, n) {
-        const i = this.schema;
-        [t, n] = GR({
-            length: this.numRows
-        }, t, n);
-        const r = KR(this.data, this._offsets, t, n);
-        return new ti(i, r.map((s) => new bi(i, s)));
-    }
-    /**
-     * Returns a child Vector by name, or null if this Vector has no child with the given name.
-     *
-     * @param name The name of the child to retrieve.
-     */
-    getChild(t) {
-        return this.getChildAt(this.schema.fields.findIndex((n) => n.name === t));
-    }
-    /**
-     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
-     *
-     * @param index The index of the child to retrieve.
-     */
-    getChildAt(t) {
-        if (t > -1 && t < this.schema.fields.length) {
-            const n = this.data.map((i) => i.children[t]);
-            if (n.length === 0) {
-                const {
-                    type: i
-                } = this.schema.fields[t], r = Ct({
-                    type: i,
-                    length: 0,
-                    nullCount: 0
-                });
-                n.push(r._changeLengthAndBackfillNullBitmap(this.numRows));
-            }
-            return new ae(n);
-        }
-        return null;
-    }
-    /**
-     * Sets a child Vector by name.
-     *
-     * @param name The name of the child to overwrite.
-     * @returns A new Table with the supplied child for the specified name.
-     */
-    setChild(t, n) {
-        var i;
-        return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
-    }
-    setChildAt(t, n) {
-        let i = this.schema,
-            r = [...this.batches];
-        if (t > -1 && t < this.numCols) {
-            n || (n = new ae([Ct({
-                type: new to(),
-                length: this.numRows
-            })]));
-            const s = i.fields.slice(),
-                o = s[t].clone({
-                    type: n.type
-                }),
-                a = this.schema.fields.map((c, l) => this.getChildAt(l));
-            [s[t], a[t]] = [o, n], [i, r] = fg(i, a);
-        }
-        return new ti(i, r);
-    }
-    /**
-     * Construct a new Table containing only specified columns.
-     *
-     * @param columnNames Names of columns to keep.
-     * @returns A new Table of columns matching the specified names.
-     */
-    select(t) {
-        const n = this.schema.fields.reduce((i, r, s) => i.set(r.name, s), /* @__PURE__ */ new Map());
-        return this.selectAt(t.map((i) => n.get(i)).filter((i) => i > -1));
-    }
-    /**
-     * Construct a new Table containing only columns at the specified indices.
-     *
-     * @param columnIndices Indices of columns to keep.
-     * @returns A new Table of columns at the specified indices.
-     */
-    selectAt(t) {
-        const n = this.schema.selectAt(t),
-            i = this.batches.map((r) => r.selectAt(t));
-        return new ti(n, i);
-    }
-    assign(t) {
-        const n = this.schema.fields,
-            [i, r] = t.schema.fields.reduce((a, c, l) => {
-                const [u, f] = a, h = n.findIndex((d) => d.name === c.name);
-                return ~h ? f[h] = l : u.push(l), a;
-            }, [
-                [],
-                []
-            ]),
-            s = this.schema.assign(t.schema),
-            o = [
-                ...n.map((a, c) => [c, r[c]]).map(([a, c]) => c === void 0 ? this.getChildAt(a) : t.getChildAt(c)),
-                ...i.map((a) => t.getChildAt(a))
-            ].filter(Boolean);
-        return new ti(...fg(s, o));
-    }
-}
-aC = Symbol.toStringTag;
-ti[aC] = ((e) => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = My(h_), e.get = My(Fn.getVisitFn(E.Struct)), e.set = ZR(fi.getVisitFn(E.Struct)), e.indexOf = QR($y.getVisitFn(E.Struct)), "Table"))(ti.prototype);
-var cC;
-let bi = class au {
-    constructor(...t) {
-        switch (t.length) {
-            case 2: {
-                if ([this.schema] = t, !(this.schema instanceof ee))
-                    throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
-                if ([,
-                        this.data = Ct({
-                            nullCount: 0,
-                            type: new hn(this.schema.fields),
-                            children: this.schema.fields.map((n) => Ct({
-                                type: n.type,
-                                nullCount: 0
-                            }))
-                        })
-                    ] = t, !(this.data instanceof ne))
-                    throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
-                [this.schema, this.data] = xI(this.schema, this.data.children);
-                break;
-            }
-            case 1: {
-                const [n] = t, {
-                    fields: i,
-                    children: r,
-                    length: s
-                } = Object.keys(n).reduce((c, l, u) => (c.children[u] = n[l], c.length = Math.max(c.length, n[l].length), c.fields[u] = ge.new({
-                    name: l,
-                    type: n[l].type,
-                    nullable: !0
-                }), c), {
-                    length: 0,
-                    fields: new Array(),
-                    children: new Array()
-                }), o = new ee(i), a = Ct({
-                    type: new hn(i),
-                    length: s,
-                    children: r,
-                    nullCount: 0
-                });
-                [this.schema, this.data] = xI(o, a.children, s);
-                break;
-            }
-            default:
-                throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
-        }
-    }
-    get dictionaries() {
-        return this._dictionaries || (this._dictionaries = lC(this.schema.fields, this.data.children));
-    }
-    /**
-     * The number of columns in this RecordBatch.
-     */
-    get numCols() {
-        return this.schema.fields.length;
-    }
-    /**
-     * The number of rows in this RecordBatch.
-     */
-    get numRows() {
-        return this.data.length;
-    }
-    /**
-     * The number of null rows in this RecordBatch.
-     */
-    get nullCount() {
-        return this.data.nullCount;
-    }
-    /**
-     * Check whether an element is null.
-     * @param index The index at which to read the validity bitmap.
-     */
-    isValid(t) {
-        return this.data.getValid(t);
-    }
-    /**
-     * Get a row by position.
-     * @param index The index of the element to read.
-     */
-    get(t) {
-        return Fn.visit(this.data, t);
-    }
-    /**
-     * Set a row by position.
-     * @param index The index of the element to write.
-     * @param value The value to set.
-     */
-    set(t, n) {
-        return fi.visit(this.data, t, n);
-    }
-    /**
-     * Retrieve the index of the first occurrence of a row in an RecordBatch.
-     * @param element The row to locate in the RecordBatch.
-     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
-     */
-    indexOf(t, n) {
-        return $y.visit(this.data, t, n);
-    }
-    /**
-     * Iterator for rows in this RecordBatch.
-     */
-    [Symbol.iterator]() {
-        return d_.visit(new ae([this.data]));
-    }
-    /**
-     * Return a JavaScript Array of the RecordBatch rows.
-     * @returns An Array of RecordBatch rows.
-     */
-    toArray() {
-        return [...this];
-    }
-    /**
-     * Combines two or more RecordBatch of the same schema.
-     * @param others Additional RecordBatch to add to the end of this RecordBatch.
-     */
-    concat(...t) {
-        return new ti(this.schema, [this, ...t]);
-    }
-    /**
-     * Return a zero-copy sub-section of this RecordBatch.
-     * @param start The beginning of the specified portion of the RecordBatch.
-     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
-     */
-    slice(t, n) {
-        const [i] = new ae([this.data]).slice(t, n).data;
-        return new au(this.schema, i);
-    }
-    /**
-     * Returns a child Vector by name, or null if this Vector has no child with the given name.
-     * @param name The name of the child to retrieve.
-     */
-    getChild(t) {
-        var n;
-        return this.getChildAt((n = this.schema.fields) === null || n === void 0 ? void 0 : n.findIndex((i) => i.name === t));
-    }
-    /**
-     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
-     * @param index The index of the child to retrieve.
-     */
-    getChildAt(t) {
-        return t > -1 && t < this.schema.fields.length ? new ae([this.data.children[t]]) : null;
-    }
-    /**
-     * Sets a child Vector by name.
-     * @param name The name of the child to overwrite.
-     * @returns A new RecordBatch with the new child for the specified name.
-     */
-    setChild(t, n) {
-        var i;
-        return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t), n);
-    }
-    setChildAt(t, n) {
-        let i = this.schema,
-            r = this.data;
-        if (t > -1 && t < this.numCols) {
-            n || (n = new ae([Ct({
-                type: new to(),
-                length: this.numRows
-            })]));
-            const s = i.fields.slice(),
-                o = r.children.slice(),
-                a = s[t].clone({
-                    type: n.type
-                });
-            [s[t], o[t]] = [a, n.data[0]], i = new ee(s, new Map(this.schema.metadata)), r = Ct({
-                type: new hn(s),
-                children: o
-            });
-        }
-        return new au(i, r);
-    }
-    /**
-     * Construct a new RecordBatch containing only specified columns.
-     *
-     * @param columnNames Names of columns to keep.
-     * @returns A new RecordBatch of columns matching the specified names.
-     */
-    select(t) {
-        const n = this.schema.select(t),
-            i = new hn(n.fields),
-            r = [];
-        for (const s of t) {
-            const o = this.schema.fields.findIndex((a) => a.name === s);
-            ~o && (r[o] = this.data.children[o]);
-        }
-        return new au(n, Ct({
-            type: i,
-            length: this.numRows,
-            children: r
-        }));
-    }
-    /**
-     * Construct a new RecordBatch containing only columns at the specified indices.
-     *
-     * @param columnIndices Indices of columns to keep.
-     * @returns A new RecordBatch of columns matching at the specified indices.
-     */
-    selectAt(t) {
-        const n = this.schema.selectAt(t),
-            i = t.map((s) => this.data.children[s]).filter(Boolean),
-            r = Ct({
-                type: new hn(n.fields),
-                length: this.numRows,
-                children: i
-            });
-        return new au(n, r);
-    }
-};
-cC = Symbol.toStringTag;
-bi[cC] = ((e) => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))(bi.prototype);
-
-function xI(e, t, n = t.reduce((i, r) => Math.max(i, r.length), 0)) {
-    var i;
-    const r = [...e.fields],
-        s = [...t],
-        o = (n + 63 & -64) >> 3;
-    for (const [a, c] of e.fields.entries()) {
-        const l = t[a];
-        (!l || l.length !== n) && (r[a] = c.clone({
-            nullable: !0
-        }), s[a] = (i = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(n)) !== null && i !== void 0 ? i : Ct({
-            type: c.type,
-            length: n,
-            nullCount: n,
-            nullBitmap: new Uint8Array(o)
-        }));
-    }
-    return [
-        e.assign(r),
-        Ct({
-            type: new hn(r),
-            length: n,
-            children: s
-        })
-    ];
-}
-
-function lC(e, t, n = /* @__PURE__ */ new Map()) {
-    var i, r;
-    if (((i = e == null ? void 0 : e.length) !== null && i !== void 0 ? i : 0) > 0 && (e == null ? void 0 : e.length) === (t == null ? void 0 : t.length))
-        for (let s = -1, o = e.length; ++s < o;) {
-            const {
-                type: a
-            } = e[s], c = t[s];
-            for (const l of [c, ...((r = c == null ? void 0 : c.dictionary) === null || r === void 0 ? void 0 : r.data) || []])
-                lC(a.children, l == null ? void 0 : l.children, n);
-            if (st.isDictionary(a)) {
-                const {
-                    id: l
-                } = a;
-                if (!n.has(l))
-                    c != null && c.dictionary && n.set(l, c.dictionary);
-                else if (n.get(l) !== c.dictionary)
-                    throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
-            }
-        }
-    return n;
-}
-class uC extends bi {
-    constructor(t) {
-        const n = t.fields.map((r) => Ct({
-                type: r.type
-            })),
-            i = Ct({
-                type: new hn(t.fields),
-                nullCount: 0,
-                children: n
-            });
-        super(t, i);
-    }
-}
-let vs = class qi {
-    constructor() {
-        this.bb = null, this.bb_pos = 0;
-    }
-    __init(t, n) {
-        return this.bb_pos = t, this.bb = n, this;
-    }
-    static getRootAsMessage(t, n) {
-        return (n || new qi()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    static getSizePrefixedRootAsMessage(t, n) {
-        return t.setPosition(t.position() + nt), (n || new qi()).__init(t.readInt32(t.position()) + t.position(), t);
-    }
-    version() {
-        const t = this.bb.__offset(this.bb_pos, 4);
-        return t ? this.bb.readInt16(this.bb_pos + t) : Le.V1;
-    }
-    headerType() {
-        const t = this.bb.__offset(this.bb_pos, 6);
-        return t ? this.bb.readUint8(this.bb_pos + t) : te.NONE;
-    }
-    header(t) {
-        const n = this.bb.__offset(this.bb_pos, 8);
-        return n ? this.bb.__union(t, this.bb_pos + n) : null;
-    }
-    bodyLength() {
-        const t = this.bb.__offset(this.bb_pos, 10);
-        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
-    }
-    customMetadata(t, n) {
-        const i = this.bb.__offset(this.bb_pos, 12);
-        return i ? (n || new Ce()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null;
-    }
-    customMetadataLength() {
-        const t = this.bb.__offset(this.bb_pos, 12);
-        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
-    }
-    static startMessage(t) {
-        t.startObject(5);
-    }
-    static addVersion(t, n) {
-        t.addFieldInt16(0, n, Le.V1);
-    }
-    static addHeaderType(t, n) {
-        t.addFieldInt8(1, n, te.NONE);
-    }
-    static addHeader(t, n) {
-        t.addFieldOffset(2, n, 0);
-    }
-    static addBodyLength(t, n) {
-        t.addFieldInt64(3, n, BigInt("0"));
-    }
-    static addCustomMetadata(t, n) {
-        t.addFieldOffset(4, n, 0);
-    }
-    static createCustomMetadataVector(t, n) {
-        t.startVector(4, n.length, 4);
-        for (let i = n.length - 1; i >= 0; i--)
-            t.addOffset(n[i]);
-        return t.endVector();
-    }
-    static startCustomMetadataVector(t, n) {
-        t.startVector(4, n, 4);
-    }
-    static endMessage(t) {
-        return t.endObject();
-    }
-    static finishMessageBuffer(t, n) {
-        t.finish(n);
-    }
-    static finishSizePrefixedMessageBuffer(t, n) {
-        t.finish(n, void 0, !0);
-    }
-    static createMessage(t, n, i, r, s, o) {
-        return qi.startMessage(t), qi.addVersion(t, n), qi.addHeaderType(t, i), qi.addHeader(t, r), qi.addBodyLength(t, s), qi.addCustomMetadata(t, o), qi.endMessage(t);
-    }
-};
-class pct extends zt {
-    visit(t, n) {
-        return t == null || n == null ? void 0 : super.visit(t, n);
-    }
-    visitNull(t, n) {
-        return hI.startNull(n), hI.endNull(n);
-    }
-    visitInt(t, n) {
-        return Rn.startInt(n), Rn.addBitWidth(n, t.bitWidth), Rn.addIsSigned(n, t.isSigned), Rn.endInt(n);
-    }
-    visitFloat(t, n) {
-        return tr.startFloatingPoint(n), tr.addPrecision(n, t.precision), tr.endFloatingPoint(n);
-    }
-    visitBinary(t, n) {
-        return aI.startBinary(n), aI.endBinary(n);
-    }
-    visitLargeBinary(t, n) {
-        return lI.startLargeBinary(n), lI.endLargeBinary(n);
-    }
-    visitBool(t, n) {
-        return cI.startBool(n), cI.endBool(n);
-    }
-    visitUtf8(t, n) {
-        return dI.startUtf8(n), dI.endUtf8(n);
-    }
-    visitLargeUtf8(t, n) {
-        return uI.startLargeUtf8(n), uI.endLargeUtf8(n);
-    }
-    visitDecimal(t, n) {
-        return qa.startDecimal(n), qa.addScale(n, t.scale), qa.addPrecision(n, t.precision), qa.addBitWidth(n, t.bitWidth), qa.endDecimal(n);
-    }
-    visitDate(t, n) {
-        return ld.startDate(n), ld.addUnit(n, t.unit), ld.endDate(n);
-    }
-    visitTime(t, n) {
-        return Zn.startTime(n), Zn.addUnit(n, t.unit), Zn.addBitWidth(n, t.bitWidth), Zn.endTime(n);
-    }
-    visitTimestamp(t, n) {
-        const i = t.timezone && n.createString(t.timezone) || void 0;
-        return Qn.startTimestamp(n), Qn.addUnit(n, t.unit), i !== void 0 && Qn.addTimezone(n, i), Qn.endTimestamp(n);
-    }
-    visitInterval(t, n) {
-        return er.startInterval(n), er.addUnit(n, t.unit), er.endInterval(n);
-    }
-    visitDuration(t, n) {
-        return ud.startDuration(n), ud.addUnit(n, t.unit), ud.endDuration(n);
-    }
-    visitList(t, n) {
-        return fI.startList(n), fI.endList(n);
-    }
-    visitStruct(t, n) {
-        return Co.startStruct_(n), Co.endStruct_(n);
-    }
-    visitUnion(t, n) {
-        In.startTypeIdsVector(n, t.typeIds.length);
-        const i = In.createTypeIdsVector(n, t.typeIds);
-        return In.startUnion(n), In.addMode(n, t.mode), In.addTypeIds(n, i), In.endUnion(n);
-    }
-    visitDictionary(t, n) {
-        const i = this.visit(t.indices, n);
-        return qr.startDictionaryEncoding(n), qr.addId(n, BigInt(t.id)), qr.addIsOrdered(n, t.isOrdered), i !== void 0 && qr.addIndexType(n, i), qr.endDictionaryEncoding(n);
-    }
-    visitFixedSizeBinary(t, n) {
-        return fd.startFixedSizeBinary(n), fd.addByteWidth(n, t.byteWidth), fd.endFixedSizeBinary(n);
-    }
-    visitFixedSizeList(t, n) {
-        return hd.startFixedSizeList(n), hd.addListSize(n, t.listSize), hd.endFixedSizeList(n);
-    }
-    visitMap(t, n) {
-        return dd.startMap(n), dd.addKeysSorted(n, t.keysSorted), dd.endMap(n);
-    }
-}
-const hg = new pct();
-
-function yct(e, t = /* @__PURE__ */ new Map()) {
-    return new ee(gct(e, t), yd(e.metadata), t);
-}
-
-function fC(e) {
-    return new Fi(e.count, hC(e.columns), dC(e.columns));
-}
-
-function mct(e) {
-    return new os(fC(e.data), e.id, e.isDelta);
-}
-
-function gct(e, t) {
-    return (e.fields || []).filter(Boolean).map((n) => ge.fromJSON(n, t));
-}
-
-function SI(e, t) {
-    return (e.children || []).filter(Boolean).map((n) => ge.fromJSON(n, t));
-}
-
-function hC(e) {
-    return (e || []).reduce((t, n) => [
-        ...t,
-        new gl(n.count, bct(n.VALIDITY)),
-        ...hC(n.children)
-    ], []);
-}
-
-function dC(e, t = []) {
-    for (let n = -1, i = (e || []).length; ++n < i;) {
-        const r = e[n];
-        r.VALIDITY && t.push(new Kr(t.length, r.VALIDITY.length)), r.TYPE_ID && t.push(new Kr(t.length, r.TYPE_ID.length)), r.OFFSET && t.push(new Kr(t.length, r.OFFSET.length)), r.DATA && t.push(new Kr(t.length, r.DATA.length)), t = dC(r.children, t);
-    }
-    return t;
-}
-
-function bct(e) {
-    return (e || []).reduce((t, n) => t + +(n === 0), 0);
-}
-
-function wct(e, t) {
-    let n, i, r, s, o, a;
-    return !t || !(s = e.dictionary) ? (o = AI(e, SI(e, t)), r = new ge(e.name, o, e.nullable, yd(e.metadata))) : t.has(n = s.id) ? (i = (i = s.indexType) ? II(i) : new rf(), a = new Xc(t.get(n), i, n, s.isOrdered), r = new ge(e.name, a, e.nullable, yd(e.metadata))) : (i = (i = s.indexType) ? II(i) : new rf(), t.set(n, o = AI(e, SI(e, t))), a = new Xc(o, i, n, s.isOrdered), r = new ge(e.name, a, e.nullable, yd(e.metadata))), r || null;
-}
-
-function yd(e = []) {
-    return new Map(e.map(({
-        key: t,
-        value: n
-    }) => [t, n]));
-}
-
-function II(e) {
-    return new eo(e.isSigned, e.bitWidth);
-}
-
-function AI(e, t) {
-    const n = e.type.name;
-    switch (n) {
-        case "NONE":
-            return new to();
-        case "null":
-            return new to();
-        case "binary":
-            return new fy();
-        case "largebinary":
-            return new hy();
-        case "utf8":
-            return new dy();
-        case "largeutf8":
-            return new py();
-        case "bool":
-            return new yy();
-        case "list":
-            return new _y((t || [])[0]);
-        case "struct":
-            return new hn(t || []);
-        case "struct_":
-            return new hn(t || []);
-    }
-    switch (n) {
-        case "int": {
-            const i = e.type;
-            return new eo(i.isSigned, i.bitWidth);
-        }
-        case "floatingpoint": {
-            const i = e.type;
-            return new sf(rn[i.precision]);
-        }
-        case "decimal": {
-            const i = e.type;
-            return new my(i.scale, i.precision, i.bitWidth);
-        }
-        case "date": {
-            const i = e.type;
-            return new gy(Oi[i.unit]);
-        }
-        case "time": {
-            const i = e.type;
-            return new of(bt[i.unit], i.bitWidth);
-        }
-        case "timestamp": {
-            const i = e.type;
-            return new by(bt[i.unit], i.timezone);
-        }
-        case "interval": {
-            const i = e.type;
-            return new wy(mr[i.unit]);
-        }
-        case "duration": {
-            const i = e.type;
-            return new vy(bt[i.unit]);
-        }
-        case "union": {
-            const i = e.type,
-                [r, ...s] = (i.mode + "").toLowerCase(),
-                o = r.toUpperCase() + s.join("");
-            return new xy(On[o], i.typeIds || [], t || []);
-        }
-        case "fixedsizebinary": {
-            const i = e.type;
-            return new Sy(i.byteWidth);
-        }
-        case "fixedsizelist": {
-            const i = e.type;
-            return new Iy(i.listSize, (t || [])[0]);
-        }
-        case "map": {
-            const i = e.type;
-            return new Ay((t || [])[0], i.keysSorted);
-        }
-    }
-    throw new Error(`Unrecognized type: "${n}"`);
-}
-var vct = Cy,
-    _ct = ur;
-class vi {
-    /** @nocollapse */
-    static fromJSON(t, n) {
-        const i = new vi(0, Le.V5, n);
-        return i._createHeader = xct(t, n), i;
-    }
-    /** @nocollapse */
-    static decode(t) {
-        t = new _ct(Wt(t));
-        const n = vs.getRootAsMessage(t),
-            i = n.bodyLength(),
-            r = n.version(),
-            s = n.headerType(),
-            o = new vi(i, r, s);
-        return o._createHeader = Sct(n, s), o;
-    }
-    /** @nocollapse */
-    static encode(t) {
-        const n = new vct();
-        let i = -1;
-        return t.isSchema() ? i = ee.encode(n, t.header()) : t.isRecordBatch() ? i = Fi.encode(n, t.header()) : t.isDictionaryBatch() && (i = os.encode(n, t.header())), vs.startMessage(n), vs.addVersion(n, Le.V5), vs.addHeader(n, i), vs.addHeaderType(n, t.headerType), vs.addBodyLength(n, BigInt(t.bodyLength)), vs.finishMessageBuffer(n, vs.endMessage(n)), n.asUint8Array();
-    }
-    /** @nocollapse */
-    static from(t, n = 0) {
-        if (t instanceof ee)
-            return new vi(0, Le.V5, te.Schema, t);
-        if (t instanceof Fi)
-            return new vi(n, Le.V5, te.RecordBatch, t);
-        if (t instanceof os)
-            return new vi(n, Le.V5, te.DictionaryBatch, t);
-        throw new Error(`Unrecognized Message header: ${t}`);
-    }
-    get type() {
-        return this.headerType;
-    }
-    get version() {
-        return this._version;
-    }
-    get headerType() {
-        return this._headerType;
-    }
-    get bodyLength() {
-        return this._bodyLength;
-    }
-    header() {
-        return this._createHeader();
-    }
-    isSchema() {
-        return this.headerType === te.Schema;
-    }
-    isRecordBatch() {
-        return this.headerType === te.RecordBatch;
-    }
-    isDictionaryBatch() {
-        return this.headerType === te.DictionaryBatch;
-    }
-    constructor(t, n, i, r) {
-        this._version = n, this._headerType = i, this.body = new Uint8Array(0), r && (this._createHeader = () => r), this._bodyLength = bn(t);
-    }
-}
-class Fi {
-    get nodes() {
-        return this._nodes;
-    }
-    get length() {
-        return this._length;
-    }
-    get buffers() {
-        return this._buffers;
-    }
-    constructor(t, n, i) {
-        this._nodes = n, this._buffers = i, this._length = bn(t);
-    }
-}
-class os {
-    get id() {
-        return this._id;
-    }
-    get data() {
-        return this._data;
-    }
-    get isDelta() {
-        return this._isDelta;
-    }
-    get length() {
-        return this.data.length;
-    }
-    get nodes() {
-        return this.data.nodes;
-    }
-    get buffers() {
-        return this.data.buffers;
-    }
-    constructor(t, n, i = !1) {
-        this._data = t, this._isDelta = i, this._id = bn(n);
-    }
-}
-class Kr {
-    constructor(t, n) {
-        this.offset = bn(t), this.length = bn(n);
-    }
-}
-class gl {
-    constructor(t, n) {
-        this.length = bn(t), this.nullCount = bn(n);
-    }
-}
-
-function xct(e, t) {
-    return () => {
-        switch (t) {
-            case te.Schema:
-                return ee.fromJSON(e);
-            case te.RecordBatch:
-                return Fi.fromJSON(e);
-            case te.DictionaryBatch:
-                return os.fromJSON(e);
-        }
-        throw new Error(`Unrecognized Message type: { name: ${te[t]}, type: ${t} }`);
-    };
-}
-
-function Sct(e, t) {
-    return () => {
-        switch (t) {
-            case te.Schema:
-                return ee.decode(e.header(new Gi()), /* @__PURE__ */ new Map(), e.version());
-            case te.RecordBatch:
-                return Fi.decode(e.header(new kr()), e.version());
-            case te.DictionaryBatch:
-                return os.decode(e.header(new Va()), e.version());
-        }
-        throw new Error(`Unrecognized Message type: { name: ${te[t]}, type: ${t} }`);
-    };
-}
-ge.encode = Ect;
-ge.decode = Oct;
-ge.fromJSON = wct;
-ee.encode = Fct;
-ee.decode = Ict;
-ee.fromJSON = yct;
-Fi.encode = Lct;
-Fi.decode = Act;
-Fi.fromJSON = fC;
-os.encode = Rct;
-os.decode = Mct;
-os.fromJSON = mct;
-gl.encode = Cct;
-gl.decode = Tct;
-Kr.encode = kct;
-Kr.decode = $ct;
-
-function Ict(e, t = /* @__PURE__ */ new Map(), n = Le.V5) {
-    const i = Bct(e, t);
-    return new ee(i, md(e), t, n);
-}
-
-function Act(e, t = Le.V5) {
-    if (e.compression() !== null)
-        throw new Error("Record batch compression not implemented");
-    return new Fi(e.length(), Dct(e), Nct(e, t));
-}
-
-function Mct(e, t = Le.V5) {
-    return new os(Fi.decode(e.data(), t), e.id(), e.isDelta());
-}
-
-function $ct(e) {
-    return new Kr(e.offset(), e.length());
-}
-
-function Tct(e) {
-    return new gl(e.length(), e.nullCount());
-}
-
-function Dct(e) {
-    const t = [];
-    for (let n, i = -1, r = -1, s = e.nodesLength(); ++i < s;)
-        (n = e.nodes(i)) && (t[++r] = gl.decode(n));
-    return t;
-}
-
-function Nct(e, t) {
-    const n = [];
-    for (let i, r = -1, s = -1, o = e.buffersLength(); ++r < o;)
-        (i = e.buffers(r)) && (t < Le.V4 && (i.bb_pos += 8 * (r + 1)), n[++s] = Kr.decode(i));
-    return n;
-}
-
-function Bct(e, t) {
-    const n = [];
-    for (let i, r = -1, s = -1, o = e.fieldsLength(); ++r < o;)
-        (i = e.fields(r)) && (n[++s] = ge.decode(i, t));
-    return n;
-}
-
-function MI(e, t) {
-    const n = [];
-    for (let i, r = -1, s = -1, o = e.childrenLength(); ++r < o;)
-        (i = e.children(r)) && (n[++s] = ge.decode(i, t));
-    return n;
-}
-
-function Oct(e, t) {
-    let n, i, r, s, o, a;
-    return !t || !(a = e.dictionary()) ? (r = TI(e, MI(e, t)), i = new ge(e.name(), r, e.nullable(), md(e))) : t.has(n = bn(a.id())) ? (s = (s = a.indexType()) ? $I(s) : new rf(), o = new Xc(t.get(n), s, n, a.isOrdered()), i = new ge(e.name(), o, e.nullable(), md(e))) : (s = (s = a.indexType()) ? $I(s) : new rf(), t.set(n, r = TI(e, MI(e, t))), o = new Xc(r, s, n, a.isOrdered()), i = new ge(e.name(), o, e.nullable(), md(e))), i || null;
-}
-
-function md(e) {
-    const t = /* @__PURE__ */ new Map();
-    if (e)
-        for (let n, i, r = -1, s = Math.trunc(e.customMetadataLength()); ++r < s;)
-            (n = e.customMetadata(r)) && (i = n.key()) != null && t.set(i, n.value());
-    return t;
-}
-
-function $I(e) {
-    return new eo(e.isSigned(), e.bitWidth());
-}
-
-function TI(e, t) {
-    const n = e.typeType();
-    switch (n) {
-        case pe.NONE:
-            return new to();
-        case pe.Null:
-            return new to();
-        case pe.Binary:
-            return new fy();
-        case pe.LargeBinary:
-            return new hy();
-        case pe.Utf8:
-            return new dy();
-        case pe.LargeUtf8:
-            return new py();
-        case pe.Bool:
-            return new yy();
-        case pe.List:
-            return new _y((t || [])[0]);
-        case pe.Struct_:
-            return new hn(t || []);
-    }
-    switch (n) {
-        case pe.Int: {
-            const i = e.type(new Rn());
-            return new eo(i.isSigned(), i.bitWidth());
-        }
-        case pe.FloatingPoint: {
-            const i = e.type(new tr());
-            return new sf(i.precision());
-        }
-        case pe.Decimal: {
-            const i = e.type(new qa());
-            return new my(i.scale(), i.precision(), i.bitWidth());
-        }
-        case pe.Date: {
-            const i = e.type(new ld());
-            return new gy(i.unit());
-        }
-        case pe.Time: {
-            const i = e.type(new Zn());
-            return new of(i.unit(), i.bitWidth());
-        }
-        case pe.Timestamp: {
-            const i = e.type(new Qn());
-            return new by(i.unit(), i.timezone());
-        }
-        case pe.Interval: {
-            const i = e.type(new er());
-            return new wy(i.unit());
-        }
-        case pe.Duration: {
-            const i = e.type(new ud());
-            return new vy(i.unit());
-        }
-        case pe.Union: {
-            const i = e.type(new In());
-            return new xy(i.mode(), i.typeIdsArray() || [], t || []);
-        }
-        case pe.FixedSizeBinary: {
-            const i = e.type(new fd());
-            return new Sy(i.byteWidth());
-        }
-        case pe.FixedSizeList: {
-            const i = e.type(new hd());
-            return new Iy(i.listSize(), (t || [])[0]);
-        }
-        case pe.Map: {
-            const i = e.type(new dd());
-            return new Ay((t || [])[0], i.keysSorted());
-        }
-    }
-    throw new Error(`Unrecognized type: "${pe[n]}" (${n})`);
-}
-
-function Fct(e, t) {
-    const n = t.fields.map((s) => ge.encode(e, s));
-    Gi.startFieldsVector(e, n.length);
-    const i = Gi.createFieldsVector(e, n),
-        r = t.metadata && t.metadata.size > 0 ? Gi.createCustomMetadataVector(e, [...t.metadata].map(([s, o]) => {
-            const a = e.createString(`${s}`),
-                c = e.createString(`${o}`);
-            return Ce.startKeyValue(e), Ce.addKey(e, a), Ce.addValue(e, c), Ce.endKeyValue(e);
-        })) : -1;
-    return Gi.startSchema(e), Gi.addFields(e, i), Gi.addEndianness(e, Uct ? Gc.Little : Gc.Big), r !== -1 && Gi.addCustomMetadata(e, r), Gi.endSchema(e);
-}
-
-function Ect(e, t) {
-    let n = -1,
-        i = -1,
-        r = -1;
-    const s = t.type;
-    let o = t.typeId;
-    st.isDictionary(s) ? (o = s.dictionary.typeId, r = hg.visit(s, e), i = hg.visit(s.dictionary, e)) : i = hg.visit(s, e);
-    const a = (s.children || []).map((u) => ge.encode(e, u)),
-        c = Xn.createChildrenVector(e, a),
-        l = t.metadata && t.metadata.size > 0 ? Xn.createCustomMetadataVector(e, [...t.metadata].map(([u, f]) => {
-            const h = e.createString(`${u}`),
-                d = e.createString(`${f}`);
-            return Ce.startKeyValue(e), Ce.addKey(e, h), Ce.addValue(e, d), Ce.endKeyValue(e);
-        })) : -1;
-    return t.name && (n = e.createString(t.name)), Xn.startField(e), Xn.addType(e, i), Xn.addTypeType(e, o), Xn.addChildren(e, c), Xn.addNullable(e, !!t.nullable), n !== -1 && Xn.addName(e, n), r !== -1 && Xn.addDictionary(e, r), l !== -1 && Xn.addCustomMetadata(e, l), Xn.endField(e);
-}
-
-function Lct(e, t) {
-    const n = t.nodes || [],
-        i = t.buffers || [];
-    kr.startNodesVector(e, n.length);
-    for (const o of n.slice().reverse())
-        gl.encode(e, o);
-    const r = e.endVector();
-    kr.startBuffersVector(e, i.length);
-    for (const o of i.slice().reverse())
-        Kr.encode(e, o);
-    const s = e.endVector();
-    return kr.startRecordBatch(e), kr.addLength(e, BigInt(t.length)), kr.addNodes(e, r), kr.addBuffers(e, s), kr.endRecordBatch(e);
-}
-
-function Rct(e, t) {
-    const n = Fi.encode(e, t.data);
-    return Va.startDictionaryBatch(e), Va.addId(e, BigInt(t.id)), Va.addIsDelta(e, t.isDelta), Va.addData(e, n), Va.endDictionaryBatch(e);
-}
-
-function Cct(e, t) {
-    return NL.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount));
-}
-
-function kct(e, t) {
-    return DL.createBuffer(e, BigInt(t.offset), BigInt(t.length));
-}
-const Uct = (() => {
-        const e = new ArrayBuffer(2);
-        return new DataView(e).setInt16(
-            0,
-            256,
-            !0
-            /* littleEndian */
-        ), new Int16Array(e)[0] === 256;
-    })(),
-    w_ = (e) => `Expected ${te[e]} Message in stream, but was null or length 0.`,
-    v_ = (e) => `Header pointer of flatbuffer-encoded ${te[e]} Message is null or length 0.`,
-    pC = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`,
-    yC = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`;
-class mC {
-    constructor(t) {
-            this.source = t instanceof Dy ? t : new Dy(t);
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-    next() {
-        let t;
-        return (t = this.readMetadataLength()).done || t.value === -1 && (t = this.readMetadataLength()).done || (t = this.readMetadata(t.value)).done ? Ie : t;
-    }
-    throw (t) {
-        return this.source.throw(t);
-    }
-    return (t) {
-        return this.source.return(t);
-    }
-    readMessage(t) {
-        let n;
-        if ((n = this.next()).done)
-            return null;
-        if (t != null && n.value.headerType !== t)
-            throw new Error(w_(t));
-        return n.value;
-    }
-    readMessageBody(t) {
-        if (t <= 0)
-            return new Uint8Array(0);
-        const n = Wt(this.source.read(t));
-        if (n.byteLength < t)
-            throw new Error(yC(t, n.byteLength));
-        return (
-            /* 1. */
-            n.byteOffset % 8 === 0 && /* 2. */
-            n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
-        );
-    }
-    readSchema(t = !1) {
-        const n = te.Schema,
-            i = this.readMessage(n),
-            r = i == null ? void 0 : i.header();
-        if (t && !r)
-            throw new Error(v_(n));
-        return r;
-    }
-    readMetadataLength() {
-        const t = this.source.read(Q0),
-            n = t && new ur(t),
-            i = (n == null ? void 0 : n.readInt32(0)) || 0;
-        return {
-            done: i === 0,
-            value: i
-        };
-    }
-    readMetadata(t) {
-        const n = this.source.read(t);
-        if (!n)
-            return Ie;
-        if (n.byteLength < t)
-            throw new Error(pC(t, n.byteLength));
-        return {
-            done: !1,
-            value: vi.decode(n)
-        };
-    }
-}
-class zct {
-    constructor(t, n) {
-            this.source = t instanceof Jc ? t : IL(t) ? new Ny(t, n) : new Jc(t);
-        }
-        [Symbol.asyncIterator]() {
-            return this;
-        }
-    next() {
-        return W(this, void 0, void 0, function*() {
-            let t;
-            return (t = yield this.readMetadataLength()).done || t.value === -1 && (t = yield this.readMetadataLength()).done || (t = yield this.readMetadata(t.value)).done ? Ie : t;
-        });
-    }
-    throw (t) {
-        return W(this, void 0, void 0, function*() {
-            return yield this.source.throw(t);
-        });
-    }
-    return (t) {
-        return W(this, void 0, void 0, function*() {
-            return yield this.source.return(t);
-        });
-    }
-    readMessage(t) {
-        return W(this, void 0, void 0, function*() {
-            let n;
-            if ((n = yield this.next()).done)
-                return null;
-            if (t != null && n.value.headerType !== t)
-                throw new Error(w_(t));
-            return n.value;
-        });
-    }
-    readMessageBody(t) {
-        return W(this, void 0, void 0, function*() {
-            if (t <= 0)
-                return new Uint8Array(0);
-            const n = Wt(yield this.source.read(t));
-            if (n.byteLength < t)
-                throw new Error(yC(t, n.byteLength));
-            return (
-                /* 1. */
-                n.byteOffset % 8 === 0 && /* 2. */
-                n.byteOffset + n.byteLength <= n.buffer.byteLength ? n : n.slice()
-            );
-        });
-    }
-    readSchema(t = !1) {
-        return W(this, void 0, void 0, function*() {
-            const n = te.Schema,
-                i = yield this.readMessage(n), r = i == null ? void 0 : i.header();
-            if (t && !r)
-                throw new Error(v_(n));
-            return r;
-        });
-    }
-    readMetadataLength() {
-        return W(this, void 0, void 0, function*() {
-            const t = yield this.source.read(Q0), n = t && new ur(t), i = (n == null ? void 0 : n.readInt32(0)) || 0;
-            return {
-                done: i === 0,
-                value: i
-            };
-        });
-    }
-    readMetadata(t) {
-        return W(this, void 0, void 0, function*() {
-            const n = yield this.source.read(t);
-            if (!n)
-                return Ie;
-            if (n.byteLength < t)
-                throw new Error(pC(t, n.byteLength));
-            return {
-                done: !1,
-                value: vi.decode(n)
-            };
-        });
-    }
-}
-class Pct extends mC {
-    constructor(t) {
-        super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof vI ? t : new vI(t);
-    }
-    next() {
-        const {
-            _json: t
-        } = this;
-        if (!this._schema)
-            return this._schema = !0, {
-                done: !1,
-                value: vi.fromJSON(t.schema, te.Schema)
-            };
-        if (this._dictionaryIndex < t.dictionaries.length) {
-            const n = t.dictionaries[this._dictionaryIndex++];
-            return this._body = n.data.columns, {
-                done: !1,
-                value: vi.fromJSON(n, te.DictionaryBatch)
-            };
-        }
-        if (this._batchIndex < t.batches.length) {
-            const n = t.batches[this._batchIndex++];
-            return this._body = n.columns, {
-                done: !1,
-                value: vi.fromJSON(n, te.RecordBatch)
-            };
-        }
-        return this._body = [], Ie;
-    }
-    readMessageBody(t) {
-        return n(this._body);
-
-        function n(i) {
-            return (i || []).reduce((r, s) => [
-                ...r,
-                ...s.VALIDITY && [s.VALIDITY] || [],
-                ...s.TYPE_ID && [s.TYPE_ID] || [],
-                ...s.OFFSET && [s.OFFSET] || [],
-                ...s.DATA && [s.DATA] || [],
-                ...n(s.children)
-            ], []);
-        }
-    }
-    readMessage(t) {
-        let n;
-        if ((n = this.next()).done)
-            return null;
-        if (t != null && n.value.headerType !== t)
-            throw new Error(w_(t));
-        return n.value;
-    }
-    readSchema() {
-        const t = te.Schema,
-            n = this.readMessage(t),
-            i = n == null ? void 0 : n.header();
-        if (!n || !i)
-            throw new Error(v_(t));
-        return i;
-    }
-}
-const Q0 = 4,
-    ub = "ARROW1",
-    By = new Uint8Array(ub.length);
-for (let e = 0; e < ub.length; e += 1)
-    By[e] = ub.codePointAt(e);
-
-function __(e, t = 0) {
-    for (let n = -1, i = By.length; ++n < i;)
-        if (By[n] !== e[t + n])
-            return !1;
-    return !0;
-}
-const Qf = By.length,
-    gC = Qf + Q0,
-    Vct = Qf * 2 + Q0;
-class ns extends rC {
-    constructor(t) {
-        super(), this._impl = t;
-    }
-    get closed() {
-        return this._impl.closed;
-    }
-    get schema() {
-        return this._impl.schema;
-    }
-    get autoDestroy() {
-        return this._impl.autoDestroy;
-    }
-    get dictionaries() {
-        return this._impl.dictionaries;
-    }
-    get numDictionaries() {
-        return this._impl.numDictionaries;
-    }
-    get numRecordBatches() {
-        return this._impl.numRecordBatches;
-    }
-    get footer() {
-        return this._impl.isFile() ? this._impl.footer : null;
-    }
-    isSync() {
-        return this._impl.isSync();
-    }
-    isAsync() {
-        return this._impl.isAsync();
-    }
-    isFile() {
-        return this._impl.isFile();
-    }
-    isStream() {
-        return this._impl.isStream();
-    }
-    next() {
-        return this._impl.next();
-    }
-    throw (t) {
-        return this._impl.throw(t);
-    }
-    return (t) {
-        return this._impl.return(t);
-    }
-    cancel() {
-        return this._impl.cancel();
-    }
-    reset(t) {
-        return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this;
-    }
-    open(t) {
-        const n = this._impl.open(t);
-        return Qu(n) ? n.then(() => this) : this;
-    }
-    readRecordBatch(t) {
-            return this._impl.isFile() ? this._impl.readRecordBatch(t) : null;
-        }
-        [Symbol.iterator]() {
-            return this._impl[Symbol.iterator]();
-        }
-        [Symbol.asyncIterator]() {
-            return this._impl[Symbol.asyncIterator]();
-        }
-    toDOMStream() {
-        return Jn.toDOMStream(this.isSync() ? {
-            [Symbol.iterator]: () => this
-        } : {
-            [Symbol.asyncIterator]: () => this
-        });
-    }
-    toNodeStream() {
-        return Jn.toNodeStream(this.isSync() ? {
-            [Symbol.iterator]: () => this
-        } : {
-            [Symbol.asyncIterator]: () => this
-        }, {
-            objectMode: !0
-        });
-    }
-    /** @nocollapse */
-    // @ts-ignore
-    static throughNode(t) {
-        throw new Error('"throughNode" not available in this environment');
-    }
-    /** @nocollapse */
-    static throughDOM(t, n) {
-        throw new Error('"throughDOM" not available in this environment');
-    }
-    /** @nocollapse */
-    static from(t) {
-        return t instanceof ns ? t : nb(t) ? Wct(t) : IL(t) ? Hct(t) : Qu(t) ? W(this, void 0, void 0, function*() {
-            return yield ns.from(yield t);
-        }) : AL(t) || n_(t) || $L(t) || e_(t) ? Xct(new Jc(t)) : Gct(new Dy(t));
-    }
-    /** @nocollapse */
-    static readAll(t) {
-        return t instanceof ns ? t.isSync() ? DI(t) : NI(t) : nb(t) || ArrayBuffer.isView(t) || J0(t) || SL(t) ? DI(t) : NI(t);
-    }
-}
-class Oy extends ns {
-    constructor(t) {
-        super(t), this._impl = t;
-    }
-    readAll() {
-            return [...this];
-        }
-        [Symbol.iterator]() {
-            return this._impl[Symbol.iterator]();
-        }
-        [Symbol.asyncIterator]() {
-            return Re(this, arguments, function*() {
-                yield H(yield* ks(ai(this[Symbol.iterator]())));
-            });
-        }
-}
-class Fy extends ns {
-    constructor(t) {
-        super(t), this._impl = t;
-    }
-    readAll() {
-            var t, n, i, r;
-            return W(this, void 0, void 0, function*() {
-                const s = new Array();
-                try {
-                    for (var o = !0, a = ai(this), c; c = yield a.next(), t = c.done, !t; o = !0) {
-                        r = c.value, o = !1;
-                        const l = r;
-                        s.push(l);
-                    }
-                } catch (l) {
-                    n = {
-                        error: l
-                    };
-                } finally {
-                    try {
-                        !o && !t && (i = a.return) && (yield i.call(a));
-                    } finally {
-                        if (n)
-                            throw n.error;
-                    }
-                }
-                return s;
-            });
-        }
-        [Symbol.iterator]() {
-            throw new Error("AsyncRecordBatchStreamReader is not Iterable");
-        }
-        [Symbol.asyncIterator]() {
-            return this._impl[Symbol.asyncIterator]();
-        }
-}
-class bC extends Oy {
-    constructor(t) {
-        super(t), this._impl = t;
-    }
-}
-class jct extends Fy {
-    constructor(t) {
-        super(t), this._impl = t;
-    }
-}
-class wC {
-    get numDictionaries() {
-        return this._dictionaryIndex;
-    }
-    get numRecordBatches() {
-        return this._recordBatchIndex;
-    }
-    constructor(t = /* @__PURE__ */ new Map()) {
-        this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t;
-    }
-    isSync() {
-        return !1;
-    }
-    isAsync() {
-        return !1;
-    }
-    isFile() {
-        return !1;
-    }
-    isStream() {
-        return !1;
-    }
-    reset(t) {
-        return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = /* @__PURE__ */ new Map(), this;
-    }
-    _loadRecordBatch(t, n) {
-        const i = this._loadVectors(t, n, this.schema.fields),
-            r = Ct({
-                type: new hn(this.schema.fields),
-                length: t.length,
-                children: i
-            });
-        return new bi(this.schema, r);
-    }
-    _loadDictionaryBatch(t, n) {
-        const {
-            id: i,
-            isDelta: r
-        } = t, {
-            dictionaries: s,
-            schema: o
-        } = this, a = s.get(i);
-        if (r || !a) {
-            const c = o.dictionaries.get(i),
-                l = this._loadVectors(t.data, n, [c]);
-            return (a && r ? a.concat(new ae(l)) : new ae(l)).memoize();
-        }
-        return a.memoize();
-    }
-    _loadVectors(t, n, i) {
-        return new oC(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
-    }
-}
-class Ey extends wC {
-    constructor(t, n) {
-        super(n), this._reader = nb(t) ? new Pct(this._handle = t) : new mC(this._handle = t);
-    }
-    isSync() {
-        return !0;
-    }
-    isStream() {
-            return !0;
-        }
-        [Symbol.iterator]() {
-            return this;
-        }
-    cancel() {
-        !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
-    }
-    open(t) {
-        return this.closed || (this.autoDestroy = _C(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this;
-    }
-    throw (t) {
-        return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : Ie;
-    }
-    return (t) {
-        return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : Ie;
-    }
-    next() {
-        if (this.closed)
-            return Ie;
-        let t;
-        const {
-            _reader: n
-        } = this;
-        for (; t = this._readNextMessageAndValidate();)
-            if (t.isSchema())
-                this.reset(t.header());
-            else if (t.isRecordBatch()) {
-            this._recordBatchIndex++;
-            const i = t.header(),
-                r = n.readMessageBody(t.bodyLength);
-            return {
-                done: !1,
-                value: this._loadRecordBatch(i, r)
-            };
-        } else if (t.isDictionaryBatch()) {
-            this._dictionaryIndex++;
-            const i = t.header(),
-                r = n.readMessageBody(t.bodyLength),
-                s = this._loadDictionaryBatch(i, r);
-            this.dictionaries.set(i.id, s);
-        }
-        return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, {
-            done: !1,
-            value: new uC(this.schema)
-        }) : this.return();
-    }
-    _readNextMessageAndValidate(t) {
-        return this._reader.readMessage(t);
-    }
-}
-class Ly extends wC {
-    constructor(t, n) {
-        super(n), this._reader = new zct(this._handle = t);
-    }
-    isAsync() {
-        return !0;
-    }
-    isStream() {
-            return !0;
-        }
-        [Symbol.asyncIterator]() {
-            return this;
-        }
-    cancel() {
-        return W(this, void 0, void 0, function*() {
-            !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
-        });
-    }
-    open(t) {
-        return W(this, void 0, void 0, function*() {
-            return this.closed || (this.autoDestroy = _C(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this;
-        });
-    }
-    throw (t) {
-        return W(this, void 0, void 0, function*() {
-            return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t): Ie;
-        });
-    }
-    return (t) {
-        return W(this, void 0, void 0, function*() {
-            return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t): Ie;
-        });
-    }
-    next() {
-        return W(this, void 0, void 0, function*() {
-            if (this.closed)
-                return Ie;
-            let t;
-            const {
-                _reader: n
-            } = this;
-            for (; t = yield this._readNextMessageAndValidate();)
-                if (t.isSchema())
-                    yield this.reset(t.header());
-                else if (t.isRecordBatch()) {
-                this._recordBatchIndex++;
-                const i = t.header(),
-                    r = yield n.readMessageBody(t.bodyLength);
-                return {
-                    done: !1,
-                    value: this._loadRecordBatch(i, r)
-                };
-            } else if (t.isDictionaryBatch()) {
-                this._dictionaryIndex++;
-                const i = t.header(),
-                    r = yield n.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(i, r);
-                this.dictionaries.set(i.id, s);
-            }
-            return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, {
-                done: !1,
-                value: new uC(this.schema)
-            }) : yield this.return();
-        });
-    }
-    _readNextMessageAndValidate(t) {
-        return W(this, void 0, void 0, function*() {
-            return yield this._reader.readMessage(t);
-        });
-    }
-}
-class vC extends Ey {
-    get footer() {
-        return this._footer;
-    }
-    get numDictionaries() {
-        return this._footer ? this._footer.numDictionaries : 0;
-    }
-    get numRecordBatches() {
-        return this._footer ? this._footer.numRecordBatches : 0;
-    }
-    constructor(t, n) {
-        super(t instanceof _I ? t : new _I(t), n);
-    }
-    isSync() {
-        return !0;
-    }
-    isFile() {
-        return !0;
-    }
-    open(t) {
-        if (!this.closed && !this._footer) {
-            this.schema = (this._footer = this._readFooter()).schema;
-            for (const n of this._footer.dictionaryBatches())
-                n && this._readDictionaryBatch(this._dictionaryIndex++);
-        }
-        return super.open(t);
-    }
-    readRecordBatch(t) {
-        var n;
-        if (this.closed)
-            return null;
-        this._footer || this.open();
-        const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
-        if (i && this._handle.seek(i.offset)) {
-            const r = this._reader.readMessage(te.RecordBatch);
-            if (r != null && r.isRecordBatch()) {
-                const s = r.header(),
-                    o = this._reader.readMessageBody(r.bodyLength);
-                return this._loadRecordBatch(s, o);
-            }
-        }
-        return null;
-    }
-    _readDictionaryBatch(t) {
-        var n;
-        const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
-        if (i && this._handle.seek(i.offset)) {
-            const r = this._reader.readMessage(te.DictionaryBatch);
-            if (r != null && r.isDictionaryBatch()) {
-                const s = r.header(),
-                    o = this._reader.readMessageBody(r.bodyLength),
-                    a = this._loadDictionaryBatch(s, o);
-                this.dictionaries.set(s.id, a);
-            }
-        }
-    }
-    _readFooter() {
-        const {
-            _handle: t
-        } = this, n = t.size - gC, i = t.readInt32(n), r = t.readAt(n - i, i);
-        return p_.decode(r);
-    }
-    _readNextMessageAndValidate(t) {
-        var n;
-        if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
-            const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(this._recordBatchIndex);
-            if (i && this._handle.seek(i.offset))
-                return this._reader.readMessage(t);
-        }
-        return null;
-    }
-}
-class qct extends Ly {
-    get footer() {
-        return this._footer;
-    }
-    get numDictionaries() {
-        return this._footer ? this._footer.numDictionaries : 0;
-    }
-    get numRecordBatches() {
-        return this._footer ? this._footer.numRecordBatches : 0;
-    }
-    constructor(t, ...n) {
-        const i = typeof n[0] != "number" ? n.shift() : void 0,
-            r = n[0] instanceof Map ? n.shift() : void 0;
-        super(t instanceof Ny ? t : new Ny(t, i), r);
-    }
-    isFile() {
-        return !0;
-    }
-    isAsync() {
-        return !0;
-    }
-    open(t) {
-        const n = Object.create(null, {
-            open: {
-                get: () => super.open
-            }
-        });
-        return W(this, void 0, void 0, function*() {
-            if (!this.closed && !this._footer) {
-                this.schema = (this._footer = yield this._readFooter()).schema;
-                for (const i of this._footer.dictionaryBatches())
-                    i && (yield this._readDictionaryBatch(this._dictionaryIndex++));
-            }
-            return yield n.open.call(this, t);
-        });
-    }
-    readRecordBatch(t) {
-        var n;
-        return W(this, void 0, void 0, function*() {
-            if (this.closed)
-                return null;
-            this._footer || (yield this.open());
-            const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getRecordBatch(t);
-            if (i && (yield this._handle.seek(i.offset))) {
-                const r = yield this._reader.readMessage(te.RecordBatch);
-                if (r != null && r.isRecordBatch()) {
-                    const s = r.header(),
-                        o = yield this._reader.readMessageBody(r.bodyLength);
-                    return this._loadRecordBatch(s, o);
-                }
-            }
-            return null;
-        });
-    }
-    _readDictionaryBatch(t) {
-        var n;
-        return W(this, void 0, void 0, function*() {
-            const i = (n = this._footer) === null || n === void 0 ? void 0 : n.getDictionaryBatch(t);
-            if (i && (yield this._handle.seek(i.offset))) {
-                const r = yield this._reader.readMessage(te.DictionaryBatch);
-                if (r != null && r.isDictionaryBatch()) {
-                    const s = r.header(),
-                        o = yield this._reader.readMessageBody(r.bodyLength), a = this._loadDictionaryBatch(s, o);
-                    this.dictionaries.set(s.id, a);
-                }
-            }
-        });
-    }
-    _readFooter() {
-        return W(this, void 0, void 0, function*() {
-            const {
-                _handle: t
-            } = this;
-            t._pending && (yield t._pending);
-            const n = t.size - gC,
-                i = yield t.readInt32(n), r = yield t.readAt(n - i, i);
-            return p_.decode(r);
-        });
-    }
-    _readNextMessageAndValidate(t) {
-        return W(this, void 0, void 0, function*() {
-            if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
-                const n = this._footer.getRecordBatch(this._recordBatchIndex);
-                if (n && (yield this._handle.seek(n.offset)))
-                    return yield this._reader.readMessage(t);
-            }
-            return null;
-        });
-    }
-}
-class Yct extends Ey {
-    constructor(t, n) {
-        super(t, n);
-    }
-    _loadVectors(t, n, i) {
-        return new ict(n, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i);
-    }
-}
-
-function _C(e, t) {
-    return t && typeof t.autoDestroy == "boolean" ? t.autoDestroy : e.autoDestroy;
-}
-
-function* DI(e) {
-    const t = ns.from(e);
-    try {
-        if (!t.open({
-                autoDestroy: !1
-            }).closed)
-            do
-                yield t;
-            while (!t.reset().open().closed);
-    } finally {
-        t.cancel();
-    }
-}
-
-function NI(e) {
-    return Re(this, arguments, function*() {
-        const n = yield H(ns.from(e));
-        try {
-            if (!(yield H(n.open({
-                    autoDestroy: !1
-                }))).closed)
-                do
-                    yield yield H(n);
-                while (!(yield H(n.reset().open())).closed);
-        } finally {
-            yield H(n.cancel());
-        }
-    });
-}
-
-function Wct(e) {
-    return new Oy(new Yct(e));
-}
-
-function Gct(e) {
-    const t = e.peek(Qf + 7 & -8);
-    return t && t.byteLength >= 4 ? __(t) ? new bC(new vC(e.read())) : new Oy(new Ey(e)) : new Oy(new Ey(function*() {}()));
-}
-
-function Xct(e) {
-    return W(this, void 0, void 0, function*() {
-        const t = yield e.peek(Qf + 7 & -8);
-        return t && t.byteLength >= 4 ? __(t) ? new bC(new vC(yield e.read())) : new Fy(new Ly(e)) : new Fy(new Ly(function() {
-            return Re(this, arguments, function*() {});
-        }()));
-    });
-}
-
-function Hct(e) {
-    return W(this, void 0, void 0, function*() {
-        const {
-            size: t
-        } = yield e.stat(), n = new Ny(e, t);
-        return t >= Vct && __(yield n.readAt(0, Qf + 7 & -8)) ? new jct(new qct(n)) : new Fy(new Ly(n));
-    });
-}
-
-function xC(e) {
-    const t = ns.from(e);
-    return Qu(t) ? t.then((n) => xC(n)) : t.isAsync() ? t.readAll().then((n) => new ti(n)) : new ti(t.readAll());
-}
-let Ch;
-const Jct = new Uint8Array(16);
-
-function Kct() {
-    if (!Ch && (Ch = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Ch))
+function Stt() {
+    if (!wl && (wl = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !wl))
         throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
-    return Ch(Jct);
+    return wl(xtt);
 }
-const Ge = [];
+const xe = [];
 for (let e = 0; e < 256; ++e)
-    Ge.push((e + 256).toString(16).slice(1));
+    xe.push((e + 256).toString(16).slice(1));
 
-function Zct(e, t = 0) {
-    return Ge[e[t + 0]] + Ge[e[t + 1]] + Ge[e[t + 2]] + Ge[e[t + 3]] + "-" + Ge[e[t + 4]] + Ge[e[t + 5]] + "-" + Ge[e[t + 6]] + Ge[e[t + 7]] + "-" + Ge[e[t + 8]] + Ge[e[t + 9]] + "-" + Ge[e[t + 10]] + Ge[e[t + 11]] + Ge[e[t + 12]] + Ge[e[t + 13]] + Ge[e[t + 14]] + Ge[e[t + 15]];
+function Mtt(e, t = 0) {
+    return xe[e[t + 0]] + xe[e[t + 1]] + xe[e[t + 2]] + xe[e[t + 3]] + "-" + xe[e[t + 4]] + xe[e[t + 5]] + "-" + xe[e[t + 6]] + xe[e[t + 7]] + "-" + xe[e[t + 8]] + xe[e[t + 9]] + "-" + xe[e[t + 10]] + xe[e[t + 11]] + xe[e[t + 12]] + xe[e[t + 13]] + xe[e[t + 14]] + xe[e[t + 15]];
 }
-const Qct = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
-    BI = {
-        randomUUID: Qct
+const Att = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
+    _v = {
+        randomUUID: Att
     };
 
-function tlt(e, t, n) {
-    if (BI.randomUUID && !t && !e)
-        return BI.randomUUID();
+function $tt(e, t, n) {
+    if (_v.randomUUID && !t && !e)
+        return _v.randomUUID();
     e = e || {};
-    const i = e.random || (e.rng || Kct)();
-    if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, t) {
+    const r = e.random || (e.rng || Stt)();
+    if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, t) {
         n = n || 0;
-        for (let r = 0; r < 16; ++r)
-            t[n + r] = i[r];
+        for (let i = 0; i < 16; ++i)
+            t[n + i] = r[i];
         return t;
     }
-    return Zct(i);
+    return Mtt(r);
 }
-const Tut = {
+const Ott = {
     /** @type {import('anywidget/types').Initialize<Model>} */
     // eslint-disable-next-line no-unused-vars
     initialize(e) {},
     /** @type {import('anywidget/types').Render<Model>} */
     render(e) {
         e.el.classList.add("mosaic-widget");
         const t = () => e.model.get("spec"),
             n = () => e.model.get("temp_indexes"),
-            i = Wr().logger(),
-            r = /* @__PURE__ */ new Map();
+            r = Wr().logger(),
+            i = /* @__PURE__ */ new Map();
 
-        function s(u, f, h) {
-            const d = tlt();
-            r.set(d, {
-                query: u,
+        function s(l, f, h) {
+            const d = $tt();
+            i.set(d, {
+                query: l,
                 startTime: performance.now(),
                 resolve: f,
                 reject: h
             }), e.model.send({
-                ...u,
+                ...l,
                 uuid: d
             });
         }
         const o = {
-            query(u) {
-                return new Promise((f, h) => s(u, f, h));
+            query(l) {
+                return new Promise((f, h) => s(l, f, h));
             }
         };
 
         function a() {
-            Wr().clear(), Yv.clear();
+            Wr().clear(), N1.clear();
         }
         async function c() {
-            const u = t();
-            a(), i.log("Setting spec:", u);
-            const f = await elt(u);
+            const l = t();
+            a(), r.log("Setting spec:", l);
+            const f = await Itt(l);
             e.el.replaceChildren(f.element);
             const h = {};
             for (const [d, p] of f.params)
                 h[d] = {
                     value: p.value,
-                    ...p.predicate ? {
+                    ...dr(p) ? {
                         predicate: String(p.predicate())
                     } : {}
-                }, p.addEventListener("value", (m) => {
+                }, p.addEventListener("value", (y) => {
                     h[d] = {
-                        value: m,
-                        predicate: String(p.predicate())
+                        value: y,
+                        ...dr(p) ? {
+                            predicate: String(p.predicate())
+                        } : {}
                     }, e.model.set("params", h), e.model.save_changes();
                 });
             e.model.set("params", h), e.model.save_changes();
         }
         e.model.on("change:spec", () => c());
 
-        function l() {
-            const u = {
+        function u() {
+            const l = {
                 temp: n()
             };
             Wr().configure({
-                indexes: u
+                indexes: l
             });
         }
-        return e.model.on("change:temp_indexes", () => l()), e.model.on("msg:custom", (u, f) => {
-            i.group(`query ${u.uuid}`), i.log("received message", u, f);
-            const h = r.get(u.uuid);
-            if (r.delete(u.uuid), i.log(h.query.sql, (performance.now() - h.startTime).toFixed(1)), u.error)
-                h.reject(u.error), i.error(u.error);
+        return e.model.on("change:temp_indexes", () => u()), e.model.on("msg:custom", (l, f) => {
+            r.group(`query ${l.uuid}`), r.log("received message", l, f);
+            const h = i.get(l.uuid);
+            if (i.delete(l.uuid), r.log(h.query.sql, (performance.now() - h.startTime).toFixed(1)), l.error)
+                h.reject(l.error), r.error(l.error);
             else
-                switch (u.type) {
+                switch (l.type) {
                     case "arrow": {
-                        const d = xC(f[0].buffer);
-                        i.log("table", d), h.resolve(d);
+                        const d = fm(f[0].buffer);
+                        r.log("table", d), h.resolve(d);
                         break;
                     }
                     case "json": {
-                        i.log("json", u.result), h.resolve(u.result);
+                        r.log("json", l.result), h.resolve(l.result);
                         break;
                     }
                     default: {
                         h.resolve({});
                         break;
                     }
                 }
-            i.groupEnd("query");
-        }), Wr().databaseConnector(o), l(), c(), () => {
+            r.groupEnd("query");
+        }), Wr().databaseConnector(o), u(), c(), () => {
             a();
         };
     }
 };
 
-function elt(e) {
-    const t = bot(e);
-    return Fst(t);
+function Itt(e) {
+    const t = vtt(e);
+    return RQ(t);
 }
 export {
-    Tut as
+    Ott as
     default
 };
```

### Comparing `mosaic_widget-0.8.0/mosaic_widget/static/style.css` & `mosaic_widget-0.9.0/mosaic_widget/static/style.css`

 * *Files identical despite different names*

### Comparing `mosaic_widget-0.8.0/src/index.js` & `mosaic_widget-0.9.0/src/index.js`

 * *Files identical despite different names*

### Comparing `mosaic_widget-0.8.0/src/style.css` & `mosaic_widget-0.9.0/src/style.css`

 * *Files identical despite different names*

### Comparing `mosaic_widget-0.8.0/README.md` & `mosaic_widget-0.9.0/README.md`

 * *Files identical despite different names*

### Comparing `mosaic_widget-0.8.0/pyproject.toml` & `mosaic_widget-0.9.0/pyproject.toml`

 * *Files identical despite different names*

### Comparing `mosaic_widget-0.8.0/PKG-INFO` & `mosaic_widget-0.9.0/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mosaic-widget
-Version: 0.8.0
+Version: 0.9.0
 Summary: A Jupyter widget for Mosaic
 Project-URL: homepage, https://github.com/uwdata/mosaic
 Requires-Python: >=3.9
 Requires-Dist: anywidget>=0.9.0
 Requires-Dist: duckdb==0.10.2
 Requires-Dist: pyarrow
 Provides-Extra: dev
```

